[{"subject": "RE: Resource clas", "content": "\"Eric Sedlar\" <eric.sedlar@oracle.com> wrote:\n>\n> > (b) How about extending <DAV:propname/>? such as\n> > <DAV:propname>\n> >     <DAV:checked-out/>\n> > </DAV:propname>\n> > then the client would get back just the name or a 404 to determine if\nit\n> > exists.\n>\n> I don't see why that's that much different from what we do right now (get\n> all of the names and see if the one you want is there)\n\nOnly that it is a very simple extension to <DAV:propname> to allow the\nclient to be more specific, and to reduce the amount of info that the\nserver has to send back.\n\nTim\n\n\n\n", "id": "lists-006-0000000"}, {"subject": "Re: AW: Resource clas", "content": "\"Stefan Eissing\" <stefan.eissing@greenbytes.de>\n> This touches on an issue I (the guy with the webdav [maybe caching\n> a little] proxy) have with discovering type and status of a WebDAV\nresource.\n\n\"maybe caching a little\" <g>\n\n> As Geoff made quite clear,\n\nDid he?  I'll have to re-read that post (joking!)\n\n> DAV:supported-live-property-set contains all\n> there is to know about a versioned resource. But what about versionable\n> resources? Will/Should they have any versioning props apart from\n> DAV:supported-method-set with at least VERSION-CONTROL as content?\n\nCorrect, VERSION-CONTROL would identify the resource as versionable to a\nclient.\n\n> How is supported-method-set supposed to work in conjunction with other\n> WebDAV extensions (ordered collections, reference, etc.) Will all those\n> methods be mentioned there as well?\n\nYes.\n\n> Won't deltaV become a necessary\n> functionality for these extensions, then?\n\nNo.  DeltaV defines those properties so if there is no DeltaV the client\nwould use some other way to distinguish a resource's classification as\nwritten in whatever spec. they are probing for.\n\n> If not, does OPTIONS then remain a better place to look for methods?\n\nPass -- we've been round that loop a few times.  Geoff has written it both\nways, probably more than once.\n\n> Stefan\n> (won't like resource type\n> DAV:checked-out-external-reference-to-ordered-collection)\n\nThe intent was not to have a monster type name, rather something cumulative\nlike:\n\n<DAV:resourcetype>\n   <DAV:collection/>\n   <DAV:workspace/>\n</DAV:resourcetype>\n\n\nTim\n\n\n\n", "id": "lists-006-0007695"}, {"subject": "PROPFIND allprop with more properties (was AW: Resource class", "content": "> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von\n> Tim_Ellison@uk.ibm.com\n>\n> \"Stefan Eissing\" <stefan.eissing@greenbytes.de>\n> > This touches on an issue I (the guy with the webdav [maybe caching\n> > a little] proxy) have with discovering type and status of a WebDAV\n> resource.\n>\n> \"maybe caching a little\" <g>\n;)\n\n> >[...]\n> No.  DeltaV defines those properties so if there is no DeltaV the client\n> would use some other way to distinguish a resource's classification as\n> written in whatever spec. they are probing for.\n\nThanks for the clarification.\n\n> > If not, does OPTIONS then remain a better place to look for methods?\n>\n> Pass -- we've been round that loop a few times.  Geoff has written it both\n> ways, probably more than once.\n\nI've read up on it in the mailing list archive. The argument goes that\na) Depth header makes it more efficient and\nb) doing it in one PROPFIND make it consistent\n\nNow for a proxy with a little bit of caching, this is the way\nto go. But then, oops, I found that the versioning properties did\nvanish from PROPFIND/allprop in revision 14.1 of the draft.\n\nWith the current state of things, I'd have to do 2 PROPFINDS (one\nallprop to catch all dead properties, one specific DAV:supported*\nto know about versioning and resource status).\n\nHas it been discussed already (could not find it in the archive) to\nenhance allprop by allowing the client to specify additional properties?\nThis would make the body of a PROPFIND look like\n\n<propfind xmlns=\"DAV:\">\n  <allprop>\n  <prop>\n    <supported-method-set/>\n    <supported-live-property-set/>\n  </prop>\n</propfind>\n\nand the result would be the joined set of a PROPFIND/allprop\nand PROPFIND/prop.\n\n(The only related thing I could find was the \"WebDAV PROPFIND\nExtension To List Specified Namespaces\" Draft from August 1999.\nWhich is a nice draft, but I assume it is too late to move the\nversioning props into a separate namespace...)\n\nStefan\n\n\n\n", "id": "lists-006-0016845"}, {"subject": "RE: Resource clas", "content": "Resent (again) something fishy going on...\n-----------------------------------\n> \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n>    From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n>\n>    The issue of determining a versioning resource's classification\n>    based on the absence (or otherwise) of properties has been raised\n>    before on the list.  Recently however, (in other contexts) people\n>    have shifted in favour of extensions to <DAV:resourcetype> to\n>    convey more 'type' information.\n>\n> Not me ... I think you should just look in the\n> DAV:supported-method-set and DAV:supported-live-property-set for the\n> methods or properties that you care about.  If it supports the methods\n> and properties you care about, who cares what's in the \"resourcetype\"\n> field (:-).  But then again, if you want to add a bunch of redundant\n> information to the resourcetype field, I guess I don't really care all\n> that much (although it does violate the Goland rule of \"you are done\n> when there is nothing left to cut out\" :-).\n\nThe '(in other contexts)' that I was referring to was the ACL list.  I\nunderstood that the proposal was to extend <DAV:resourcetype> there with\nprincipal and other distinguishers.  I now wonder why there would be two\ndifferent mechanisms adopted to solve the same problem.  What am I missing?\n\nNaturally, I'm not in favour of introducing 'a bunch of redundant\ninformation' anywhere in the spec.  I agree that the\n<DAV:supported-live-property-set> has all the information needed.\n\n<<snip>>\n\n> Note that whether or not a resource is checked-in or checked-out\n> is normally considered part of its \"state\" rather than part of\n> its \"type\" (which just illustrates the vague boundary between\n> \"state\" and \"type\" :-).  If you wanted to know whether or not\n> a resource was checked-in or checked-out, then you would have\n> to PROPFIND for checked-in and checked-out.\n\nI agree that the distinction is vague, which is why I said\n'classification'.  When making high-level UI decisions (menu options\ngreyed-out, choice of icons, etc.) the information required is usually\n'type' _and_ 'state'.  Providing an efficient means of getting the full\nclassification will be important for responsive UIs.\n\nSince <DAV:checked-in> and <DAV:checked-out> will appear in the\n<DAV:supported-live-properties> set I believe that it will be sufficient to\nPROPFIND on <DAV:supported-live-properties> and <DAV:resourcetype> (for\n<DAV:collection/> or a MIME-type etc.) to get an accurate classification.\n\n>>REQUEST\n     PROPFIND /foo HTTP/1.1\n     Host: bar.com\n     Content-Type: text/xml; charset=\"utf-8\"\n     Content-Length: xxx\n\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n     <D:propfind xmlns:D=\"DAV:\">\n         <D:prop>\n             <D:supported-live-property-set/>\n             <D:resourcetype/>\n         </D:prop>\n     </D:propfind>\n\n<<snip>>\n\n>    (ii) It would seem that activities should have a <DAV:resourcetype>\n>    of <DAV:activity>, but I didn't see that in the -15 spec.\n>\n> It appears in the postcondition of MKACTIVITY, but I'm happy to\n> mention it in section 13.1 as well.\n\nI think that would be more consistent with other declarations of\nresourcetype.\n\n<<snip>>\n\n> Or (as I'm sure you can predict I will say ... :-) how about just\n> using DAV:supported-live-property-set?\n\nOk, I get the point<g>\n\nHowever...\nIt feels strange (in a woolly, hand-waving way) to characterise a resource\nbased soley upon its observed/stated behavior -- especially given the\nexistance of a <DAV:resourcetype> property that is being used intuatively\nin some cases (e.g. an activity), and not in others (e.g. a\nversion-controlled configuration).\n\nThe danger that I see is that clients must base their characterisations of\nresources on the existance of specific live properties, and that future\nextensions to DeltaV will have to bear this in mind when defining new\nresource 'types'.  Spec writers will have to deliberately *undefine* a\nproperty just so that clients don't mistake them for the DeltaV types.\nFor example, if I had an idea for a resource that was not a Baseline, but\nhad a legitimate use for the <DAV:baseline-collection> property, all legacy\n(to-be:-) clients would spot the <DAV:baseline-collection> property and\nincorrectly assume it was a Baseline.\n\nHow much more verbose English would be if we had to describe the\ncharacteristics of a crocodile and an alligator in order to distingush them\nrather than rely on their names.\n\nTim\n\n\n\n", "id": "lists-006-0027599"}, {"subject": "AW: Resource clas", "content": "> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von\n> Tim_Ellison@uk.ibm.com\n> > \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> > [...]\n> The '(in other contexts)' that I was referring to was the ACL list.  I\n> understood that the proposal was to extend <DAV:resourcetype> there with\n> principal and other distinguishers.  I now wonder why there would be two\n> different mechanisms adopted to solve the same problem.  What am\n> I missing?\n>\n> Naturally, I'm not in favour of introducing 'a bunch of redundant\n> information' anywhere in the spec.  I agree that the\n> <DAV:supported-live-property-set> has all the information needed.\n>\n> <<snip>>\n>\n> > Note that whether or not a resource is checked-in or checked-out\n> > is normally considered part of its \"state\" rather than part of\n> > its \"type\" (which just illustrates the vague boundary between\n> > \"state\" and \"type\" :-).  If you wanted to know whether or not\n> > a resource was checked-in or checked-out, then you would have\n> > to PROPFIND for checked-in and checked-out.\n>\n> I agree that the distinction is vague, which is why I said\n> 'classification'.  When making high-level UI decisions (menu options\n> greyed-out, choice of icons, etc.) the information required is usually\n> 'type' _and_ 'state'.  Providing an efficient means of getting the full\n> classification will be important for responsive UIs.\n\nOne example I can contribute to this discussion is that in our code\nwe have frequently to check if a resource is version controlled, and\nonly then we start to worry about the state, checked-in or -out,\nof a version controlled resource.\nBut since I have to rely on checked-in/-out according to current\ndraft, I did some performance tests with a\npropfind/allprop+supported-live-property-set instead of just allprop\nand noticed a 5% performance hit with our test suite. Obviously I'm\ndoing a lot of propfinds, and likely our code can be improved, but\nit surely indicates that supported-live-property-set does not\ncome for free. And keep in mind that every future extension of WebDAV\nwill have to show up in that set as well...\n\n> Since <DAV:checked-in> and <DAV:checked-out> will appear in the\n> <DAV:supported-live-properties> set I believe that it will be\n> sufficient to\n> PROPFIND on <DAV:supported-live-properties> and <DAV:resourcetype> (for\n> <DAV:collection/> or a MIME-type etc.) to get an accurate classification.\n>\n> [...]\n> >    (ii) It would seem that activities should have a <DAV:resourcetype>\n> >    of <DAV:activity>, but I didn't see that in the -15 spec.\n> >\n> > It appears in the postcondition of MKACTIVITY, but I'm happy to\n> > mention it in section 13.1 as well.\n>\n> I think that would be more consistent with other declarations of\n> resourcetype.\n>\n> <<snip>>\n>\n> > Or (as I'm sure you can predict I will say ... :-) how about just\n> > using DAV:supported-live-property-set?\n>\n> Ok, I get the point<g>\n>\n> However...\n> It feels strange (in a woolly, hand-waving way) to characterise a resource\n> based soley upon its observed/stated behavior -- especially given the\n> existance of a <DAV:resourcetype> property that is being used intuatively\n> in some cases (e.g. an activity), and not in others (e.g. a\n> version-controlled configuration).\n\nSo, using Java terminology, we are talking about classes and interfaces.\nDifferent classes are reflected in the resourcetype and the implemented\ninterfaces are currently deduced from the set of live properties.\n\nSo, maybe the designers of Java had also Tim's strange, wooly feeling\nabout just relying on class properties and required that a Java class\nhas to declare that it implements a certain interface. Therefore\na) compilers/runtime can easily see what an object supports\nb) compilers can warn/fail if a class does not fully implement an interface\nc) class designers can say what they mean. They avoid implementing\n   an interface by accident. (What Tim talks about in the next paragraph).\n\n> The danger that I see is that clients must base their characterisations of\n> resources on the existance of specific live properties, and that future\n> extensions to DeltaV will have to bear this in mind when defining new\n> resource 'types'.  Spec writers will have to deliberately *undefine* a\n> property just so that clients don't mistake them for the DeltaV types.\n> For example, if I had an idea for a resource that was not a Baseline, but\n> had a legitimate use for the <DAV:baseline-collection> property,\n> all legacy\n> (to-be:-) clients would spot the <DAV:baseline-collection> property and\n> incorrectly assume it was a Baseline.\n\nThat is an argument to be more generous with new DAV: XML namespaces.\n\n> How much more verbose English would be if we had to describe the\n> characteristics of a crocodile and an alligator in order to\n> distingush them\n> rather than rely on their names.\n>\n> Tim\n>\n\nI should probably read more and propose less, but I would like a DAV\nproperty\n\n<implements xmlns=\"DAV:\" xmlns:DV=\"DAV:versioning\" xmlns:DX=\"DAV:feature-X\">\n  <DV:versionable-resource/>\n  <DV:versioned-resource/>\n  <DX:x-type/>\n</implements>\n\nwhich is part of a standard propfind/allprop response.\n\nStefan\n\n\n\n", "id": "lists-006-0040196"}, {"subject": "Re: lock and access control lists on (working) version", "content": "\"Pill, Juergen\" <Juergen.Pill@softwareag.com>\n> Hello,\n>\n> 1) Would it be possible with DETA-V to have different access control list\n> for different versions of a resource, e.g. V1 of resource /foo will allow\n> user A to modify and read, but V2 of resource /foo will allow user A to\nread\n> read only?\n\nYou'd have to ask the ACL-folk that question, but I would sincerely hope\nthe answer is 'yes'.\n\n> 2) Would it be possible to have two distinct locks on two different\n> (working) resources?\n\nYes.  Working resources have distinct server-defined URLs.  They can be\nlocked using their URLs just like any other resource.\n\n> Does that make sense at all?\n\nYep.\n\nTim\n\n\n\n", "id": "lists-006-0053858"}, {"subject": "RE: checked-out VCC: A new proposa", "content": "   From: Fay, Chuck [mailto:CFay@filenet.com]\n\n   > From: Clemm, Geoff [mailto:gclemm@rational.com]\n\n   > ....  Now it is true that if auto-checkout=locked-update is not\n   > set, then a locked resource would never have been automatically\n   > checked out, but this doesn't change/affect the meaning of\n   > auto-checkin=locked-update.\n\n   That was my underlying concern about the two-property approach:\n   there are combinations of settings for auto-checkout and\n   auto-checkin that produce odd results, or are just dysfunctional\n   (as in the above example).  So in that sense, the use of these two\n   properties is not as well-defined as auto-version was.\n\nI don't believe this behavior is any more odd or dysfunctional than\nthe fact that CHECKIN fails if it is applied to a resource that is not\nchecked in, or that UNLOCK fails if it is applied to a resource that\nis not locked.\n\n   I'll leave it up to the list as to whether this is a problem.  It\n   can certainly be avoided by using only combinations that match the\n   old settings for auto-version.\n\nI agree.\n\n   My take on the mapping:\n\n   never:\n       auto-checkout = not set\n       auto-checkin  = not set\n\n   always-checkout-always-checkin:\n       auto-checkout = locked-update, unlocked-update\n       auto-checkin  = locked-update, unlocked-update\n\n   always-checkout-when-unlocked-checkin:\n       auto-checkout = locked-update, unlocked-update\n       auto-checkin  = unlocked-update\n\n   when-locked-checkout:\n       auto-checkout = locked-update\n       auto-checkin  = unlocked-update\n\nYou could also just leave auto-checkin unset in this case, since the\nDAV:auto-checkout indicates that unlocked resource will not be\nautomatically checked out, but setting it to DAV:unlocked-update\nis fine too.\n\n   always-checkout-manual-checkin:\n       auto-checkout = locked-update, unlocked-update\n       auto-checkin  = not set\n\n   > If a write-locked version-controlled resource was automatically\n   > checked out because the DAV:auto-checkout property was\n   > DAV:locked-update, and if the resource was still checked-out when the\n   > write lock is removed (such as from an UNLOCK or lock timeout), then\n   > the removal of the write lock is automatically preceded by a checkin\n   > operation.\n\n   This doesn't seem sufficient.  It would imply that \"auto-checkin = not\nset\"\n   would cause an automatic checkin when the write lock is removed.  I don't\n   think this is what you intended.  That's why I included the specific\nsetting\n   of auto-checkin in my suggested wording.\n\nActually, that was what I intended, i.e. if an auto-checked-out\nresource is unlocked, it is automatically checked in before the unlock\n(independent of the current settings of DAV:auto-checkin).\n\nBut one could make a case to allow this to be explicitly specified in\nthe DAV:auto-checkin setting, i.e. add a \"DAV:unlock\" value for\nDAV:auto-checkin, and only do the auto-checkin on UNLOCK if this value\nis set.  This also makes this behavior more explicit.\n\nAny votes on whether we keep it the way it is, or whether we add an\nexplicit DAV:unlock value to DAV:auto-checkin?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0061867"}, {"subject": "RE: Table for autoversionin", "content": "To map Jim's table to the current protocol:\n\nDAV:always-checkout-always-checkin =>\n   DAV:auto-checkout = (DAV:locked-update, DAV:unlocked-update)\n   DAV:auto-checkin  = (DAV:locked-update, DAV:unlocked-update)\nDAV:always-checkout-when-unlocked-checkin =>\n   DAV:auto-checkout = (DAV:locked-update, DAV:unlocked-update)\n   DAV:auto-checkin  = (DAV:unlocked-update)\nDAV:when-locked-checkout =>\n   DAV:auto-checkout = (DAV:locked-update)\n   DAV:auto-checkin  = ()\nDAV:checkout-on-update-and-keep-checked-out =>\n   DAV:auto-checkout = (DAV:locked-update, DAV:unlocked-update)\n   DAV:auto-checkin  = ()\n\nI believe this illustrates the superiority of the current approach,\nsince the checkout/checkin behavior is largely \"self-evident\"\nfrom the values of the auto-checkout and auto-checkin values.\n\nNote: Half of Jim's rows are for \"co locked\" or \"co unlocked\".\nSince auto-checkout (and therefore auto-checkin) only applies\nwhen the resource being updated is in the checked-in state,\nthe \"co xxx\" lines are not relevant for this table, because\ntheir behavior is unaffected by the auto-checkout status.\n\nNote: Although this table is a useful way to test ones understanding of\nlocking and auto-versioning behavior, I don't think it is suitable\nfor inclusion in the protocol definition of auto-versioning.\nIn particular, I believe it makes auto-versioning behavior look\nmore complex than it really is, because it mixes standard\nlocking semantics (i.e. you can't write-lock a resource if its\nalready locked, and you can't unlock a resource if it is not\nlocked) with auto-versioning semantics.  By doing so, it hides\nthe underlying regularity of the auto-versioning behavior.\n\nJim's table was largely correct, except for a few notes below\n(marked as \"[gmc: ...]\").\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\nSent: Tuesday, April 17, 2001 7:33 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Table for autoversioning\n\n\nIn an effort to wrap my brain around all of the autoversioning options, I\ndeveloped the following table. I'm hoping some variant of this might make it\ninto the specification, since I believe it could increase the correctness of\nimplementations of this feature.  I'm also curious to see if I got it all\nright (I'm most curious about the checked-in states...) :-)\n\nAbreviations used:\n\nci = check-in (or checked-in)\nco = check-out (or checked-out)\nul = unlock\nlk = lock\n-> = sequence of operations (1->2)\nacoaci = always-checkout-always-checkin\nacowuci = always-checkout-when-unlocked-checkin\nwlco = when locked checkout\ncoouakco = checkout-on-update-and-keep-checked-out\n\nOperation \"write\" is defined to be the state modification action of the\nmethod. For a PUT, write = changing the body.  For PROPPATCH, write =\nchanging the property values.\n\nThe table is orgazined as follows:\n\nrows correspond to specific states of the resource (e.g., checked out and\nwrite locked).\ncolumns correspond to specific autoversion options\ncells contain descriptions of what happens when specific methods are invoked\nunder these conditions\n\n\n                acoaci                          acowuci\n\nci locked    PUT/PROPPATCH                    PUT/PROPPATCH\n             co->write->ci                    co->write\n             UNLOCK                           UNLOCK\n             ul                               ul\n             LOCK                             LOCK\n             err:423 Locked                   err:423 Locked\n\n\nci unlocked  PUT/PROPPATCH                    PUT/PROPPATCH\n             co->write->ci                    co->write->ci\n             UNLOCK                           UNLOCK\n             err:412                          err:412\n             LOCK                             LOCK\n             lk                               lk\n\n\nco locked    PUT/PROPPATCH                    PUT/PROPPATCH\n             write                            write\n             UNLOCK                           UNLOCK\n             ul                               ci->ul\n                                      [gmc: only if auto-checked-out]\n             LOCK                             LOCK\n             err:423 Locked                   err: 423 Locked\n\nco unlocked  PUT/PROPPATCH                    PUT/PROPPATCH\n             write                            write\n             UNLOCK                           UNLOCK\n             err:412                          err:412\n             LOCK                             LOCK\n             lk                               lk\n\n\n\n\n               wlco                            coouakco\n\nci locked    PUT/PROPPATCH                    PUT/PROPPATCH\n             co->write                        co->write\n             UNLOCK                           UNLOCK\n             ul                               ul\n    [the unlock will automatically check it in]\n             LOCK                             LOCK\n             err:423                          err:423\n    [gmc: why the 423?  it is not currently locked]\n\nci unlocked  PUT/PROPPATCH                    PUT/PROPPATCH\n             err:DAV:cannot-modify-version-   co->write\n                     controlled-content\n             UNLOCK                           UNLOCK\n             err:412                          err:412\n             LOCK                             LOCK\n             lk                               lk\n\n\nco locked    PUT/PROPPATCH                    PUT/PROPPATCH\n             write                            write\n             UNLOCK                           UNLOCK\n             ci->ul                           ul\n   [gmc: only if auto-checked out]\n             LOCK                             LOCK\n             err:423                          err:423\n                                              CHECKIN\n                                              ci\n\nco unlocked  PUT/PROPPATCH                    PUT/PROPPATCH\n             write                            write\n             UNLOCK                           UNLOCK\n             err:412                          err:412\n             LOCK                             LOCK\n             lk                               lk\n                                              CHECKIN\n                                              ci\n\n\n\n", "id": "lists-006-0072246"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class ", "content": "   From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n\n   ... I found that the versioning properties did\n   vanish from PROPFIND/allprop in revision 14.1 of the draft.\n\n   With the current state of things, I'd have to do 2 PROPFINDS (one\n   allprop to catch all dead properties, one specific DAV:supported*\n   to know about versioning and resource status).\n\nVersioning properties are included in PROPFIND/DAV:propname, so you do\nneed two requests, but they would be a PROPFIND/DAV:propname request,\nand then a PROPFIND on the list of properties returned by the\nPROPFIND/DAV:propname.\n\nBut I would think hard about ever having an application blindly ask\nfor all the properties on a set of resources.  These properties could\nbe very expensive to compute, and since you have no way of determining\nhow long these property values are valid, caching them is of\nquestionable value.\n\n   Has it been discussed already (could not find it in the archive) to\n   enhance allprop by allowing the client to specify additional properties?\n   This would make the body of a PROPFIND look like\n\n   <propfind xmlns=\"DAV:\">\n     <allprop>\n     <prop>\n       <supported-method-set/>\n       <supported-live-property-set/>\n     </prop>\n   </propfind>\n\n   and the result would be the joined set of a PROPFIND/allprop\n   and PROPFIND/prop.\n\n   (The only related thing I could find was the \"WebDAV PROPFIND\n   Extension To List Specified Namespaces\" Draft from August 1999.\n   Which is a nice draft, but I assume it is too late to move the\n   versioning props into a separate namespace...)\n\nBecause of the issues mentioned above (i.e. expense of computing live\nproperty values, and the absence of support for reliable property\nvalue caching), the versioning protocol does not worry about the extra\nround required to obtain \"all versioning properties\".  A live property\nis effectively a \"query\" on the state of a resource.  Would one\nexpect to be able to \"perform all known queries on this resource\"\nin a single round trip?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0085827"}, {"subject": "AW: PROPFIND allprop with more properties (was AW: Resource class ", "content": "> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n> Gesendet: Dienstag, 22. Mai 2001 16:24\n>    From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n>\n>    ... I found that the versioning properties did\n>    vanish from PROPFIND/allprop in revision 14.1 of the draft.\n>\n>    With the current state of things, I'd have to do 2 PROPFINDS (one\n>    allprop to catch all dead properties, one specific DAV:supported*\n>    to know about versioning and resource status).\n>\n> Versioning properties are included in PROPFIND/DAV:propname, so you do\n\nOops. Our understanding was that DAV:propname behaves analog to DAV:allprop\nand will not include the versioning properties. I see that \"propname\" is\nnot mentioned in ietf-deltav-versioning-15. Could you clarify?\n\n> need two requests, but they would be a PROPFIND/DAV:propname request,\n> and then a PROPFIND on the list of properties returned by the\n> PROPFIND/DAV:propname.\n\nMy example was referring back to your explanation about the true usefulness\nof DAV:supported-live-property-set. Since I would like to present all\ndead and standard properties (propfind/allprop), plus know what type\nof resource I have got, I would need to get DAV:supported-live-property-set\nas well (and hopefully _not_ more).\n\n> But I would think hard about ever having an application blindly ask\n> for all the properties on a set of resources.  These properties could\n> be very expensive to compute, and since you have no way of determining\n> how long these property values are valid, caching them is of\n> questionable value.\n\nI totally agree.\n\n>    Has it been discussed already (could not find it in the archive) to\n>    enhance allprop by allowing the client to specify additional\n> properties?\n>    This would make the body of a PROPFIND look like\n>\n>    <propfind xmlns=\"DAV:\">\n>      <allprop>\n>      <prop>\n>        <supported-method-set/>\n>        <supported-live-property-set/>\n>      </prop>\n>    </propfind>\n>\n>    and the result would be the joined set of a PROPFIND/allprop\n>    and PROPFIND/prop.\n>\n>    (The only related thing I could find was the \"WebDAV PROPFIND\n>    Extension To List Specified Namespaces\" Draft from August 1999.\n>    Which is a nice draft, but I assume it is too late to move the\n>    versioning props into a separate namespace...)\n>\n> Because of the issues mentioned above (i.e. expense of computing live\n> property values, and the absence of support for reliable property\n> value caching), the versioning protocol does not worry about the extra\n> round required to obtain \"all versioning properties\".  A live property\n> is effectively a \"query\" on the state of a resource.  Would one\n> expect to be able to \"perform all known queries on this resource\"\n> in a single round trip?\n\nCertainly not. Maybe I need to supply a more specific example:\nMy code could be used by a WebFolder like application, which knows\nabout basic versioning. It would need to know for a collection\na) the \"standard\" RFC 2518 Properties, plus all dead properties (which\n   it might make use of internally)\nb) if a resource is versionable (to allow context menu \"make\nversionable...\")\nc) if a resource is version-controlled, e.g. checked-in/out (to allow\ncontext menu\n   entries like \"check in...\" etc.)\nd) if a resource is versioned, e.g. part of history (to indicate that it\ncannot be altered)\n\nFor this, it is useful to enhance PROPFIND/allprop to make only one request\nagainst the WebDAV server. We did this in our implementation with good\nresults\nlike:\n\n<D:propfind xmlns:D=\"DAV:\">\n  <D:allprop/>\n  <ext:include xmlns:ext=\"http://greenbytes.de/ns/tests\">\n     <D:checked-in/>\n     <D:checked-out/>\n     <D:version-name/>\n  </ext:include>\n</D:propfind>\n\nThis gives us good performance and also works against current\nimplementations\nof moddav, IIS 5.0 and SharePoint RC1.\n\nRegards, Stefan\n\n\n\n", "id": "lists-006-0095617"}, {"subject": "AW: PROPFIND allprop with more properties (was AW: Resource class ", "content": "Forget my head next...\n\n> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Stefan Eissing\n> For this, it is useful to enhance PROPFIND/allprop to make only \n> one request\n> against the WebDAV server. We did this in our implementation with good\n> results\n> like:\n> \n> <D:propfind xmlns:D=\"DAV:\">\n>   <D:allprop/>\n>   <ext:include xmlns:ext=\"http://greenbytes.de/ns/tests\">\n>      <D:checked-in/>\n>      <D:checked-out/>\n>      <D:version-name/>\n\n       <D:supported-method-set/>   <!-- saves OPTIONS call as well -->\n\n>   </ext:include>\n> </D:propfind>\n> \n> This gives us good performance and also works against current\n> implementations\n> of moddav, IIS 5.0 and SharePoint RC1.\n> \n> Regards, Stefan\n> \n> \n\n\n\n", "id": "lists-006-0108520"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class  ", "content": "   From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n\n   Oops. Our understanding was that DAV:propname behaves analog to\n   DAV:allprop and will not include the versioning properties. I see\n   that \"propname\" is not mentioned in\n   ietf-deltav-versioning-15. Could you clarify?\n\nWith the versioning protocol, everything stated in HTTP-1.1 (RFC-2616)\nand WebDAV (RFC-2518) holds unless explicitly extended or modified by\nthe versioning protocol.  Since nothing is said about DAV:propname, it\nhas the behavior defined in RFC-2518, i.e. it lists all the properties\nof a resource (including the versioning properties).\n\n   My example was referring back to your explanation about the true\n   usefulness of DAV:supported-live-property-set. Since I would like\n   to present all dead and standard properties (propfind/allprop),\n   plus know what type of resource I have got, I would need to get\n   DAV:supported-live-property-set as well (and hopefully _not_ more).\n\nOK I misunderstood (I thought you then wanted to actually retrieve all\nthose properties as well) ... now that I understand what you actually\nare doing, I agree that it is very reasonable and sensible.\n\n   ... Maybe I need to supply a more specific example:\n   My code could be used by a WebFolder like application, which knows\n   about basic versioning. It would need to know for a collection\n   a) the \"standard\" RFC 2518 Properties, plus all dead properties (which\n      it might make use of internally)\n   b) if a resource is versionable (to allow context menu \"make\n   versionable...\")\n   c) if a resource is version-controlled, e.g. checked-in/out (to allow\n   context menu\n      entries like \"check in...\" etc.)\n   d) if a resource is versioned, e.g. part of history (to indicate that it\n   cannot be altered)\n\n   For this, it is useful to enhance PROPFIND/allprop to make only one\nrequest\n   against the WebDAV server. We did this in our implementation with good\n   results\n   like:\n\n   <D:propfind xmlns:D=\"DAV:\">\n     <D:allprop/>\n     <ext:include xmlns:ext=\"http://greenbytes.de/ns/tests\">\n<D:checked-in/>\n<D:checked-out/>\n<D:version-name/>\n     </ext:include>\n   </D:propfind>\n\n   This gives us good performance and also works against current\n   implementations of moddav, IIS 5.0 and SharePoint RC1.\n\nThis all makes sense.  I agree that this is the best you can do\nwith the current behavior of D:allprop.  \n\nI support Stefan's proposal that we have a way of querying for\nall dead properties and a specified set of live properties. I\nbelieve we have a cleaner compatibility story if we introduce a\nnew value (e.g. DAV:alldeadprop or DAV:all-dead-prop), and then\nallow that to be combined with a list of explicit properties, i.e.:\n\n   <D:propfind xmlns:D=\"DAV:\">\n     <D:all-dead-prop/>\n     <D:checked-in/>\n     <D:checked-out/>\n     <D:version-name/>\n   </D:propfind>\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0117557"}, {"subject": "FYI: DeltaV implementation report availabl", "content": "For your information: An implementation report for an early version\nof DeltaV (draft 04.5) is available at:\n\nhttp://wwwipd.ira.uka.de/~reuter/publications/deltav.pdf\n\nThis paper was submitted as case study to ICSE '01.\n\nGreetings,\n            Juergen\n\n\n\n", "id": "lists-006-0128486"}, {"subject": "Process for moving to Proposed Standar", "content": "Here's an update on where we are in the process of moving the DeltaV spec \nto Proposed Standard. All IESG documents start their lives as \"Internet \nDrafts\".  Standards-track document goes through a number of life-cycle \nphases starting at \"Proposed Standard\", then progressing to \"Draft \nStandard\" and finally full \"Standard\". According to RFC 2026 (\"The \nInternet Standards Process -- Revision 3\"), a Proposed Standard has the \nfollowing characteristics:\n\n   A Proposed Standard specification is generally stable, has resolved\n   known design choices, is believed to be well-understood, has received\n   significant community review, and appears to enjoy enough community\n   interest to be considered valuable.  However, further experience\n   might result in a change or even retraction of the specification\n   before it advances.\n\n   Usually, neither implementation nor operational experience is\n   required for the designation of a specification as a Proposed\n   Standard.  However, such experience is highly desirable, and will\n   usually represent a strong argument in favor of a Proposed Standard\n   designation.\n\nWe have gone through a number of working group last calls, and at this \ntime have no outstanding issues. We believe the spec is well understood, \nhas received sufficient community review, and has a number of in-progress \nimplementations. To make further progress, we need interoperable \nimplementations. Implementors, are generally more comfortable dealing with \nstable specifications, hence the reason for Proposed Standard. It provides \na specification sufficient for implementation and indicates intent to \nprogress to full Standard.\n\nThe process and rough schedule include:\n\n1. Candidate DeltaV Internet Draft submitted to IETF Application Area \nDirectors for initial review - 4/24/2001.\n\n2. The area directors give the document a review and send it back to the \nworking group for any changes. The working group will respond to these \nchanges through the mailing lists, working group meetings, and or design \nteam meetings as necessary. The updated internet draft is then submitted \nto the Area Directors for further review. If there are a number of \nsignificant changes, we may want to have an additional working group last \ncall. \n\n3. Once the document has been approved by the application area directors, it \ngoes out to an IETF wide last call that lasts for a time specified by the \narea director (at least two weeks). The working group will then respond to \nany feedback from the IETF last call, update the spec as needed, \nsubmitting new Internet Drafts. If the IETF wide last call results in \nsignificant changes or issues, we may have to cycle through the process \nagain to address their issues.\n\n4. Once we have completed the IETF wide last call, the document is \nsubmitted to the full IESG for consideration as a Proposed Standard. \nDepending on the results of the IESG vote, it may be necessary to update \nthe document and resubmit. Once the IESG votes to approve the document, it \nbecomes a Proposed Standard, and we're ready to begin moving to Draft \nStandard. \n\n\n\n", "id": "lists-006-0135747"}, {"subject": "RE: Process for moving to Proposed Standar", "content": "Jim,\n\nI think that trying to do too much \"pipelining\" in the process\nmay actually slow you down. I don't think it is appropriate\nto wait until \"during IESG last call\" to respond to the 6-7\nissues that have been raised on the mailing list since the\n-15 draft of 4/17/01. \n\nAn IESG last call is appropriate when you have a document that\nyou believe has \"resolved known design choices\". Not revising\nthe document now means that you're asking people to review\nsomething when you expect to change it.\n\nThe issues I see on the mailing list are:\n\n>  add a DAV:updated-set\n> and DAV:ignored-set in the UPDATE response body.\n\n# should use\n# <dav:resourcetype> to indicate multiple pieces of type information \n\n# The response to a VERSION-CONTROL request does not carry\n# a Location header similar to CHECKIN (Draft 15).\n\n# Cache-Control: no-cache is not\n# needed for the VERSION-CONTROL response. \n\n#   \"A collection has all the properties of a version.\"\n#   should say \"A collection version has all the properties of a version.\"\n\n# both the \"checkout\" and the \"working-resource\" features\n# introduce a CHECKOUT method that is affected by these properties,\n# the fork-control properties should be identified in\n# both features.  \n\nalthough perhaps you have a different (longer) list?\n\nLarry\n-- \nhttp://larry.masinter.net\n\n\n\n", "id": "lists-006-0147235"}, {"subject": "RE: Process for moving to Proposed Standar", "content": "\"Larry Masinter\" <LMM@acm.org> wrote:\n> Jim,\n>\n> I think that trying to do too much \"pipelining\" in the process\n> may actually slow you down. I don't think it is appropriate\n> to wait until \"during IESG last call\" to respond to the 6-7\n> issues that have been raised on the mailing list since the\n> -15 draft of 4/17/01.\n>\n> An IESG last call is appropriate when you have a document that\n> you believe has \"resolved known design choices\". Not revising\n> the document now means that you're asking people to review\n> something when you expect to change it.\n>\n> The issues I see on the mailing list are:\n>\n> >  add a DAV:updated-set\n> > and DAV:ignored-set in the UPDATE response body.\n\nAgreed -- though I suspect this will be uncontrovertial.\n\n> # should use\n> # <dav:resourcetype> to indicate multiple pieces of type information\n\nAgreed -- ideally it would be sent to the WebDAV WG so that it may apply to\nACLs and friends equally well.\n\n> # The response to a VERSION-CONTROL request does not carry\n> # a Location header similar to CHECKIN (Draft 15).\n\nI believe that this was agreed as a non-issue, or rather that Stefan wanted\nto know when VERSION-CONTROL had affected a resource and when it had not.\n\n> # Cache-Control: no-cache is not\n> # needed for the VERSION-CONTROL response.\n\nAgain, a trivial change that I believe will be non-controvertial.\n\n> #   \"A collection has all the properties of a version.\"\n> #   should say \"A collection version has all the properties of a\nversion.\"\n\nEditorial change.\n\n> # both the \"checkout\" and the \"working-resource\" features\n> # introduce a CHECKOUT method that is affected by these properties,\n> # the fork-control properties should be identified in\n> # both features.\n\nEditorial change.\n\n> although perhaps you have a different (longer) list?\n\nI'm kicking myself for not keeping the list, but I guess I was expecting\nGeoff to do so.  I have asked him to make it generally available as I\nbelieve that there are other issues that were raised (but don't ask me to\nname them without searching<g>)\n\nYour point is well taken, but I don't think it is as bad as you make out.\n\nTim\n\n\n\n", "id": "lists-006-0156893"}, {"subject": "RE: Process for moving to Proposed Standar", "content": "Larry,\nI didn't mean to imply that we would wait for IETF last call to address \nissues. Only that issues that come up in that last call would need to be \naddressed, potentially resulting in the need for spec revisions and an \nadditional last call. I expect to address issues as soon as they come up, \nrefresh the internet draft, and re-submit to the area directors as needed. \nSo I think we're in agreement.\n\n\n\n\n\"Larry Masinter\" <LMM@acm.org>\n05/24/2001 02:29 PM\n\n \n        To:     \"Jim Amsden\" <jamsden@us.ibm.com>, <ietf-dav-versioning@w3.org>\n        cc:     <ned@innosoft.com>, <paf@cisco.com>, \"Geoffrey Clemm\" <gclemm@atria.com>\n        Subject:        RE: Process for moving to Proposed Standard\n\n \n\nJim,\n\nI think that trying to do too much \"pipelining\" in the process\nmay actually slow you down. I don't think it is appropriate\nto wait until \"during IESG last call\" to respond to the 6-7\nissues that have been raised on the mailing list since the\n-15 draft of 4/17/01. \n\nAn IESG last call is appropriate when you have a document that\nyou believe has \"resolved known design choices\". Not revising\nthe document now means that you're asking people to review\nsomething when you expect to change it.\n\nThe issues I see on the mailing list are:\n\n>  add a DAV:updated-set\n> and DAV:ignored-set in the UPDATE response body.\n\n# should use\n# <dav:resourcetype> to indicate multiple pieces of type information \n\n# The response to a VERSION-CONTROL request does not carry\n# a Location header similar to CHECKIN (Draft 15).\n\n# Cache-Control: no-cache is not\n# needed for the VERSION-CONTROL response. \n\n#   \"A collection has all the properties of a version.\"\n#   should say \"A collection version has all the properties of a version.\"\n\n# both the \"checkout\" and the \"working-resource\" features\n# introduce a CHECKOUT method that is affected by these properties,\n# the fork-control properties should be identified in\n# both features. \n\nalthough perhaps you have a different (longer) list?\n\nLarry\n-- \nhttp://larry.masinter.net\n\n\n\n", "id": "lists-006-0166642"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class  ", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Tuesday, May 22, 2001 6:38 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: PROPFIND allprop with more properties (was AW: Resource\n> class )\n>\n>\n>    From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n>\n>    Oops. Our understanding was that DAV:propname behaves analog to\n>    DAV:allprop and will not include the versioning properties. I see\n>    that \"propname\" is not mentioned in\n>    ietf-deltav-versioning-15. Could you clarify?\n>\n> With the versioning protocol, everything stated in HTTP-1.1 (RFC-2616)\n> and WebDAV (RFC-2518) holds unless explicitly extended or modified by\n> the versioning protocol.  Since nothing is said about DAV:propname, it\n> has the behavior defined in RFC-2518, i.e. it lists all the properties\n> of a resource (including the versioning properties).\n\nMy two cents:\n\n- looking at RFC2518 alone, a sever implementor might be tempted to\nimplement <propname> as returning *exactly* those properties that <allprop>\nwill return (I did). If this is not the case with DeltaV, it might be a good\nidea to make that explicit.\n\n- So <propname> needs to compute which deltaV properties are defined for a\nparticular resource. This might *still* be an expensive operation, for\ninstance computing wether  <checked-in> or <checked-out> are present might\nbe as expensive as actually computing their values.\n\n>    My example was referring back to your explanation about the true\n>    usefulness of DAV:supported-live-property-set. Since I would like\n>    to present all dead and standard properties (propfind/allprop),\n>    plus know what type of resource I have got, I would need to get\n>    DAV:supported-live-property-set as well (and hopefully _not_ more).\n>\n> OK I misunderstood (I thought you then wanted to actually retrieve all\n> those properties as well) ... now that I understand what you actually\n> are doing, I agree that it is very reasonable and sensible.\n>\n>    ... Maybe I need to supply a more specific example:\n>    My code could be used by a WebFolder like application, which knows\n>    about basic versioning. It would need to know for a collection\n>    a) the \"standard\" RFC 2518 Properties, plus all dead properties (which\n>       it might make use of internally)\n>    b) if a resource is versionable (to allow context menu \"make\n>    versionable...\")\n>    c) if a resource is version-controlled, e.g. checked-in/out (to allow\n>    context menu\n>       entries like \"check in...\" etc.)\n>    d) if a resource is versioned, e.g. part of history (to\n> indicate that it\n>    cannot be altered)\n>\n>    For this, it is useful to enhance PROPFIND/allprop to make only one\n> request\n>    against the WebDAV server. We did this in our implementation with good\n>    results\n>    like:\n>\n>    <D:propfind xmlns:D=\"DAV:\">\n>      <D:allprop/>\n>      <ext:include xmlns:ext=\"http://greenbytes.de/ns/tests\">\n> <D:checked-in/>\n> <D:checked-out/>\n> <D:version-name/>\n>      </ext:include>\n>    </D:propfind>\n>\n>    This gives us good performance and also works against current\n>    implementations of moddav, IIS 5.0 and SharePoint RC1.\n>\n> This all makes sense.  I agree that this is the best you can do\n> with the current behavior of D:allprop.\n>\n> I support Stefan's proposal that we have a way of querying for\n> all dead properties and a specified set of live properties. I\n> believe we have a cleaner compatibility story if we introduce a\n> new value (e.g. DAV:alldeadprop or DAV:all-dead-prop), and then\n> allow that to be combined with a list of explicit properties, i.e.:\n>\n>    <D:propfind xmlns:D=\"DAV:\">\n>      <D:all-dead-prop/>\n>      <D:checked-in/>\n>      <D:checked-out/>\n>      <D:version-name/>\n>    </D:propfind>\n\nI prefer Stefan's proposal because\n\na) it doesn't require a new \"pseudo\" property and\n\nb) will interoperate with \"old\" RFC2518 based severs and clients well.\n\n\nJulian\n\n\n\n", "id": "lists-006-0177750"}, {"subject": "RE: Process for moving to Proposed Standar", "content": "I agree with Tim.  The changes proposed since version 15\nhave been minor marshalling changes, editorial changes,\nor changes with generic WebDAV impact\n(and therefore are more appropriately handled in the\nrev of 2518 and not in the DeltaV spec).\n\nI've been keeping this list\njust as a folder of email messages,\nbut I'll try to get it posted in summary form to the website\nthis weekend or next week.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Thursday, May 24, 2001 4:54 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Process for moving to Proposed Standard\n\n\n\n\n\"Larry Masinter\" <LMM@acm.org> wrote:\n> Jim,\n>\n> I think that trying to do too much \"pipelining\" in the process\n> may actually slow you down. I don't think it is appropriate\n> to wait until \"during IESG last call\" to respond to the 6-7\n> issues that have been raised on the mailing list since the\n> -15 draft of 4/17/01.\n>\n> An IESG last call is appropriate when you have a document that\n> you believe has \"resolved known design choices\". Not revising\n> the document now means that you're asking people to review\n> something when you expect to change it.\n>\n> The issues I see on the mailing list are:\n>\n> >  add a DAV:updated-set\n> > and DAV:ignored-set in the UPDATE response body.\n\nAgreed -- though I suspect this will be uncontrovertial.\n\n> # should use\n> # <dav:resourcetype> to indicate multiple pieces of type information\n\nAgreed -- ideally it would be sent to the WebDAV WG so that it may apply to\nACLs and friends equally well.\n\n> # The response to a VERSION-CONTROL request does not carry\n> # a Location header similar to CHECKIN (Draft 15).\n\nI believe that this was agreed as a non-issue, or rather that Stefan wanted\nto know when VERSION-CONTROL had affected a resource and when it had not.\n\n> # Cache-Control: no-cache is not\n> # needed for the VERSION-CONTROL response.\n\nAgain, a trivial change that I believe will be non-controvertial.\n\n> #   \"A collection has all the properties of a version.\"\n> #   should say \"A collection version has all the properties of a\nversion.\"\n\nEditorial change.\n\n> # both the \"checkout\" and the \"working-resource\" features\n> # introduce a CHECKOUT method that is affected by these properties,\n> # the fork-control properties should be identified in\n> # both features.\n\nEditorial change.\n\n> although perhaps you have a different (longer) list?\n\nI'm kicking myself for not keeping the list, but I guess I was expecting\nGeoff to do so.  I have asked him to make it generally available as I\nbelieve that there are other issues that were raised (but don't ask me to\nname them without searching<g>)\n\nYour point is well taken, but I don't think it is as bad as you make out.\n\nTim\n\n\n\n", "id": "lists-006-0191785"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class  ", "content": "> >\n> >    <D:propfind xmlns:D=\"DAV:\">\n> >      <D:all-dead-prop/>\n> >      <D:checked-in/>\n> >      <D:checked-out/>\n> >      <D:version-name/>\n> >    </D:propfind>\n>\n> I prefer Stefan's proposal because\n>\n> a) it doesn't require a new \"pseudo\" property and\n>\n> b) will interoperate with \"old\" RFC2518 based severs and clients well.\n>\nIt would NOT work with old implementations unless it looks like this:\n\n<D:propfind xmlns:D=\"DAV:\">\n  <D:all-dead-prop/>\n  <D:prop>\n    <D:checked-in/>\n    <D:checked-out/>\n    <D:version-name/>\n  </D:prop>\n</D:propfind>\n\nIt's also not a solution to the problem unless we specifically deprecate\nallprop or change its meaning because naive and old clients will still do\nthe expensive 'allprop'.  Especially because 'allprop' is the default for an\nempty PROPFIND request.\n\n--Lisa\n\n\n\n", "id": "lists-006-0202989"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class  ", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: Friday, May 25, 2001 1:50 AM\n> To: Julian F. Reschke; ietf-dav-versioning@w3.org\n> Subject: RE: PROPFIND allprop with more properties (was AW: Resource\n> class )\n>\n>\n> > >\n> > >    <D:propfind xmlns:D=\"DAV:\">\n> > >      <D:all-dead-prop/>\n> > >      <D:checked-in/>\n> > >      <D:checked-out/>\n> > >      <D:version-name/>\n> > >    </D:propfind>\n> >\n> > I prefer Stefan's proposal because\n> >\n> > a) it doesn't require a new \"pseudo\" property and\n> >\n> > b) will interoperate with \"old\" RFC2518 based severs and clients well.\n> >\n> It would NOT work with old implementations unless it looks like this:\n>\n> <D:propfind xmlns:D=\"DAV:\">\n>   <D:all-dead-prop/>\n>   <D:prop>\n>     <D:checked-in/>\n>     <D:checked-out/>\n>     <D:version-name/>\n>   </D:prop>\n> </D:propfind>\n\nCould you explain?\n\nOld servers will ignore the \"include\" element -- a new client will be aware\nthat is was ignored because the additionally selected properties will not\nturn up anywhere in the multistatus response. An old client will never use\nthe \"include\" element, therefore there'll be no interoperatibility issues.\n\nWith your proposal, how would one get a) the RFC2518 standard properties +\nb) dead properties + c) selected computed properties from DASL/ACL/... with\none PROPFIND?\n\n> It's also not a solution to the problem unless we specifically deprecate\n> allprop or change its meaning because naive and old clients will still do\n> the expensive 'allprop'.  Especially because 'allprop' is the\n> default for an\n> empty PROPFIND request.\n\nIt wasn't meant to solve this problem -- it's a way for a client to\nspecifically request \"almost all\" properties + selected properties that\nwouldn't show up otherwise.\n\n\n\n", "id": "lists-006-0212171"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class  ", "content": "> > >    <D:propfind xmlns:D=\"DAV:\">\n> > >      <D:all-dead-prop/>\n> > >      <D:checked-in/>\n> > >      <D:checked-out/>\n> > >      <D:version-name/>\n> > >    </D:propfind>\n> >\n> >\n> > <D:propfind xmlns:D=\"DAV:\">\n> >   <D:all-dead-prop/>\n> >   <D:prop>\n> >     <D:checked-in/>\n> >     <D:checked-out/>\n> >     <D:version-name/>\n> >   </D:prop>\n> > </D:propfind>\n>\n> Could you explain?\n>\n> Old servers will ignore the \"include\" element -- a new client\n> will be aware\n> that is was ignored because the additionally selected properties will not\n> turn up anywhere in the multistatus response. An old client will never use\n> the \"include\" element, therefore there'll be no interoperatibility issues.\n\nI don't understand what you're saying about the \"include\" element.\n\nNevertheless, I do have strong logic for putting the property names under\nsome container, and that's to distinguish property names from non-property\nnames.  \"all-dead-prop\" is not a property name.  \"checked-in\" is.  If they\nare glommed together in a list, then that's treating \"all-dead-prop\" as if\nit was a property name.  That prevents the server from ever having a\nproperty called \"all-dead-prop\", since the XML element with that name was\nused the way you're proposing.\n\nlisa\n\n\n\n", "id": "lists-006-0223692"}, {"subject": "Deleting version", "content": "I know not all implementations of DeltaV will allow deleting old versions,\nbut the specifications specifically allows it.  I've been looking into that\nfunctionality and encountered some issues and questions.\n\n#1)  Is there some way of finding out, before trying the delete, if it's\npossible to delete a version?  Before you say \"supported-method-set\", allow\nme to point out that this property is not shown to exist on versions.\n\n#2) It looks like there's a set of error msgs the server can return if it\ndecides to prevent the user from deleting the referenced version, the root\nversion, or all versions.  What error msg should the server return if it\ndecides to prevent the user from deleting the \"current\" version (though one\nthat is not checked out)?  Or what if the server decides to prevent the only\nremaining version from being deleted?\n\n#3) I don't understand the following text from 3.12:\n\"(DAV:update-predecessor-set): If a version is deleted, any reference to\nthat version in a DAV:predecessor-set MUST be replaced by a copy of the\nDAV:predecessor-set of the deleted version.\"  Does that mean that before\ndeleting a version, the client must munge the predecessor-set properties of\na bunch of other versions?  But the predecessor-set is protected!  Or does\nit mean that the server must update the predecessor-set before performing\nthe action, and if it cannot, it returns the error msg?  Please explain this\nbetter in the draft & to the list...\n\n#4) Can situations arise where resources can have no versions?  I can\nactually think of two ways this might be achieved:\n - A client deletes all the versions (but not the version-controlled\nresource)\n - A null resource gets versioning turned on but no body is added\nMust clients be able to deal with VCRs with zero versions?  If not, then we\nneed to make a requirement on servers that they must not ever create a VCR\nwith zero versions.\n\nlisa\n\n\n\n", "id": "lists-006-0233384"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class  ", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: Friday, May 25, 2001 6:28 PM\n> To: Julian F. Reschke; ietf-dav-versioning@w3.org\n> Subject: RE: PROPFIND allprop with more properties (was AW: Resource\n> class )\n>\n>\n>\n> > > >    <D:propfind xmlns:D=\"DAV:\">\n> > > >      <D:all-dead-prop/>\n> > > >      <D:checked-in/>\n> > > >      <D:checked-out/>\n> > > >      <D:version-name/>\n> > > >    </D:propfind>\n> > >\n> > >\n> > > <D:propfind xmlns:D=\"DAV:\">\n> > >   <D:all-dead-prop/>\n> > >   <D:prop>\n> > >     <D:checked-in/>\n> > >     <D:checked-out/>\n> > >     <D:version-name/>\n> > >   </D:prop>\n> > > </D:propfind>\n> >\n> > Could you explain?\n> >\n> > Old servers will ignore the \"include\" element -- a new client\n> > will be aware\n> > that is was ignored because the additionally selected\n> properties will not\n> > turn up anywhere in the multistatus response. An old client\n> will never use\n> > the \"include\" element, therefore there'll be no\n> interoperatibility issues.\n>\n> I don't understand what you're saying about the \"include\" element.\n\nMaybe you should go back to the proposal. We have suggested adding an\n<include> element as child of <propfind>, which can be used to specifically\nadd properties to those which would be reported by <allprop>. This allows to\nget the RFC2518-<allprop> *plus* specific properties from DeltaV/ACL with\none call.\n\n> Nevertheless, I do have strong logic for putting the property names under\n> some container, and that's to distinguish property names from non-property\n> names.  \"all-dead-prop\" is not a property name.  \"checked-in\" is.  If they\n\nSo do I. Please check what we proposed -- you were quoting from Geoff's\nexample, not ours.\n\nWe are currently doing it this way (with \"include\" in our own namespace):\n\n<propfind xmlns=\"DAV:\">\n  <allprop/>\n  <include>\n    <checked-in/><checked-out/><version-name/>\n  </include>\n</propfind>\n\n> are glommed together in a list, then that's treating \"all-dead-prop\" as if\n> it was a property name.  That prevents the server from ever having a\n> property called \"all-dead-prop\", since the XML element with that name was\n> used the way you're proposing.\n\n\n\n", "id": "lists-006-0244575"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class  ", "content": "> Maybe you should go back to the proposal. We have suggested adding an\n...\n>\n> So do I. Please check what we proposed -- you were quoting from Geoff's\n> example, not ours.\n>\n> We are currently doing it this way (with \"include\" in our own namespace):\n>\n> <propfind xmlns=\"DAV:\">\n>   <allprop/>\n>   <include>\n>     <checked-in/><checked-out/><version-name/>\n>   </include>\n> </propfind>\n>\nSorry, you're right, I got confused after a few replies and was criticizing\nGeoff's example, not yours.\n\nYour example has good backward-compatibility, as did mine.\n\nlisa\n\n\n\n", "id": "lists-006-0256594"}, {"subject": "RE: Deleting version", "content": "> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: 25 May 2001 17:58\n> To: DeltaV\n> Subject: Deleting versions\n>\n>\n>\n> I know not all implementations of DeltaV will allow deleting old versions,\n> but the specifications specifically allows it.  I've been looking\n> into that\n> functionality and encountered some issues and questions.\n>\n> #1)  Is there some way of finding out, before trying the delete, if it's\n> possible to delete a version?  Before you say\n> \"supported-method-set\", allow\n> me to point out that this property is not shown to exist on versions.\n\nSure it is.  All resource properteis described in versioning-15 sec 3.1\nstates \"The version-control feature introduces the following REQUIRED\nproperties for any WebDAV resource.\", and since \"The version-control feature\nMUST be supported if any other versioning feature is supported.\" it follows\nthat you can always ask a versioning resource for its supported methods.\n\n> #2) It looks like there's a set of error msgs the server can return if it\n> decides to prevent the user from deleting the referenced version, the root\n> version, or all versions.  What error msg should the server return if it\n> decides to prevent the user from deleting the \"current\" version\n> (though one\n> that is not checked out)?\n\nPlease clarify what you mean by the \"current\" version?\n\n> Or what if the server decides to prevent the only\n> remaining version from being deleted?\n\nThis case is not called out by the spec., so I would expect 403 Forbidden\nwith no interoperable extended error info.  Just as there will be other\ncases that servers (say for implementation reasons) refuse methods and have\ninterop way of explaining why.\n\n> #3) I don't understand the following text from 3.12:\n> \"(DAV:update-predecessor-set): If a version is deleted, any reference to\n> that version in a DAV:predecessor-set MUST be replaced by a copy of the\n> DAV:predecessor-set of the deleted version.\"  Does that mean that before\n> deleting a version, the client must munge the predecessor-set\n> properties of\n> a bunch of other versions?\n\nYes, potentially.  The postcondition is required to fix up the history to\nshow a continuous ancestry for the remaining versions.\n\n> But the predecessor-set is protected!\n\n... from clients.  There are many examples of protected properties that a\nserver can/will modify.\n\n> Or does\n> it mean that the server must update the predecessor-set before performing\n> the action, and if it cannot, it returns the error msg?  Please\n> explain this\n> better in the draft & to the list...\n\nIt is a postcondition of the DELETE method for a version, therefore if it\ncannot be made true it MUST be as though the method was never sent.  No\npartial results will be left by the server, whether the fix up is done\nbefore/after the action is up to the implementation -- the spec states\neffectively that by the time 'the response is dispatched' the postcondition\nis true.  This is the same for all methods (not just DeltaV).\n\n> #4) Can situations arise where resources can have no versions?\n\nNo.  Take a look at the 3.12 postcondition\n(DAV:must-be-root-version): If the root version of a version history is\ndeleted, there MUST be another version that is the new root version,\ni.e. that is the ancestor of all other versions in the version history.\n\n> I can\n> actually think of two ways this might be achieved:\n>  - A client deletes all the versions (but not the version-controlled\n> resource)\n\nSee above.\n\n>  - A null resource gets versioning turned on but no body is added\n\nA what? <g>\n\n> Must clients be able to deal with VCRs with zero versions?  If\n> not, then we\n> need to make a requirement on servers that they must not ever create a VCR\n> with zero versions.\n\nThe way to create a version-controlled resource is with VERSION-CONTROL\nwhich always creates a version-controlled resource based on a version.  If\nthe target resource was versionable the new version is created, or the\nVERSION-CONTROL can reference an existing version in the request body.\n\nTim\n\n\n\n", "id": "lists-006-0264784"}, {"subject": "RE: Deleting version", "content": "I agree with Tim's responses.  To make sure that nobody misunderstands\nthe semantics of the method preconditions and postconditions, I propose\nto modify section 1.6 to read as follows:\n\n---------------------\n\n1.6Method Preconditions and Postconditions\n\nA \"precondition\" of a method describes the state on the server that must be\ntrue\nfor that method to be performed.  A \"postcondition\" of a method describes\nthe\nstate on the server that must be true after that method has completed.\nIf a precondition is violated by a request or a postcondition cannot\nbe satisfied, the response status of the request MUST be 403\n(Forbidden) or 409 (Conflict).  A 403 (Forbidden) status indicates\nthat an error has occurred that the client cannot resolve, and\ntherefore the request should not be resubmitted.  A 409 (Conflict)\nstatus indicates that an error has occurred that the client can\nresolve, after which the request could be resubmitted.\n\nIn order to allow better client handling of 403 and 409 responses, a\ndistinct XML element type is associated with each method\nprecondition and postcondition of a request.  When a particular\nprecondition is violated or a particular postcondition cannot be\nsatisfied, the appropriate XML element MUST be returned as the child\nof a top-level DAV:error element in the response body, unless\notherwise negotiated by the request.  In a 207 Multi-Status response,\nthis element would appear in the appropriate DAV:response-description\nelement.\n\n----------------------\n\nLisa: Does this address your concern?\n\nAnyone: Is this wording OK?\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Tim Ellison [mailto:tim@peir.com]\nSent: Friday, May 25, 2001 5:43 PM\nTo: DeltaV\nSubject: RE: Deleting versions\n\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: 25 May 2001 17:58\n> To: DeltaV\n> Subject: Deleting versions\n>\n>\n>\n> I know not all implementations of DeltaV will allow deleting old versions,\n> but the specifications specifically allows it.  I've been looking\n> into that\n> functionality and encountered some issues and questions.\n>\n> #1)  Is there some way of finding out, before trying the delete, if it's\n> possible to delete a version?  Before you say\n> \"supported-method-set\", allow\n> me to point out that this property is not shown to exist on versions.\n\nSure it is.  All resource properteis described in versioning-15 sec 3.1\nstates \"The version-control feature introduces the following REQUIRED\nproperties for any WebDAV resource.\", and since \"The version-control feature\nMUST be supported if any other versioning feature is supported.\" it follows\nthat you can always ask a versioning resource for its supported methods.\n\n> #2) It looks like there's a set of error msgs the server can return if it\n> decides to prevent the user from deleting the referenced version, the root\n> version, or all versions.  What error msg should the server return if it\n> decides to prevent the user from deleting the \"current\" version\n> (though one\n> that is not checked out)?\n\nPlease clarify what you mean by the \"current\" version?\n\n> Or what if the server decides to prevent the only\n> remaining version from being deleted?\n\nThis case is not called out by the spec., so I would expect 403 Forbidden\nwith no interoperable extended error info.  Just as there will be other\ncases that servers (say for implementation reasons) refuse methods and have\ninterop way of explaining why.\n\n> #3) I don't understand the following text from 3.12:\n> \"(DAV:update-predecessor-set): If a version is deleted, any reference to\n> that version in a DAV:predecessor-set MUST be replaced by a copy of the\n> DAV:predecessor-set of the deleted version.\"  Does that mean that before\n> deleting a version, the client must munge the predecessor-set\n> properties of\n> a bunch of other versions?\n\nYes, potentially.  The postcondition is required to fix up the history to\nshow a continuous ancestry for the remaining versions.\n\n> But the predecessor-set is protected!\n\n... from clients.  There are many examples of protected properties that a\nserver can/will modify.\n\n> Or does\n> it mean that the server must update the predecessor-set before performing\n> the action, and if it cannot, it returns the error msg?  Please\n> explain this\n> better in the draft & to the list...\n\nIt is a postcondition of the DELETE method for a version, therefore if it\ncannot be made true it MUST be as though the method was never sent.  No\npartial results will be left by the server, whether the fix up is done\nbefore/after the action is up to the implementation -- the spec states\neffectively that by the time 'the response is dispatched' the postcondition\nis true.  This is the same for all methods (not just DeltaV).\n\n> #4) Can situations arise where resources can have no versions?\n\nNo.  Take a look at the 3.12 postcondition\n(DAV:must-be-root-version): If the root version of a version history\nis\ndeleted, there MUST be another version that is the new root version,\ni.e. that is the ancestor of all other versions in the version\nhistory.\n\n> I can\n> actually think of two ways this might be achieved:\n>  - A client deletes all the versions (but not the version-controlled\n> resource)\n\nSee above.\n\n>  - A null resource gets versioning turned on but no body is added\n\nA what? <g>\n\n> Must clients be able to deal with VCRs with zero versions?  If\n> not, then we\n> need to make a requirement on servers that they must not ever create a VCR\n> with zero versions.\n\nThe way to create a version-controlled resource is with VERSION-CONTROL\nwhich always creates a version-controlled resource based on a version.  If\nthe target resource was versionable the new version is created, or the\nVERSION-CONTROL can reference an existing version in the request body.\n\nTim\n\n\n\n", "id": "lists-006-0276346"}, {"subject": "RE: Process for moving to Proposed Standar", "content": "I've followed Larry's advice, and posted a 15.1 working draft\nto the web site.  This contains the editorial changes suggested\nsince the 15 draft was submitted (and a section enumerating these\nchanges), as well as an \"issues list\" (with proposed resolutions\nof those issues).  (The issues Larry enumerated below appear in\neither the changes list or the issues list).\n\n<http://www.webdav.org/deltav/protocol/draft-ietf-deltav-versioning-15.1.htm\n>\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Larry Masinter [mailto:LMM@acm.org]\n\nI think that trying to do too much \"pipelining\" in the process\nmay actually slow you down. I don't think it is appropriate\nto wait until \"during IESG last call\" to respond to the 6-7\nissues that have been raised on the mailing list since the\n-15 draft of 4/17/01. \n\nAn IESG last call is appropriate when you have a document that\nyou believe has \"resolved known design choices\". Not revising\nthe document now means that you're asking people to review\nsomething when you expect to change it.\n\nThe issues I see on the mailing list are:\n\n>  add a DAV:updated-set\n> and DAV:ignored-set in the UPDATE response body.\n\n# should use\n# <dav:resourcetype> to indicate multiple pieces of type information \n\n# The response to a VERSION-CONTROL request does not carry\n# a Location header similar to CHECKIN (Draft 15).\n\n# Cache-Control: no-cache is not\n# needed for the VERSION-CONTROL response. \n\n#   \"A collection has all the properties of a version.\"\n#   should say \"A collection version has all the properties of a version.\"\n\n# both the \"checkout\" and the \"working-resource\" features\n# introduce a CHECKOUT method that is affected by these properties,\n# the fork-control properties should be identified in\n# both features.  \n\nalthough perhaps you have a different (longer) list?\n\n\n\n", "id": "lists-006-0290189"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class   ", "content": "I agree with Lisa's criticism of my counter-proposal,\ni.e. that it prevented DAV:all-dead-prop from being\nused as a property name.\n\nTo avoid the introduction of the DAV:include element,\nand to reflect that fact that we are \"adding stuff to what\nDAV:allprop returns\", another minor variant we could consider\nwould be:\n\n<propfind xmlns=\"DAV:\">\n  <allprop>\n    <checked-in/><checked-out/><version-name/>\n  </allprop>\n</propfind>\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\nSent: Friday, May 25, 2001 1:31 PM\nTo: Lisa Dusseault; ietf-dav-versioning@w3.org\nSubject: RE: PROPFIND allprop with more properties (was AW: Resource\nclass )\n\n\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: Friday, May 25, 2001 6:28 PM\n> To: Julian F. Reschke; ietf-dav-versioning@w3.org\n> Subject: RE: PROPFIND allprop with more properties (was AW: Resource\n> class )\n>\n>\n>\n> > > >    <D:propfind xmlns:D=\"DAV:\">\n> > > >      <D:all-dead-prop/>\n> > > >      <D:checked-in/>\n> > > >      <D:checked-out/>\n> > > >      <D:version-name/>\n> > > >    </D:propfind>\n> > >\n> > >\n> > > <D:propfind xmlns:D=\"DAV:\">\n> > >   <D:all-dead-prop/>\n> > >   <D:prop>\n> > >     <D:checked-in/>\n> > >     <D:checked-out/>\n> > >     <D:version-name/>\n> > >   </D:prop>\n> > > </D:propfind>\n> >\n> > Could you explain?\n> >\n> > Old servers will ignore the \"include\" element -- a new client\n> > will be aware\n> > that is was ignored because the additionally selected\n> properties will not\n> > turn up anywhere in the multistatus response. An old client\n> will never use\n> > the \"include\" element, therefore there'll be no\n> interoperatibility issues.\n>\n> I don't understand what you're saying about the \"include\" element.\n\nMaybe you should go back to the proposal. We have suggested adding an\n<include> element as child of <propfind>, which can be used to specifically\nadd properties to those which would be reported by <allprop>. This allows to\nget the RFC2518-<allprop> *plus* specific properties from DeltaV/ACL with\none call.\n\n> Nevertheless, I do have strong logic for putting the property names under\n> some container, and that's to distinguish property names from non-property\n> names.  \"all-dead-prop\" is not a property name.  \"checked-in\" is.  If they\n\nSo do I. Please check what we proposed -- you were quoting from Geoff's\nexample, not ours.\n\nWe are currently doing it this way (with \"include\" in our own namespace):\n\n<propfind xmlns=\"DAV:\">\n  <allprop/>\n  <include>\n    <checked-in/><checked-out/><version-name/>\n  </include>\n</propfind>\n\n> are glommed together in a list, then that's treating \"all-dead-prop\" as if\n> it was a property name.  That prevents the server from ever having a\n> property called \"all-dead-prop\", since the XML element with that name was\n> used the way you're proposing.\n\n\n\n", "id": "lists-006-0300449"}, {"subject": "RE: lock and access control lists on (working) version", "content": "As Tim surmised, the answer to (1) is in fact \"yes\".\nEach version is a separate resource, and each resource\ncan have its own distinct access control list.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Wednesday, May 16, 2001 5:42 AM\nTo: ietf-dav-versioning@w3.org\nCc: acl@webdav.org\nSubject: Re: lock and access control lists on (working) versions\n\n\n\n\n\"Pill, Juergen\" <Juergen.Pill@softwareag.com>\n> Hello,\n>\n> 1) Would it be possible with DETA-V to have different access control list\n> for different versions of a resource, e.g. V1 of resource /foo will allow\n> user A to modify and read, but V2 of resource /foo will allow user A to\nread\n> read only?\n\nYou'd have to ask the ACL-folk that question, but I would sincerely hope\nthe answer is 'yes'.\n\n> 2) Would it be possible to have two distinct locks on two different\n> (working) resources?\n\nYes.  Working resources have distinct server-defined URLs.  They can be\nlocked using their URLs just like any other resource.\n\n> Does that make sense at all?\n\nYep.\n\nTim\n\n\n\n", "id": "lists-006-0313099"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class   ", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Saturday, May 26, 2001 5:27 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: PROPFIND allprop with more properties (was AW: Resource\n> class )\n>\n>\n> I agree with Lisa's criticism of my counter-proposal,\n> i.e. that it prevented DAV:all-dead-prop from being\n> used as a property name.\n>\n> To avoid the introduction of the DAV:include element,\n> and to reflect that fact that we are \"adding stuff to what\n> DAV:allprop returns\", another minor variant we could consider\n> would be:\n>\n> <propfind xmlns=\"DAV:\">\n>   <allprop>\n>     <checked-in/><checked-out/><version-name/>\n>   </allprop>\n> </propfind>\n\nThis one won't interoperate with old servers, because <allprop> is defined\nto be EMPTY (in RFC2518).\n\nSo if you hit an old server, you'll have to two two additional requests\n(<allprop> and <prop> with the three named properties), while with\n<include>, it will be just one additional request (using <prop> to get the\nthree additional properties).\n\nBTW: chapter 23.3.2 of RFC2518 gives a very similar example for legally\nextending PROPFIND.\n\n\n\n", "id": "lists-006-0323335"}, {"subject": "AW: PROPFIND allprop with more properties (was AW: Resource class   ", "content": "> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Julian F.\n> Reschke\n> Gesendet: Montag, 28. Mai 2001 09:50\n> An: Clemm, Geoff; ietf-dav-versioning@w3.org\n> Betreff: RE: PROPFIND allprop with more properties (was AW: Resource\n> class )\n>\n>\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > Sent: Saturday, May 26, 2001 5:27 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: RE: PROPFIND allprop with more properties (was AW: Resource\n> > class )\n> >\n> >\n> > I agree with Lisa's criticism of my counter-proposal,\n> > i.e. that it prevented DAV:all-dead-prop from being\n> > used as a property name.\n> >\n> > To avoid the introduction of the DAV:include element,\n> > and to reflect that fact that we are \"adding stuff to what\n> > DAV:allprop returns\", another minor variant we could consider\n> > would be:\n> >\n> > <propfind xmlns=\"DAV:\">\n> >   <allprop>\n> >     <checked-in/><checked-out/><version-name/>\n> >   </allprop>\n> > </propfind>\n>\n> This one won't interoperate with old servers, because <allprop> is defined\n> to be EMPTY (in RFC2518).\n>\n> So if you hit an old server, you'll have to two two additional requests\n> (<allprop> and <prop> with the three named properties), while with\n> <include>, it will be just one additional request (using <prop> to get the\n> three additional properties).\n>\n> BTW: chapter 23.3.2 of RFC2518 gives a very similar example for legally\n> extending PROPFIND.\n>\n\nI find the arguments in RFC2518 Ch. 23.3 (esp. 23.3.2.2) very convincing.\nThus the most backward compatible solution is using include in its own\nnamespace:\n\n<propfind xmlns=\"DAV:\">\n  <allprop/>\n  <DV:include xmlns:DV=\"DAV:deltav\">\n    <checked-in/><checked-out/><version-name/>\n  </DV:include>\n</propfind>\n\nwhere I don't specifically care what the namespace is (could also be\n\"DAV:extended\" or \"DAV:addons-to-rfc2518\"). If an implementor follows\nRFC2518, non-aware servers have to accept this message as a valid\npropfind/allprop (and indeed all I could test against do).\n\nCan someone of the more experienced DAVers suggest a good namespace?\n\n//Stefan\n\n\n\n", "id": "lists-006-0334070"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class   ", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Stefan Eissing\n> Sent: Monday, May 28, 2001 10:37 AM\n> To: Clemm, Geoff; ietf-dav-versioning@w3.org\n> Subject: AW: PROPFIND allprop with more properties (was AW: Resource\n> class )\n>\n> ...\n>\n> I find the arguments in RFC2518 Ch. 23.3 (esp. 23.3.2.2) very convincing.\n> Thus the most backward compatible solution is using include in its own\n> namespace:\n>\n> <propfind xmlns=\"DAV:\">\n>   <allprop/>\n>   <DV:include xmlns:DV=\"DAV:deltav\">\n>     <checked-in/><checked-out/><version-name/>\n>   </DV:include>\n> </propfind>\n>\n> where I don't specifically care what the namespace is (could also be\n> \"DAV:extended\" or \"DAV:addons-to-rfc2518\"). If an implementor follows\n> RFC2518, non-aware servers have to accept this message as a valid\n> propfind/allprop (and indeed all I could test against do).\n\nI can't see why putting it into the DAV: namespace would be a problem.\nAlthough I'd prefer to have other WebDAV related specs (like ACL and deltaV)\nuse their own namespaces, this one seems to apply to all WebDAV servers, no\nmatter whether any combination of ACL and DeltaV is implemented...\n\n\n\n", "id": "lists-006-0347163"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class    ", "content": "   From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n\n   > <propfind xmlns=\"DAV:\">\n   >   <allprop>\n   >     <checked-in/><checked-out/><version-name/>\n   >   </allprop>\n   > </propfind>\n\n   This one won't interoperate with old servers, because <allprop> is\n   defined to be EMPTY (in RFC2518).\n\nArgh.  Julian is of course right (again :-).  Although I will point\nout (hopefully correctly, for a change :-), that you could nest the\nDAV:include node inside the DAV:allprop, rather than inside the\nDAV:propfind, i.e.\n\n <propfind xmlns=\"DAV:\">\n  <allprop>\n   <include>\n    <checked-in/><checked-out/><version-name/>\n   </include>\n  </allprop>\n </propfind>\n\nBut either way (i.e. nesting the DAV:include inside of DAV:propfind,\nor nesting it inside of DAV:allprop) is fine with me.\n\n   > From: Stefan Eissing\n   > ...\n   > I find the arguments in RFC2518 Ch. 23.3 (esp. 23.3.2.2) very\n   > convincing.  Thus the most backward compatible solution is using\n   > include in its own namespace:\n   >\n   > <propfind xmlns=\"DAV:\">\n   >   <allprop/>\n   >   <DV:include xmlns:DV=\"DAV:deltav\">\n   >     <checked-in/><checked-out/><version-name/>\n   >   </DV:include>\n   > </propfind>\n   >\n   > where I don't specifically care what the namespace is (could also\n   > be \"DAV:extended\" or \"DAV:addons-to-rfc2518\"). If an implementor\n   > follows RFC2518, non-aware servers have to accept this message as\n   > a valid propfind/allprop (and indeed all I could test against\n   > do).\n\n   I can't see why putting it into the DAV: namespace would be a\n   problem.  Although I'd prefer to have other WebDAV related specs\n   (like ACL and deltaV) use their own namespaces, this one seems to\n   apply to all WebDAV servers, no matter whether any combination of\n   ACL and DeltaV is implemented...\n\nI agree with Julian that there is no reason to put the \"include\"\nelement in its own namespace.  RFC 2518 requires a server to ignore\nany XML element it doesn't understand, irrespective of what namespace\nit appears in.  The example in 23.3.2.2 does show the extension in\nanother namespace, but that is just an example.\n\nJulian: Why would you prefer to have WebDAV extensions defined through\nthe IETF (such as DeltaV and ACL) use their own namespaces?  There\nclearly is a reason to define non-IETF standardized properties in\ntheir own namespace, but it is simpler to just have all IETF WebDAV\nextensions use the DAV: namespace.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0357753"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class    ", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Monday, May 28, 2001 5:05 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: PROPFIND allprop with more properties (was AW: Resource\n> class )\n>\n>\n>    From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n>\n>    > <propfind xmlns=\"DAV:\">\n>    >   <allprop>\n>    >     <checked-in/><checked-out/><version-name/>\n>    >   </allprop>\n>    > </propfind>\n>\n>    This one won't interoperate with old servers, because <allprop> is\n>    defined to be EMPTY (in RFC2518).\n>\n> Argh.  Julian is of course right (again :-).  Although I will point\n> out (hopefully correctly, for a change :-), that you could nest the\n> DAV:include node inside the DAV:allprop, rather than inside the\n> DAV:propfind, i.e.\n>\n>  <propfind xmlns=\"DAV:\">\n>   <allprop>\n>    <include>\n>     <checked-in/><checked-out/><version-name/>\n>    </include>\n>   </allprop>\n>  </propfind>\n\nWell, that would be invalid for the same reason (I think).\n\n> But either way (i.e. nesting the DAV:include inside of DAV:propfind,\n> or nesting it inside of DAV:allprop) is fine with me.\n\nOK, I'll put together a proposal.\n\n>    > From: Stefan Eissing\n>    > ...\n>    > I find the arguments in RFC2518 Ch. 23.3 (esp. 23.3.2.2) very\n>    > convincing.  Thus the most backward compatible solution is using\n>    > include in its own namespace:\n>    >\n>    > <propfind xmlns=\"DAV:\">\n>    >   <allprop/>\n>    >   <DV:include xmlns:DV=\"DAV:deltav\">\n>    >     <checked-in/><checked-out/><version-name/>\n>    >   </DV:include>\n>    > </propfind>\n>    >\n>    > where I don't specifically care what the namespace is (could also\n>    > be \"DAV:extended\" or \"DAV:addons-to-rfc2518\"). If an implementor\n>    > follows RFC2518, non-aware servers have to accept this message as\n>    > a valid propfind/allprop (and indeed all I could test against\n>    > do).\n>\n>    I can't see why putting it into the DAV: namespace would be a\n>    problem.  Although I'd prefer to have other WebDAV related specs\n>    (like ACL and deltaV) use their own namespaces, this one seems to\n>    apply to all WebDAV servers, no matter whether any combination of\n>    ACL and DeltaV is implemented...\n>\n> I agree with Julian that there is no reason to put the \"include\"\n> element in its own namespace.  RFC 2518 requires a server to ignore\n> any XML element it doesn't understand, irrespective of what namespace\n> it appears in.  The example in 23.3.2.2 does show the extension in\n> another namespace, but that is just an example.\n>\n> Julian: Why would you prefer to have WebDAV extensions defined through\n> the IETF (such as DeltaV and ACL) use their own namespaces?  There\n> clearly is a reason to define non-IETF standardized properties in\n> their own namespace, but it is simpler to just have all IETF WebDAV\n> extensions use the DAV: namespace.\n\nOther to make it simpler to find out to which spec a \"new\" property belongs\nto? No. Right now we have the unfortunate situation that deltaV defines live\nproperties in the DAV: namespace which could apply to base WebDAV as well --\nso for an implementor it's not obvious where to find the definition.\nAdditionally, deltaV requires a change in the RFC2518-defined behaviour for\n<allprop>, which should be defined in the base WebDAV spec instead...\n\nJulian\n\n\n\n", "id": "lists-006-0368485"}, {"subject": "RE: Deleting version", "content": "Following the principal that the document does not redefine existing\nstandards, and only describes extensions and departures, I think you could\ndrop the following:\n\n> A 403 (Forbidden) status indicates\n> that an error has occurred that the client cannot\n> resolve, and therefore the request should not be\n> resubmitted.  A 409 (Conflict) status indicates that\n> an error has occurred that the client can resolve,\n> after which the request could be resubmitted.\n\non the grounds that it is an incomplete description of these 'stati'\nalready defined by HTTP/1.1.\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n\nI agree with Tim's responses.  To make sure that nobody misunderstands\nthe semantics of the method preconditions and postconditions, I propose\nto modify section 1.6 to read as follows:\n\n---------------------\n\n1.6  Method Preconditions and Postconditions\n\nA \"precondition\" of a method describes the state on the server that must be\ntrue\nfor that method to be performed.  A \"postcondition\" of a method describes\nthe\nstate on the server that must be true after that method has completed.\nIf a precondition is violated by a request or a postcondition cannot\nbe satisfied, the response status of the request MUST be 403\n(Forbidden) or 409 (Conflict).  A 403 (Forbidden) status indicates\nthat an error has occurred that the client cannot resolve, and\ntherefore the request should not be resubmitted.  A 409 (Conflict)\nstatus indicates that an error has occurred that the client can\nresolve, after which the request could be resubmitted.\n\nIn order to allow better client handling of 403 and 409 responses, a\ndistinct XML element type is associated with each method\nprecondition and postcondition of a request.  When a particular\nprecondition is violated or a particular postcondition cannot be\nsatisfied, the appropriate XML element MUST be returned as the child\nof a top-level DAV:error element in the response body, unless\notherwise negotiated by the request.  In a 207 Multi-Status response,\nthis element would appear in the appropriate DAV:response-description\nelement.\n\n----------------------\n\nLisa: Does this address your concern?\n\nAnyone: Is this wording OK?\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Tim Ellison [mailto:tim@peir.com]\nSent: Friday, May 25, 2001 5:43 PM\nTo: DeltaV\nSubject: RE: Deleting versions\n\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: 25 May 2001 17:58\n> To: DeltaV\n> Subject: Deleting versions\n>\n>\n>\n> I know not all implementations of DeltaV will allow deleting old\nversions,\n> but the specifications specifically allows it.  I've been looking\n> into that\n> functionality and encountered some issues and questions.\n>\n> #1)  Is there some way of finding out, before trying the delete, if it's\n> possible to delete a version?  Before you say\n> \"supported-method-set\", allow\n> me to point out that this property is not shown to exist on versions.\n\nSure it is.  All resource properteis described in versioning-15 sec 3.1\nstates \"The version-control feature introduces the following REQUIRED\nproperties for any WebDAV resource.\", and since \"The version-control\nfeature\nMUST be supported if any other versioning feature is supported.\" it follows\nthat you can always ask a versioning resource for its supported methods.\n\n> #2) It looks like there's a set of error msgs the server can return if it\n> decides to prevent the user from deleting the referenced version, the\nroot\n> version, or all versions.  What error msg should the server return if it\n> decides to prevent the user from deleting the \"current\" version\n> (though one\n> that is not checked out)?\n\nPlease clarify what you mean by the \"current\" version?\n\n> Or what if the server decides to prevent the only\n> remaining version from being deleted?\n\nThis case is not called out by the spec., so I would expect 403 Forbidden\nwith no interoperable extended error info.  Just as there will be other\ncases that servers (say for implementation reasons) refuse methods and have\ninterop way of explaining why.\n\n> #3) I don't understand the following text from 3.12:\n> \"(DAV:update-predecessor-set): If a version is deleted, any reference to\n> that version in a DAV:predecessor-set MUST be replaced by a copy of the\n> DAV:predecessor-set of the deleted version.\"  Does that mean that before\n> deleting a version, the client must munge the predecessor-set\n> properties of\n> a bunch of other versions?\n\nYes, potentially.  The postcondition is required to fix up the history to\nshow a continuous ancestry for the remaining versions.\n\n> But the predecessor-set is protected!\n\n... from clients.  There are many examples of protected properties that a\nserver can/will modify.\n\n> Or does\n> it mean that the server must update the predecessor-set before performing\n> the action, and if it cannot, it returns the error msg?  Please\n> explain this\n> better in the draft & to the list...\n\nIt is a postcondition of the DELETE method for a version, therefore if it\ncannot be made true it MUST be as though the method was never sent.  No\npartial results will be left by the server, whether the fix up is done\nbefore/after the action is up to the implementation -- the spec states\neffectively that by the time 'the response is dispatched' the postcondition\nis true.  This is the same for all methods (not just DeltaV).\n\n> #4) Can situations arise where resources can have no versions?\n\nNo.  Take a look at the 3.12 postcondition\n     (DAV:must-be-root-version): If the root version of a version history\nis\n     deleted, there MUST be another version that is the new root version,\n     i.e. that is the ancestor of all other versions in the version\nhistory.\n\n> I can\n> actually think of two ways this might be achieved:\n>  - A client deletes all the versions (but not the version-controlled\n> resource)\n\nSee above.\n\n>  - A null resource gets versioning turned on but no body is added\n\nA what? <g>\n\n> Must clients be able to deal with VCRs with zero versions?  If\n> not, then we\n> need to make a requirement on servers that they must not ever create a\nVCR\n> with zero versions.\n\nThe way to create a version-controlled resource is with VERSION-CONTROL\nwhich always creates a version-controlled resource based on a version.  If\nthe target resource was versionable the new version is created, or the\nVERSION-CONTROL can reference an existing version in the request body.\n\nTim\n\n\n\n", "id": "lists-006-0381475"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class     ", "content": "(Warning: detailed multi-spec language lawyering to follow :-)\n\n   From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n\n   > From:  Clemm, Geoff\n   > ... you could nest the\n   > DAV:include node inside the DAV:allprop, rather than inside the\n   > DAV:propfind, i.e.\n   >\n   >  <propfind xmlns=\"DAV:\">\n   >   <allprop>\n   >    <include>\n   >     <checked-in/><checked-out/><version-name/>\n   >    </include>\n   >   </allprop>\n   >  </propfind>\n\n   Well, that would be invalid for the same reason (I think).\n\nNow that's an interesting question.  According to section 14 of RFC\n2518, a server that didn't understand the DAV:include element must\nignore it (and its children).  So the question then is, what does\n\"ignore\" mean?  In particular, does the result of \"ignoring\" the\ninclude element in:\n <allprop> <include>...</include> </allprop>\nhave to be:\n <allprop> </allprop>\nor could it be:\n <allprop/>\n\nAccording to the XML standard, these are equivalent, so either one of\nthese is fine.  There is an \"interoperability\" recommendation that\nempty tags be used if and only if the DTD explicitly declares it to be\nEMPTY, where interoperability is defined as:\n\n\"A non-binding recommendation included to increase the chances that\nXML documents can be processed by the existing installed base of SGML\nprocessors\".\n\nSince the chances of using an existing SGML processor to parse WebDAV\nresponse messages is vanishingly small, the only sensible approach\nwould be for WebDAV to ignore this \"non-binding recommendation\".  For\nsome reason, Section 23.3.1 of RFC 2518 (incorrectly) states that \"It\nis a violation of the XML specification\" to do otherwise.  Perhaps\nJimW or some other 2518 author can explain the rationale behind this?\n\nSo in summary, nesting the <DAV:include> inside of the <DAV:allprop>\nwould be illegal only by a certain interpretation of \"ignore\",\ncombinded with the (incorrect) statements made by 23.3.1 about the use\nof empty element tags.\n\n(language-lawyering off :-)\n\n   > Julian: Why would you prefer to have WebDAV extensions defined\n   > through the IETF (such as DeltaV and ACL) use their own\n   > namespaces?  There clearly is a reason to define non-IETF\n   > standardized properties in their own namespace, but it is simpler\n   > to just have all IETF WebDAV extensions use the DAV: namespace.\n\n   Other to make it simpler to find out to which spec a \"new\" property\n   belongs to? No. Right now we have the unfortunate situation that\n   deltaV defines live properties in the DAV: namespace which could\n   apply to base WebDAV as well -- so for an implementor it's not\n   obvious where to find the definition.  Additionally, deltaV\n   requires a change in the RFC2518-defined behaviour for <allprop>,\n   which should be defined in the base WebDAV spec instead...\n\nThis assumes that the definition of a property will over time remain\nin a single RFC.  I don't think this is likely.  In particular, there\nare several properties currently defined by the deltav spec that over\ntime may well migrate into the \"base WebDAV\" protocol\n(e.g. DAV:supported-live-property-set).  If so, the only thing you\nwill be able infer from the namespace of a property is that it was\n\"first defined\" in RFC XYZ, but that is of neglible value.\n\nSo I believe putting all IETF standardized WebDAV properties into the\nDAV: namespace is the best approach.  Save the other namespaces for\nproperties introduced by non-IETF standards (which therefore require\ntheir own namespaces to avoid name clashes).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0396374"}, {"subject": "RE: Deleting version", "content": "I am certainly happy to drop these two sentences, for the\nreason Tim gives.  Anyone want to argue for keeping them in?\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Tuesday, May 29, 2001 1:36 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Deleting versions\n\n\n\n\nFollowing the principal that the document does not redefine existing\nstandards, and only describes extensions and departures, I think you could\ndrop the following:\n\n> A 403 (Forbidden) status indicates\n> that an error has occurred that the client cannot\n> resolve, and therefore the request should not be\n> resubmitted.  A 409 (Conflict) status indicates that\n> an error has occurred that the client can resolve,\n> after which the request could be resubmitted.\n\non the grounds that it is an incomplete description of these 'stati'\nalready defined by HTTP/1.1.\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n\nI agree with Tim's responses.  To make sure that nobody misunderstands\nthe semantics of the method preconditions and postconditions, I propose\nto modify section 1.6 to read as follows:\n\n---------------------\n\n1.6  Method Preconditions and Postconditions\n\nA \"precondition\" of a method describes the state on the server that must be\ntrue\nfor that method to be performed.  A \"postcondition\" of a method describes\nthe\nstate on the server that must be true after that method has completed.\nIf a precondition is violated by a request or a postcondition cannot\nbe satisfied, the response status of the request MUST be 403\n(Forbidden) or 409 (Conflict).  A 403 (Forbidden) status indicates\nthat an error has occurred that the client cannot resolve, and\ntherefore the request should not be resubmitted.  A 409 (Conflict)\nstatus indicates that an error has occurred that the client can\nresolve, after which the request could be resubmitted.\n\nIn order to allow better client handling of 403 and 409 responses, a\ndistinct XML element type is associated with each method\nprecondition and postcondition of a request.  When a particular\nprecondition is violated or a particular postcondition cannot be\nsatisfied, the appropriate XML element MUST be returned as the child\nof a top-level DAV:error element in the response body, unless\notherwise negotiated by the request.  In a 207 Multi-Status response,\nthis element would appear in the appropriate DAV:response-description\nelement.\n\n----------------------\n\nLisa: Does this address your concern?\n\nAnyone: Is this wording OK?\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Tim Ellison [mailto:tim@peir.com]\nSent: Friday, May 25, 2001 5:43 PM\nTo: DeltaV\nSubject: RE: Deleting versions\n\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: 25 May 2001 17:58\n> To: DeltaV\n> Subject: Deleting versions\n>\n>\n>\n> I know not all implementations of DeltaV will allow deleting old\nversions,\n> but the specifications specifically allows it.  I've been looking\n> into that\n> functionality and encountered some issues and questions.\n>\n> #1)  Is there some way of finding out, before trying the delete, if it's\n> possible to delete a version?  Before you say\n> \"supported-method-set\", allow\n> me to point out that this property is not shown to exist on versions.\n\nSure it is.  All resource properteis described in versioning-15 sec 3.1\nstates \"The version-control feature introduces the following REQUIRED\nproperties for any WebDAV resource.\", and since \"The version-control\nfeature\nMUST be supported if any other versioning feature is supported.\" it follows\nthat you can always ask a versioning resource for its supported methods.\n\n> #2) It looks like there's a set of error msgs the server can return if it\n> decides to prevent the user from deleting the referenced version, the\nroot\n> version, or all versions.  What error msg should the server return if it\n> decides to prevent the user from deleting the \"current\" version\n> (though one\n> that is not checked out)?\n\nPlease clarify what you mean by the \"current\" version?\n\n> Or what if the server decides to prevent the only\n> remaining version from being deleted?\n\nThis case is not called out by the spec., so I would expect 403 Forbidden\nwith no interoperable extended error info.  Just as there will be other\ncases that servers (say for implementation reasons) refuse methods and have\ninterop way of explaining why.\n\n> #3) I don't understand the following text from 3.12:\n> \"(DAV:update-predecessor-set): If a version is deleted, any reference to\n> that version in a DAV:predecessor-set MUST be replaced by a copy of the\n> DAV:predecessor-set of the deleted version.\"  Does that mean that before\n> deleting a version, the client must munge the predecessor-set\n> properties of\n> a bunch of other versions?\n\nYes, potentially.  The postcondition is required to fix up the history to\nshow a continuous ancestry for the remaining versions.\n\n> But the predecessor-set is protected!\n\n... from clients.  There are many examples of protected properties that a\nserver can/will modify.\n\n> Or does\n> it mean that the server must update the predecessor-set before performing\n> the action, and if it cannot, it returns the error msg?  Please\n> explain this\n> better in the draft & to the list...\n\nIt is a postcondition of the DELETE method for a version, therefore if it\ncannot be made true it MUST be as though the method was never sent.  No\npartial results will be left by the server, whether the fix up is done\nbefore/after the action is up to the implementation -- the spec states\neffectively that by the time 'the response is dispatched' the postcondition\nis true.  This is the same for all methods (not just DeltaV).\n\n> #4) Can situations arise where resources can have no versions?\n\nNo.  Take a look at the 3.12 postcondition\n     (DAV:must-be-root-version): If the root version of a version history\nis\n     deleted, there MUST be another version that is the new root version,\n     i.e. that is the ancestor of all other versions in the version\nhistory.\n\n> I can\n> actually think of two ways this might be achieved:\n>  - A client deletes all the versions (but not the version-controlled\n> resource)\n\nSee above.\n\n>  - A null resource gets versioning turned on but no body is added\n\nA what? <g>\n\n> Must clients be able to deal with VCRs with zero versions?  If\n> not, then we\n> need to make a requirement on servers that they must not ever create a\nVCR\n> with zero versions.\n\nThe way to create a version-controlled resource is with VERSION-CONTROL\nwhich always creates a version-controlled resource based on a version.  If\nthe target resource was versionable the new version is created, or the\nVERSION-CONTROL can reference an existing version in the request body.\n\nTim\n\n\n\n", "id": "lists-006-0408200"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class     ", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Tuesday, May 29, 2001 9:23 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: PROPFIND allprop with more properties (was AW: Resource\n> class )\n>\n>\n> (Warning: detailed multi-spec language lawyering to follow :-)\n>\n>    From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n>\n>    > From:  Clemm, Geoff\n>    > ... you could nest the\n>    > DAV:include node inside the DAV:allprop, rather than inside the\n>    > DAV:propfind, i.e.\n>    >\n>    >  <propfind xmlns=\"DAV:\">\n>    >   <allprop>\n>    >    <include>\n>    >     <checked-in/><checked-out/><version-name/>\n>    >    </include>\n>    >   </allprop>\n>    >  </propfind>\n>\n>    Well, that would be invalid for the same reason (I think).\n>\n> Now that's an interesting question.  According to section 14 of RFC\n\nYes, it is :-) That's why I tried to carefully phrase my last reply..\n\n> 2518, a server that didn't understand the DAV:include element must\n> ignore it (and its children).  So the question then is, what does\n> \"ignore\" mean?  In particular, does the result of \"ignoring\" the\n> include element in:\n>  <allprop> <include>...</include> </allprop>\n> have to be:\n>  <allprop> </allprop>\n> or could it be:\n>  <allprop/>\n\nI'd say, if the request was\n\n<allprop> <include>...</include> </allprop>\n\nthe result of \"ignoring\" would indeed be:\n\n<allprop> </allprop>\n\nHowever, if the request was\n\n<allprop><include>...</include></allprop>\n\nit would surely be\n\n<allprop></allprop>, which for all practical purposes is the same as\n<allprop/>.\n\n> According to the XML standard, these are equivalent, so either one of\n> these is fine.  There is an \"interoperability\" recommendation that\n\nNot really -- the first variation contained a text node with whitespace, so\nit wan't empty...\n\n> empty tags be used if and only if the DTD explicitly declares it to be\n> EMPTY, where interoperability is defined as:\n>\n> \"A non-binding recommendation included to increase the chances that\n> XML documents can be processed by the existing installed base of SGML\n> processors\".\n>\n> Since the chances of using an existing SGML processor to parse WebDAV\n> response messages is vanishingly small, the only sensible approach\n> would be for WebDAV to ignore this \"non-binding recommendation\".  For\n> some reason, Section 23.3.1 of RFC 2518 (incorrectly) states that \"It\n\nI agree that this statement needs to be removed.\n\n> is a violation of the XML specification\" to do otherwise.  Perhaps\n> JimW or some other 2518 author can explain the rationale behind this?\n>\n> So in summary, nesting the <DAV:include> inside of the <DAV:allprop>\n> would be illegal only by a certain interpretation of \"ignore\",\n> combinded with the (incorrect) statements made by 23.3.1 about the use\n> of empty element tags.\n>\n> (language-lawyering off :-)\n\nI feel you're right.\n\nHow do we proceed?\n\nI've done interoperabilty tests with \"our\" version of the include element\n(with mod_dav, IIS and Sharepoint). Should I redo them using \"your\" format\nbefore we proceed with one of them?\n\n>    > Julian: Why would you prefer to have WebDAV extensions defined\n>    > through the IETF (such as DeltaV and ACL) use their own\n>    > namespaces?  There clearly is a reason to define non-IETF\n>    > standardized properties in their own namespace, but it is simpler\n>    > to just have all IETF WebDAV extensions use the DAV: namespace.\n>\n>    Other to make it simpler to find out to which spec a \"new\" property\n>    belongs to? No. Right now we have the unfortunate situation that\n>    deltaV defines live properties in the DAV: namespace which could\n>    apply to base WebDAV as well -- so for an implementor it's not\n>    obvious where to find the definition.  Additionally, deltaV\n>    requires a change in the RFC2518-defined behaviour for <allprop>,\n>    which should be defined in the base WebDAV spec instead...\n>\n> This assumes that the definition of a property will over time remain\n> in a single RFC.  I don't think this is likely.  In particular, there\n> are several properties currently defined by the deltav spec that over\n> time may well migrate into the \"base WebDAV\" protocol\n> (e.g. DAV:supported-live-property-set).  If so, the only thing you\n> will be able infer from the namespace of a property is that it was\n> \"first defined\" in RFC XYZ, but that is of neglible value.\n\nSure. That's why I would like to see those moved out of deltaV (and into\nRFC2518's successor).\n\n> So I believe putting all IETF standardized WebDAV properties into the\n> DAV: namespace is the best approach.  Save the other namespaces for\n> properties introduced by non-IETF standards (which therefore require\n> their own namespaces to avoid name clashes).\n\n\n\n", "id": "lists-006-0424038"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class     ", "content": "> Since the chances of using an existing SGML processor to parse WebDAV\n> response messages is vanishingly small,\n\nWell, I wouldn't put it past James Hunt and Jurgen Reuter (two noted\nadvocates for strong validity checking of DAV messages) :-)\n\n> the only sensible approach\n> would be for WebDAV to ignore this \"non-binding recommendation\".  For\n> some reason, Section 23.3.1 of RFC 2518 (incorrectly) states that \"It\n> is a violation of the XML specification\" to do otherwise.  Perhaps\n> JimW or some other 2518 author can explain the rationale behind this?\n\nWell, this does appear to be an error, since the requirement in the XML\nspecification is a \"should\", not a \"must\". If I guessed at the rationale, it\nwould be to keep things simple for DAV XML parsers.\n\n- Jim\n\n\n\n", "id": "lists-006-0439227"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class     ", "content": "> How do we proceed?\n\nWhy don't you write up an Internet-Draft?\n\nIt's pretty easy to do.\n\nJust describe (a) the problem you're trying to solve, and (b) your proposed\nsolution.\n\nThere are a few simple guidelines, described in:\n\nhttp://www.ietf.org/ietf/1id-guidelines.txt\n\nSome tools for doing this are listed at:\nhttp://www3.innosoft.com/~chris/rfctools.html\n\nAs well, if you like working in XML, there are some tools for I-D authors\navailable at:\nhttp://xml.resource.org/authoring/\ndescribed in:\nhttp://www.innosoft.com/rfc/rfc2629.html\n\nBut really, a simple text editor will do the job.\n\nLet me know when you're ready to submit, and I'll give you an I-D name to\nuse.\n\n- Jim\n\n\n\n", "id": "lists-006-0447416"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class      ", "content": "Julian makes a good point about whether or not white-space is\nleft around as the result of \"ignoring\" unknown XML elements.\nMy personal vote is that when you \"ignore\" an XML element, you\nshould also \"ignore\" white space on either side of that XML element.\n\nJimW: This probably should go on the WebDAV issues list.\nIn particular, as part of that issue (or possibly another\nrelated issue), we should fix section 23.3.1, so that it\nno longer makes misleading statements about the XML spec\n(and preferably, declare that for WebDAV, <x></x> is equivalent\nto <x/>.\n\nJulian: If you have a chance to do some interoperability testing\nwith the \"unknown element\" nested inside of <allprop/>,\nthat would be great, since that would give us a basis for\nfixing 23.3.1 (i.e. without introducing interoperability\nissues for existing servers).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\nSent: Tuesday, May 29, 2001 3:55 PM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: RE: PROPFIND allprop with more properties (was AW: Resource\nclass )\n\n\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Tuesday, May 29, 2001 9:23 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: PROPFIND allprop with more properties (was AW: Resource\n> class )\n>\n>\n> (Warning: detailed multi-spec language lawyering to follow :-)\n>\n>    From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n>\n>    > From:  Clemm, Geoff\n>    > ... you could nest the\n>    > DAV:include node inside the DAV:allprop, rather than inside the\n>    > DAV:propfind, i.e.\n>    >\n>    >  <propfind xmlns=\"DAV:\">\n>    >   <allprop>\n>    >    <include>\n>    >     <checked-in/><checked-out/><version-name/>\n>    >    </include>\n>    >   </allprop>\n>    >  </propfind>\n>\n>    Well, that would be invalid for the same reason (I think).\n>\n> Now that's an interesting question.  According to section 14 of RFC\n\nYes, it is :-) That's why I tried to carefully phrase my last reply..\n\n> 2518, a server that didn't understand the DAV:include element must\n> ignore it (and its children).  So the question then is, what does\n> \"ignore\" mean?  In particular, does the result of \"ignoring\" the\n> include element in:\n>  <allprop> <include>...</include> </allprop>\n> have to be:\n>  <allprop> </allprop>\n> or could it be:\n>  <allprop/>\n\nI'd say, if the request was\n\n<allprop> <include>...</include> </allprop>\n\nthe result of \"ignoring\" would indeed be:\n\n<allprop> </allprop>\n\nHowever, if the request was\n\n<allprop><include>...</include></allprop>\n\nit would surely be\n\n<allprop></allprop>, which for all practical purposes is the same as\n<allprop/>.\n\n> According to the XML standard, these are equivalent, so either one of\n> these is fine.  There is an \"interoperability\" recommendation that\n\nNot really -- the first variation contained a text node with whitespace, so\nit wan't empty...\n\n> empty tags be used if and only if the DTD explicitly declares it to be\n> EMPTY, where interoperability is defined as:\n>\n> \"A non-binding recommendation included to increase the chances that\n> XML documents can be processed by the existing installed base of SGML\n> processors\".\n>\n> Since the chances of using an existing SGML processor to parse WebDAV\n> response messages is vanishingly small, the only sensible approach\n> would be for WebDAV to ignore this \"non-binding recommendation\".  For\n> some reason, Section 23.3.1 of RFC 2518 (incorrectly) states that \"It\n\nI agree that this statement needs to be removed.\n\n> is a violation of the XML specification\" to do otherwise.  Perhaps\n> JimW or some other 2518 author can explain the rationale behind this?\n>\n> So in summary, nesting the <DAV:include> inside of the <DAV:allprop>\n> would be illegal only by a certain interpretation of \"ignore\",\n> combinded with the (incorrect) statements made by 23.3.1 about the use\n> of empty element tags.\n>\n> (language-lawyering off :-)\n\nI feel you're right.\n\nHow do we proceed?\n\nI've done interoperabilty tests with \"our\" version of the include element\n(with mod_dav, IIS and Sharepoint). Should I redo them using \"your\" format\nbefore we proceed with one of them?\n\n>    > Julian: Why would you prefer to have WebDAV extensions defined\n>    > through the IETF (such as DeltaV and ACL) use their own\n>    > namespaces?  There clearly is a reason to define non-IETF\n>    > standardized properties in their own namespace, but it is simpler\n>    > to just have all IETF WebDAV extensions use the DAV: namespace.\n>\n>    Other to make it simpler to find out to which spec a \"new\" property\n>    belongs to? No. Right now we have the unfortunate situation that\n>    deltaV defines live properties in the DAV: namespace which could\n>    apply to base WebDAV as well -- so for an implementor it's not\n>    obvious where to find the definition.  Additionally, deltaV\n>    requires a change in the RFC2518-defined behaviour for <allprop>,\n>    which should be defined in the base WebDAV spec instead...\n>\n> This assumes that the definition of a property will over time remain\n> in a single RFC.  I don't think this is likely.  In particular, there\n> are several properties currently defined by the deltav spec that over\n> time may well migrate into the \"base WebDAV\" protocol\n> (e.g. DAV:supported-live-property-set).  If so, the only thing you\n> will be able infer from the namespace of a property is that it was\n> \"first defined\" in RFC XYZ, but that is of neglible value.\n\nSure. That's why I would like to see those moved out of deltaV (and into\nRFC2518's successor).\n\n> So I believe putting all IETF standardized WebDAV properties into the\n> DAV: namespace is the best approach.  Save the other namespaces for\n> properties introduced by non-IETF standards (which therefore require\n> their own namespaces to avoid name clashes).\n\n\n\n", "id": "lists-006-0456782"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class     ", "content": "> JimW: This probably should go on the WebDAV issues list.\n> In particular, as part of that issue (or possibly another\n> related issue), we should fix section 23.3.1, so that it\n> no longer makes misleading statements about the XML spec\n> (and preferably, declare that for WebDAV, <x></x> is equivalent\n> to <x/>.\n\nAdded.\n\n- Jim\n\n\n\n", "id": "lists-006-0473694"}, {"subject": "RE: Deleting version", "content": "Geoff said:\n>\n> I agree with Tim's responses.  To make sure that nobody misunderstands\n> the semantics of the method preconditions and postconditions, I propose\n> to modify section 1.6 to read as follows:\n>\n...\n>\n> Lisa: Does this address your concern?\n>\n\nIt's an improvement in the definition of post/pre-conditions, certainly.\nThere are still a couple of issues remaining:\n\n1.  By having (DAV:must-be-root-version) as a postcondition, you're\npreventing an implementation from deleting the last remaining version from a\nversion history.  I assume this is your intent?  Like so many other things,\nit must be inferred rather than finding it stated in the text.  *sigh*\n\n2.  I don't think the issue of a version-controlled-resource with zero\nversions is sufficiently addressed.  For your convenience, here's the\nsection from 2518:\n\n   A write locked null resource, referred to as a lock-null resource,\n   MUST respond with a 404 (Not Found) or 405 (Method Not Allowed) to\n   any HTTP/1.1 or DAV methods except for PUT, MKCOL, OPTIONS, PROPFIND,\n   LOCK, and UNLOCK.  A lock-null resource MUST appear as a member of\n   its parent collection.  Additionally the lock-null resource MUST have\n   defined on it all mandatory DAV properties.  Most of these\n   properties, such as all the get* properties, will have no value as a\n   lock-null resource does not support the GET method.  Lock-Null\n   resources MUST have defined values for lockdiscovery and\n   supportedlock properties.\n\n   Until a method such as PUT or MKCOL is successfully executed on the\n   lock-null resource the resource MUST stay in the lock-null state.\n   However, once a PUT or MKCOL is successfully executed on a lock-null\n   resource the resource ceases to be in the lock-null state.\n\nA direct read of this paragraph combined with deltaV draft 15 (and your\nimplication) would indicate that you can't issue a VERSION-CONTROL method on\na lock-null resource.  That's bogus.  A \"write locked null resource\" is\nthere so that the creator can do all the write operations and state changes\nthey need before making the resource visible to everybody.\n\nSo, I suggest that VERSION-CONTROL (and perhaps other methods like CHECKOUT,\nMKWORKSPACE...) should be explicitly allowed by DeltaV to be done on write\nlocked null resources, and that the spec define a precondition that can be\nreturned if the server decides not to allow operations on write-lock\nresources.\n\nLisa\n\n>\n> -----Original Message-----\n> From: Tim Ellison [mailto:tim@peir.com]\n> Sent: Friday, May 25, 2001 5:43 PM\n> To: DeltaV\n> Subject: RE: Deleting versions\n>\n>\n>\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> > Sent: 25 May 2001 17:58\n> > To: DeltaV\n> > Subject: Deleting versions\n> >\n> >\n> >\n> > I know not all implementations of DeltaV will allow deleting\n> old versions,\n> > but the specifications specifically allows it.  I've been looking\n> > into that\n> > functionality and encountered some issues and questions.\n> >\n> > #1)  Is there some way of finding out, before trying the delete, if it's\n> > possible to delete a version?  Before you say\n> > \"supported-method-set\", allow\n> > me to point out that this property is not shown to exist on versions.\n>\n> Sure it is.  All resource properteis described in versioning-15 sec 3.1\n> states \"The version-control feature introduces the following REQUIRED\n> properties for any WebDAV resource.\", and since \"The\n> version-control feature\n> MUST be supported if any other versioning feature is supported.\"\n> it follows\n> that you can always ask a versioning resource for its supported methods.\n>\n> > #2) It looks like there's a set of error msgs the server can\n> return if it\n> > decides to prevent the user from deleting the referenced\n> version, the root\n> > version, or all versions.  What error msg should the server return if it\n> > decides to prevent the user from deleting the \"current\" version\n> > (though one\n> > that is not checked out)?\n>\n> Please clarify what you mean by the \"current\" version?\n>\n> > Or what if the server decides to prevent the only\n> > remaining version from being deleted?\n>\n> This case is not called out by the spec., so I would expect 403 Forbidden\n> with no interoperable extended error info.  Just as there will be other\n> cases that servers (say for implementation reasons) refuse\n> methods and have\n> interop way of explaining why.\n>\n> > #3) I don't understand the following text from 3.12:\n> > \"(DAV:update-predecessor-set): If a version is deleted, any reference to\n> > that version in a DAV:predecessor-set MUST be replaced by a copy of the\n> > DAV:predecessor-set of the deleted version.\"  Does that mean that before\n> > deleting a version, the client must munge the predecessor-set\n> > properties of\n> > a bunch of other versions?\n>\n> Yes, potentially.  The postcondition is required to fix up the history to\n> show a continuous ancestry for the remaining versions.\n>\n> > But the predecessor-set is protected!\n>\n> ... from clients.  There are many examples of protected properties that a\n> server can/will modify.\n>\n> > Or does\n> > it mean that the server must update the predecessor-set before\n> performing\n> > the action, and if it cannot, it returns the error msg?  Please\n> > explain this\n> > better in the draft & to the list...\n>\n> It is a postcondition of the DELETE method for a version, therefore if it\n> cannot be made true it MUST be as though the method was never sent.  No\n> partial results will be left by the server, whether the fix up is done\n> before/after the action is up to the implementation -- the spec states\n> effectively that by the time 'the response is dispatched' the\n> postcondition\n> is true.  This is the same for all methods (not just DeltaV).\n>\n> > #4) Can situations arise where resources can have no versions?\n>\n> No.  Take a look at the 3.12 postcondition\n> (DAV:must-be-root-version): If the root version of a version history\n> is\n> deleted, there MUST be another version that is the new root version,\n> i.e. that is the ancestor of all other versions in the version\n> history.\n>\n> > I can\n> > actually think of two ways this might be achieved:\n> >  - A client deletes all the versions (but not the version-controlled\n> > resource)\n>\n> See above.\n>\n> >  - A null resource gets versioning turned on but no body is added\n>\n> A what? <g>\n>\n> > Must clients be able to deal with VCRs with zero versions?  If\n> > not, then we\n> > need to make a requirement on servers that they must not ever\n> create a VCR\n> > with zero versions.\n>\n> The way to create a version-controlled resource is with VERSION-CONTROL\n> which always creates a version-controlled resource based on a version.  If\n> the target resource was versionable the new version is created, or the\n> VERSION-CONTROL can reference an existing version in the request body.\n>\n> Tim\n\n\n\n", "id": "lists-006-0481672"}, {"subject": "RE: Deleting version", "content": "\"Lisa Dusseault\" <lisa@xythos.com> wrote:\n\n> Geoff said:\n> >\n> > I agree with Tim's responses.  To make sure that nobody misunderstands\n> > the semantics of the method preconditions and postconditions, I propose\n> > to modify section 1.6 to read as follows:\n> >\n> ...\n> >\n> > Lisa: Does this address your concern?\n>\n>\n> It's an improvement in the definition of post/pre-conditions, certainly.\n> There are still a couple of issues remaining:\n>\n> 1.  By having (DAV:must-be-root-version) as a postcondition, you're\n> preventing an implementation from deleting the last remaining version\n> from a version history.  I assume this is your intent?  Like so many\n> other things, it must be inferred rather than finding it stated in\n> the text.  *sigh*\n\nThe entire postcondition statement is:\n     (DAV:must-be-root-version): If the root version of a version\n     history is deleted, there MUST be another version that is the\n     new root version, i.e. that is the ancestor of all other versions\n     in the version history.\n\nI think it is easily implied that you cannot therefore delete *all*\nversions of a version history and satisfy this postcondition; but I have no\nobjection to adding to this statement if you really think it needs it.\n\n> 2.  I don't think the issue of a version-controlled-resource with zero\n> versions is sufficiently addressed.  For your convenience, here's the\n> section from 2518:\n>\n>    A write locked null resource, referred to as a lock-null resource,\n>    MUST respond with a 404 (Not Found) or 405 (Method Not Allowed) to\n>    any HTTP/1.1 or DAV methods except for PUT, MKCOL, OPTIONS, PROPFIND,\n>    LOCK, and UNLOCK.  A lock-null resource MUST appear as a member of\n>    its parent collection.  Additionally the lock-null resource MUST have\n>    defined on it all mandatory DAV properties.  Most of these\n>    properties, such as all the get* properties, will have no value as a\n>    lock-null resource does not support the GET method.  Lock-Null\n>    resources MUST have defined values for lockdiscovery and\n>    supportedlock properties.\n>\n>    Until a method such as PUT or MKCOL is successfully executed on the\n>    lock-null resource the resource MUST stay in the lock-null state.\n>    However, once a PUT or MKCOL is successfully executed on a lock-null\n>    resource the resource ceases to be in the lock-null state.\n>\n> A direct read of this paragraph combined with deltaV draft 15 (and your\n> implication) would indicate that you can't issue a VERSION-CONTROL method\n> on a lock-null resource.  That's bogus.\n\nNo, that's great!<g>  The lock null resource is a nonce concept that is not\nrequired by Delta-V.\nReading the quoted paragraph with Delta-V gives (IMHO) the correct\nimpression that versioning operations are not allowed on lock null\nresources.\n\n> A \"write locked null resource\"\n> is there so that the creator can do all the write operations and state\n> changes they need before making the resource visible to everybody.\n\nThis isn't true since you cannot PROPPATCH a lock null resource, and as\nsoon as the first PUT/MKCOL succeeds it is no longer in the lock-null state\n-- so there really is no set of state changes that can be applied to a lock\nnull resource.\n\nI'm not sure what you mean by \"before making the resource visible to\neverybody\".  The resource name is a member of the parent collection, so\nthat is 'visible'.  It has visible mandatory DAV properties (including\nthose defined by Delta-V for all DAV resources).  But until the initial\nPUT/MKCOL there is no content/are no members.\n\nAre you are suggesting that the lock null resource should be a versionable\nresource?\nAre you suggesting that the lock null resource can be brought under version\ncontrol before the initial PUT/MKCOL?  Delta-V allows for the resource to\nbe brought under version control as part of the initial PUT/MKCOL; and if\nit is brought under version control _after_ the initial PUT/MKCOL then the\nresource is no longer a lock null resource.\n\n> So, I suggest that VERSION-CONTROL (and perhaps other methods like\nCHECKOUT,\n> MKWORKSPACE...) should be explicitly allowed by DeltaV to be done on\nwrite\n> locked null resources, and that the spec define a precondition that can\nbe\n> returned if the server decides not to allow operations on write-lock\n> resources.\n\nI see no argument for VERSION-CONTROL or CHECKOUT, but MKWORKSPACE is a\nmore likely candidate since it is akin to MKCOL.  This would obviously\nrequire a modification to RFC2518's statement that the lock null resource\nMUST fail methods that are not in the named list.\n\nTim\n\n\n\n", "id": "lists-006-0497043"}, {"subject": "AW: PROPFIND allprop with more properties (was AW: Resource class      ", "content": "> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n>\n> [...]\n> Julian: If you have a chance to do some interoperability testing\n> with the \"unknown element\" nested inside of <allprop/>,\n> that would be great, since that would give us a basis for\n> fixing 23.3.1 (i.e. without introducing interoperability\n> issues for existing servers).\n\nOk, our tests showed that\n<allprop/><include>...</include>\n   works with moddav, IIS and our servlet, while\n<allprop><include>...</include></allprop>\n   works with moddav and IIS. Julian's PROPFIND\n   handler is throwing the book at me with 422s.\n\nHowever our code is not in production and can easily\nbe changed by twisting Julian's arm a little. Sitting\nopposite of him helps.\n\nIf anyone else has a public server which I should test,\nplease let me know.\n\n//Stefan\n\n\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n> Sent: Tuesday, May 29, 2001 3:55 PM\n> To: Clemm, Geoff; ietf-dav-versioning@w3.org\n> Subject: RE: PROPFIND allprop with more properties (was AW: Resource\n> class )\n>\n>\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > Sent: Tuesday, May 29, 2001 9:23 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: RE: PROPFIND allprop with more properties (was AW: Resource\n> > class )\n> >\n> >\n> > (Warning: detailed multi-spec language lawyering to follow :-)\n> >\n> >    From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n> >\n> >    > From:  Clemm, Geoff\n> >    > ... you could nest the\n> >    > DAV:include node inside the DAV:allprop, rather than inside the\n> >    > DAV:propfind, i.e.\n> >    >\n> >    >  <propfind xmlns=\"DAV:\">\n> >    >   <allprop>\n> >    >    <include>\n> >    >     <checked-in/><checked-out/><version-name/>\n> >    >    </include>\n> >    >   </allprop>\n> >    >  </propfind>\n> >\n> >    Well, that would be invalid for the same reason (I think).\n> >\n> > Now that's an interesting question.  According to section 14 of RFC\n>\n> Yes, it is :-) That's why I tried to carefully phrase my last reply..\n>\n> > 2518, a server that didn't understand the DAV:include element must\n> > ignore it (and its children).  So the question then is, what does\n> > \"ignore\" mean?  In particular, does the result of \"ignoring\" the\n> > include element in:\n> >  <allprop> <include>...</include> </allprop>\n> > have to be:\n> >  <allprop> </allprop>\n> > or could it be:\n> >  <allprop/>\n>\n> I'd say, if the request was\n>\n> <allprop> <include>...</include> </allprop>\n>\n> the result of \"ignoring\" would indeed be:\n>\n> <allprop> </allprop>\n>\n> However, if the request was\n>\n> <allprop><include>...</include></allprop>\n>\n> it would surely be\n>\n> <allprop></allprop>, which for all practical purposes is the same as\n> <allprop/>.\n>\n> > According to the XML standard, these are equivalent, so either one of\n> > these is fine.  There is an \"interoperability\" recommendation that\n>\n> Not really -- the first variation contained a text node with\n> whitespace, so\n> it wan't empty...\n>\n> > empty tags be used if and only if the DTD explicitly declares it to be\n> > EMPTY, where interoperability is defined as:\n> >\n> > \"A non-binding recommendation included to increase the chances that\n> > XML documents can be processed by the existing installed base of SGML\n> > processors\".\n> >\n> > Since the chances of using an existing SGML processor to parse WebDAV\n> > response messages is vanishingly small, the only sensible approach\n> > would be for WebDAV to ignore this \"non-binding recommendation\".  For\n> > some reason, Section 23.3.1 of RFC 2518 (incorrectly) states that \"It\n>\n> I agree that this statement needs to be removed.\n>\n> > is a violation of the XML specification\" to do otherwise.  Perhaps\n> > JimW or some other 2518 author can explain the rationale behind this?\n> >\n> > So in summary, nesting the <DAV:include> inside of the <DAV:allprop>\n> > would be illegal only by a certain interpretation of \"ignore\",\n> > combinded with the (incorrect) statements made by 23.3.1 about the use\n> > of empty element tags.\n> >\n> > (language-lawyering off :-)\n>\n> I feel you're right.\n>\n> How do we proceed?\n>\n> I've done interoperabilty tests with \"our\" version of the include element\n> (with mod_dav, IIS and Sharepoint). Should I redo them using \"your\" format\n> before we proceed with one of them?\n>\n> >    > Julian: Why would you prefer to have WebDAV extensions defined\n> >    > through the IETF (such as DeltaV and ACL) use their own\n> >    > namespaces?  There clearly is a reason to define non-IETF\n> >    > standardized properties in their own namespace, but it is simpler\n> >    > to just have all IETF WebDAV extensions use the DAV: namespace.\n> >\n> >    Other to make it simpler to find out to which spec a \"new\" property\n> >    belongs to? No. Right now we have the unfortunate situation that\n> >    deltaV defines live properties in the DAV: namespace which could\n> >    apply to base WebDAV as well -- so for an implementor it's not\n> >    obvious where to find the definition.  Additionally, deltaV\n> >    requires a change in the RFC2518-defined behaviour for <allprop>,\n> >    which should be defined in the base WebDAV spec instead...\n> >\n> > This assumes that the definition of a property will over time remain\n> > in a single RFC.  I don't think this is likely.  In particular, there\n> > are several properties currently defined by the deltav spec that over\n> > time may well migrate into the \"base WebDAV\" protocol\n> > (e.g. DAV:supported-live-property-set).  If so, the only thing you\n> > will be able infer from the namespace of a property is that it was\n> > \"first defined\" in RFC XYZ, but that is of neglible value.\n>\n> Sure. That's why I would like to see those moved out of deltaV (and into\n> RFC2518's successor).\n>\n> > So I believe putting all IETF standardized WebDAV properties into the\n> > DAV: namespace is the best approach.  Save the other namespaces for\n> > properties introduced by non-IETF standards (which therefore require\n> > their own namespaces to avoid name clashes).\n>\n>\n>\n\n\n\n", "id": "lists-006-0508977"}, {"subject": "RE: PROPFIND allprop with more properties (was AW: Resource class      ", "content": "> If anyone else has a public server which I should test,\n> please let me know.\n\nWe're always happy to have people test Xythos WebFile Server at\nhttp://www.sharemation.com.  You can set up your own account through the\nGUI, then point your DAV client at http://www.sharemation.com/~yourusername.\n\nI assume you tested IIS by running it yourself?  There isn't a\npublicly-available IIS site, is there?  Any others??\n\nlisa\n\n\n\n", "id": "lists-006-0527739"}, {"subject": "Protected properties..", "content": "DeltaV lists one property, DAV:predecessor-set, that MAY be protected on a\nchecked-out resource, it's up to the implementation.  However, on a version,\npredecessor-set MUST be protected.  So far, so cool:  I understand that.\n\nNext, note that precursor-set is NOT protected on a checked-out resource,\nbut MUST be protected on a version.  Might some implementations choose to\nprotect precursor-set in all cases as well?  Why is precursor-set handled\ndifferently than predecessor-set?\n\nlisa\n\n\n\n", "id": "lists-006-0536909"}, {"subject": "Re (2): Deleting version", "content": "> > 1.  By having (DAV:must-be-root-version) as a postcondition, you're\n> > preventing an implementation from deleting the last remaining version\n> > from a version history.  I assume this is your intent?  Like so many\n> > other things, it must be inferred rather than finding it stated in\n> > the text.  *sigh*\n> \n> The entire postcondition statement is:\n>      (DAV:must-be-root-version): If the root version of a version\n>      history is deleted, there MUST be another version that is the\n>      new root version, i.e. that is the ancestor of all other versions\n>      in the version history.\n> I think it is easily implied that you cannot therefore delete *all*\n> versions of a version history and satisfy this postcondition; but I have no\n> objection to adding to this statement if you really think it needs it.\nI agree that it's rather clear that you can't delete the last version.\nOTOH I find the name a little bit misleading. Perhaps because I'm not a\nnative speaker.\nI would prefer must-be-a-root-version or perhaps better must-exist-root-version.\n\nCheers, Edgar\n\n\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-0544213"}, {"subject": "Re: PROPFIND allprop with more propertie", "content": "On Fri, Jun 01, 2001 at 02:00:04PM +0200, Stefan Eissing wrote:\n> \n> > Von: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n> >\n> > [...]\n> > Julian: If you have a chance to do some interoperability testing\n> > with the \"unknown element\" nested inside of <allprop/>,\n> > that would be great, since that would give us a basis for\n> > fixing 23.3.1 (i.e. without introducing interoperability\n> > issues for existing servers).\n> \n> Ok, our tests showed that\n> <allprop/><include>...</include>\n>    works with moddav, IIS and our servlet, while\n> <allprop><include>...</include></allprop>\n>    works with moddav and IIS. Julian's PROPFIND\n>    handler is throwing the book at me with 422s.\n\n\nTo beat the horse:\n\nmod_dav uses the following algorithm in its propfind:\n\n1) validate that the root element (if provided) is DAV:propfind\n2) if no body was provided, or a DAV:allprop child is present in the root\n   element, then the PROPFIND is an \"allprop\"\n3) look for a DAV:propname as a child of the root element; if found, then\n   the PROPFIND is a \"propname\" style\n4) look for DAV:prop; if founc, then it is a \"prop\" style\n5) else fail\n\n6) For a prop style fetch, only the immediate child elements (whether a\n   start element, or an empty element) of the DAV:prop element are used.\n   Children of those elements are not examined.\n\n-- whitespace is completely ignored in the entire PROPFIND processing\n\n\nSo... mod_dav is going to be extremely flexible with any kind of screwing\naround you might want to perform in the PROPFIND body :-)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-0552418"}, {"subject": "RE: Resource clas", "content": "   From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n\n   ....  When making high-level UI decisions (menu options greyed-out,\n   choice of icons, etc.) the information required is usually 'type'\n   _and_ 'state'.  Providing an efficient means of getting the full\n   classification will be important for responsive UIs.\n\nDeciding what menu options to put up should be based on\nDAV:supported-method-set.  The \"icon\" that is chosen should be based\non the \"content\" of the resource.  For the versioning metadata\nresources, this can be inferred from the\nDAV:supported-live-property-set.  The only time you need\nDAV:resourcetype is when there are not any special live properties for\nthe resource (for example, there is no live property that lets you\ndistinguish an empty collection from a non-collection resource).\n\n   Since <DAV:checked-in> and <DAV:checked-out> will appear in the\n   <DAV:supported-live-properties> set I believe that it will be\n   sufficient to PROPFIND on <DAV:supported-live-properties> and\n   <DAV:resourcetype> (for <DAV:collection/> or a MIME-type etc.) to\n   get an accurate classification.\n\n   However...  It feels strange (in a woolly, hand-waving way) to\n   characterise a resource based soley upon its observed/stated\n   behavior -- especially given the existance of a <DAV:resourcetype>\n   property that is being used intuatively in some cases (e.g. an\n   activity), and not in others (e.g. a version-controlled\n   configuration).\n\nGood point.  We are currently unnecessarily setting DAV:resourcetype\nfor a few resources (e.g. activities), when this information is\nalready available in DAV:supported-live-property-set.\n\nI propose that we delete this redundant and inconsistent use of\nDAV:resourcetype from the versioning protocol.\n\nIf consensus is ever reached at the general\nWebDAV level that we should extend DAV:resourcetype with sets of\ntokens, we can then add this information in a consistent fashion\n(i.e. consistent wrt whatever criteria is decided for what goes\ninto DAV:resourcetype).\n\n   The danger that I see is that clients must base their\n   characterisations of resources on the existance of specific live\n   properties, and that future extensions to DeltaV will have to bear\n   this in mind when defining new resource 'types'.\n\nIf a new resource type has exactly the same\nDAV:supported-live-property-set as an existing resource type, I\nbelieve it is reasonable and correct for the GUI to show the same icon\nfor both resources.\n\n   For example, if I had an idea for a resource that was not a\n   Baseline, but had a legitimate use for the\n   <DAV:baseline-collection> property, all legacy (to-be:-) clients\n   would spot the <DAV:baseline-collection> property and incorrectly\n   assume it was a Baseline.\n\nA client that cared about this would look for an exact match with\nthe set of DAV:supported-live-property-set for a baseline.  And if\nit didn't have an exact match, I suggest that displaying the\nbaseline icon (or whatever icon has the best matching property\nset) is significantly superior to displaying the \"unknown resource\ntype\" icon.\n\n   How much more verbose English would be if we had to describe the\n   characteristics of a crocodile and an alligator in order to distingush\nthem\n   rather than rely on their names.\n\nSuppose I had an \"X-ray vision WebDAV\" application on my palm pilot\nthat I pointed at a closed door in front of me.  If that application\nwas written before the \"alligator\" resource was defined, I'd much\nrather have the \"reptile with big teeth that will eat you\" icon pop up\non my palm pilot, than the \"unknown resource type\" icon.  (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0561362"}, {"subject": "RE: Resource clas", "content": "   From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n\n   Im Auftrag von Tim_Ellison@uk.ibm.com\n   > However...  It feels strange (in a woolly, hand-waving way) to\n   > characterise a resource based soley upon its observed/stated\n   > behavior -- especially given the existance of a\n   > <DAV:resourcetype> property that is being used intuatively in\n   > some cases (e.g. an activity), and not in others (e.g. a\n   > version-controlled configuration).\n\n   So, using Java terminology, we are talking about classes and\n   interfaces.  Different classes are reflected in the resourcetype\n   and the implemented interfaces are currently deduced from the set\n   of live properties.\n\n   So, maybe the designers of Java had also Tim's strange, wooly feeling\n   about just relying on class properties and required that a Java class\n   has to declare that it implements a certain interface.\n\nMore likely they just wanted to be able to efficiently compile code.\nSince we are not compiling our HTTP method invocations,\nthere is no need for us to deal with the complexity and\noverhead of a compile-time type and interface system.\n\n   Therefore\n   a) compilers/runtime can easily see what an object supports\n\nNote though that we don't write HTTP method compilers, and runtime can just\nuse DAV:supported-method-set and DAV:supported-live-property-set.\n\n   b) compilers can warn/fail if a class does not fully implement an\ninterface\n\nAgain note that we don't write HTTP method compilers.\n\n   c) class designers can say what they mean. They avoid implementing\n      an interface by accident. (What Tim talks about in the next\nparagraph).\n\nWe're using this information to decide on what icon to display\nto the user.  In this context, if it acts like a duck and looks\nlike a duck, using the \"duck icon\" is probably a good choice (:-).\n\nA java compiler and runtime system uses this information for\na lot more than deciding on what icon to display, and therefore\nreaches different conclusions on this issue.\n\n   I should probably read more and propose less, but I would like a DAV\n   property\n\n   <implements xmlns=\"DAV:\" xmlns:DV=\"DAV:versioning\"\nxmlns:DX=\"DAV:feature-X\">\n     <DV:versionable-resource/>\n     <DV:versioned-resource/>\n     <DX:x-type/>\n   </implements>\n\n   which is part of a standard propfind/allprop response.\n\nWhat would this give a WebDAV client that it does not get\nfrom  DAV:supported-method-set and DAV:supported-live-property-set?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0572464"}, {"subject": "RE: Deleting version", "content": "   From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n\n   \"Lisa Dusseault\" <lisa@xythos.com> wrote:\n\n   > Geoff said:\n\n   > 2.  I don't think the issue of a version-controlled-resource with zero\n   > versions is sufficiently addressed.  For your convenience, here's the\n   > section from 2518:\n   > ...\n   > A direct read of this paragraph combined with deltaV draft 15 (and your\n   > implication) would indicate that you can't issue a VERSION-CONTROL\nmethod\n   > on a lock-null resource.  That's bogus.\n\n   No, that's great!<g> The lock null resource is a nonce concept that\n   is not required by Delta-V.  Reading the quoted paragraph with\n   Delta-V gives (IMHO) the correct impression that versioning\n   operations are not allowed on lock null resources.\n\nAnother reason that we do not require a server to support putting a\n\"null\" resource under version control is that some version control\nsystems cannot put a resource under version control until they know\nwhat kind of resource it is.  For example, a collection often requires\na very different kind of version history resource from a text\ndocument.\n\n   > A \"write locked null resource\"\n   > is there so that the creator can do all the write operations and state\n   > changes they need before making the resource visible to everybody.\n\n   This isn't true since you cannot PROPPATCH a lock null resource,\n   and as soon as the first PUT/MKCOL succeeds it is no longer in the\n   lock-null state -- so there really is no set of state changes that\n   can be applied to a lock null resource.\n\nI agree.\n\n   > So, I suggest that VERSION-CONTROL (and perhaps other methods\n   > like CHECKOUT, MKWORKSPACE...) should be explicitly allowed by\n   > DeltaV to be done on write locked null resources, and that the\n   > spec define a precondition that can be returned if the server\n   > decides not to allow operations on write-lock resources.\n\n   I see no argument for VERSION-CONTROL or CHECKOUT, but MKWORKSPACE is a\n   more likely candidate since it is akin to MKCOL.  This would obviously\n   require a modification to RFC2518's statement that the lock null resource\n   MUST fail methods that are not in the named list.\n\nI agree that it does at least make sense to allow MKWORKSPACE (and\nMKACTIVITY) to apply to lock null resources, but since creating a lock\nnull resource before issuing the MKWORKSPACE provides little or no\nbenefit, and since the concept of a lock null resource is so bogus\n(:-), I would prefer not mentioning lock null resources in the\nversioning protocol unless a pressing need to do so is identified.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0582136"}, {"subject": "RE: Re (2): Deleting version", "content": "   From: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n\n   > > By having (DAV:must-be-root-version) as a postcondition, you're\n   > > preventing an implementation from deleting the last remaining\n   > > version from a version history.  I assume this is your intent?\n   > > Like so many other things, it must be inferred rather than\n   > > finding it stated in the text.  *sigh*\n\n   > The entire postcondition statement is:\n   >      (DAV:must-be-root-version): If the root version of a version\n   >      history is deleted, there MUST be another version that is\n   >      the new root version, i.e. that is the ancestor of all other\n   >      versions in the version history.\n   > I think it is easily implied that you cannot therefore delete\n   > *all* versions of a version history and satisfy this\n   > postcondition; but I have no objection to adding to this\n   > statement if you really think it needs it.\n\n   I agree that it's rather clear that you can't delete the last\n   version.  OTOH I find the name a little bit misleading. Perhaps\n   because I'm not a native speaker.  I would prefer\n   must-be-a-root-version or perhaps better must-exist-root-version.\n\nHow about \"DAV:version-history-has-root\" ?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0592232"}, {"subject": "Removing the DAV:activity and DAV:version-history and DAV:baselin e resource type value", "content": "Currently, the versioning spec defines a few special values for\nDAV:resourcetype.\n\nIt has been pointed out in a current thread that this is only done in a few\ncases,\nwhereas in most cases, the type of a resource is inferred from the\nDAV:supported-live-property-set.\n\nTo make this more consistent, I propose that we remove those redundant\nresource\ntypes, which means that you will be able to tell whether or not something is\nan\nactivity, version history, or baseline, by looking at its\nDAV:supported-live-property-set,\nas is done for the other versioning resources.\n\nThis follows the Goland \"you are done when you can't delete anything\"\nprotocol principle.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0600710"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:baselin e resource type value", "content": "It would appear that there are two camps represented on the list.\n\nThose that want more info in DAV:resourcetype, even if that means\nduplicating information that can be deduced by DAV:supported-live-properties\net al.\n\nThose that want the opposite, i.e. downplay DAV:resourcetype and rely on the\ncapabilities of a resource to determine it's 'type'.\n\nPistols at dawn?  A democratic vote?  Reasoned debate?\n\nTim\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: 02 June 2001 21:51\n> To: DeltaV (E-mail)\n> Subject: Removing the DAV:activity and DAV:version-history and\n> DAV:baselin e resource type values\n>\n>\n> Currently, the versioning spec defines a few special values for\n> DAV:resourcetype.\n>\n> It has been pointed out in a current thread that this is only\n> done in a few\n> cases,\n> whereas in most cases, the type of a resource is inferred from the\n> DAV:supported-live-property-set.\n>\n> To make this more consistent, I propose that we remove those redundant\n> resource\n> types, which means that you will be able to tell whether or not\n> something is\n> an\n> activity, version history, or baseline, by looking at its\n> DAV:supported-live-property-set,\n> as is done for the other versioning resources.\n>\n> This follows the Goland \"you are done when you can't delete anything\"\n> protocol principle.\n>\n> Cheers,\n> Geoff\n>\n\n\n\n", "id": "lists-006-0609324"}, {"subject": "RE: Resource clas", "content": "> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: 02 June 2001 13:57\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Resource class\n>\n>\n>    From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n>\n>    ....  When making high-level UI decisions (menu options greyed-out,\n>    choice of icons, etc.) the information required is usually 'type'\n>    _and_ 'state'.  Providing an efficient means of getting the full\n>    classification will be important for responsive UIs.\n>\n> Deciding what menu options to put up should be based on\n> DAV:supported-method-set.  The \"icon\" that is chosen should be based\n> on the \"content\" of the resource.\n\nI disagree, the actions to be performed on a resource (the 'menu options')\nand the representation of a resource to an application (its 'icon') will be\nbased on both the supported methods and content.\nFor example, the 'compiling' action makes sense for a source resource, but\nnot a binary.  The icon for a version is likely different to that of a\nmutable resource.  And so on.\nI simply claim that you need both efficiently.\n\n> For the versioning metadata\n> resources, this can be inferred from the\n> DAV:supported-live-property-set.  The only time you need\n> DAV:resourcetype is when there are not any special live properties for\n> the resource (for example, there is no live property that lets you\n> distinguish an empty collection from a non-collection resource).\n\nMKCOL creates an empty collection, but its DAV:resourcetype still contains\nDAV:collection (which is a live property that distinguishes the empty\ncollection from a non-collection resource).\n\n>    Since <DAV:checked-in> and <DAV:checked-out> will appear in the\n>    <DAV:supported-live-properties> set I believe that it will be\n>    sufficient to PROPFIND on <DAV:supported-live-properties> and\n>    <DAV:resourcetype> (for <DAV:collection/> or a MIME-type etc.) to\n>    get an accurate classification.\n>\n>    However...  It feels strange (in a woolly, hand-waving way) to\n>    characterise a resource based soley upon its observed/stated\n>    behavior -- especially given the existance of a <DAV:resourcetype>\n>    property that is being used intuatively in some cases (e.g. an\n>    activity), and not in others (e.g. a version-controlled\n>    configuration).\n>\n> Good point.  We are currently unnecessarily setting DAV:resourcetype\n> for a few resources (e.g. activities), when this information is\n> already available in DAV:supported-live-property-set.\n>\n> I propose that we delete this redundant and inconsistent use of\n> DAV:resourcetype from the versioning protocol.\n\n<G> Ha! That's a classic!  I didn't see that coming - fantastic!\n\n> If consensus is ever reached at the general\n> WebDAV level that we should extend DAV:resourcetype with sets of\n> tokens, we can then add this information in a consistent fashion\n> (i.e. consistent wrt whatever criteria is decided for what goes\n> into DAV:resourcetype).\n>\n>    The danger that I see is that clients must base their\n>    characterisations of resources on the existance of specific live\n>    properties, and that future extensions to DeltaV will have to bear\n>    this in mind when defining new resource 'types'.\n>\n> If a new resource type has exactly the same\n> DAV:supported-live-property-set as an existing resource type, I\n> believe it is reasonable and correct for the GUI to show the same icon\n> for both resources.\n\nGUI's aside for a moment, clearly there are cases where a different 'type'\nmay be important in some other respect, and I was speculating that the live\nproperty set of a new type may be a proper superset of an existing type --\nand thereby cause a problem.\n\n>    For example, if I had an idea for a resource that was not a\n>    Baseline, but had a legitimate use for the\n>    <DAV:baseline-collection> property, all legacy (to-be:-) clients\n>    would spot the <DAV:baseline-collection> property and incorrectly\n>    assume it was a Baseline.\n>\n> A client that cared about this would look for an exact match with\n> the set of DAV:supported-live-property-set for a baseline.  And if\n> it didn't have an exact match, I suggest that displaying the\n> baseline icon (or whatever icon has the best matching property\n> set) is significantly superior to displaying the \"unknown resource\n> type\" icon.\n\nIt may be a lot worse than the wrong icon (though I also disagree that\nshowing the wrong icon is superior).  In this example the 'icon' represents\nany number of application level choices based on type that will be screwed\nup.\n\n>    How much more verbose English would be if we had to describe the\n>    characteristics of a crocodile and an alligator in order to distingush\n> them\n>    rather than rely on their names.\n>\n> Suppose I had an \"X-ray vision WebDAV\" application on my palm pilot\n> that I pointed at a closed door in front of me.  If that application\n> was written before the \"alligator\" resource was defined, I'd much\n> rather have the \"reptile with big teeth that will eat you\" icon pop up\n> on my palm pilot, than the \"unknown resource type\" icon.  (:-).\n\nMy question is how did you come up with 'reptile', 'big teeth', and 'eat\nyou' as defining properties for the croc?  and how did you know that this\nwould not collide with the definition of another animal you don't know about\nyet.\n\nOur choice of live properties to define the type _may_ be equivalent to\nhaving defined a crocodile as 'a large animal with an enigmatic smile', and\nyou'd open the door expecting your mother-in-law (awh, maybe not such a good\nexample :-)\n\nTim\n\n\n\n", "id": "lists-006-0619245"}, {"subject": "RE: Protected properties..", "content": "It's because the precursor defines the logical ancestor to the version from\na different version history.  The precursor is a resource that the client\nchose to copy or merge into the working resource / checked out version\ncontrolled resource because it made ('application') sense for them to do so;\nwhereas the predecessor defines the resource that was actually checked out.\nThis distinction was considered important.\n\nSome systems may not support changing the value of the resource that was\nactually checked out, hence the predecessor MAY be protected, however, of\ncourse the precursor cannot have such system limitations and therefore has\nno right to be protected.\n\nTim\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: 01 June 2001 20:22\n> To: DeltaV\n> Subject: Protected properties...\n>\n>\n>\n> DeltaV lists one property, DAV:predecessor-set, that MAY be protected on a\n> checked-out resource, it's up to the implementation.  However, on\n> a version,\n> predecessor-set MUST be protected.  So far, so cool:  I understand that.\n>\n> Next, note that precursor-set is NOT protected on a checked-out resource,\n> but MUST be protected on a version.  Might some implementations choose to\n> protect precursor-set in all cases as well?  Why is precursor-set handled\n> differently than predecessor-set?\n>\n> lisa\n>\n\n\n\n", "id": "lists-006-0633132"}, {"subject": "Re: Removing the DAV:activity and DAV:version-history and DAV:baselin e resource type value", "content": "This doesn't feel right. Tim's point about supersets worries me. And clients\nthat don't look at enough scope to be able to differentiate future/private\ntypes.\n\nWe have specific types of resources in the spec. Semantic/conceptual types\nof resources. It seems better to state \"this resource is of <THIS> type\"\nthan to let it be inferred by the property set.\n\nThat inference step is rather brittle over time.\n\nCheers,\n-g\n\nOn Sat, Jun 02, 2001 at 04:50:44PM -0400, Clemm, Geoff wrote:\n> Currently, the versioning spec defines a few special values for\n> DAV:resourcetype.\n> \n> It has been pointed out in a current thread that this is only done in a few\n> cases,\n> whereas in most cases, the type of a resource is inferred from the\n> DAV:supported-live-property-set.\n> \n> To make this more consistent, I propose that we remove those redundant\n> resource\n> types, which means that you will be able to tell whether or not something is\n> an\n> activity, version history, or baseline, by looking at its\n> DAV:supported-live-property-set,\n> as is done for the other versioning resources.\n> \n> This follows the Goland \"you are done when you can't delete anything\"\n> protocol principle.\n> \n> Cheers,\n> Geoff\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-0641679"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "   From: Tim Ellison [mailto:tim@peir.com]\n\n   It would appear that there are two camps represented on the list.\n\n   Those that want more info in DAV:resourcetype, even if that means\n   duplicating information that can be deduced by\n   DAV:supported-live-properties et al.\n\n   Those that want the opposite, i.e. downplay DAV:resourcetype and\n   rely on the capabilities of a resource to determine it's 'type'.\n\n   Pistols at dawn?  A democratic vote?  Reasoned debate?\n\nI'll go for what's behind door number three (reasoned debate).\n\nAs tempting as it is to continue the alligator and mother-in-law\nanalogies (:-), it's probably more productive to focus on a concrete\nbenefit these new DAV:resourcetype values provide to a client.\n\nSo to start off, let's look at the only DAV:resourcetype value defined\nby RFC-2518: DAV:collection.  The utility of this resourcetype value\nis clear: if you have done a PROPFIND's with Depth:1, this tells you\nwhether to put a \"+\" next to a member resource, telling the\nuser that they can ask for nested members of that member.\n\nAs an aside, what RFC-2518 *should* have done is provide some live\nproperty such as DAV:internal-member-count.  This would have given\nthe client the same information (i.e. this resource can have internal\nmembers), but also given it something useful (like how many members\nit has).  But this thread is not to correct the mistakes of RFC-2518\n(but that doesn't mean we shouldn't learn from those mistakes :-).\n\nThe floor is now open for proposed additions to DAV:resourcetype,\nand a specific reason for that addition (i.e. what specifically\ncan clients do with that new value that they couldn't already do\nwithout it).  \n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0651357"}, {"subject": "RE: Resource clas", "content": "   From: Tim Ellison [mailto:tim@peir.com]\n\n   >    The danger that I see is that clients must base their\n   >    characterisations of resources on the existance of specific\n   >    live properties, and that future extensions to DeltaV will\n   >    have to bear this in mind when defining new resource 'types'.\n   >\n   > If a new resource type has exactly the same\n   > DAV:supported-live-property-set as an existing resource type, I\n   > believe it is reasonable and correct for the GUI to show the same\n   > icon for both resources.\n\n   GUI's aside for a moment, clearly there are cases where a different\n   'type' may be important in some other respect, and I was\n   speculating that the live property set of a new type may be a\n   proper superset of an existing type -- and thereby cause a problem.\n\nThis is only true for languages that do not provide for \"namespaces\"\nfor their property names (which therefore leads to unexpected\nproperty name collisions).  But in WebDAV, we use XML namespaces to\nprevent unintended property name collisions.  This means that the\nmethod and live property of a resource will be a proper superset of\nthose of another resource only if it is a \"subtype\" of that other\nresource.\n\n   >    For example, if I had an idea for a resource that was not a\n   >    Baseline, but had a legitimate use for the\n   >    <DAV:baseline-collection> property, all legacy (to-be:-) clients\n   >    would spot the <DAV:baseline-collection> property and incorrectly\n   >    assume it was a Baseline.\n   >\n   > A client that cared about this would look for an exact match with\n   > the set of DAV:supported-live-property-set for a baseline.  And if\n   > it didn't have an exact match, I suggest that displaying the\n   > baseline icon (or whatever icon has the best matching property\n   > set) is significantly superior to displaying the \"unknown resource\n   > type\" icon.\n\n   It may be a lot worse than the wrong icon (though I also disagree\n   that showing the wrong icon is superior).  In this example the\n   'icon' represents any number of application level choices based on\n   type that will be screwed up.\n\nI'd need some specific (and compelling :-) examples.  Someone that is\nextending the protocol by re-using existing properties needs to be\naware of the semantics of those properties, and not modify them.  This\nthen allows any client that knows about those properties to interoperate\neffectively against any resource that displays that subset.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0663140"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas elin e resource type value", "content": "   From: Greg Stein [mailto:gstein@lyra.org]\n\n   This doesn't feel right. Tim's point about supersets worries\n   me. And clients that don't look at enough scope to be able to\n   differentiate future/private types.\n\n   We have specific types of resources in the\n   spec. Semantic/conceptual types of resources. It seems better to\n   state \"this resource is of <THIS> type\" than to let it be inferred\n   by the property set.\n\n   That inference step is rather brittle over time.\n\nBut it's important to keep in mind what a WebDAV client will do with\nthis \"type\" information.  It is not a compiler that will be\nhard-wiring in assembly language method offset values based upon the\ndeclared signature of a declared variable type.  It is a client\nputting up an icon or a menu list.  And this client is going to\nencounter resources that have been extended with additional properties\nand methods.  What is better ... that the client say \"unknown resource\ntype\" and give you nothing, or that it put up an icon that is designed\nto reflect a set of live properties and methods that are known to\nexist on that resource?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0672752"}, {"subject": "Re (3): Deleting version", "content": "gclemm@rational.com wrote\n>    I agree that it's rather clear that you can't delete the last\n>    version.  OTOH I find the name a little bit misleading. Perhaps\n>    because I'm not a native speaker.  I would prefer\n>    must-be-a-root-version or perhaps better must-exist-root-version.\n> \n> How about \"DAV:version-history-has-root\" ?\nMuch better than 'must-be-root-version'.\n\nCheers, Edgar\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-0681212"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas  eline resource type value", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n>    From: Tim Ellison [mailto:tim@peir.com]\n>\n>    It would appear that there are two camps represented on the list.\n>\n>    Those that want more info in DAV:resourcetype, even if that means\n>    duplicating information that can be deduced by\n>    DAV:supported-live-properties et al.\n>\n>    Those that want the opposite, i.e. downplay DAV:resourcetype and\n>    rely on the capabilities of a resource to determine it's 'type'.\n>\n>    Pistols at dawn?  A democratic vote?  Reasoned debate?\n>\n> I'll go for what's behind door number three (reasoned debate).\n>\n> As tempting as it is to continue the alligator and mother-in-law\n> analogies (:-), it's probably more productive to focus on a concrete\n> benefit these new DAV:resourcetype values provide to a client.\n\n(Sorry about that -- but I can't talk about bytes on the wire for too long\nwithout getting a bit silly.)\n\n> So to start off, let's look at the only DAV:resourcetype value defined\n> by RFC-2518: DAV:collection.  The utility of this resourcetype value\n> is clear: if you have done a PROPFIND's with Depth:1, this tells you\n> whether to put a \"+\" next to a member resource, telling the\n> user that they can ask for nested members of that member.\n\nAgreed.  Or, indeed a PROPFIND depth zero, whatever.\n\n> As an aside, what RFC-2518 *should* have done is provide some live\n> property such as DAV:internal-member-count.  This would have given\n> the client the same information (i.e. this resource can have internal\n> members), but also given it something useful (like how many members\n> it has).  But this thread is not to correct the mistakes of RFC-2518\n> (but that doesn't mean we shouldn't learn from those mistakes :-).\n\nOk, but I've also never seen anybody confused by the DAV:collection\n'marker' or its purpose either, so we can assume that it is a reasonable\nthing to do.\n\n> The floor is now open for proposed additions to DAV:resourcetype,\n\nOne suggestion is to annotate DAV:resourcetype with those types and\ncategorizations adopted by the Delta-V specification (version, working\nresource, baseline, etc.)  Those types were obviously considered important\nwhen writing the specification to aid in its understanding, so it seems\nreasonable to reflect them in the resources themselves.\n\nSo, for example, a resource may have a DAV:resourcetype as follows:\n    <DAV:resourcetype>\n        <DAV:collection/>\n        <DAV:version/>\n    </DAV:resourcetype>\nand another may have:\n    <DAV:resourcetype>\n        <DAV:version-controlled-resource/>\n    </DAV:resourcetype>\n\nI'm guessing that I don't need to explain what the additional annotations\nare conveying(?) and that is my point.  Isn't it more intuative to see\n<DAV:version/> in the resource type rather than looking for the\nDAV:version-name property and deducing that therefore the resource is a\nversion?\n\n> and a specific reason for that addition\n\nIt is going to make the adoption of deltav easier because people will\nunderstand it better.\nIt will also remove the possibility of ambiguity being inadvertantly\nintroduced by some later addition to the specification (though due\ndiligence would dictate that the future designers avoid such pitfalls).\n\n> (i.e. what specifically\n> can clients do with that new value that they couldn't already do\n> without it).\n\nI agree that giving resource type a new value will not give clients any\nfurther capabilities.  I never intended to portray this as a failing of the\nspecification, and it certainly should not hold up its progress through the\nprocess.  It is a matter of style, and I think that is why there is a\nprotracted debate about it.  The problem has already been solved, and I\nhave had the opportunity to express my viewpoint.  I have no objection if\nthe authors 'pull-rank' and proceed.\n\nTim\n\n\n\n", "id": "lists-006-0688709"}, {"subject": "RE: Deleting version", "content": "I responded to Tim last week but neglected to cc' the list...\n\n(I think) Tim said:\n> The entire postcondition statement is:\n>      (DAV:must-be-root-version): If the root version of a version\n>      history is deleted, there MUST be another version that is the\n>      new root version, i.e. that is the ancestor of all other versions\n>      in the version history.\n>\n> I think it is easily implied that you cannot therefore delete *all*\n> versions of a version history and satisfy this postcondition; but\n> I have no\n> objection to adding to this statement if you really think it needs it.\n\nActually, I think the problem is that I (do other readers?) still don't\nlook\nin the preconditions and postconditions for normative requirements.  I\nthink\nof them as error/status codes, but in fact a lot of the postconditions make\nrequirements.  And, in the case of this requirement, the use of the passive\nvoice makes it a bit of work to figure out whether the client is\nresponsible or the server is responsible.\n\nSo yes, a clear statement like \"The server MUST NOT allow the last version\nto be deleted\" would be useful.\n\n\n> No, that's great!<g>  The lock null resource is a nonce concept\n> that is not\n> required by Delta-V.\n\nSince the lock null resource is enshrined in RFC2518, I do not think it's\nmerely a nonce concept (yes, I had to look it up :)\n\nBut you have a point about the purpose, let me try again and see if I get\nit\nbetter:  the lock-null feature allows people to lock something before it's\ncreated so that there's no window, or gap, when somebody else can lock it\n(after it's created but before the creator has finished with it).\nAgreement?\n\n> I see no argument for VERSION-CONTROL or CHECKOUT, but MKWORKSPACE is a\n> more likely candidate since it is akin to MKCOL.  This would obviously\n> require a modification to RFC2518's statement that the lock null resource\n> MUST fail methods that are not in the named list.\n\nI agree.  Rather than relying on the not-fully-prescient wording of\nRFC2518,\nI'd suggest saying that MKWORKSPACE can be allowed on a write-locked null\nresource, but no other DeltaV methods.\n\nThe modification to RFC2518 is not required because it states \"any HTTP/1.1\nor DAV methods \".  DeltaV methods, obviously, are not covered by this,\nbecause if HTTP/1.1 was meant to be inclusive, then DAV wouldn't have been\ncalled out explicitly.\n:)\n\n\nlisa\n\n\n\n", "id": "lists-006-0701085"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "   From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n\n   \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n\n   > As tempting as it is to continue the alligator and mother-in-law\n   > analogies (:-), it's probably more productive to focus on a\n   > concrete benefit these new DAV:resourcetype values provide to a\n   > client.\n\n   (Sorry about that -- but I can't talk about bytes on the wire for\n   too long without getting a bit silly.)\n\nPlease, no apologies!  That was my favorite part of this whole\nthread (:-).  I was just forcing myself to stop (:-).   From:\nTim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n\n   \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n\n   > As tempting as it is to continue the alligator and mother-in-law\n   > analogies (:-), it's probably more productive to focus on a\n   > concrete benefit these new DAV:resourcetype values provide to a\n   > client.\n\n   (Sorry about that -- but I can't talk about bytes on the wire for\n   too long without getting a bit silly.)\n\nPlease, no apologies!  That was my favorite part of this whole\nthread (:-).  I was just forcing myself to stop (:-).\n\n   One suggestion is to annotate DAV:resourcetype with those types and\n   categorizations adopted by the Delta-V specification (version,\n   working resource, baseline, etc.)  Those types were obviously\n   considered important when writing the specification to aid in its\n   understanding, so it seems reasonable to reflect them in the\n   resources themselves.\n\nI believe it is important to distinguish things that are needed to\nunderstand the protocol definition from things that are needed in\nthe protocol itself.  To use an extreme example, although examples of\nhow to use the methods are very important parts of the protocol\ndefinition, we will not be supporting a \"get-example\" method that at\nruntime retrieves for you a standard example of how each method is\nused.  I believe that the \"resource type\", like the \"examples\",\nare needed to understand the protocol definition but are not needed\nat runtime by the protocol.\n\n   It will also remove the possibility of ambiguity being\n   inadvertantly introduced by some later addition to the\n   specification (though due diligence would dictate that the future\n   designers avoid such pitfalls).\n\nThis I believe remains the key argument.  Is future interoperability\nimproved, unaffected, or harmed through the addition of these new\nresourcetype values?  My argument is the \"like a duck\" argument\n(i.e. if it looks like a duck and acts like a duck, even if it is some\nrefinement of a duck, if your client does not know about that\n\"duck refinement\", it is better for your client to treat it as a duck\nthan to treat it as an \"unknown resource\").\n\n   > (i.e. what specifically\n   > can clients do with that new value that they couldn't already do\n   > without it).\n\n   I agree that giving resource type a new value will not give clients\n   any further capabilities.  I never intended to portray this as a\n   failing of the specification, and it certainly should not hold up\n   its progress through the process.  It is a matter of style, and I\n   think that is why there is a protracted debate about it.\n\nI think it's actually a good sign for the stability of the spec that\nall we have to debate about is this kind of \"angels on the head of a\npin\" issue (:-).\n\n   The problem has already been solved, and I have had the opportunity\n   to express my viewpoint.  I have no objection if the authors\n   'pull-rank' and proceed.\n\nWell, we have to do something while our area directors are looking the\nspec over (:-).  There is ample precedence for the author's opinions\nbeing superceded (the label feature and the update feature come to\nmind :-), and this is an interesting (by some extremely geekish\ndefinition of interesting :-) topic, so please don't let it drop if\nyou feel there are still any interesting points to be made.\n\nCheers,\nGeoff\n\n\n   One suggestion is to annotate DAV:resourcetype with those types and\n   categorizations adopted by the Delta-V specification (version,\n   working resource, baseline, etc.)  Those types were obviously\n   considered important when writing the specification to aid in its\n   understanding, so it seems reasonable to reflect them in the\n   resources themselves.\n\nI believe it is important to distinguish things that are needed to\nunderstand the protocol definition from things that are needed in\nthe protocol itself.  To use an extreme example, although examples of\nhow to use the methods are very important parts of the protocol\ndefinition, we will not be supporting a \"get-example\" method that at\nruntime retrieves for you a standard example of how each method is\nused.  I believe that the \"resource type\", like the \"examples\",\nare needed to understand the protocol definition but are not needed\nat runtime by the protocol.\n\n   It will also remove the possibility of ambiguity being\n   inadvertantly introduced by some later addition to the\n   specification (though due diligence would dictate that the future\n   designers avoid such pitfalls).\n\nThis I believe remains the key argument.  Is future interoperability\nimproved, unaffected, or harmed through the addition of these new\nresourcetype values?  My argument is the \"like a duck\" argument\n(i.e. if it looks like a duck and acts like a duck, even if it is some\nrefinement of a duck, if your client does not know about that\n\"duck refinement\", it is better for your client to treat it as a duck\nthan to treat it as an \"unknown resource\").\n\n   > (i.e. what specifically\n   > can clients do with that new value that they couldn't already do\n   > without it).\n\n   I agree that giving resource type a new value will not give clients\n   any further capabilities.  I never intended to portray this as a\n   failing of the specification, and it certainly should not hold up\n   its progress through the process.  It is a matter of style, and I\n   think that is why there is a protracted debate about it.\n\nI think it's actually a good sign for the stability of the spec that\nall we have to debate about is this kind of \"angels on the head of a\npin\" issue (:-).\n\n   The problem has already been solved, and I have had the opportunity\n   to express my viewpoint.  I have no objection if the authors\n   'pull-rank' and proceed.\n\nWell, we have to do something while our area directors are looking the\nspec over (:-).  There is ample precedence for the author's opinions\nbeing superceded (the label feature and the update feature come to\nmind :-), and this is an interesting (by some extremely geekish\ndefinition of interesting :-) topic, so please don't let it drop if\nyou feel there are still any interesting points to be made.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0710839"}, {"subject": "RE: Deleting version", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   Actually, I think the problem is that I (do other readers?) still\n   don't look in the preconditions and postconditions for normative\n   requirements.  I think of them as error/status codes, but in fact a\n   lot of the postconditions make requirements.\n\nThat would be a problem, because the majority of the normative\nrequirements are specified in the pre and post conditions. The\nintroductory text provides motivation and guidance, but the\npre and post conditions are the actual specification of functionality.\n\n   And, in the case of this requirement, the use of the passive voice\n   makes it a bit of work to figure out whether the client is\n   responsible or the server is responsible.\n\nSatisfying a precondition is always the responsibility of the client, \nand satisfying a postcondition is always the responsibility of the\nserver.  This is now stated explicitly in the introduction.\n\nBut I agree that this could be emphasized by replacing the passive\nvoice with \"the server MUST ...\", and will do so.\n\n   So yes, a clear statement like \"The server MUST NOT allow the last\n   version to be deleted\" would be useful.\n\nOK, how about if I add the following sentence to the postcondition: \"A\nresult of this postcondition is that every version history will have\nat least one version.\" ?\n\n   I'd suggest saying that MKWORKSPACE can be allowed on a\n   write-locked null resource, but no other DeltaV methods.\n\nWhat is the (compelling :-) use case for creating a lock-null\nresource before issuing the MKWORKSPACE request?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0727687"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:baseline resource type value", "content": ">\n> This doesn't feel right. Tim's point about supersets worries me.\n> And clients that don't look at enough scope to be able to differentiate\n> future/private types.\n>\n> We have specific types of resources in the spec. Semantic/conceptual types\n> of resources. It seems better to state \"this resource is of <THIS> type\"\n> than to let it be inferred by the property set.\n>\n> That inference step is rather brittle over time.\n\nI agree with Greg. I believe that all client implementors can correctly\nimplement a simple string comparison against the value(s) in\nDAV:resourcetype. I do not have faith that *all* client implementors will\n(a) think about the issue long enough to realize that they can, in fact,\ninfer the resource types from the supported live properties, and (b)\nimplement the inference logic uniformly and correctly. Clients and servers\ndon't even support the \"charset\" MIME parameter uniformly, and this is\nrelatively simple in comparison.\n\nTherefore, I recommend that the DeltaV specification *keep* the\nDAV:activity, DAV:version-history, and DAV:baseline resourcetype values.\n\n- Jim\n\n\n\n", "id": "lists-006-0736846"}, {"subject": "RE: Deleting version", "content": ">    From: Lisa Dusseault [mailto:lisa@xythos.com]\n> \n>    Actually, I think the problem is that I (do other readers?) still\n>    don't look in the preconditions and postconditions for normative\n>    requirements.  I think of them as error/status codes, but in fact a\n>    lot of the postconditions make requirements.\n> \n> That would be a problem, because the majority of the normative\n> requirements are specified in the pre and post conditions. The\n> introductory text provides motivation and guidance, but the\n> pre and post conditions are the actual specification of functionality.\n> \n\nFor the record, I have found this confusing on multiple occasions as well.\n\n- Jim\n\n\n\n", "id": "lists-006-0745914"}, {"subject": "AW: PROPFIND allprop with more properties (was AW: Resource class      ", "content": "Lisa\n\n> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Lisa Dusseault\n> Gesendet: Freitag, 1. Juni 2001 17:50\n> [...]\n> We're always happy to have people test Xythos WebFile Server at\n> http://www.sharemation.com.  You can set up your own account through the\n> GUI, then point your DAV client at \n> http://www.sharemation.com/~yourusername.\n> \n\nOk, the variant \"<allprop><include>...</include></allprop>\ngives \"400 Bad Request\" on sharemation.com.\nThe variant \"<allprop/><include>...</include>\" is accepted.\n\n> I assume you tested IIS by running it yourself?  There isn't a\n> publicly-available IIS site, is there?  Any others??\n> \n\nYep, it's an internal IIS.\n\n\n\n", "id": "lists-006-0753851"}, {"subject": "AW: Removing the DAV:activity and DAV:version-history and DAV:baseline resource type value", "content": "> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n> \n> [...]\n> \n>    It will also remove the possibility of ambiguity being\n>    inadvertantly introduced by some later addition to the\n>    specification (though due diligence would dictate that the future\n>    designers avoid such pitfalls).\n> \n> This I believe remains the key argument.  Is future interoperability\n> improved, unaffected, or harmed through the addition of these new\n> resourcetype values?  My argument is the \"like a duck\" argument\n> (i.e. if it looks like a duck and acts like a duck, even if it is some\n> refinement of a duck, if your client does not know about that\n> \"duck refinement\", it is better for your client to treat it as a duck\n> than to treat it as an \"unknown resource\").\n\nI think it's not only future interoperability, but also interoperability\nas such which can be improved by explicitly stating the type of a resource.\nRumour has it that code can have bugs. Sticking to the analogies in this \nthread, if your mother-in-law does not report a property properly, the \nalligator might look like a duck and eat your client alive.\n\nWell. \n\nHow about a <D:implements> property which has all supported flavours\nof a resource? This could help keep resourcetype backward compatible.\nOtherwise I would favour extending resourcetype...\n\n//Stefan\n\n\n\n", "id": "lists-006-0764023"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV :baseline resource type value", "content": "\"Jim Whitehead\" <ejw@cse.ucsc.edu> wrote:\n> >\n> > This doesn't feel right. Tim's point about supersets worries me.\n> > And clients that don't look at enough scope to be able to differentiate\n> > future/private types.\n> >\n> > We have specific types of resources in the spec. Semantic/conceptual\ntypes\n> > of resources. It seems better to state \"this resource is of <THIS>\ntype\"\n> > than to let it be inferred by the property set.\n> >\n> > That inference step is rather brittle over time.\n>\n> I agree with Greg. I believe that all client implementors can correctly\n> implement a simple string comparison against the value(s) in\n> DAV:resourcetype. I do not have faith that *all* client implementors will\n> (a) think about the issue long enough to realize that they can, in fact,\n> infer the resource types from the supported live properties,\n\nThen this has to be spelled out in the spec in such a fashion that client\nimplementors don't have to discover it.\n\n> and (b)\n> implement the inference logic uniformly and correctly. Clients and\nservers\n> don't even support the \"charset\" MIME parameter uniformly, and this is\n> relatively simple in comparison.\n\nWe are asking clients to do far more than Set comparisons if they are to\nuse Delta-V effectively.  I don't think this is a matter of complex\nimplementation.\n\n> Therefore, I recommend that the DeltaV specification *keep* the\n> DAV:activity, DAV:version-history, and DAV:baseline resourcetype values.\n\nIt's worse than that; I was also suggesting extending the existing resource\ntypes as detailed in preious posts.\n\nTim\n\n\n\n", "id": "lists-006-0774323"}, {"subject": "Lock null resources (was RE: Deleting versions", "content": "\"Lisa Dusseault\" <lisa@xythos.com> wrote:\n>\n> > No, that's great!<g>  The lock null resource is a nonce concept\n> > that is not required by Delta-V.\n>\n> Since the lock null resource is enshrined in RFC2518, I do not think\n> it's merely a nonce concept (yes, I had to look it up :)\n\nSorry, what I meant was that \"lock-null\" resources are wierd.  The notion\nwas introduced for a unique purpose, and it is probably best if we tolerate\nit but don't propogate it in Delta-V.\n\n> But you have a point about the purpose, let me try again and see if I\n> get it better:  the lock-null feature allows people to lock something\n> before it's created so that there's no window, or gap, when somebody\n> else can lock it (after it's created but before the creator has finished\n> with it). Agreement?\n\nClients can't \"lock something before it is created\".  The problem is how to\nreserve the namespace for a future resource.  Since HTTP deals with named\nresources RFC2518 had to introduce a 'null' resource to get the namespace\nlocking without providing a meaningful resource entity.\n\n> > I see no argument for VERSION-CONTROL or CHECKOUT, but MKWORKSPACE is a\n> > more likely candidate since it is akin to MKCOL.  This would obviously\n> > require a modification to RFC2518's statement that the lock null\nresource\n> > MUST fail methods that are not in the named list.\n>\n> I agree.  Rather than relying on the not-fully-prescient wording of\n> RFC2518, I'd suggest saying that MKWORKSPACE can be allowed on a\n> write-locked null resource, but no other DeltaV methods.\n>\n> The modification to RFC2518 is not required because it states \"any\nHTTP/1.1\n> or DAV methods \".  DeltaV methods, obviously, are not covered by this,\n> because if HTTP/1.1 was meant to be inclusive, then DAV wouldn't have\nbeen\n> called out explicitly.\n> :)\n\nFine.\n\n\nTim\n\n\n\n", "id": "lists-006-0784325"}, {"subject": "RE: Deleting version", "content": "\"Jim Whitehead\" <ejw@cse.ucsc.edu> wrote:\n> >    From: Lisa Dusseault [mailto:lisa@xythos.com]\n> >\n> >    Actually, I think the problem is that I (do other readers?) still\n> >    don't look in the preconditions and postconditions for normative\n> >    requirements.  I think of them as error/status codes, but in fact a\n> >    lot of the postconditions make requirements.\n> >\n> > That would be a problem, because the majority of the normative\n> > requirements are specified in the pre and post conditions. The\n> > introductory text provides motivation and guidance, but the\n> > pre and post conditions are the actual specification of functionality.\n> >\n>\n> For the record, I have found this confusing on multiple occasions as\nwell.\n\nWhat can I add?  They are an integral part of the specification and should\nbe read carefully and understood.  At least for me, the layout and style do\nnot imply that pre/post-conditions may be glossed over or ignored.  In\nfact, I find it useful to have the conditions stated explicitly in this\nway, and _named_ for easy reference.\n\nTim\n\n\n\n", "id": "lists-006-0793293"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "   From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n\n   > Von: Clemm, Geoff\n   > This I believe remains the key argument.  Is future\n   > interoperability improved, unaffected, or harmed through the\n   > addition of these new resourcetype values?  My argument is the\n   > \"like a duck\" argument (i.e. if it looks like a duck and acts\n   > like a duck, even if it is some refinement of a duck, if your\n   > client does not know about that \"duck refinement\", it is better\n   > for your client to treat it as a duck than to treat it as an\n   > \"unknown resource\").\n\n   I think it's not only future interoperability, but also\n   interoperability as such which can be improved by explicitly\n   stating the type of a resource.  Rumour has it that code can have\n   bugs.  Sticking to the analogies in this thread, if your\n   mother-in-law does not report a property properly, the alligator\n   might look like a duck and eat your client alive.\n\nSo the reason for adding values to DAV:resourcetype is that it is more\nlikely for a server to be able to return the correct DAV:resourcetype\nvalue than it is for it to return the correct DAV:supported-method-set\nor DAV:supported-live-property-set value?  I find that rather hard\nto understand (much less, believe :-).\n\nThe reason I'm applying so much time/energy to this thread, is that it\nis really a general DAV question that shows up (and will continue to\nshow up) in every DAV extension.  I'd like to develop some guiding\nprinciple for \"what goes in DAV:resourcetype\", so that we don't end up\nhaving these same (often metaphysical :-) arguments every time the\ntopic comes up.\n\nFor some historical background, I orginally proposed\nDAV:supported-method-set and DAV:supported-live-property-set because\nDAV:resourcetype wasn't giving me the detail I needed to populate my\nGUI's.  Certainly, before I had these two properties, DAV:resourcetype\nwas essential.  This may therefore be one of those times where a\nprotocol feature that was required has become redundant through the\naddition of later features.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0801950"}, {"subject": "RE: Deleting version", "content": ">\n> What is the (compelling :-) use case for creating a lock-null\n> resource before issuing the MKWORKSPACE request?\n>\n\nWhat other way would you create a workspace and guarantee that it can't be\naltered by other people before you set permissions and such correctly?\n\nSame goes for ACTIVITY.\n\nlisa\n\n\n\n", "id": "lists-006-0812509"}, {"subject": "RE: Deleting version", "content": "The only use case this addresses is that your client has\nissued a MKWORKSPACE/LOCK sequence, and that in the narrow\ntime interval between the completion of the MKWORKSPACE\nrequest and the LOCK request, some other client has managed\nto discover the name of your new workspace and has issued\na LOCK request that somehow gets in before yours.\n\nI believe that not only is the likelihood of this happening\nvanishingly small, but even if it does happen, your client\nwould just use the \"that workspace is already in use\nby someone else\" response that it needs in case\nsomebody got their MKWORKSPACE request in ahead of yours. \n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Tuesday, June 05, 2001 12:08 PM\nTo: Clemm, Geoff\nCc: DeltaV\nSubject: RE: Deleting versions\n\n\n>\n> What is the (compelling :-) use case for creating a lock-null\n> resource before issuing the MKWORKSPACE request?\n>\n\nWhat other way would you create a workspace and guarantee that it can't be\naltered by other people before you set permissions and such correctly?\n\nSame goes for ACTIVITY.\n\nlisa\n\n\n\n", "id": "lists-006-0820036"}, {"subject": "RE: Deleting version", "content": "It's not \"vanishingly small\" if you lose your network connection between the\nMKWORKSPACE and the LOCK request.  Or if the LOCK request is lost.  Or if\nthe latency is ~2 seconds each way.\n\nIf somebody who's not supposed to, gets in and changes something inbetween a\nMKWORKSPACE command and a ACL request, that's a serious problem.  Null\nresources help avoid that.\n\nIt's not that somebody got their MKWORKSPACE request in ahead of\nmine --that's not the purpose of null resources at all.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Tuesday, June 05, 2001 1:03 PM\n> To: DeltaV\n> Subject: RE: Deleting versions\n>\n>\n> The only use case this addresses is that your client has\n> issued a MKWORKSPACE/LOCK sequence, and that in the narrow\n> time interval between the completion of the MKWORKSPACE\n> request and the LOCK request, some other client has managed\n> to discover the name of your new workspace and has issued\n> a LOCK request that somehow gets in before yours.\n>\n> I believe that not only is the likelihood of this happening\n> vanishingly small, but even if it does happen, your client\n> would just use the \"that workspace is already in use\n> by someone else\" response that it needs in case\n> somebody got their MKWORKSPACE request in ahead of yours.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Lisa Dusseault [mailto:lisa@xythos.com]\n> Sent: Tuesday, June 05, 2001 12:08 PM\n> To: Clemm, Geoff\n> Cc: DeltaV\n> Subject: RE: Deleting versions\n>\n>\n> >\n> > What is the (compelling :-) use case for creating a lock-null\n> > resource before issuing the MKWORKSPACE request?\n> >\n>\n> What other way would you create a workspace and guarantee that it can't be\n> altered by other people before you set permissions and such correctly?\n>\n> Same goes for ACTIVITY.\n>\n> lisa\n\n\n\n", "id": "lists-006-0828400"}, {"subject": "Re (2): Removing the DAV:activity and DAV:version-history and DAV:baseline resource type value", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> The reason I'm applying so much time/energy to this thread, is that it\n> is really a general DAV question that shows up (and will continue to\n> show up) in every DAV extension.  I'd like to develop some guiding\n> principle for \"what goes in DAV:resourcetype\", so that we don't end up\n> having these same (often metaphysical :-) arguments every time the\n> topic comes up.\nHey, that's an impressive target. I won't pretend to solve this problem\nwith my comments :-)\n\n> For some historical background, I orginally proposed\n> DAV:supported-method-set and DAV:supported-live-property-set because\n> DAV:resourcetype wasn't giving me the detail I needed to populate my\n> GUI's.  Certainly, before I had these two properties, DAV:resourcetype\n> was essential.  This may therefore be one of those times where a\n> protocol feature that was required has become redundant through the\n> addition of later features.\nI follow this thread already for a while and couldn't decide which way to go.\nBut at the moment I think I agree with Geoff.\nIt sure is easier to cope with a limited number of resource types. OTOH there\nis the problem to define them and their differences. Then some are similar\nbut still different and you are in danger to define a (class) hierarchy sometime\nin the future.\nThen you always will have discussions about whether new resource types will\nbe necessary if they just have one or two more methods or properties than\nanother one.\nIn the realm of programming languages there are ideas of avoiding\ncompatibility problems between classes (which have their defined place in a\nclass hierarchy) or components (Buzz word :-) by just defining interfaces\nin the form of messages/methods. As long as an object understands all of\nthe messages (By name) of an interface it is treated as that (resource)type.\nIf it has a different semantics for some methods ? Bad luck.\nI see that this is a risk, but OTOH it is more flexible.\nI acknowledge the drawbacks some of you have mentioned, but a design without\n(too much) redundencies also has it's advantages.\nSo I guess removing resource type is okay with me (See my signature about Einstein)\n\nCheers, Edgar\n\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-0838327"}, {"subject": "RE: Deleting version", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   If somebody who's not supposed to, gets in and changes something in\n   between a MKWORKSPACE command and a ACL request, that's a serious\n   problem.  Null resources help avoid that.\n\n   It's not that somebody got their MKWORKSPACE request in ahead of\n   mine --that's not the purpose of null resources at all.\n\nMy point was not that a lock can prevent somebody from\ncreating the workspace ahead of you, but rather that\nsomeone locking \"your\" workspace is no different from\nsomeone creating a workspace by that name before you\ncan lock that URL.\n\nIn particular, we are discussing two alternative sequences:\n LOCK/MKWORKSPACE/ACL/UNLOCK\nor\n MKWORKSPACE/LOCK/ACL/UNLOCK\n\nIn the first sequence, the LOCK may fail (because there already\nis a lock on that URL), so you tell the user \"that workspace is\nalready in use by another user\".\n\nIn the second sequence, either the MKWORKSPACE may fail (because\nsomebody got in and created a workspace before you) or the LOCK\nmay fail (because somebody got in and locked the workspace before\nyou).  In either case, you still tell the user \"that workspace is \nalready in use by another user\".\n\nSo from the user's perspective, it doesn't matter whether\nor not their client did a LOCK/MKWORKSPACE or a\nMKWORKSPACE/LOCK.  Their request can fail because another\nclient \"got there before them\".\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0848829"}, {"subject": "RE: Deleting version", "content": "The problem is that the \"client that got there before them\" may have\npermission to alter a workspace, but they may NOT have permission to CREATE\na workspace.\n\nThe problem is not that the other client locked it, but that they might\napply changes before you get a chance to prevent them!  I create a Workspace\n(or a resource, or a collection).  I want to then set the ACLs so that I'm\nthe only one that can alter this resource, because it's MINE.  But, in\nbetween the MKWORKSPACE and the subsequent LOCK, the other client comes in\nand sets ACLs so that they can write the workspace and I can't!  Ouch.\n\nNull resource went through similar discussions, and was kept for reasons\nwhich apply to MKWORKSPACE the same way they apply to PUT, MKCOL.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Tuesday, June 05, 2001 3:48 PM\n> To: DeltaV\n> Subject: RE: Deleting versions\n>\n>\n>    From: Lisa Dusseault [mailto:lisa@xythos.com]\n>\n>    If somebody who's not supposed to, gets in and changes something in\n>    between a MKWORKSPACE command and a ACL request, that's a serious\n>    problem.  Null resources help avoid that.\n>\n>    It's not that somebody got their MKWORKSPACE request in ahead of\n>    mine --that's not the purpose of null resources at all.\n>\n> My point was not that a lock can prevent somebody from\n> creating the workspace ahead of you, but rather that\n> someone locking \"your\" workspace is no different from\n> someone creating a workspace by that name before you\n> can lock that URL.\n>\n> In particular, we are discussing two alternative sequences:\n>  LOCK/MKWORKSPACE/ACL/UNLOCK\n> or\n>  MKWORKSPACE/LOCK/ACL/UNLOCK\n>\n> In the first sequence, the LOCK may fail (because there already\n> is a lock on that URL), so you tell the user \"that workspace is\n> already in use by another user\".\n>\n> In the second sequence, either the MKWORKSPACE may fail (because\n> somebody got in and created a workspace before you) or the LOCK\n> may fail (because somebody got in and locked the workspace before\n> you).  In either case, you still tell the user \"that workspace is\n> already in use by another user\".\n>\n> So from the user's perspective, it doesn't matter whether\n> or not their client did a LOCK/MKWORKSPACE or a\n> MKWORKSPACE/LOCK.  Their request can fail because another\n> client \"got there before them\".\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-0857658"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:baseline resource type value", "content": ">\n> Therefore, I recommend that the DeltaV specification *keep* the\n> DAV:activity, DAV:version-history, and DAV:baseline resourcetype values.\n\nWhat about \"version-controlled-resource\", \"version\" and \"workspace\"?\n\nIt would also be nice to identify a version-controlled collection in some\nway that it's also recognizable as a collection (e.g.\n\n<DAV:resourcetype><DAV:collection/><DAV:version-controlled-collection/></DAV\n:resourcetype>\n\nlisa\n\n\n\n", "id": "lists-006-0868152"}, {"subject": "&quot;nothing left to cut&quot; (was: Re: [ACL] Owner issues", "content": "On Tue, Jun 05, 2001 at 01:26:43AM -0400, Clemm, Geoff wrote:\n> I believe I was the one that originally suggested we allow\n> updating the owner with a PROPPATCH.  I have seen the error\n> of my ways (:-).  So unless there really is someone that\n> feels this functionality is important, I believe that the\n> principle of \"you aren't\n> done until there is nothing left to cut\" says to take it out.\n\nI am beginning to seriously disagree with the whole notion of \"cut\neverything until there is nothing left to cut.\"\n\nYou are taking it to the extreme, leaving a specification that is obtuse,\nhard to understand, and requires a half-dozen readings just to figure out\nthe subtleties and interactions between the elements, such that you can\n*infer* what should have been outright specified.\n\nCutting features is great. Creating obtuse specifications is absurd.\n\nIf you want a *STANDARD*, then it must be obvious to *all* implementors what\nthe standard should be. If one out of twenty people can figure out ALL of\nthe implications and inferences to implement the \"standard\", then you simply\nDON'T have a standard. You've only created a guide. The other 19 people\nimplemented something wrong because they couldn't grok the darned document.\n\nI'm not making a statement on the <owner> thing. Instead, I'm arguing that\nyour policy is erroneous. It needs to be tempered.\n\n[ I believe this applies more to the DeltaV spec than the ACL spec (I\n  haven't read the ACL spec lately); the DeltaV spec is currently a very\n  opaque document because of the \"say it once; anything more is redundant\"\n  attitude taken towards it. ]\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-0877003"}, {"subject": "Re: Re (2): Removing the DAV:activity and DAV:version-history and DAV:baseline resource type value", "content": "On Tue, Jun 05, 2001 at 05:29:08PM -0400, Edgar@edgarschwarz.de wrote:\n>...\n> Then you always will have discussions about whether new resource types will\n> be necessary if they just have one or two more methods or properties than\n> another one.\n\nThe resources in the spec are not defined by the set of methods or\nproperties. They are defined by *human* concepts. We have identified a model\nwhich incorporates Version Controlled Resources, Baselines, Activities,\nWorkspaces, Working Resources, Version Resource, etc.\n\nNote that I used labels to define those things. I did *not* use\n{DAV:checked-in}, {DAV:baseline-collection}, {DAV:activity-version-set},\n{DAV:workspace-checkout-set}, {???}, {DAV:checkout-set} as the descriptions.\n\nSome further points:\n\n*) howthehell do I describe a Working Resource? I can't see that it has a\n   unique property.\n\n*) is DAV:checkout-set actually unique to a Version resource? Some of those\n   properties are reflected in VCRs. Which Version Resource properties *do*\n   get copied to a VCR, and which do not? The ones that don't will therefore\n   signal whether a resource is a Version resource or not.\n\nSorry. But the human is what we are writing this spec for. And we attach\nlabels to these things. Not a set.\n\nOh: and Tim argued, \"well, for somebody to implement DeltaV, we're going to\nask a lot more than simple Set computations.\" Oh. Great. Just because some\npart is difficult, that means we can make *everything* difficult? That's\nbogus.\n\n\"Hey, John. You can do DeltaV if you can jump over this 6 foot bar. Oh.\nWait. The DeltaV designers said that if you can do that, then you can also\njump over this 10 foot bar. Cool. Go, man! Jump!\"\n\npthtpth. Non-starter.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-0887049"}, {"subject": "Re: Removing the DAV:activity and DAV:version-history and DAV:baseline resource type value", "content": "On Tue, Jun 05, 2001 at 04:53:04PM -0700, Lisa Dusseault wrote:\n> >\n> > Therefore, I recommend that the DeltaV specification *keep* the\n> > DAV:activity, DAV:version-history, and DAV:baseline resourcetype values.\n> \n> What about \"version-controlled-resource\", \"version\" and \"workspace\"?\n> \n> It would also be nice to identify a version-controlled collection in some\n> way that it's also recognizable as a collection (e.g.\n> \n> <DAV:resourcetype><DAV:collection/><DAV:version-controlled-collection/></DAV\n> :resourcetype>\n\nAnd DAV:working-resource\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-0896526"}, {"subject": "Re: Re (2): Removing the DAV:activity and DAV:version-history and  DAV:baseline resource type value", "content": "Greg Stein <gstein@lyra.org> wrote:\n> On Tue, Jun 05, 2001 at 05:29:08PM -0400, Edgar@edgarschwarz.de wrote:\n> >...\n> > Then you always will have discussions about whether new resource types\nwill\n> > be necessary if they just have one or two more methods or properties\nthan\n> > another one.\n>\n> The resources in the spec are not defined by the set of methods or\n> properties. They are defined by *human* concepts. We have identified a\nmodel\n> which incorporates Version Controlled Resources, Baselines, Activities,\n> Workspaces, Working Resources, Version Resource, etc.\n>\n> Note that I used labels to define those things. I did *not* use\n> {DAV:checked-in}, {DAV:baseline-collection}, {DAV:activity-version-set},\n> {DAV:workspace-checkout-set}, {???}, {DAV:checkout-set} as the\ndescriptions.\n\nThis is precisely the point I raised in\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001AprJun/0181.html\n        \"One suggestion is to annotate DAV:resourcetype with\n        those types and categorizations adopted by the Delta-V\n        specification (version, working resource, baseline, etc.)\n        Those types were obviously considered important when\n        writing the specification to aid in its understanding,\n        so it seems reasonable to reflect them in the resources\n        themselves.\"\n\n> Some further points:\n>\n> *) howthehell do I describe a Working Resource? I can't see that it has a\n>    unique property.\n\n(You're going to like this :-)\n\nA working resource has <DAV:checked-out/> and does not have\n<DAV:auto-checkout/>\n(appears and does not appear, respectively, in\nDAV:supported-live-property-set)\n\n> *) is DAV:checkout-set actually unique to a Version resource? Some of\nthose\n>    properties are reflected in VCRs. Which Version Resource properties\n*do*\n>    get copied to a VCR, and which do not? The ones that don't will\ntherefore\n>    signal whether a resource is a Version resource or not.\n\nA version is identified by its support for the <DAV:version-name> property.\n\nFor the full list of defining properties, plus Geoff's corrections, see\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001AprJun/0115.html\n\n> Sorry. But the human is what we are writing this spec for. And we attach\n> labels to these things. Not a set.\n\nAgreed.\n\n> Oh: and Tim argued, \"well, for somebody to implement DeltaV, we're going\nto\n> ask a lot more than simple Set computations.\" Oh. Great. Just because\nsome\n> part is difficult, that means we can make *everything* difficult? That's\n> bogus.\n>\n> \"Hey, John. You can do DeltaV if you can jump over this 6 foot bar. Oh.\n> Wait. The DeltaV designers said that if you can do that, then you can\nalso\n> jump over this 10 foot bar. Cool. Go, man! Jump!\"\n>\n> pthtpth. Non-starter.\n\n(I don't know what 'pthtpth' means, but you probably just swore at me in\nacronym-speak:^)\n\nFlame on.\n\nCome on Greg -- you can't be serious.\n(1) Performing set intersection is absolutely trivial.  It requires WAY\nmore intelect to figure out how to implement merge functionality, XML\nparsing, PROPPATCH atomicity.\n(2) If we _do_ go for extending DAV:resourcetype the likely outcome is\nsomething like a *Set* of orthogonal characteristics, such as\n<version-controlled-resource>, <collection>, <checked-in> -- guess what,\nyou'll have to do that \"difficult\" Set thing again anyway.\n(3) Just because I said that there is more to delta-v than these simple\noperations doesn't mean that I'm suggesting we make everything difficult.\nThat doesn't follow at all.  Clients and servers are *already* doing these\nSet operations for each PROPPATCH, PROPFIND and other methods.\nGive people some credit.\n\n\nTim\n\n\n\n", "id": "lists-006-0905044"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV :baseline resource type value", "content": "\"Lisa Dusseault\" <lisa@xythos.com> wrote:\n> >\n> > Therefore, I recommend that the DeltaV specification *keep* the\n> > DAV:activity, DAV:version-history, and DAV:baseline resourcetype\nvalues.\n>\n> What about \"version-controlled-resource\", \"version\" and \"workspace\"?\n>\n> It would also be nice to identify a version-controlled collection in some\n> way that it's also recognizable as a collection (e.g.\n>\n>\n<DAV:resourcetype><DAV:collection/><DAV:version-controlled-collection/></DAV\n\n> :resourcetype>\n\n(I'm just doing this so Geoff will change color -- too bad I shan't be\nthere to see it<g>)\n\nMy view of the world...\n\nHere's the list of elements that could appear in a DAV:resourcetype.  Some\nof these can be combined to provide a really meaningful experience for the\nclient.  Obviously, some combinations are invalid.\n     <DAV:checked-in/>\n     <DAV:checked-out/>\n     <DAV:collection/>\n     <DAV:working-resource/>\n     <DAV:version-controlled-resource/>\n     <DAV:version/>\n     <DAV:version-history/>\n     <DAV:workspace/>\n     <DAV:version-controlled-configuration/>\n     <DAV:baseline/>\n     <DAV:activity/>\n\nSo,\n<DAV:resourcetype>\n     <DAV:activity/>\n</DAV:resourcetype\n\nwould be good, that is, not surprisingly, an activity resource.\n\n<DAV:resourcetype>\n     <DAV:checked-out/>\n     <DAV:version-controlled-resource/>\n     <DAV:collection/>\n     <DAV:workspace/>\n</DAV:resourcetype>\n\nwould be good too, it is a checked-out, version-controlled resource for a\nworkspace collection.  And so on.\n\nTim\n\n\n\n", "id": "lists-006-0918082"}, {"subject": "Re: Re (2): Removing the DAV:activity and DAV:version-history and  DAV:baseline resource type value", "content": "Edgar@EdgarSchwarz.de wrote:\n> \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> > The reason I'm applying so much time/energy to this thread, is that it\n> > is really a general DAV question that shows up (and will continue to\n> > show up) in every DAV extension.  I'd like to develop some guiding\n> > principle for \"what goes in DAV:resourcetype\", so that we don't end up\n> > having these same (often metaphysical :-) arguments every time the\n> > topic comes up.\n> Hey, that's an impressive target. I won't pretend to solve this problem\n> with my comments :-)\n\nGeoff: hey, you've been rumbled! From your ACL list posting:\n    \"For DAV:resourcetype in the versioning protocol, I\n    really don't care much what we do with DAV:resourcetype\n    there either, but figured we might as well argue about\n    something in the versioning list while we're waiting\n    for the area directors to review the versioning protocol.\"\n\nWhich is it? You want to \"develop some guiding principle\" for future\ngenerations, or \"don't much care ... but figured we might as well argue\nabout something\"<g>\n(You don't have to answer that question:-)\n\n> > For some historical background, I orginally proposed\n> > DAV:supported-method-set and DAV:supported-live-property-set because\n> > DAV:resourcetype wasn't giving me the detail I needed to populate my\n> > GUI's.  Certainly, before I had these two properties, DAV:resourcetype\n> > was essential.  This may therefore be one of those times where a\n> > protocol feature that was required has become redundant through the\n> > addition of later features.\n>\n> I follow this thread already for a while and couldn't decide which way to\ngo.\n> But at the moment I think I agree with Geoff.\n> It sure is easier to cope with a limited number of resource types. OTOH\nthere\n> is the problem to define them and their differences. Then some are\nsimilar\n> but still different and you are in danger to define a (class) hierarchy\nsometime\n> in the future.\n> Then you always will have discussions about whether new resource types\nwill\n> be necessary if they just have one or two more methods or properties than\n> another one.\n> In the realm of programming languages there are ideas of avoiding\n> compatibility problems between classes (which have their defined place in\na\n> class hierarchy) or components (Buzz word :-) by just defining interfaces\n> in the form of messages/methods. As long as an object understands all of\n> the messages (By name) of an interface it is treated as that\n(resource)type.\n> If it has a different semantics for some methods ? Bad luck.\n> I see that this is a risk, but OTOH it is more flexible.\n> I acknowledge the drawbacks some of you have mentioned, but a design\nwithout\n> (too much) redundencies also has it's advantages.\n> So I guess removing resource type is okay with me (See my signature about\nEinstein)\n\nI agree with your observation, and note that the \"interfaces\" are usually\n_named_.  Since the specification has already named these interfaces\n(\"types\") I think it makes sense to use those names rather than constantly\nrefer to resource types by the set of \"messages/methods\" they define.\n\nTim\n\n\n\n", "id": "lists-006-0928645"}, {"subject": "RE: Deleting version", "content": "\"Lisa Dusseault\" <lisa@xythos.com> wrote:\n>\n> > What can I add?  They are an integral part of the specification and\nshould\n> > be read carefully and understood.  At least for me, the layout\n> > and style do\n> > not imply that pre/post-conditions may be glossed over or ignored.  In\n> > fact, I find it useful to have the conditions stated explicitly in this\n> > way, and _named_ for easy reference.\n>\n> It's not that your convention is not useful, it's that it's not normal.\n> It's not how RFC2518 is laid out, for example -- none of the sections on\n> error codes have contained normative stuff on how to _successfully_\ncomplete\n> the request.  We've all be trained by the other RFCs we've read to skip\nover\n> the error code sections at first read, and only refer when somethings\ngone\n> wrong. So of course one approach is to reorganize the way readers expect\nto\n> see it, putting requirements in the main text and simply listing the\ncodes\n> later.\n\nThe pre- and post- conditions are not \"error code sections\".  They are an\nintegral part of the specification.  Furthermore, each condition is\nindividually stated in its own paragraph so you don't have to disentangle\nthem from the prose, and as a bonus the conditions are _named_ so that we\ncan talk about the <DAV:version-history-is-tree> precondition and know what\nwe mean without having to recount the entire description.  I think this is\nvery important and very productive (an analogy with pattern languages\nsprings to mind).  As an added bonus, these names are to be returned by the\nserver so that clients can determine why some operations failed!\n\n> Since people don't read introductions, and they certainly don't remember\n> introductory material if it doesn't refer to something they have seen\n> already, you could recap the explanation the first time the\n\"precondition\"\n> and \"postcondition\" are mentioned.\n\nDelta-V's conditions sections are not the same as RFC2518's Status Codes\nsections.\nI'd much rather have the conditions set out like this than have to mark-up\nthe document with each condition as you come across it in the general\ndescription.\n\n> Another approach is to replace passive voice in those section with active\n> voice: \"client MUST ensure...\" and \"server MUST\"\n\nThis is good practice anyway.\n\nTim\n\n\n\n", "id": "lists-006-0940820"}, {"subject": "AW: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n>\n>    From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n>\n>    > Von: Clemm, Geoff\n>    > This I believe remains the key argument.  Is future\n>    > interoperability improved, unaffected, or harmed through the\n>    > addition of these new resourcetype values?  My argument is the\n>    > \"like a duck\" argument (i.e. if it looks like a duck and acts\n>    > like a duck, even if it is some refinement of a duck, if your\n>    > client does not know about that \"duck refinement\", it is better\n>    > for your client to treat it as a duck than to treat it as an\n>    > \"unknown resource\").\n>\n>    I think it's not only future interoperability, but also\n>    interoperability as such which can be improved by explicitly\n>    stating the type of a resource.  Rumour has it that code can have\n>    bugs.  Sticking to the analogies in this thread, if your\n>    mother-in-law does not report a property properly, the alligator\n>    might look like a duck and eat your client alive.\n>\n> So the reason for adding values to DAV:resourcetype is that it is more\n> likely for a server to be able to return the correct DAV:resourcetype\n> value than it is for it to return the correct DAV:supported-method-set\n> or DAV:supported-live-property-set value?  I find that rather hard\n> to understand (much less, believe :-).\n\nNot _the_ reason, but one reason, yes. My experience from implementing basic\ndeltaV features in server and client code is that the code often (not\nalways) deals with types of resources. \"Is this a versioned, plain or\nversion-controlled resource?\" is a typical question.\n\nBoth server and client code has the same concepts, but they are not\ndirectly communicated over the wire - only indirectly by properities.\nAnd even for those we try to invent something like allprop/include to\ngain acceptable performance.\n\nSince <supported-live-property-set> is rather expensive (and was moved\nout of allprop for that reason, right?) I ask the server for specific\nproperties (checked-in, checked-out and version-name) in order to\ndeduce that a resource is plain, versioned or version-controlled.\nHowever that will break immediatly when some other type of resource\ncarries a version-name.\n\nSo, I am looking for an airbag and seat belt - I do not want to\nremove any horse power so that it would be safe to drive without any. ;)\n\n> The reason I'm applying so much time/energy to this thread, is that it\n> is really a general DAV question that shows up (and will continue to\n> show up) in every DAV extension.  I'd like to develop some guiding\n> principle for \"what goes in DAV:resourcetype\", so that we don't end up\n> having these same (often metaphysical :-) arguments every time the\n> topic comes up.\n\nYour time and energy is really appreciated. Such a guiding principle\nwould make life easier for everyone. Be it draft writers or implementors.\n\n> For some historical background, I orginally proposed\n> DAV:supported-method-set and DAV:supported-live-property-set because\n> DAV:resourcetype wasn't giving me the detail I needed to populate my\n> GUI's.  Certainly, before I had these two properties, DAV:resourcetype\n> was essential.  This may therefore be one of those times where a\n> protocol feature that was required has become redundant through the\n> addition of later features.\n>\n> Cheers,\n> Geoff\n\nI still think that both have their value and purpose. Excuse me bringing\nback Java analogies, but reflection in Java is a very powerful feature\nand you can do lots of useful, flexible things with it. However there are\nalso\ninterfaces and it's good that they are there for speed and type safety.\n\nRegards, Stefan\n\n\n\n", "id": "lists-006-0950592"}, {"subject": "AW: Removing the DAV:activity and DAV:version-history and DAV :baseline resource type value", "content": "> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von\n> Tim_Ellison@uk.ibm.com\n> [...]\n>\n> My view of the world...\n>\n> Here's the list of elements that could appear in a DAV:resourcetype.  Some\n> of these can be combined to provide a really meaningful experience for the\n> client.  Obviously, some combinations are invalid.\n>      <DAV:checked-in/>\n>      <DAV:checked-out/>\n>      <DAV:collection/>\n>      <DAV:working-resource/>\n>      <DAV:version-controlled-resource/>\n>      <DAV:version/>\n>      <DAV:version-history/>\n>      <DAV:workspace/>\n>      <DAV:version-controlled-configuration/>\n>      <DAV:baseline/>\n>      <DAV:activity/>\n>\n\nWhat is your rationale for checked-in/out in the type? I think\nI have missed something in the spec, since it feels like a\nproperty to me.\n\n> So,\n> <DAV:resourcetype>\n>      <DAV:activity/>\n> </DAV:resourcetype\n>\n> would be good, that is, not surprisingly, an activity resource.\n>\n> <DAV:resourcetype>\n>      <DAV:checked-out/>\n>      <DAV:version-controlled-resource/>\n>      <DAV:collection/>\n>      <DAV:workspace/>\n> </DAV:resourcetype>\n>\n> would be good too, it is a checked-out, version-controlled resource for a\n> workspace collection.  And so on.\n>\n> Tim\n>\n>\n\n\n\n", "id": "lists-006-0963638"}, {"subject": "Re: AW: Removing the DAV:activity and DAV:version-history and DAV  :baseline resource type value", "content": "\"Stefan Eissing\" <stefan.eissing@greenbytes.de> wrote:\n>\n> What is your rationale for checked-in/out in the type?\n> I think I have missed something in the spec, since it\n> feels like a property to me.\n\nI agree that, for most of us, the checked-in status of a resource would be\nconsidered part of its 'state' rather than its 'type'.  However, these\nterms are ambiguous at best, and in previous posts I had tried to avoid\nusing 'type'.\n\nThe only DAV:resourcetype that we have right now is DAV:collection which is\nuseful to clients since it tells them that the namespace can be / is\nextended 'through' this resource.  It is also redundant since clients could\nsimply try an operation on the extended namespace and react to its success\nor failure (e.g. PROPFIND depth 1 on something, or PUT to a URL\none-segment-longer) to determine if the resource has collection semantics.\nSo I would suggest that the rationale for providing DAV:collection is that\nit is a convenient way to give clients a hint that these 'extended\nnamespace' operations have a chance of succeeding, and to given them a\nreasonable assumption that they should display the [+] twisty progressively\nas the namespace is explored, etc.\n\n[Footnote: Of course after discovering a DAV:collection resource there is\nnothing to stop another client deleting the DAV:collection and replacing it\nwith a non-DAV:collection thereby foiling the client's assumptions, which\nmeans all clients must have some way to deal with the world as though there\nwas no DAV:collection anyway. (lock everything yeh)]\n\nSo, if we are to continue this use of DAV:resourcetype it would be to give\nclients a useful classification of a resource at a particular point in time\nthat would give them a reasonable set of data for displaying an icon,\ngreying menu items and so on.  It should convey both versioning 'type' and\n'state' that is within the mandate of WebDAV.  The specification has\nalready called out a number of useful resource classifications and they are\nthe ones that I proposed (DAV:checked-in _and_ DAV:checked-out may be\nredundant).\n\nTim\np.s.  Just in case anyone missed an earlier post, I'll reiterate that the\nspec is not broken, it works just fine as it is written today, and I\ncontinue to support it fully in its present form.  I'm just exploring this\nidea and enjoying the thoughtful observations that it produces re: spec\ncomplexity, clarity of presentation, etc.\n\n\n\n", "id": "lists-006-0973644"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "   From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n\n   My experience from implementing basic deltaV features in server and\n   client code is that the code often (not always) deals with types of\n   resources. \"Is this a versioned, plain or version-controlled\n   resource?\" is a typical question.\n\n   Both server and client code has the same concepts, but they are not\n   directly communicated over the wire - only indirectly by properities.\n\nSo how is getting the information from DAV:resourcetype \"directly\nover the wire\" while getting the information from DAV:supported-method-set\nand DAV:supported-live-property-set \"indirect\"?  They are just two\nproperties, each containing a set of values, that the client is going\nto look for particular values that are of interest.\n\nAnd as Tim pointed out, the values we are going to end up putting\nin DAV:resourcetype are going to start looking amazingly similar\nto the set of values that currently exist in DAV:supported-method-set\nand DAV:supported-live-property-set.\n\n   And even for those we try to invent something like allprop/include to\n   gain acceptable performance.\n\nThere are no performance issues that I am aware of that would\ndistinguish the performance of accessing DAV:resourcetype from\nDAV:supported-xxx.  They are just fixed strings that are associated\nwith a resource when it is created.\n\n   Since <supported-live-property-set> is rather expensive (and was moved\n   out of allprop for that reason, right?)\n\nNo, it is not the value of DAV:supported-live-property-set that was\nexpensive (it is very cheap), but the values of the live properties\nthemselves which can be expensive.  \n\n   I ask the server for specific\n   properties (checked-in, checked-out and version-name) in order to\n   deduce that a resource is plain, versioned or version-controlled.\n\nNo, you check to see if those values appear in the\nDAV:supported-live-property set of the resource (which means the\nserver doesn't compute any of these property values, it just tells you\nthat they are supported).\n\n   However that will break immediatly when some other type of resource\n   carries a version-name.\n\nWhat do you mean by \"break\"?  The DAV:version-name property has \ncertain well defined semantics.  If your application wants to do\nsomething that depends on those semantics, it can do those things\non *any* resource that supports that property.  The dependency is\non whether or not the resource supports that property, not whether\nor not the resource has a certain \"type\".\n\nThe only things that an interoperable client can \"do\" on a resource is\nperform methods on the resource and access properties.  If a resource\nsupports a particular method or live property, you are guaranteed\n(if the resource is implemented properly) that you can do what that\nmethod says, or what that live property provides, which means it\n*won't* break.\n\n   So, I am looking for an airbag and seat belt - I do not want to\n   remove any horse power so that it would be safe to drive without any. ;)\n\nBut it's important to keep in mind that we are not actually talking\nabout driving a car, but rather interoperating with web servers (:-).\n\n   I still think that both have their value and purpose. Excuse me\n   bringing back Java analogies, but reflection in Java is a very\n   powerful feature and you can do lots of useful, flexible things\n   with it. However there are also interfaces and it's good that they\n   are there for speed and type safety.\n\nAlthough Java is a closer analogy than ducks, alligators, and \nmother-in-laws (:-), it is still just an analogy, and you can make\nan analogy reach any conclusion you want.  For example, you can\nmake an analogy with Smalltalk.  The reason why Smalltalk is such a good\nprototyping language, is that it *does not* require you\nto declare types, but rather allows you to invoke a routine on\nany object (resource) that supports the method you are invoking.\nLike Smalltalk, we want our protocol to continue working even when\nthe caller (the client) is modified or the callee (the server)\nis modified.  The benefits of explicit type definitions is that\nit is easier to do separate and efficient compilation.  But we\n*don't* compile our HTTP method calls ... we just invoke them,\nwhich is where the Java (and any strongly typed language) analogy\nbreaks down, but the Smalltalk (and Lisp, and ML, and most other\ngood prototyping languages) analogy holds.\n\nBut there I go again, indulging in analogy games ... (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0984523"}, {"subject": "RE: Deleting version", "content": "   From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n\n   \"Lisa Dusseault\" <lisa@xythos.com> wrote:\n\n   > Another approach is to replace passive voice in those section with\nactive\n   > voice: \"client MUST ensure...\" and \"server MUST\"\n\n   This is good practice anyway.\n\nI agree.  Unless someone objects, I will try to replace all\npostcondition passives with \"server MUST\" active statements in the\nnext working draft.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-0997362"}, {"subject": "RE: Version-controlled collection resources - I am still missing     somethin", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n\n> Introducing an empty root version will have no\n> significant implementation cost, and logically,\n> it is very reasonable to say that every new\n> collection starts out empty, so there is no\n> conceptual problem here with users encountering\n> a root version that is empty.\n\nI disagree that users would reasonably expect to see an empty collection\nversion.  I only expect to see versions that capture states that I'm\ninterested in (the initial empty state is not one of them).  But, other\nthan the fact that I wouldn't want to rely on it, that is something of a\ndigression...\n\n> But whether or not an empty root version is \"bogus\"\n> or \"sensible\" (:-), the VERSION-CONTROL request is\n> not expensive, because a server can easily leave an\n> \"uninitialized\" value for any such binding, and only\n> retrieve the root version if the client actually\n> requests a value from an unitialized binding.\n\nI agree that the server can be lazy, the question is what value should a\nclient see if it looked?\n\n>    From the client's perspective, is it any better\n>    to have no members of the version-controlled\n>    collection (and have to fill them in explicitly),\n>    or have the root versions for each member (and\n>    likely have to go and update them explicitly)?\n>    I accept that for the server it is easier to not\n>    create members.\n>\n> The server can use basically the same implementation\n> in either case.  The only question is whether it returns\n> some \"uninitialized\" status when you encounter one of\n> those internal members, or returns the root version.\n\nI agree that is the issue, unless we identify another candidate.\n\n> Note that since the client is extremely likely to follow\n> the VERSION-CONTROL request with the appropriate MERGE or\n> UPDATE request, a client won't be encountering these\n> \"uninitialized\" bindings very often anyway.\n\nAgreed.\n\n>    The members of a version-controlled collection created\n>    from a collection version are:\n>    (1) the DAV:root-version of the member's history (as\n>    proposed) an implementation note should be added to\n>    state that severs may chose to make root-versions of\n>    versioned collections empty to avoid cascading\n>    version-controlled collections.\n>\n> or could just implement them as \"uninitialized\", and only\n> retrieve the root version if the binding is used before it\n> is explicitly initialized.\n\nI don't want to get too much into implementation at this stage, though I\nagree with your observation.\n\nThe question at hand is whether the spec should be changed (as proposed) to\ndefine the default value of such a binding.  If we believe that the client\nwill always fix-up the binding anyway the answer may as well be 'no'.\n\n>    (2) undefined and have to be explictly created by another\n>    version-control/merge request.\n>    i.e. when the version-controlled collection is created\n>    a PROPFIND depth 1 would answer the internal member names,\n>    but attempts to GET them would return 404 Not Found.\n>\n> I considered this, but it introduced what appears to be an\n> unnecessary obscure case (you'd need a DAV:uninitialized-binding-set\n> so that a client could discover what was going on here).  Note:\n> I'm not against this, but just thought the current way was simpler.\n\nI tend to agree.  Although we did have it this way months ago, I think it\nis likely to be confusing, so I'd happily rule this option out.\n\n>    (3) the spec is silent and servers do what they choose.\n>    It seems that clients are very likely going to have to go\n>    and fix-up all the members anyway so who cares about the\n>    initial value.\n>\n> Yes, although I think it is better to define the behavior, so I\n> prefer 1 or 2.\n\nI kinda like this one, but can see the benefit of defining the behavior;\nit's just too bad that the DAV:root-version is unlikely to be a useful\nchoice for most clients.\n\n>    (4) forget that I even mentioned \"latest\" :-(\n>    Geoff wrote:\n>    > \"latest\" is a very bad choice ... I believe that selecting\n>    > the DAV:root-version is significantly superior.\n>    I agree that leaping around across branches is less than optimal,\n>    I was stumbing towards Alan's notion of the \"linear series\"\n>\n> Note that this effectively would bundle \"MERGE from activity\"\n> into the VERSION-CONTROL request.  One of the reasons I resist\n> bundling any of these into the VERSION-CONTROL is that any variant\n> of the MERGE or UPDATE request is reasonable following the\n> VERSION-CONTROL request, so we'd have to give VERSION-CONTROL\n> all the semantics of MERGE and UPDATE if we wanted to do this\n> cleanly.\n\nI agree.\n\n> Since I believe that there are several techniques a\n> server can use to make the initial VERSION-CONTROL request very\n> inexpensive (described above) , I think it is cleaner to keep\n> them separate.\n\nI agree that it is cleaner to keep them separate (despite the server\nimplementation).\n\nI'm mildly in favor of leaving it undefined, and mildly in favour of making\nit the DAV:root-version, and strong in favor of selecting the 'right'\nversion <g>  (... we could have these revision selection rules that\n...hmmm)(joke)\nRegards,\nTim\n\n\n\n", "id": "lists-006-10002800"}, {"subject": "RE: Version-controlled collection resources - I am still missing      somethin", "content": "Tim says:\nI'm mildly in favor of leaving it undefined, and mildly in favour of \nmaking\nit the DAV:root-version, and strong in favor of selecting the 'right'\nversion <g>  (... we could have these revision selection rules that\n...hmmm)(joke)\n\nI agree, but probably prefer leaving it undefined. We know using \nDAV:root-version won't be useful to almost any client even though its the \nonly good choice servers currently have. If its undefined, servers that \nsupport activities could advertise a \"main\" activity that they use. This \nmight be a good differentiator without introducing any interoperability \nissues. \n\n\n\n", "id": "lists-006-10015902"}, {"subject": "RE: Version-controlled collection resources - I am still missing  somethin", "content": "I'm happy to change this from \"the DAV:root-version\" to be\n\"undefined\".  Before I do so, does anyone want to argue in\nfavor of keeping it as the DAV:root-version?\n\nAnd in case anyone needs some context, the question is:\n\nWhen a new version-controlled collection is created by\napplying VERSION-CONTROL with a collection version\nto an unmapped URL, what should the DAV:checked-in\nproperty value be for the initial version-controlled\ninternal members of that new version-controlled collection?\n\nCheers,\nGeoff \n\n-----Original Message-----\nFrom: Jim Amsden [mailto:jamsden@us.ibm.com]\nSent: Thursday, July 05, 2001 1:19 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Version-controlled collection resources - I am still\nmissing something\n\n\nTim says:\nI'm mildly in favor of leaving it undefined, and mildly in favour of \nmaking\nit the DAV:root-version, and strong in favor of selecting the 'right'\nversion <g>  (... we could have these revision selection rules that\n...hmmm)(joke)\n\nI agree, but probably prefer leaving it undefined. We know using \nDAV:root-version won't be useful to almost any client even though its the \nonly good choice servers currently have. If its undefined, servers that \nsupport activities could advertise a \"main\" activity that they use. This \nmight be a good differentiator without introducing any interoperability \nissues. \n\n\n\n", "id": "lists-006-10023708"}, {"subject": "Bindings to non versioned controlled resources in version controlled  collection", "content": "The spec says:\n14 Version-Controlled-Collection Feature\n    Although a collection version only records the version-controlled\n    bindings of a collection, a version controlled collection MAY\n    contain both version-controlled and non-version-controlled\n    bindings. Non-version-controlled bindings are not under version\n    control, and therefore can be added or deleted without checking\n    out the version-controlled collection.\n\nGeoff says:\nYes, a version-controlled collection can (but note that only\nthe version-controlled bindings are captured by a collection\nversion, so the non-version-controlled members are not \"shared\"\nby other workspaces).\n\nThis is a little confusing. Maybe we could make the section above a little \nclearer if we indicated that adding non-version controlled resources to a \nversion controlled collection has no effect on it assocated version. So \nthe version controlled collection doesn't have to be checked out to add \nthese bindings. \n\n\n\n", "id": "lists-006-10033071"}, {"subject": "RE: Bindings to non versioned controlled resources in version con trolled  collection", "content": "Modifying a version controlled resource never has an effect on\nits associated version, so we probably wouldn't want to phrase\nit that way.  Can you think of some other wording that you would\nlike to add?\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Amsden [mailto:jamsden@us.ibm.com]\nSent: Thursday, July 05, 2001 3:35 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Bindings to non versioned controlled resources in version\ncontrolled collections\n\n\nThe spec says:\n14 Version-Controlled-Collection Feature\n    Although a collection version only records the version-controlled\n    bindings of a collection, a version controlled collection MAY\n    contain both version-controlled and non-version-controlled\n    bindings. Non-version-controlled bindings are not under version\n    control, and therefore can be added or deleted without checking\n    out the version-controlled collection.\n\nThis is a little confusing. Maybe we could make the section above a little \nclearer if we indicated that adding non-version controlled resources to a \nversion controlled collection has no effect on it assocated version. So \nthe version controlled collection doesn't have to be checked out to add \nthese bindings. \n\n\n\n", "id": "lists-006-10041140"}, {"subject": "RE: Bindings to non versioned controlled resources in version con trolled   collection", "content": "Perhaps distinguish between adding a binding to a non-versioned-controlled \nresource doesn't require the checkout while ading a binding to a \nversion-controlled-resource does because the latter results in a change to \nthe associated versioned collection while the former doesn't.\n\n\n\n\n\n\"Clemm, Geoff\" <gclemm@rational.com>\nSent by: ietf-dav-versioning-request@w3.org\n07/05/2001 04:21 PM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        RE: Bindings to non versioned controlled resources in version con trolled \ncollections\n\n \n\nModifying a version controlled resource never has an effect on\nits associated version, so we probably wouldn't want to phrase\nit that way.  Can you think of some other wording that you would\nlike to add?\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Amsden [mailto:jamsden@us.ibm.com]\nSent: Thursday, July 05, 2001 3:35 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Bindings to non versioned controlled resources in version\ncontrolled collections\n\n\nThe spec says:\n14 Version-Controlled-Collection Feature\n    Although a collection version only records the version-controlled\n    bindings of a collection, a version controlled collection MAY\n    contain both version-controlled and non-version-controlled\n    bindings. Non-version-controlled bindings are not under version\n    control, and therefore can be added or deleted without checking\n    out the version-controlled collection.\n\nThis is a little confusing. Maybe we could make the section above a little \n\nclearer if we indicated that adding non-version controlled resources to a \nversion controlled collection has no effect on it assocated version. So \nthe version controlled collection doesn't have to be checked out to add \nthese bindings. \n\n\n\n", "id": "lists-006-10050122"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "I think Tim's point was that if \"under version control\" \n(e.g. \"version-controlled-resource\") is part of\nthe \"type\" of a resource, then \"checked-out\" and \"checked-in\" \nwould equally usefully be considered as part of the type\n(since the significantly affect what methods can be\napplied to that resource).\n\nIn each case, you have the same resource (i.e. when you\nput a resource under version control, it is the same resource\nbut has some additional live properties and methods you can\napply to it).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\nSent: Wednesday, June 06, 2001 6:27 AM\nTo: DeltaV (E-mail)\nSubject: AW: Removing the DAV:activity and DAV:version-history and DAV\n:baseline resource type values\n\n\n\n\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von\n> Tim_Ellison@uk.ibm.com\n> [...]\n>\n> My view of the world...\n>\n> Here's the list of elements that could appear in a DAV:resourcetype.  Some\n> of these can be combined to provide a really meaningful experience for the\n> client.  Obviously, some combinations are invalid.\n>      <DAV:checked-in/>\n>      <DAV:checked-out/>\n>      <DAV:collection/>\n>      <DAV:working-resource/>\n>      <DAV:version-controlled-resource/>\n>      <DAV:version/>\n>      <DAV:version-history/>\n>      <DAV:workspace/>\n>      <DAV:version-controlled-configuration/>\n>      <DAV:baseline/>\n>      <DAV:activity/>\n>\n\nWhat is your rationale for checked-in/out in the type? I think\nI have missed something in the spec, since it feels like a\nproperty to me.\n\n> So,\n> <DAV:resourcetype>\n>      <DAV:activity/>\n> </DAV:resourcetype\n>\n> would be good, that is, not surprisingly, an activity resource.\n>\n> <DAV:resourcetype>\n>      <DAV:checked-out/>\n>      <DAV:version-controlled-resource/>\n>      <DAV:collection/>\n>      <DAV:workspace/>\n> </DAV:resourcetype>\n>\n> would be good too, it is a checked-out, version-controlled resource for a\n> workspace collection.  And so on.\n>\n> Tim\n>\n>\n\n\n\n", "id": "lists-006-1005528"}, {"subject": "I-D ACTION:draft-ietf-deltav-versioning-16.tx", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Web Versioning and Configuration Management Working Group of the IETF.\n\nTitle: Versioning Extensions to WebDAV\nAuthor(s): G. Clemm, J. Amsden, T. Ellison, C. Kaler,\n                          J. Whitehead\nFilename: draft-ietf-deltav-versioning-16.txt\nPages: 104\nDate: 05-Jul-01\n\nThis document specifies a set of methods, headers, and resource types \nthat define the WebDAV Versioning extensions to the HTTP/1.1 protocol. \nWebDAV Versioning will minimize the complexity of clients that are\ncapable of interoperating with a variety of versioning repository\nmanagers, to facilitate widespread deployment of applications capable of\nutilizing the WebDAV Versioning services.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-16.txt\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-deltav-versioning-16.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-deltav-versioning-16.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n\n\n\nMessage/External-body attachment: stored\n\n\n\n\n", "id": "lists-006-10060820"}, {"subject": "A Tidied draft-1", "content": "Hi!\n\nI ran HTML Tidy <http://www.w3.org/People/Raggett/tidy/> on draft-16\nof DeltaV, and the results were 277kB rather than 1.4MB, and looked a\nlot better in Opera than the original.\n\nIf you want it, you can pick it up from\n<http://www3.metis.no/private/sb/misc/draft-ietf-deltav-versioning-16.htm>\n\nI generated the above link, using tidy.exe (at the top of the download\nlist in the Tidy homepage), with the parameters:\ntidy --word-2000 yes -m draft-ietf-deltav-versioning-16.htm\n\nI'm sure there are more parameters that could be tinkered with, but\nthe above works for me.\n\n\n\n", "id": "lists-006-10069756"}, {"subject": "Re: A Tidied draft-1", "content": "Steinar,\n\nAs you are probably aware the ASCII renditioning is the official format,\nHTML and Word format are provided as a convenience for those who prefer it.\n\nRegards,\nTim\n\np.s.  When I looked at the link you gave (in IE) the document included\ndamaged ascii-art pictures and double-spaced request and response messages.\n:-(\n\nSteinar Bang <sb@metis.no> wote:\n> I ran HTML Tidy <http://www.w3.org/People/Raggett/tidy/>\n> on draft-16 of DeltaV, and the results were 277kB rather\n> than 1.4MB, and looked a lot better in Opera than the original.\n>\n> If you want it, you can pick it up from\n>    <\nhttp://www3.metis.no/private/sb/misc/draft-ietf-deltav-versioning-16.htm>\n>\n> I generated the above link, using tidy.exe (at the top\n> of the download list in the Tidy homepage), with the\n> parameters:\n>    tidy --word-2000 yes -m draft-ietf-deltav-versioning-16.htm\n>\n> I'm sure there are more parameters that could be tinkered with,\n> but the above works for me.\n\n\n\n", "id": "lists-006-10077040"}, {"subject": "Revision 16 of the DeltaV spec is all advanced :-", "content": "Hi,\n\nI don't know if anyone else has already noticed, but in revision 16 of the\ndeltav document we \nhave lost a crucial '1' from the last paragraph of the introduction (section\n1).\n\nIn revision 16 it now reads:\n\n\"An implementer that is only interested in basic versioning should \n skip the advanced versioning sections (Section 0 to Section 15).\"\n\nI think it should be 10 to 15.\n\nMaybe this was intentional, perhaps the whole spec is advanced :-)\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (ADM)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-10085599"}, {"subject": "Re: Revision 16 of the DeltaV spec is all advanced :-", "content": "I agree :-)\n\nRegards,\nTim\n\nPeter Raymond <Peter.Raymond@merant.com> wrote:\n> Hi,\n>\n> I don't know if anyone else has already noticed, but in revision 16 of\nthe\n> deltav document we\n> have lost a crucial '1' from the last paragraph of the introduction\n(section\n> 1).\n>\n> In revision 16 it now reads:\n>\n> \"An implementer that is only interested in basic versioning should\n>  skip the advanced versioning sections (Section 0 to Section 15).\"\n>\n> I think it should be 10 to 15.\n>\n> Maybe this was intentional, perhaps the whole spec is advanced :-)\n\n\n\n", "id": "lists-006-10094054"}, {"subject": "Re: A Tidied draft-1", "content": ">>>>> \"Tim Ellison\" <Tim_Ellison@uk.ibm.com>:\n\n> As you are probably aware the ASCII renditioning is the official\n> format,\n\nYes.\n\n> HTML and Word format are provided as a convenience for those who\n> prefer it.\n\nWell, actually, on\n<http://www.webdav.org/deltav/>\nonly links to HTML and Word versions of the draft are provided.\n\nI looked for a link to a text version of draft-16, but couldn't find\nany.  Do you know where/if it can be found?\n\n> p.s.  When I looked at the link you gave (in IE) the document\n> included damaged ascii-art pictures and double-spaced request and\n> response messages.\n> :-(\n\nHm... that's too bad.  I wonder if that's fixable with a suitable tidy\nparameter?  Hm... the ASCII art in\n  <http://www.webdav.org/deltav/protocol/draft-ietf-deltav-versioning-16.htm>\nis broken in Opera, but shows up correctly in Netscape 4.72 on linux\n(which is actually pretty unusual...:-) )\nI'll try later, and publish the results.\n\n\n\n", "id": "lists-006-10102408"}, {"subject": "RE: A Tidied draft-1", "content": "I think it would make sense to use the RFC XML format instead :-)\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Steinar Bang\n> Sent: Monday, July 09, 2001 11:32 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: A Tidied draft-16\n> \n> \n> >>>>> \"Tim Ellison\" <Tim_Ellison@uk.ibm.com>:\n> \n> > As you are probably aware the ASCII renditioning is the official\n> > format,\n> \n> Yes.\n> \n> > HTML and Word format are provided as a convenience for those who\n> > prefer it.\n> \n> Well, actually, on\n> <http://www.webdav.org/deltav/>\n> only links to HTML and Word versions of the draft are provided.\n> \n> I looked for a link to a text version of draft-16, but couldn't find\n> any.  Do you know where/if it can be found?\n> \n> > p.s.  When I looked at the link you gave (in IE) the document\n> > included damaged ascii-art pictures and double-spaced request and\n> > response messages.\n> > :-(\n> \n> Hm... that's too bad.  I wonder if that's fixable with a suitable tidy\n> parameter?  Hm... the ASCII art in\n>   \n> <http://www.webdav.org/deltav/protocol/draft-ietf-deltav-versionin\n> g-16.htm>\n> is broken in Opera, but shows up correctly in Netscape 4.72 on linux\n> (which is actually pretty unusual...:-) )\n> I'll try later, and publish the results.\n> \n> \n> \n\n\n\n", "id": "lists-006-10110796"}, {"subject": "Missing reference in section 8..", "content": "Hi,\n\nAs you can probably tell I am having a detailed read of version 16 of the\nspecification\nthis morning.\n\nI just noticed that in Section 8 (Labels) we are missing a reference.\nThe text in version 16 of the specification reads:\n\n\"For certain methods, if the request-URL identifies a version-controlled\nresource, \na label can be specified in a Label request header (see Section Error!\nReference \nsource not found.)\"\n\nI think it should be referencing section 8.3.\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (ADM)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-10120725"}, {"subject": "Expiration date on draft 16", "content": "This is probably just a nitpick, but the ASCII version of the current\ndraft at ietf.org has an expiration date of January 3, 2001, even\nthough it wasn't written until July 3 2001.\n\n-Mark\n\n\n\n", "id": "lists-006-10128578"}, {"subject": "Re: Expiration date on draft 16", "content": "Thanks Mark, that should be \"January 3, 2002\".\n\nGeoff's mail auto responder tells me that he is on vacation this week (and\nhe took the editor's token with him<g>); so keep these corrections coming\nand expect to see a refresh draft sometime shortly after his return.\n\nRegards,\nTim\n\n\"Mark C. Chu-Carroll\" <mcc@watson.ibm.com> wrote:\n> This is probably just a nitpick, but the ASCII version\n> of the current draft at ietf.org has an expiration date\n> of January 3, 2001, even though it wasn't written until\n> July 3 2001.\n\n\n\n", "id": "lists-006-10135664"}, {"subject": "The definition of a &quot;Baseline-Controlled Collection&quot", "content": "Hi,\n\nSection 10.2 of the specification defines a \"Baseline-Controlled Collection\"\nas follows:\n\nA \"baseline-controlled collection\" is a collection from which baselines can\nbe created.\n\nBut section 12 says:\n\nA collection that is under baseline control is called a \"baseline-controlled\ncollection\".\n\nThey can't both be right, is a BCC a resource from which a Baseline CAN be\ncreated\nor is it a resource from which a Baseline HAS BEEN created?\n\nThe definition in Section 10.2 seems wrong, I don't think you create a\nBaseline from a\ncollection, you create it by checking-in a version-controlled configuration,\nwhich\nitself was created by placing a collection under BASELINE-CONTROL.\n\nInfact, am I right in thinking that a \"Baseline-Controlled Collection\" is\nsimply a\ncollection which has a DAV:version-controlled-configuration property?\n\nI am trying to get my head around what steps are needed to create a new\nBaseline, \npopulated with the contents of a collection, for example:\n\nThere is a Version-Controlled Collection /build/src/\n\nMy client issues a BASELINE-CONTROL on that Version-Controlled Collection\nAt this point a new \"Version-Controlled Configuration\" is created\nThe original collection gets a DAV:version-controlled-configuration\nproperty set to the newly created resource\nThe Version-Controlled Configuration gets a\nDAV:baseline-controlled-collection property set to the original collection\nA new Baseline History resource is created\nA new Baseline version is created (the \"root baseline\")\nThe DAV:checked-in property of the Version-Controlled Configuration\nis set to the \"root baseline\"\n            A new collection with no members is created\nThe \"root baseline\" has a DAV:baseline-collection pointing to the\nabove empty collection\n\nSo at this point I have a \"empty\" baseline, how do I populate it with the\nchecked-in versions of resources\nfrom the original collection?\n\nI guess I check-out the version-controlled configuration that was created by\nthe BASELINE-CONTROL and \njust check it in again???\n\nThis is not clear in section 12, perhaps an example or diagram of creating a\nnew baseline might help in this \nsection....something like this:\n\n               +-----------+ \n               |Version    |\n  +------------|Controlled |<--+\n  |            |Collection |   |\n  |            +-----------+   |\n  |                            |DAV:b-c-collection\n  |DAV:v-c-configuration       | \n  |                            |\n  |  +-------------+           |\n  +->|Version      |-----------+\n     |Controlled   |  \n     |Configuration|--+\n     +-------------+  |\n                      |\n       DAV:checked-in |  +---------+\n                      |  |Baseline |\n                      |  |History  |\n                      |  |         |\n                      |  | +---+   |                   +-------------+\n                      +--->|V1 |   | DAV:b-collection  |Collection   |\n                         | |   |---------------------->|with bindings|\n                         | +---+   |                   |to resources |\n                         +---------+                   |from the     |\n                                                       |original     |\n                                                       |collection.  |\n                                                       +-------------+\n       \nAm I on the right track?\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (ADM)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-10143676"}, {"subject": "Postconditions with no XML elements defined", "content": "Hi,\n\nIn section 1.6 of the specification it states:\n\nIn order to allow better client handling of 403 and 409 responses, a\ndistinct XML element \ntype is associated with each method precondition and postcondition of a\nrequest.\n\nBut several Postconditions in the specification do not have any XML elements\ndefined.\n\nSection 8.5, 8.6, 8.7, 8.8, and 9.6 for example.  Do we need to change 1.6\nto say that some\npreconditions and postconditions have distinct XML elements?\n\nAlso regarding the 403/409 responses it was not clear from the spec when to\nsend 403\nand when to send 409.  The text in section 1.6 reads:\n\nIf a method precondition for a request is not satisfied, or if a method\npostcondition for a \nrequest cannot be achieved, the response status of the request MUST be 403\n(Forbidden) \nor 409 (Conflict).\n\nDoes this mean a 403 should be sent for a failed precondition and a 409\nshould be sent\nfor a postcondition failure.  Or does it mean the server implementer can\nreturn either code\nin either situation.  This is not clear from reading the spec.\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (ADM)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-10155872"}, {"subject": "RE: Postconditions with no XML elements defined", "content": "Postconditions with no XML elements defined?I had interpreted it as being\n403 with precondition, 409 with postcondition, like you, but I agree it's\nnot directly stated.\n\nCan the spec clarify please?\n\nlisa\n  -----Original Message-----\n  From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Peter Raymond\n  Sent: Monday, July 09, 2001 8:39 AM\n  To: ietf-dav-versioning@w3.org\n  Subject: Postconditions with no XML elements defined?\n\n\n  Hi,\n\n  In section 1.6 of the specification it states:\n\n  In order to allow better client handling of 403 and 409 responses, a\ndistinct XML element\n  type is associated with each method precondition and postcondition of a\nrequest.\n\n  But several Postconditions in the specification do not have any XML\nelements defined.\n\n  Section 8.5, 8.6, 8.7, 8.8, and 9.6 for example.  Do we need to change 1.6\nto say that some\n  preconditions and postconditions have distinct XML elements?\n\n  Also regarding the 403/409 responses it was not clear from the spec when\nto send 403\n  and when to send 409.  The text in section 1.6 reads:\n\n  If a method precondition for a request is not satisfied, or if a method\npostcondition for a\n  request cannot be achieved, the response status of the request MUST be 403\n(Forbidden)\n  or 409 (Conflict).\n\n  Does this mean a 403 should be sent for a failed precondition and a 409\nshould be sent\n  for a postcondition failure.  Or does it mean the server implementer can\nreturn either code\n  in either situation.  This is not clear from reading the spec.\n\n  Regards,\n  --\n  Peter Raymond - MERANT\n  Technical Architect (ADM)\n  Tel: +44 (0)1727 813362\n  Fax: +44 (0)1727 869804\n  mailto:Peter.Raymond@merant.com\n  WWW: http://www.merant.com\n\n\n\n", "id": "lists-006-10166059"}, {"subject": "RE: Deleting version", "content": "I agree that if a client is likely to get disconnected\nin the middle of its MKWORKSPACE/LOCK request sequence, and if a server\nlets you change the ACL's on a workspace but does not let\nyou create a workspace, and if a workspace can have its ACL's\nupdated by anyone other than the owner, then there is a use\ncase for issuing a MKWORKSPACE against a lock null resource.\n\nBut as you said earlier, RFC 2518 only constrains what HTTP\nand DAV methods can be applied to a lock null resource,\nso a compliant DelataV server can support this use case if it wishes.\nWe can't say it MUST support this use case, since a DeltaV\nserver is not required to support lock null resources at all.\n\nCheers,\nGeoff \n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Tuesday, June 05, 2001 7:43 PM\nTo: Clemm, Geoff; DeltaV\nSubject: RE: Deleting versions\n\n\nThe problem is that the \"client that got there before them\" may have\npermission to alter a workspace, but they may NOT have permission to CREATE\na workspace.\n\nThe problem is not that the other client locked it, but that they might\napply changes before you get a chance to prevent them!  I create a Workspace\n(or a resource, or a collection).  I want to then set the ACLs so that I'm\nthe only one that can alter this resource, because it's MINE.  But, in\nbetween the MKWORKSPACE and the subsequent LOCK, the other client comes in\nand sets ACLs so that they can write the workspace and I can't!  Ouch.\n\nNull resource went through similar discussions, and was kept for reasons\nwhich apply to MKWORKSPACE the same way they apply to PUT, MKCOL.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Tuesday, June 05, 2001 3:48 PM\n> To: DeltaV\n> Subject: RE: Deleting versions\n>\n>\n>    From: Lisa Dusseault [mailto:lisa@xythos.com]\n>\n>    If somebody who's not supposed to, gets in and changes something in\n>    between a MKWORKSPACE command and a ACL request, that's a serious\n>    problem.  Null resources help avoid that.\n>\n>    It's not that somebody got their MKWORKSPACE request in ahead of\n>    mine --that's not the purpose of null resources at all.\n>\n> My point was not that a lock can prevent somebody from\n> creating the workspace ahead of you, but rather that\n> someone locking \"your\" workspace is no different from\n> someone creating a workspace by that name before you\n> can lock that URL.\n>\n> In particular, we are discussing two alternative sequences:\n>  LOCK/MKWORKSPACE/ACL/UNLOCK\n> or\n>  MKWORKSPACE/LOCK/ACL/UNLOCK\n>\n> In the first sequence, the LOCK may fail (because there already\n> is a lock on that URL), so you tell the user \"that workspace is\n> already in use by another user\".\n>\n> In the second sequence, either the MKWORKSPACE may fail (because\n> somebody got in and created a workspace before you) or the LOCK\n> may fail (because somebody got in and locked the workspace before\n> you).  In either case, you still tell the user \"that workspace is\n> already in use by another user\".\n>\n> So from the user's perspective, it doesn't matter whether\n> or not their client did a LOCK/MKWORKSPACE or a\n> MKWORKSPACE/LOCK.  Their request can fail because another\n> client \"got there before them\".\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-1016812"}, {"subject": "Re: A Tidied draft-1", "content": ">>>>> Steinar Bang <sb@metis.no>:\n\n>>>>> \"Tim Ellison\" <Tim_Ellison@uk.ibm.com>:\n>> As you are probably aware the ASCII renditioning is the official\n>> format,\n\n> Yes.\n\n>> HTML and Word format are provided as a convenience for those who\n>> prefer it.\n\n> Well, actually, on\n> <http://www.webdav.org/deltav/>\n> only links to HTML and Word versions of the draft are provided.\n\n> I looked for a link to a text version of draft-16, but couldn't find\n> any.  Do you know where/if it can be found?\n\nHere it is:\n  <http://search.ietf.org/internet-drafts/draft-ietf-deltav-versioning-16.txt>\n\nI think it would be a good thing to have a link to the above URL on\n <http://www.webdav.org/deltav/>\n\nIt confused me that it wasn't there.\n\n\n\n", "id": "lists-006-10176383"}, {"subject": "Finding the version of a resource in a Version-Controlled-Collect ion..", "content": "Hi,\n\nDespite some excellent e-mail threads recently regarding\nVersion-Controlled-Collections\nI am still not clear how to find the specific version of a resource which is\nreferenced\nby a version of a collection resource.\n\nSection 14 goes to great lengths to explain why we chose to have the\nbinding-set\nof a version of a collection point to a VHR not a version of a resource and\nthis is fine,\nit makes sense.  But what is still not clear (at least to me) is how having\nfound the\nbinding (URL segment bound to a VHR) do I find the DAV:checked-in version of\nthe resource identified by the VHR.\n\nSo I can do a PROPFIND with a Depth=0 for the\nDAV:version-controlled-binding-set\nof a version of a collection.  This gives me the binding names and\nreferences to\nVersion History Resources.  Now how do I find the DAV:checked-in version?\n\nThis is something a client may do quite often, eg display directory\nstructure (of a \nworkspace) and when a directory is selected display versions of files\ncontained \nwithin the directory.\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (ADM)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-10184308"}, {"subject": "Label behaviour..", "content": "Hi,\n\nI have a couple of questions about Labels.\n\n1)  What's the difference between DAV:add and DAV:set of a label?\n\n     Section 8 of the spec does not spell this out.  My best guess is that\n     DAV:add will fail with a DAV:must-be-new-label if the label is already\n     used by any version of the resource, but DAV:set will remove any\nexisting\n     use of that label and then set the label on the specified version, but\nI don't\n     see this documented in the spec.\n     \n2) How does a client get a list of labels to present the user with a choice?\n\n    The only way I can see is to request the DAV:label-name-set property of\nevery\n    version resource.  Wouldn't it be useful to have a report which listed\nthe labels\n    that are in use?\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (ADM)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-10193961"}, {"subject": "Should it be DAV:must-not-be-checked-out or DAV:must-be-checked-i n", "content": "Hi,\n\nIn section 1.6.1 we have an example of a CHECKOUT method which fails with a\nDAV:must-not-be-checked-out\nand returning a 409 Conflict.\n\nI cannot actually see in the spec where the Precondition\nDAV:must-not-be-checked-out for the CHECKOUT \nmethod is defined?\n\nCHECKOUT has a DAV:must-be-checked-in Precondition NOT a\nDAV:must-not-be-checked-out\nPrecondition.  So is the example wrong or should the condition for CHECKOUT\nbe changed.\n\nI also note that DAV:must-not-be-checked-out is used as a precondition for\nthe LABEL method.\nPerhaps they should be consistent and both use DAV:must-not-be-checked-out?\n \nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (ADM)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-10202934"}, {"subject": "Re: Should it be DAV:must-not-be-checked-out or DAV:must-be-checked-i n", "content": "Looks like they all should be DAV:must-be-checked-in (to avoid the \nnegative).\n\n\n\n\n\nPeter Raymond <Peter.Raymond@merant.com>\nSent by: ietf-dav-versioning-request@w3.org\n07/10/2001 08:44 AM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        Should it be DAV:must-not-be-checked-out or DAV:must-be-checked-i       n?\n\n \n\nHi, \nIn section 1.6.1 we have an example of a CHECKOUT method which fails with \na DAV:must-not-be-checked-out \nand returning a 409 Conflict. \nI cannot actually see in the spec where the Precondition \nDAV:must-not-be-checked-out for the CHECKOUT \nmethod is defined? \nCHECKOUT has a DAV:must-be-checked-in Precondition NOT a \nDAV:must-not-be-checked-out \nPrecondition.  So is the example wrong or should the condition for \nCHECKOUT be changed. \nI also note that DAV:must-not-be-checked-out is used as a precondition for \nthe LABEL method. \nPerhaps they should be consistent and both use \nDAV:must-not-be-checked-out? \n  \nRegards, \n-- \nPeter Raymond - MERANT \nTechnical Architect (ADM) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n\n\n\n", "id": "lists-006-10211811"}, {"subject": "Re: Label behaviour..", "content": "Your are correct on the distinction between adding and setting a label. \nIts there to avoid inadvertant reuse of a label. See the precondition for \nDAV:must-be-new-label. This indicates that for DAV:add, the label MUST NOT \ncurrently select a version. The postconditions for add and set are the \nsame.\n\nI don't know what you mean by \"the labels that are in use\". Do you mean \nthe intersection of all labels on all resources? If so, why would you need \nthis? To see if a label is already used? This might be useful information, \nbut just because a label is used in one version history doesn't prevent it \nfrom being used in another. You can find out if a label is used by using \nDAV:add. It will fail if a version in that version history already has \nthat label. There's really no need to get the labels first.\n\n\n\n\n\n\nPeter Raymond <Peter.Raymond@merant.com>\nSent by: ietf-dav-versioning-request@w3.org\n07/10/2001 06:00 AM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        Label behaviour...\n\n \n\nHi, \nI have a couple of questions about Labels. \n1)  What's the difference between DAV:add and DAV:set of a label? \n     Section 8 of the spec does not spell this out.  My best guess is that \n     DAV:add will fail with a DAV:must-be-new-label if the label is \nalready \n     used by any version of the resource, but DAV:set will remove any \nexisting \n     use of that label and then set the label on the specified version, \nbut I don't \n     see this documented in the spec. \n \n2) How does a client get a list of labels to present the user with a \nchoice? \n    The only way I can see is to request the DAV:label-name-set property \nof every \n    version resource.  Wouldn't it be useful to have a report which listed \nthe labels \n    that are in use? \nRegards, \n-- \nPeter Raymond - MERANT \nTechnical Architect (ADM) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n\n\n\n", "id": "lists-006-10222623"}, {"subject": "RE: Label behaviour..", "content": "Jim says:\n\n>Your are correct on the distinction between adding and setting a label. \n>Its there to avoid inadvertant reuse of a label. See the precondition for \n>DAV:must-be-new-label. This indicates that for DAV:add, the label MUST NOT \n>currently select a version. The postconditions for add and set are the \n>same.\n\nOK, I am happy that it is clear how DAV:add should behave, but I think the\nspec needs more detail on how DAV:set behaves, does it:\n\na) \"move\" the label, eg if it is already used by another version of the\nresource \n   it will be removed from that version and added to the version indicated\nby the \n   LABEL request.\n\nor\n\nb) Allow the same label on multiple versions of the same resource? \n\nJim says:\n\n>I don't know what you mean by \"the labels that are in use\". Do you mean \n>the intersection of all labels on all resources? If so, why would you need \n>this?\n\nI want a pulldown list of currently in use (intersection of all labels on\nall resources) so the user can pick a label.  Obviously the user needs the\nability to enter one that does not already exist but seeing the list of\nexisting ones will help in several use-case scenarios, eg:\n\nImagine user Fred goes to his WebDAV client to do some work on a set of\nsource code, his colleague has told him by word of mouth etc that he should \nuse a label called \"Special Label 1\".  When he uses the WebDAV client he \ncould put in any old label, eg \"Special-Label-1\" or \"SpecialLabel1\" etc, he \ncould enter a different label from the one all the other developers have\nbeen \nusing.\n\nAnother scenario is that you want to create a new label with a similar\nnaming\nscheme from other labels already in the system, for example a project is\nunder\nQA testing and all the versions of source under test have been marked with a\nlabel called \"System Test Build 1\".  Now a user wants to mark code using a\nlabel\nto indicate versions of code for use in the next system test.  Without being\nable to see that the label \"System Test Build 1\" was used previously the\nuser\nmight choose to call this new label \"QA Build 2\".\n\nI guess what I am getting at is that by providing a list of labels already\nin use you can cut down on mistakes and the proliferation of similar label\nnames.\n\nWhat do other people think, any client writers out there that want to\nprovide\na list of existing labels?\n\nRegards,\n-- \nPeter Raymond - MERANT \nTechnical Architect (ADM) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n\n\n\n", "id": "lists-006-10232574"}, {"subject": "Re: The definition of a &quot;Baseline-Controlled Collection&quot", "content": "Here my understanding of this stuff:\nA configuration is a set of resources located at a root collection.\nA baseline is a version of a configuration.\n\nPeter Raymond <Peter.Raymond@merant.com> wrote:  \n> Section 10.2 of the specification defines a \"Baseline-Controlled Collection\"\n> as follows:\n> A \"baseline-controlled collection\" is a collection from which baselines can be created.\nA \"baseline-controlled collection\" is a collection which is a container for a configuration\nand therefore you can create baselines (configuration versions) IN it.\nThe statement in the draft isn't that clear I guess.\n\n> But section 12 says:\n> A collection that is under baseline control is called a \"baseline-controlled\n> collection\".\nDoesn't give that much information I think. Just defining a synonym.\n\n> There is a Version-Controlled Collection /build/src/\nYou can also start without a Version-Controlled Collection. Baseline-Controlled\nCollections also work without Version-Controlled Collections.\n\n> Infact, am I right in thinking that a \"Baseline-Controlled Collection\" is simply a\n> collection which has a DAV:version-controlled-configuration property?\nAnd probably the additional condition that the version-controlled-configuration's\nDAV:baseline-controlled-collection is just this collection itself like you show in\nyou ASCII art. There I would propose to change the caption of your first box to\n'Baseline Controlled Collection'. But I can see why you choose the name.\n\n> So at this point I have a \"empty\" baseline, how do I populate it with the\n> checked-in versions of resources from the original collection?\n> I guess I check-out the version-controlled configuration that was created by\n> the BASELINE-CONTROL and just check it in again ???\nJust do it like that. OTOH I think it would be intuitive to say that if there are\nalready checked-in version-controlled resources in a collection you put under\nbaseline control just take these for the initial version.\n\n[ ASCII art]\n\n> Am I on the right track?\nIMHO, yes.\n\nAnother thing I just noticed: A BASELINE-CONTROL precondition is\nDAV:must-have-no-version-controlled-members. The description then states that the\nrequest URL 'MUST have no members'. Wanted restriction or should it read\n'MUST have no version controlled members' ?\n\nCheers, Edgar\n\n\n\n\n\n\n\n\n\n\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-10242425"}, {"subject": "RE: Label behaviour..", "content": "Peter,\nWe'd be happy to include some clarification on DAV:set vs. DAV:add. \n\n\n\n\n\nPeter Raymond <Peter.Raymond@merant.com>\n07/10/2001 01:58 PM\n\n \n        To:     Jim Amsden <jamsden@us.ibm.com>\n        cc: \n        Subject:        RE: Label behaviour...\n\n \n\nHi, \nJim says: \n>The spec says that a label can only be on one version of a given version \n>history resource at a time, so DAV:set has to move the version. \nYes, I agree this is the right behaviour for the DAV:set operation, but \nI think the specification should call this out instead of inferring it \nfrom the pre and post conditions, otherwise you risk server implementers \nincorrectly implementing this and allowing multiple versions to have the \nsame label. \nJim says: \n>Querying a repository for all labels currently in use may be 1) quite \n>expensive for some servers, and 2) provide too much information for most \n>practical uses, including the scenarios you describe below. \nGood point, I suppose you could end up with too much information. \nBut then perhaps you would then want the client to have a UI facility to \n\"find\" or \"filter\" labels, eg instead of a simple drop down list you could \n\nhave a little dialogue where you can search to find labels (eg all labels \nthat start with QA). \nJim says: \n> Since reusing labels imples there's some relationship between the \nresources \n> versions (all the ones having the same label), it would be better for \nclients \n> to take advantage of these relationships to put up a more reasonable, \nand \n> smaller set of candidate version labels. For example, display the \n> DAV:label-name-set on a collection representing a 'project' or some \nother \n> prominent resource in a set of related resources. \nYes, I suppose we could maintain a set of the labels in this fashion. \nIt's just that I have worked with clients that just provide a simple \ntext entry field for label names and I have found that the label \nnames get in a mess with a proliferation of similarly named labels. \nThis issue isn't a \"killer\" for me, I can live with DeltaV the way it is \n(using your above workaround).  However, I do think we should define the \nbehaviour of DAV:set for the LABEL method more clearly, I asked several \nother developers in our office (who have also read the spec) and they were \n\nall confused as to the difference between DAV:add and DAV:set. \nThanks for the response. \nRegards, \nPeter. \n\nPeter Raymond <Peter.Raymond@merant.com> \nSent by: ietf-dav-versioning-request@w3.org \n07/10/2001 11:36 AM \n  \n        To:     ietf-dav-versioning@w3.org \n        cc: \n        Subject:        RE: Label behaviour... \n  \nJim says: \n>Your are correct on the distinction between adding and setting a label. \n>Its there to avoid inadvertant reuse of a label. See the precondition for \n\n>DAV:must-be-new-label. This indicates that for DAV:add, the label MUST \nNOT \n>currently select a version. The postconditions for add and set are the \n>same. \nOK, I am happy that it is clear how DAV:add should behave, but I think the \n\nspec needs more detail on how DAV:set behaves, does it: \na) \"move\" the label, eg if it is already used by another version of the \nresource \n   it will be removed from that version and added to the version indicated \n\nby the \n   LABEL request. \nor \nb) Allow the same label on multiple versions of the same resource? \nJim says: \n>I don't know what you mean by \"the labels that are in use\". Do you mean \n>the intersection of all labels on all resources? If so, why would you \nneed \n>this? \nI want a pulldown list of currently in use (intersection of all labels on \nall resources) so the user can pick a label.  Obviously the user needs the \n\nability to enter one that does not already exist but seeing the list of \nexisting ones will help in several use-case scenarios, eg: \nImagine user Fred goes to his WebDAV client to do some work on a set of \nsource code, his colleague has told him by word of mouth etc that he \nshould \nuse a label called \"Special Label 1\".  When he uses the WebDAV client he \ncould put in any old label, eg \"Special-Label-1\" or \"SpecialLabel1\" etc, \nhe \ncould enter a different label from the one all the other developers have \nbeen \nusing. \nAnother scenario is that you want to create a new label with a similar \nnaming \nscheme from other labels already in the system, for example a project is \nunder \nQA testing and all the versions of source under test have been marked with \n\na \nlabel called \"System Test Build 1\".  Now a user wants to mark code using a \n\nlabel \nto indicate versions of code for use in the next system test.  Without \nbeing \nable to see that the label \"System Test Build 1\" was used previously the \nuser \nmight choose to call this new label \"QA Build 2\". \nI guess what I am getting at is that by providing a list of labels already \n\nin use you can cut down on mistakes and the proliferation of similar label \n\nnames. \nWhat do other people think, any client writers out there that want to \nprovide \na list of existing labels? \nRegards, \n-- \nPeter Raymond - MERANT \nTechnical Architect (ADM) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n\n\n\n", "id": "lists-006-10252837"}, {"subject": "Re: Finding the version of a resource in a Version-Controlled-Collect ion..", "content": "On Tue, Jul 10, 2001 at 10:28:50AM +0100, Peter Raymond wrote:\n> Despite some excellent e-mail threads recently regarding\n> Version-Controlled-Collections\n> I am still not clear how to find the specific version of a resource which is\n> referenced by a version of a collection resource.\n\nI think the answer is you don't. A collection does not identify exact\nversions of resources that are referenced. If it did, then every time\na member of the collection was versioned, the collection itself would\nhave to be versioned. Versioning the collection would in turn cause\nits parent collection to be versioned, and so on up the tree. This is\nnot really acceptable, so collection histories do not identify specific\nversions, only a version history.\n\nThis felt weird to me at first, but it made sense eventually. I like\nrelating things back to CVS (because I use it a lot). In CVS, each\nfile has its own version history with version numbering. Not all files\nin a directory have the same version numbers. So when you do a cvs update\nor cvs checkout, you are actually asking each file individually for\n'the latest version' or 'a version with this label'. You do not use\nCVS to say 'get me version 1.2 of every file in a directory' because\nthe files have individual version numbering.\n\nThe same is true for collections. To do a VERSION-CONTROL in DeltaV,\nfor every single resource you get a version-controlled resource for,\nits up to you to select the particular version you want.\n\nCollections are a bit weird in that asking for the collection actually\ngives you a tree of all the member resources (including nested\ncollections etc.). The standard says however that in this case you\nalways get the root version in the history (unless its already in the\nworkspace in which case it binds to the existing VCR in that workspace).\nIts up to the client to then say \"no, I don't want the root version\nfor this resource, I want version X\" where its up to the client to\nwork out what version X is.\n\nAt least that is my current understanding. Please not however that\nI have not read up properly on activies and baselines yet, so the\nabove may be different when using those concepts. But I beleive the\nabove is correct with respect to the fundamentals of the DeltaV\nversioning.\n\nHope this helps (and is correct! :-)\n\nAlan\n\n\n\n", "id": "lists-006-10266758"}, {"subject": "Re: Finding the version of a resource in a Version-Controlled-Collect ion..", "content": "Alan Kent <ajk@mds.rmit.edu.au> wrote:\n\n> On Tue, Jul 10, 2001 at 10:28:50AM +0100, Peter Raymond wrote:\n> > Despite some excellent e-mail threads recently regarding\n> > Version-Controlled-Collections\n> > I am still not clear how to find the specific version of a\n> > resource which is referenced by a version of a collection resource.\n>\n> I think the answer is you don't. A collection does not identify exact\n> versions of resources that are referenced. If it did, then every time\n> a member of the collection was versioned, the collection itself would\n> have to be versioned. Versioning the collection would in turn cause\n> its parent collection to be versioned, and so on up the tree. This is\n> not really acceptable, so collection histories do not identify specific\n> versions, only a version history.\n\nI agree.\n\n> This felt weird to me at first, but it made sense eventually. I like\n> relating things back to CVS (because I use it a lot). In CVS, each\n> file has its own version history with version numbering. Not all files\n> in a directory have the same version numbers. So when you do a cvs update\n> or cvs checkout, you are actually asking each file individually for\n> 'the latest version' or 'a version with this label'. You do not use\n> CVS to say 'get me version 1.2 of every file in a directory' because\n> the files have individual version numbering.\n\nCVS doesn't have a baseline resource, rather it lays down a consistent\nlabel to identify a configuration of resources.  This is also possible in\nDeltaV, however, the label may be moved to a different version.  A\n'baseline' resource is an immutable version of a configuration.\n\n> The same is true for collections. To do a VERSION-CONTROL in DeltaV,\n> for every single resource you get a version-controlled resource for,\n> its up to you to select the particular version you want.\n\nNot quite sure what you meant here, but it is true that you can create new\nversion-controlled resources using VERSION-CONTROL with a DAV:version\nelement body to 'initialize' the version-controlled resource with a\nparticular DAV:checked-in version.\n\n> Collections are a bit weird in that asking for the collection actually\n> gives you a tree of all the member resources (including nested\n> collections etc.).\n\nAgain I'm not sure what you mean by \"ask for\" a collection?\nWhen you create a new version-controlled collection that is 'initialized'\nfrom an existing collection version, the members of the version-controlled\ncollection will be bound to undefined versions of the version-histories (of\neach member of the collection version).\n\nThat's a bit of a mouthful, so let me try that another way:\nGiven a collection version http://.../vr1 with a binding, say \"bar\", to the\nversion history http://.../his1.\nIf you create a new version-controlled collection and specify\nhttp://.../vr1 as the DAV:version in the body:\n    VERSION-CONTROL /foo HTTP/1.1\n    ...\n    <DAV:version>http://.../vr1</DAV:version>\n    ...\nThen you will have a new version-controlled collection called /foo that has\na member /foo/bar that refers to an undefined version of http://.../his1\n\n> The standard says however that in this case you\n> always get the root version in the history (unless its already in the\n> workspace in which case it binds to the existing VCR in that workspace).\n> Its up to the client to then say \"no, I don't want the root version\n> for this resource, I want version X\" where its up to the client to\n> work out what version X is.\n\nIt was discussed that the member should be bound to the DAV:root-version\nbut counter-argued that the root version is unlikely to be the required\nversion, and since we can't choose the best version it is probably better\nto leave it undefined (Alan's point about workspaces notwithstanding).\nClients are likely to fix-up the bindings created this way.\n\n> At least that is my current understanding. Please not however that\n> I have not read up properly on activies and baselines yet, so the\n> above may be different when using those concepts. But I beleive the\n> above is correct with respect to the fundamentals of the DeltaV\n> versioning.\n\nBaselines are much more useful since they capture the deep state of a\ncollection (a.k.a. configuration).\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10276605"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and  DAV:ba seline resource type value", "content": "   From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n\n   Geoff: hey, you've been rumbled! From your ACL list posting:\n       \"For DAV:resourcetype in the versioning protocol, I\n       really don't care much what we do with DAV:resourcetype\n       there either, but figured we might as well argue about\n       something in the versioning list while we're waiting\n       for the area directors to review the versioning protocol.\"\n\n   Which is it? You want to \"develop some guiding principle\" for future\n   generations, or \"don't much care ... but figured we might as well argue\n   about something\"<g>\n   (You don't have to answer that question:-)\n\nNot answer a question?  How would I be able to sleep at night if\nI started not answering questions? (:-)\n\nThe reason I \"don't care much\" is that it is trivial for us\nto implement additional DAV:resourcetype values in our DeltaV server,\nand we just won't use them in our DeltaV clients (we'll use\nDAV:supported-property-set and DAV:supported-method-set,\nas any sensible client implementor should :-).\n\nBut I do care in general that DeltaV (and in general WebDAV)\nprotocols be designed to encourage good client design, and\nit seems to me that there is a basic lesson from programming\nlanguage design (i.e. that typeless languages are more suited\nto environments where clients and servers get changed)\nthat is being ignored in this drive to extend DAV:resourcetype.\n\nSo the part of me is responsible for earning a salary doesn't care,\nbut the part of me that wants the world to be a better place cares\ndeeply (:-).\n\nUnfortunately (or fortunately :-), the part of me responsible for\nearning a salary is going to have to take precedence for a while,\nso my last generic word on this thread is:\n\nI suggest that no DAV:resourcetype values are needed for the\nDeltaV protocol extensions, but that I am willing to add any\nset of (well-defined! :-) values on which the working group can\nreach consensus.\n\nSo from now on, I will only be asking for clarification on\nthe semantics of proposed new DAV:resourcetype values, rather\nthan repeating why I'm against adding any at all (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1028561"}, {"subject": "Re: Finding the version of a resource in a Version-Controlled-Collect ion..", "content": "Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n> Despite some excellent e-mail threads recently regarding\n> Version-Controlled-Collections I am still not clear how\n> to find the specific version of a resource which is\n> referenced by a version of a collection resource.\n>\n> Section 14 goes to great lengths to explain why we chose\n> to have the binding-set of a version of a collection point\n> to a VHR not a version of a resource and this is fine,\n> it makes sense.  But what is still not clear (at least to\n> me) is how having found the binding (URL segment bound to\n> a VHR) do I find the DAV:checked-in version of the resource\n> identified by the VHR.\n\nAs Alan said, there is no DAV:checked-in version associated with the\nversion history.  Think of collection versions as \"shallow\" versions that\ncapture the version-controlled bindings to version history resources.  In\nDeltaV, a \"deep\" collection (i.e. the collection and all resources it is\nbound to, recursively) is called a 'configuration' and a version of a\nconfiguration is a 'baseline'.\n\n> So I can do a PROPFIND with a Depth=0 for the\n> DAV:version-controlled-binding-set of a version of a\n> collection.  This gives me the binding names and references\n> to Version History Resources.  Now how do I find the\n> DAV:checked-in version?\n\nAgain, you don't for the reasons given in the spec. and reiterated by Alan.\nCapturing shallow versions of collections avoids the ripple effect when\nchanging resources.\n\n> This is something a client may do quite often, eg display\n> directory structure (of a workspace) and when a directory\n> is selected display versions of files contained within the\n> directory.\n\nShowing versions of a file (or any resource) is not affected by its\nmembership of a collection.  It is always valid to look at the version\nhistory (or predecessor/successor relationships) of a version-controlled\nresource.  Versioned collection capture the namespace.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10289651"}, {"subject": "Re: Should it be DAV:must-not-be-checked-out or DAV:must-be-checked-i n", "content": "Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n> In section 1.6.1 we have an example of a CHECKOUT method\n> which fails with a DAV:must-not-be-checked-out and\n> returning a 409 Conflict.\n>\n> I cannot actually see in the spec where the Precondition\n> DAV:must-not-be-checked-out for the CHECKOUT method is\n> defined?\n\nOk, so its a hypothetical example of a pre/postcondition failure <g>\n\n> CHECKOUT has a DAV:must-be-checked-in Precondition NOT a\n> DAV:must-not-be-checked-out Precondition.  So is the example\n> wrong or should the condition for CHECKOUT be changed.\n\nThe example is wrong and should be updated.\n\n> I also note that DAV:must-not-be-checked-out is used as a\n> precondition for the LABEL method.  Perhaps they should be\n> consistent and both use DAV:must-not-be-checked-out?\n\nI agree with Jim that DAV:must-be-checked-in is better.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10299907"}, {"subject": "Re: The definition of a &quot;Baseline-Controlled Collection&quot", "content": "Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n> Section 10.2 of the specification defines a \"Baseline-Controlled\n> Collection\" as follows:\n>\n> A \"baseline-controlled collection\" is a collection from which\n> baselines can be created.\n>\n> But section 12 says:\n>\n> A collection that is under baseline control is called a\n> \"baseline-controlled collection\".\n>\n> They can't both be right, is a BCC a resource from which a Baseline\n> CAN be created or is it a resource from which a Baseline HAS BEEN\n> created?\n\nBoth are correct.  Similarly, a version-controlled resource is a resource\nfrom which versions can be created, while at the same time being a resource\nfrom which a version has been created.\n\n> The definition in Section 10.2 seems wrong, I don't think you create\n> a Baseline from a collection, you create it by checking-in a\n> version-controlled configuration, which itself was created by placing\n> a collection under BASELINE-CONTROL.\n\nThe definition is:  A \"baseline-controlled collection\" is a collection from\nwhich baselines can be created.\n\n\nYou are right that there is a level of indirection required to actually\ncreate the baseline resource, however, this definition was intended to be\nmore general.  Do you have any suggestions for an alternative definition?\n\n> Infact, am I right in thinking that a \"Baseline-Controlled Collection\"\n> is simply a collection which has a DAV:version-controlled-configuration\n> property?\n\nIt's as simple as that!  (Though I would suggest that alone is not a good\ndefinition:-)\n\n> I am trying to get my head around what steps are needed to create a\n> new Baseline, populated with the contents of a collection, for example:\n>\n> There is a Version-Controlled Collection /build/src/\n\nOk, though it need not be version-controlled.\n\n> My client issues a BASELINE-CONTROL on that Version-Controlled Collection\n>    At this point a new \"Version-Controlled Configuration\" is created\n>    The original collection gets a DAV:version-controlled-configuration\n>     property set to the newly created resource\n>    The Version-Controlled Configuration gets a\n>     DAV:baseline-controlled-collection property set to the original\n>     collection\n>     A new Baseline History resource is created\n>    A new Baseline version is created (the \"root baseline\")\n>    The DAV:checked-in property of the Version-Controlled Configuration\n>     is set to the \"root baseline\"\n\nAgreed.\n\n>     A new collection with no members is created\n>    The \"root baseline\" has a DAV:baseline-collection pointing to the\n> above empty collection\n\nHmm, I agree that is what is written, and that sounds suspiciously like a\nGeoff-ism (empty initial version) <g>\nI don't know when that was introduced.\n\n> So at this point I have a \"empty\" baseline, how do I populate it with the\n> checked-in versions of resources from the original collection?\n\nYou would simply checkout/checkin the version-controlled configuration.\n\n> I guess I check-out the version-controlled configuration that was created\nby\n> the BASELINE-CONTROL and just check it in again???\n\nYes, (talk to Dr Clemm about that ...)\n\n> This is not clear in section 12, perhaps an example or diagram of\ncreating a\n> new baseline might help in this\n> section....something like this:\n>\n>                +-----------+\n[tpe]            |Baseline-  |\n>   +------------|Controlled |<--+\n>   |            |Collection |   |\n>   |            +-----------+   |\n>   |                            |DAV:b-c-collection\n>   |DAV:v-c-configuration       |\n>   |                            |\n>   |  +-------------+           |\n>   +->|Version      |-----------+\n>      |Controlled   |\n>      |Configuration|--+\n>      +-------------+  |\n>                       |\n>        DAV:checked-in |  +---------+\n>                       |  |Baseline |\n>                       |  |History  |\n>                       |  |         |\n>                       |  | +---+   |                   +-------------+\n>                       +--->|V1 |   | DAV:b-collection  |Collection   |\n>                          | |   |---------------------->|with bindings|\n>                          | +---+   |                   |to resources |\n>                          +---------+                   |from the     |\n>                                                        |original     |\n>                                                        |collection.  |\n>                                                        +-------------+\n>\n> Am I on the right track?\n\nSpot on (note that I changed version to baseline above), I have exactly\nthat diagram in my notebook.\n\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n\n", "id": "lists-006-10308599"}, {"subject": "Re: Label behaviour..", "content": "p.s. If you wanted to get all labels used in a version history you could\nuse the expand property report to find all the DAV:label-name-set values\nfor all the versions.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10321653"}, {"subject": "RE: Label behaviour..", "content": "Peter Raymond <Peter.Raymond@merant.com> wrote:\n> Jim says:\n>\n> >Your are correct on the distinction between adding and setting a label.\n> >Its there to avoid inadvertant reuse of a label. See the precondition\nfor\n> >DAV:must-be-new-label. This indicates that for DAV:add, the label MUST\nNOT\n> >currently select a version. The postconditions for add and set are the\n> >same.\n>\n> OK, I am happy that it is clear how DAV:add should behave, but I think\nthe\n> spec needs more detail on how DAV:set behaves, does it:\n>\n> a) \"move\" the label, eg if it is already used by another version of the\n> resource it will be removed from that version and added to the version\n> indicated by the LABEL request.\n\nI have no problem with spelling this out in the spec.\n\n> or\n>\n> b) Allow the same label on multiple versions of the same resource?\n\nI think this is already clear.  From Section 8:\n\"A given version label can be assigned to at most one version of a given\nversion history, but client assigned labels can be reassigned to another\nversion at any time.  Note that although a given label can be applied to at\nmost one version from the same version history, the same label can be\napplied to versions from different version histories. \"\n\n> Jim says:\n>\n> >I don't know what you mean by \"the labels that are in use\". Do you mean\n> >the intersection of all labels on all resources? If so, why would you\nneed\n> >this?\n>\n> I want a pulldown list of currently in use (intersection of all labels on\n> all resources) so the user can pick a label.  Obviously the user needs\nthe\n> ability to enter one that does not already exist but seeing the list of\n> existing ones will help in several use-case scenarios, eg:\n\nThe question is what do you mean by \"all resources\"?  Since the\ndeltav-compliant resources may be managed by many overlapping servers (with\nholes created by non-deltav compliant resources), and distributed servers,\nit is unlikely that \"all resources\" is very meaningful.\n\n> Imagine user Fred goes to his WebDAV client to do some work on a set of\n> source code, his colleague has told him by word of mouth etc that he\nshould\n> use a label called \"Special Label 1\".  When he uses the WebDAV client he\n> could put in any old label, eg \"Special-Label-1\" or \"SpecialLabel1\" etc,\nhe\n> could enter a different label from the one all the other developers have\n> been using.\n\nGive Fred a Post-It <g>\n\n> Another scenario is that you want to create a new label with a similar\n> naming scheme from other labels already in the system, for example a\n> project is under QA testing and all the versions of source under test\n> have been marked with a label called \"System Test Build 1\".  Now a user\n> wants to mark code using a label to indicate versions of code for use\n> in the next system test.  Without being able to see that the label\n> \"System Test Build 1\" was used previously the user might choose to call\n> this new label \"QA Build 2\".\n>\n> I guess what I am getting at is that by providing a list of labels\nalready\n> in use you can cut down on mistakes and the proliferation of similar\nlabel\n> names.\n>\n> What do other people think, any client writers out there that want to\n> provide a list of existing labels?\n\nI understand your point, but I don't see the value for such an unbounded\nquery.  I stand to be corrected.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10329024"}, {"subject": "Re: Postconditions with no XML elements defined", "content": "Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n> In section 1.6 of the specification it states:\n>\n> In order to allow better client handling of 403 and 409 responses,\n> a distinct XML element type is associated with each method\n> precondition and postcondition of a request.\n>\n> But several Postconditions in the specification do not have any\n> XML elements defined.\n>\n> Section 8.5, 8.6, 8.7, 8.8, and 9.6 for example.  Do we need to\n> change 1.6 to say that some preconditions and postconditions have\n> distinct XML elements?\n\nI'd be inclined to name all the pre-postconditions, even if it is unlikely\nthat a client will ever see them coming back from a server I think it is\nuseful to name them so we can talk about them and refer to them easily.\n\n> Also regarding the 403/409 responses it was not clear from the spec\n> when to send 403 and when to send 409.  The text in section 1.6 reads:\n>\n> If a method precondition for a request is not satisfied, or if a\n> method postcondition for a request cannot be achieved, the response\n> status of the request MUST be 403 (Forbidden) or 409 (Conflict).\n>\n> Does this mean a 403 should be sent for a failed precondition and\n> a 409 should be sent for a postcondition failure.  Or does it mean\n> the server implementer can return either code in either situation.\n> This is not clear from reading the spec.\n\nIt simply means that DeltaV is using the definitions found in RFC2616 and\nis not redefining their meanings.  In preactise this means that server\nimplementers can choose within those guidelines, but I think we should\nagree between ourselves which are which.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10339850"}, {"subject": "RE: Postconditions with no XML elements defined", "content": "Tim says:\n\n>I'd be inclined to name all the pre-postconditions, even if it is unlikely\n>that a client will ever see them coming back from a server I think it is\n>useful to name them so we can talk about them and refer to them easily.\n\nI Agree.\n\nTim says:\n\n>It simply means that DeltaV is using the definitions found in RFC2616 and\n>is not redefining their meanings.  In preactise this means that server\n>implementers can choose within those guidelines, but I think we should\n>agree between ourselves which are which.\n\nAlso sounds like a good idea, but could be a big job to review each\npre/post condition and decide under what circumstances a 409 or a 403 \nshould be returned.\n\nWhile we are on the subject of pre/post conditions I also wonder if anyone\ncan explain why the post condition XML elements are not worded as\n\"negatives\",\nbut the preconditions are worded as \"negatives\".\n\nFor example on DELETE in section 3.12 we have:\n\nDAV:cannot-delete-referenced-version as a precondition.\nI like the wording of this XML element it is clear that you have done\nsomething that is forbidden (eg it says cannot).\n\nBUT in the same section we have:\n\nDAV:update-predecessor-set as a postcondition.\nWhy didn't we call this XML element DAV:update-predecessor-set-failed\nor some wording that indicates failure.\n\nI am just intrigued as to why they got worded this way.  The status code\nalready indicates that something is forbidden (403) or there is a conflict\n(409).  So you could actually argue that we should remove the \"negatives\"\nfrom all the elements (pre and post)...eg in the above example we should \nhave:\n\nDAV:referenced-version\nDAV:predecessor-set\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (ADM)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-10349176"}, {"subject": "RE: Postconditions with no XML elements defined", "content": "Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n> Tim says:\n>\n> >I'd be inclined to name all the pre-postconditions, even if\n> > it is unlikely that a client will ever see them coming back\n> > from a server I think it is useful to name them so we can\n> > talk about them and refer to them easily.\n>\n> I Agree.\n>\n> Tim says:\n>\n> > It simply means that DeltaV is using the definitions found in\n> > RFC2616 and is not redefining their meanings.  In preactise this\n> > means that server >implementers can choose within those guidelines,\n> > but I think we should agree between ourselves which are which.\n>\n> Also sounds like a good idea, but could be a big job to review\n> each pre/post condition and decide under what circumstances a\n> 409 or a 403 should be returned.\n\nI did that a while ago, and it was not such a big deal\n(\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0125.html)\n\nhowever, there was a large grain of salt used when deciding between 403 and\n409.  If there is interest in re-doing that list I'll happily do so, but\nwherever there is a disagreement about if it should be one or the other I\nwill not offer any resistance :-)\n\n> While we are on the subject of pre/post conditions I also wonder\n> if anyone can explain why the post condition XML elements are not\n> worded as \"negatives\", but the preconditions are worded as\n> \"negatives\".\n\nThey are not all that way.  The preconditions are statements that must be\ntrue for a method to succeed, and the postconditions are statements that\nmust be true immediately after the method has suceeded.  I guess there are\nmore cases of a resource must not be (of a certain type | in a certain\nstate | whatever) for preconditions than there are for postconditions.\n\n> For example on DELETE in section 3.12 we have:\n>\n> DAV:cannot-delete-referenced-version as a precondition.\n> I like the wording of this XML element it is clear that you have\n> done something that is forbidden (eg it says cannot).\n>\n> BUT in the same section we have:\n>\n> DAV:update-predecessor-set as a postcondition.\n> Why didn't we call this XML element DAV:update-predecessor-set-failed\n> or some wording that indicates failure.\n\nBecause the postcondition (i.e. that which must be true) is that the\npredecessor set was updated.  Don't think of them as error descriptions.\n\n> I am just intrigued as to why they got worded this way.  The status\n> code already indicates that something is forbidden (403) or there\n> is a conflict (409).  So you could actually argue that we should\n> remove the \"negatives\" from all the elements (pre and post)...eg in\n> the above example we should have:\n>\n> DAV:referenced-version\n> DAV:predecessor-set\n\nI prefer the more descriptive names.\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n\n", "id": "lists-006-10358688"}, {"subject": "RE: Postconditions with no XML elements defined", "content": "> I did that a while ago, and it was not such a big deal\n> (\n>\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0125.html\n)\n> however, there was a large grain of salt used when deciding between 403\nand\n> 409.  If there is interest in re-doing that list I'll happily do so, but\n> wherever there is a disagreement about if it should be one or the other I\n> will not offer any resistance :-)\n\nPlease make it simple and normative!\n\n> The preconditions are statements that must be true for a method to\nsucceed,\n\nSounds like if the precondition is not true the operation is \"Forbidden\",\n\n> and the postconditions are statements that must be true immediately after\nthe method has suceeded.\n\nSounds like there must be a \"Conflict\" if the postcondition cannot be met.\n\nIf there are no strong objections, I propose that we adopt the simple\nnormative rule a precondition is returned with 403 and a postcondition is\nreturned with 409.\n\nLisa\n\n\n\n", "id": "lists-006-10369774"}, {"subject": "RE: Expiration date on draft 16", "content": "Thanks!  No error is too minor or nitpicky to be worth fixing.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Mark C. Chu-Carroll [mailto:mcc@watson.ibm.com]\nSent: Monday, July 09, 2001 10:56 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Expiration date on draft 16?\n\n\n\nThis is probably just a nitpick, but the ASCII version of the current\ndraft at ietf.org has an expiration date of January 3, 2001, even\nthough it wasn't written until July 3 2001.\n\n-Mark\n\n\n\n", "id": "lists-006-10378587"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "   From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n\n   Here's the list of elements that could appear in a DAV:resourcetype.\nSome\n   of these can be combined to provide a really meaningful experience for\nthe\n   client.  Obviously, some combinations are invalid.\n<DAV:checked-in/>\n<DAV:checked-out/>\n<DAV:collection/>\n<DAV:working-resource/>\n<DAV:version-controlled-resource/>\n<DAV:version/>\n<DAV:version-history/>\n<DAV:workspace/>\n<DAV:version-controlled-configuration/>\n<DAV:baseline/>\n<DAV:activity/>\n\nJust as a reminder, DAV:version-controlled-resource, DAV:version,\nDAV:working-resource, DAV:checked-in, and DAV:checked-out as a value\nin DAV:resourcetype will make that resource appear to be a folder in\nthe (large number of) Microsoft WebDAV clients that are currently\ndeployed.  Now I know that Microsoft's misreading of the spec is\nreprehensible to the extreme, but for those of us that have to deal\nwith that unfortunate reality, we may be forced for market reasons to\nleave out those particular DAV:resourcetype values from our server\nimplementations until that bug has been fixed in a widely deployed\nreplacement for those buggy clients.\n\nCan anyone from Microsoft that is following this list give us a clue\nas to whether this bug will be fixed anytime soon?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1038474"}, {"subject": "RE: The definition of a &quot;Baseline-Controlled Collection&quot", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   Section 10.2 of the specification defines a \"Baseline-Controlled\n   Collection\" as follows:\n\n   A \"baseline-controlled collection\" is a collection from which\n   baselines can be created.\n\n   But section 12 says: \n\n   A collection that is under baseline control is called a\n   \"baseline-controlled collection\".\n\n   They can't both be right, is a BCC a resource from which a Baseline\n   CAN be created or is it a resource from which a Baseline HAS BEEN\n   created?\n\nThese statements don't explicitly talk about whether or not a baseline\nhas actually been created, but when you put a resource under version\ncontrol (or baseline control), an initial version (or baseline) is\nalways created for that resource, so all these statements (both the\nones in the protocol and yours above) are consistent.\n\n   The definition in Section 10.2 seems wrong, I don't think you\n   create a Baseline from a collection, you create it by checking-in a\n   version-controlled configuration, which itself was created by\n   placing a collection under BASELINE-CONTROL.\n\nYes, but the versions selected by that new baseline are determined\nfrom the current state of the configuration rooted at the\nbaseline-controlled collection.  This reflects the dual role of a\ncollection; namely, as a resource unto itself (from which you can\ncreate collection versions), and as the root of a configuration (from\nwhich you can create configuration versions, aka \"baselines\").\nSince WebDAV only gives us one URL to talk about the collection itself\nand the configuration rooted at the collection, we continually have\nto deal with this dual role for a collection URL.\n\n   Infact, am I right in thinking that a \"Baseline-Controlled\n   Collection\" is simply a collection which has a\n   DAV:version-controlled-configuration property?\n\nActually, all members of a baseline-controlled collection have\na DAV:version-controlled-configuration property.  So a\nbaseline-controlled collection is a collection identified by\nthe DAV:baseline-controlled-collection property of some\nversion-controlled configuration.\n\n   I am trying to get my head around what steps are needed to create a\n   new Baseline, populated with the contents of a collection, for\n   example:\n\n   There is a Version-Controlled Collection /build/src/.\n   My client issues a BASELINE-CONTROL on that Version-Controlled\nCollection.\n\n   At this point a new \"Version-Controlled Configuration\" is created.\n   The original collection gets a DAV:version-controlled-configuration\n   property set to the newly created resource.  The Version-Controlled\n   Configuration gets a DAV:baseline-controlled-collection property\n   set to the original collection.  A new Baseline History resource is\n   created.  A new Baseline version is created (the \"root baseline\").\n   The DAV:checked-in property of the Version-Controlled Configuration\n   is set to the \"root baseline\".  A new collection with no members is\n   created.  The \"root baseline\" has a DAV:baseline-collection\n   pointing to the above empty collection.\n\nYes.\n\n   So at this point I have a \"empty\" baseline, how do I populate it\n   with the checked-in versions of resources from the original\n   collection?  I guess I check-out the version-controlled\n   configuration that was created by the BASELINE-CONTROL and just\n   check it in again???\n\nYes, but you raise a good point.  The BASELINE-CONTROL request would\nbe more consistent with the VERSION-CONTROL request if it created a\nbaseline that captured the current state of the configuration rooted\nat the baseline-controlled collection, instead of creating an empty\nbaseline.  In this case, the answer to your question would just have\nbeen \"it is the current DAV:checked-in baseline\".\n\nThis would mean changing the DAV:create-empty-baseline postcondition\nof BASELINE-CONTROL to be DAV:create-new-baseline.  Does anyone object\nto this change?  I don't think many people have been implementing\nthe advanced semantics yet, so I'm more comfortable making these\nkinds of adjustments to the advanced semantics than I would be to\nthe basic semantics.\n\n   This is not clear in section 12, perhaps an example or diagram of\n   creating a new baseline might help in this section....something\n   like this:\n\n                  +-----------+ \n                  |Version    | \n     +------------|Controlled |<--+ \n     |            |Collection |   | \n     |            +-----------+   | \n     |                            |DAV:b-c-collection \n     |DAV:v-c-configuration       | \n     |                            | \n     |  +-------------+           | \n     +->|Version      |-----------+ \n        |Controlled   |  \n        |Configuration|--+ \n        +-------------+  | \n                         | \n          DAV:checked-in |  +---------+ \n                         |  |Baseline | \n                         |  |History  | \n                         |  |         | \n                         |  | +---+   |                   +-------------+ \n                         +--->|V1 |   | DAV:b-collection  |Collection   | \n                            | |   |---------------------->|with bindings| \n                            | +---+   |                   |to resources | \n                            +---------+                   |from the     | \n                                                          |original     | \n                                                          |collection.  | \n                                                          +-------------+ \n\n   Am I on the right track? \n\nYes, that is exactly right.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10386316"}, {"subject": "RE: Postconditions with no XML elements defined", "content": "We use the standard meanings of 403 and 409 defined in\nRFC 2616 i.e.:\n\n10.4.4 403 Forbidden\n\n   The server understood the request, but is refusing to fulfill it.\n   Authorization will not help and the request SHOULD NOT be repeated.\n\n10.4.10 409 Conflict\n\n   The request could not be completed due to a conflict with the current\n   state of the resource. This code is only allowed in situations where\n   it is expected that the user might be able to resolve the conflict\n   and resubmit the request.\n\nBut to make sure there is no misunderstanding, how about the \nfollowing rewording of the first paragraph of section 1.6:\n\nA \"precondition\" of a method describes the state on the server that\nmust be true for that method to be performed.  A \"postcondition\" of a\nmethod describes the state on the server that must be true after that\nmethod has completed.  If a method precondition or postcondition for a\nrequest is not satisfied, the response status of the request MUST be\neither 403 (Forbidden) if the request should not be repeated\nbecause it will always fail, or 409\n(Conflict) if it is expected that the user might be able to resolve\nthe conflict and resubmit the request.\n\nCheers,\nGeoff \n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Monday, July 09, 2001 4:10 PM\nTo: Peter Raymond; ietf-dav-versioning@w3.org\nSubject: RE: Postconditions with no XML elements defined?\n\n\nI had interpreted it as being 403 with precondition, 409 with postcondition,\nlike you, but I agree it's not directly stated.  \n \nCan the spec clarify please?\n \nlisa\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Peter Raymond\nSent: Monday, July 09, 2001 8:39 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Postconditions with no XML elements defined?\n\n\nHi, \nIn section 1.6 of the specification it states: \nIn order to allow better client handling of 403 and 409 responses, a\ndistinct XML element \ntype is associated with each method precondition and postcondition of a\nrequest. \nBut several Postconditions in the specification do not have any XML elements\ndefined. \nSection 8.5, 8.6, 8.7, 8.8, and 9.6 for example.  Do we need to change 1.6\nto say that some \npreconditions and postconditions have distinct XML elements? \nAlso regarding the 403/409 responses it was not clear from the spec when to\nsend 403 \nand when to send 409.  The text in section 1.6 reads: \nIf a method precondition for a request is not satisfied, or if a method\npostcondition for a \nrequest cannot be achieved, the response status of the request MUST be 403\n(Forbidden) \nor 409 (Conflict). \nDoes this mean a 403 should be sent for a failed precondition and a 409\nshould be sent \nfor a postcondition failure.  Or does it mean the server implementer can\nreturn either code \nin either situation.  This is not clear from reading the spec. \nRegards, \n-- \nPeter Raymond - MERANT \nTechnical Architect (ADM) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n\n\n\n", "id": "lists-006-10399860"}, {"subject": "RE: Postconditions with no XML elements defined", "content": "Those postconditions should each have a token defined for them.\nI'll give them each one.  Thanks for noticing that!\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Monday, July 09, 2001 11:39 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Postconditions with no XML elements defined?\n\n\nHi, \nIn section 1.6 of the specification it states: \nIn order to allow better client handling of 403 and 409 responses, a\ndistinct XML element \ntype is associated with each method precondition and postcondition of a\nrequest. \nBut several Postconditions in the specification do not have any XML elements\ndefined. \nSection 8.5, 8.6, 8.7, 8.8, and 9.6 for example.  Do we need to change 1.6\nto say that some \npreconditions and postconditions have distinct XML elements? \nAlso regarding the 403/409 responses it was not clear from the spec when to\nsend 403 \nand when to send 409.  The text in section 1.6 reads: \nIf a method precondition for a request is not satisfied, or if a method\npostcondition for a \nrequest cannot be achieved, the response status of the request MUST be 403\n(Forbidden) \nor 409 (Conflict). \nDoes this mean a 403 should be sent for a failed precondition and a 409\nshould be sent \nfor a postcondition failure.  Or does it mean the server implementer can\nreturn either code \nin either situation.  This is not clear from reading the spec. \nRegards, \n-- \nPeter Raymond - MERANT \nTechnical Architect (ADM) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n\n\n\n", "id": "lists-006-10411999"}, {"subject": "RE: The definition of a &quot;Baseline-Controlled Collection&quot", "content": "   From: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n\n   Here my understanding of this stuff:\n   A configuration is a set of resources located at a root collection.\n\nI'd have said \"located at or below a root collection\".\n\n   A baseline is a version of a configuration.\n\nYes.\n\n   Peter Raymond <Peter.Raymond@merant.com> wrote:  \n\n   > Section 10.2 of the specification defines a \"Baseline-Controlled\n   > Collection\" as follows: A \"baseline-controlled collection\" is a\n   > collection from which baselines can be created.\n\n   A \"baseline-controlled collection\" is a collection which is a\n   container for a configuration and therefore you can create\n   baselines (configuration versions) IN it.  The statement in the\n   draft isn't that clear I guess.\n\nThis depends on what you mean by \"container\" and \"in\" (we don't define\nthose terms in the protocol).  The baselines are not members of the\nbaseline-controlled collection, so it might be misleading to say that\nthey are \"in\" or \"contained by\" the baseline-controlled collection.\n\n   > So at this point I have a \"empty\" baseline, how do I populate it\n   > with the checked-in versions of resources from the original\n   > collection?  I guess I check-out the version-controlled\n   > configuration that was created by the BASELINE-CONTROL and just\n   > check it in again ???\n\n   Just do it like that. OTOH I think it would be intuitive to say\n   that if there are already checked-in version-controlled resources\n   in a collection you put under baseline control just take these for\n   the initial version.\n\nLooks like we have a third vote for this approach (Peter, Edgar,\nmyself), so I'll go ahead and make this adjustment if there are no\nobjections.\n\n   Another thing I just noticed: A BASELINE-CONTROL precondition is\n   DAV:must-have-no-version-controlled-members. The description then\n   states that the request URL 'MUST have no members'. Wanted\n   restriction or should it read 'MUST have no version controlled\n   members' ?\n\nGood catch, Edgar!  The token name is correct, so the description\nneeds to be fixed.  I'll take care of that.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10421767"}, {"subject": "RE: Revision 16 of the DeltaV spec is all advanced :-", "content": "Thanks! I'll fix those up.\n\nBitten once more by the \"silently trash your references\" feature\nof Word (:-(.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\nI don't know if anyone else has already noticed, but in revision 16 of the\ndeltav document we \nhave lost a crucial '1' from the last paragraph of the introduction (section\n1). \nIn revision 16 it now reads: \n\"An implementer that is only interested in basic versioning should \n skip the advanced versioning sections (Section 0 to Section 15).\" \nI think it should be 10 to 15. \n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\nI just noticed that in Section 8 (Labels) we are missing a reference. \nThe text in version 16 of the specification reads: \n\nI think it should be referencing section 8.3. \n\n\n\n", "id": "lists-006-10432369"}, {"subject": "RE: Should it be DAV:must-not-be-checked-out or DAV:must-be-check ed-i n", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   In section 1.6.1 we have an example of a CHECKOUT method which\n   fails with a DAV:must-not-be-checked-out and returning a 409\n   Conflict.  I cannot actually see in the spec where the Precondition\n   DAV:must-not-be-checked-out for the CHECKOUT method is defined?\n\n   CHECKOUT has a DAV:must-be-checked-in Precondition NOT a\n   DAV:must-not-be-checked-out Precondition.  So is the example wrong\n   or should the condition for CHECKOUT be changed.  I also note that\n   DAV:must-not-be-checked-out is used as a precondition for the LABEL\n   method.  Perhaps they should be consistent and both use\n   DAV:must-not-be-checked-out?\n\nThanks for catching that!  When I renamed the precondition a while\nback, I neglected to update the example or the occurrences in the\nLABEL method.  I'll fix that.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10440987"}, {"subject": "RE: Label behaviour..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   What's the difference between DAV:add and DAV:set of a label?\n   Section 8 of the spec does not spell this out.  My best guess is\n   that DAV:add will fail with a DAV:must-be-new-label if the label is\n   already used by any version of the resource, but DAV:set will\n   remove any existing use of that label and then set the label on the\n   specified version, but I don't see this documented in the spec.\n\nI'll create distinct DAV:add-label and DAV:set-label postconditions\nto make this clearer.  Everybody always guesses the correct answer\nhere, but no reason to make people guess things, even if they always\nget the answer right (:-).\n\n   How does a client get a list of labels to present the user with a\n   choice?  The only way I can see is to request the\n   DAV:label-name-set property of every version resource.  Wouldn't it\n   be useful to have a report which listed the labels that are in use?\n\nYou can use the DAV:expand-property report or the DAV:version-tree\nreport, and request the DAV:label-name-set property.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10449076"}, {"subject": "RE: Finding the version of a resource in a Version-Controlled-Col lect ion..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   Despite some excellent e-mail threads recently regarding\n   Version-Controlled-Collections I am still not clear how to find the\n   specific version of a resource which is referenced by a version of\n   a collection resource.\n\n   Section 14 goes to great lengths to explain why we chose to have\n   the binding-set of a version of a collection point to a VHR not a\n   version of a resource and this is fine, it makes sense.  But what\n   is still not clear (at least to me) is how having found the binding\n   (URL segment bound to a VHR) do I find the DAV:checked-in version\n   of the resource identified by the VHR.\n\nOnly a version-controlled resource has a DAV:checked-in property,\nand a version history resource is not a version-controlled resource.\n\n   So I can do a PROPFIND with a Depth=0 for the\n   DAV:version-controlled-binding-set of a version of a collection.\n   This gives me the binding names and references to Version History\n   Resources.  Now how do I find the DAV:checked-in version?\n\nIt doesn't have one, so you can't find it (:-).  If you want to\ncapture the DAV:checked-in versions of all members of a collection,\nyou need to create a baseline of that collection, not a version.\n\n   This is something a client may do quite often, eg display directory\n   structure (of a workspace) and when a directory is selected display\n   versions of files contained within the directory.\n\nA workspace contains version-controlled resources (not versions), so\nyou can do a depth PROPFIND to identify the DAV:checked-in property of\neach version-controlled resource in the workspace.\n\nRemember that there are three very different kinds of resources:\nversion-controlled resources, version resources, and version history\nresources.  A version-controlled resource is just a resource that\nhas been placed under version-control.  A version is a particular\nstate of a version-controlled resource, and it lives off in some\nserver-defined namespace.  A version history tracks all the versions\nof a version controlled resource, and also lives off in some\nserver-defined namespace.  So users will almost always encounter\nversion-controlled resources, not versions or version histories,\nunless they are explicitly browsing for versioning metadata.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10457208"}, {"subject": "RE: Label behaviour..", "content": "Expand property report is down in section 15.\n\nI'd rather them use version-tree, which restricts the search to a\nparticular version set maintained by a VHR.\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Tim Ellison\n> Sent: Wednesday, July 11, 2001 2:33 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: Label behaviour...\n> \n> \n> \n> p.s. If you wanted to get all labels used in a version \n> history you could use the expand property report to find all \n> the DAV:label-name-set values for all the versions.\n> \n> Regards,\n> Tim\n> \n> \n\n\n\n", "id": "lists-006-10467373"}, {"subject": "RE: The definition of a &quot;Baseline-Controlled Collection&quot", "content": "Geoff says:\nThis would mean changing the DAV:create-empty-baseline postcondition\nof BASELINE-CONTROL to be DAV:create-new-baseline.  Does anyone object\nto this change?  I don't think many people have been implementing\nthe advanced semantics yet, so I'm more comfortable making these\nkinds of adjustments to the advanced semantics than I would be to\nthe basic semantics.\n\nSounds good to me.\n\n\n\n", "id": "lists-006-10476227"}, {"subject": "RE: The definition of a &quot;Baseline-Controlled Collection&quot", "content": "I agree.\n\nTim\n(in fact some people may have already mistakenly implemented it that way).\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> Sent: 11 July 2001 20:50\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: The definition of a \"Baseline-Controlled Collection\"\n> \n> \n> Geoff says:\n> This would mean changing the DAV:create-empty-baseline postcondition\n> of BASELINE-CONTROL to be DAV:create-new-baseline.  Does anyone object\n> to this change?  I don't think many people have been implementing\n> the advanced semantics yet, so I'm more comfortable making these\n> kinds of adjustments to the advanced semantics than I would be to\n> the basic semantics.\n> \n> Sounds good to me.\n> \n\n\n\n", "id": "lists-006-10484407"}, {"subject": "RE: &quot;nothing left to cut&quot; (was: Re: [ACL] Owner issues", "content": "There are several very different issues here.\n\nThe \"cut until there is nothing left to cut\" refers to protocol semantics\n(i.e. what a server is required to do), *not* the text in the protocol\ndocument.\n\nIt is of course essential to supplement the normative statements\n(i.e. those with a \"MUST\") with as much descriptive text as is\nnecessary to make the meaning clear.  In particular, with descriptive\ntext, it is better to err on the side of \"too much\" than \"too little\".\nSo the criteria for descriptive text is \"keep adding as long as the\nnet clarity of the document is increased\".  (But there are\nadditions that can decrease the net clarity of the document, so\nthe criteria is not just \"add as much as possible\").\n\nI believe that \"minimizing the protocol semantics\" and \"maximizing\nthe protocol document descriptive text\" are in fact complementary goals.\n\nThere is another issue, of whether you repeat the same normative\nstatement in different ways in different parts of the document.\nIn this case, I do believe that a particular normative statement should\nappear\nin exactly one place, but that descriptive text about that normative\nstatement can and should appear in several places in the document\n(i.e. wherever it is useful to do so).\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Greg Stein [mailto:gstein@lyra.org]\nSent: Wednesday, June 06, 2001 2:07 AM\nTo: Clemm, Geoff\nCc: acl@webdav.org; ietf-dav-versioning@w3.org; w3c-dist-auth@w3.org\nSubject: \"nothing left to cut\" (was: Re: [ACL] Owner issues)\n\n\nOn Tue, Jun 05, 2001 at 01:26:43AM -0400, Clemm, Geoff wrote:\n> I believe I was the one that originally suggested we allow\n> updating the owner with a PROPPATCH.  I have seen the error\n> of my ways (:-).  So unless there really is someone that\n> feels this functionality is important, I believe that the\n> principle of \"you aren't\n> done until there is nothing left to cut\" says to take it out.\n\nI am beginning to seriously disagree with the whole notion of \"cut\neverything until there is nothing left to cut.\"\n\nYou are taking it to the extreme, leaving a specification that is obtuse,\nhard to understand, and requires a half-dozen readings just to figure out\nthe subtleties and interactions between the elements, such that you can\n*infer* what should have been outright specified.\n\nCutting features is great. Creating obtuse specifications is absurd.\n\nIf you want a *STANDARD*, then it must be obvious to *all* implementors what\nthe standard should be. If one out of twenty people can figure out ALL of\nthe implications and inferences to implement the \"standard\", then you simply\nDON'T have a standard. You've only created a guide. The other 19 people\nimplemented something wrong because they couldn't grok the darned document.\n\nI'm not making a statement on the <owner> thing. Instead, I'm arguing that\nyour policy is erroneous. It needs to be tempered.\n\n[ I believe this applies more to the DeltaV spec than the ACL spec (I\n  haven't read the ACL spec lately); the DeltaV spec is currently a very\n  opaque document because of the \"say it once; anything more is redundant\"\n  attitude taken towards it. ]\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-1048752"}, {"subject": "RE: Postconditions with no XML elements defined", "content": "> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: 11 July 2001 17:34\n> To: Tim Ellison; ietf-dav-versioning@w3.org\n> Subject: RE: Postconditions with no XML elements defined?\n>\n> Please make it simple and normative!\n\nA simple list would suffice, right?\n\n> > The preconditions are statements that must be true for a method to\n> succeed,\n>\n> Sounds like if the precondition is not true the operation is \"Forbidden\",\n>\n> > and the postconditions are statements that must be true\n> immediately after\n> the method has suceeded.\n>\n> Sounds like there must be a \"Conflict\" if the postcondition cannot be met.\n>\n> If there are no strong objections, I propose that we adopt the simple\n> normative rule a precondition is returned with 403 and a postcondition is\n> returned with 409.\n\nThe 403 Forbidden means that you shouldn't bother trying any variations on\nthis request because they will fail, an example would be trying to MOVE a\nversion resource, there is nothing a client can do to make the server happy\nabout this.\nA 409 Conflict means the client likely can do something to fix the resource\nor server state so that the request will succeed, for example trying to\nCHECKOUT a checked-out resource will fail, but can succeed if the resource\nis first checked-in.\n\nI don't think it is as simple as saying all preconditions are 403 and all\npostconditions are 409 as it would lead to some anomolies, such as the\nDAV:preserve-versioning-properties postcondition being a 409!\n\n... but I did say that I wouldn't argue<g>\n\nTim\n\n\n\n", "id": "lists-006-10493235"}, {"subject": "RE: Label behaviour..", "content": "Sure (I meant apply the expand property report to the version history\nresource so it is bounded by the number of versions in a single version\nhistory).\n\nRegards,\nTim\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of John Hall\n> Sent: 11 July 2001 20:25\n> To: 'Tim Ellison'; ietf-dav-versioning@w3.org\n> Subject: RE: Label behaviour...\n>\n>\n> Expand property report is down in section 15.\n>\n> I'd rather them use version-tree, which restricts the search to a\n> particular version set maintained by a VHR.\n>\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Tim Ellison\n> > Sent: Wednesday, July 11, 2001 2:33 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: Re: Label behaviour...\n> >\n> >\n> >\n> > p.s. If you wanted to get all labels used in a version\n> > history you could use the expand property report to find all\n> > the DAV:label-name-set values for all the versions.\n> >\n> > Regards,\n> > Tim\n> >\n> >\n>\n\n\n\n", "id": "lists-006-10502893"}, {"subject": "Versioning and Lock Null resource", "content": "I haven't seen a resolution to DeltaV's lock null resource issues.\n\nCan a client issue the following requests on a lock null resource:\n - VERSION-CONTROL\n - MKACTIVITY\n - MKWORKSPACE\n - BASELINE-CONTROL\n\nSpecifically, one might imagine a client trying to create a new versionable\nresource and work with it by attempting the following sequence:  LOCK,\nVERSION-CONTROL, CHECKOUT, PUT (etc), CHECKIN, UNLOCK\n\nLisa\n\n\n\n", "id": "lists-006-10512292"}, {"subject": "UNCHECKOUT after automatic checkout", "content": "Can a client do this sequence of commands to a single resource?\n\n1. LOCK version-controlled resource\n2. verify that VCR has \"locked-update\" in DAV:auto-checkout and\n\"locked-update\" in DAV:auto-checkin\n3. PUT\n4. UNCHECKOUT\n\n\nObviously this would have to be a versioning-aware client, relying on the\nauto-checkout and auto-checkin behaviour of the server to do the checkout,\nbut able to override the server to cancel the checkout.\n\nThe advantage of the scenario is that it is fewer commands.  I don't see any\nreason that the spec would not allow this scenario -- I wanted to point it\nout so that server implementors could be sure to test it.\n\nlisa\n\n\n\n", "id": "lists-006-10519597"}, {"subject": "auto-checkout and auto-checki", "content": "I used to think I understood what the auto checkin/checkout stuff did, and\nmeant.  Now I think I don't.  The latest changes to that section of the spec\n(might have been a while ago) actually made it harder to handle.\n\n1.  If I read the definition of auto-checkout, it's pretty clear the\ncheckout is triggered by a modification request, but whether the trigger\nhappens is dependent on the _state_ of the resource.  Thus \"unlocked-update\"\nmeans \"if the resource is unlocked when the trigger event happens, do a\ncheckout\".  But then the definition of auto-checkin is not the same.  I\nwould have thought \"unlocked-update\" meant \"when the resource is unlocked do\na checkin\", but that's different than the definition of auto-checkout.  At\nany rate, whether the tags mean the same thing in both properties is one\nproblem, but what both tags mean for auto-checkin is the real problem.  The\nmissing piece of information for auto-checkin is what requests TRIGGER the\nauto-checkin behaviour.\n\n2.  Is it really reasonable for a server to have unlocked-update, but NOT\nlocked-update?  Currently the spec allows either value, both or neither.\nThis is a total of four states the client must understand.  One can be\neliminated.\n\n3.  Is it really reasonable for a server to have auto-checkin behaviour but\nno auto-checkout behaviour?  E.g. have a auto-checkin with \"unlocked-update\"\nbut auto-checkout shows nothing?  If it's not reasonable, then 3 additional\nstates  can be eliminated without the client having to worry about them.\n\nOn the whole, I preferred the automatic checkin/checkout stuff the way I\nremember it - there was less combinatorial confusion, there were no\nunreasonable settings, and the explanations were clearer.\n\nLisa\n\n\n\n", "id": "lists-006-10527187"}, {"subject": "RE: auto-checkout and auto-checki", "content": "Well, a server is free to freeze these values.  The server doesn't have\nto let the client muck with them, and if it does allow the client to\nmuck with them I assume it could enforce whatever combinations it deems\nreasonable.\n\nConsider PUT.\n\nThe code becomes:\nputEntryStuff();\ndoPut()\nputExitStuff();\n\nWhere putEntryStuff will throw an exception if the PUT is not allowed.\n\nCheckout-Locked, Checkin-Locked:\nLock, Put, Unlocked is the expected behavior.  Though Lock, Put, CheckIn\nand Lock, Put, Uncheckout behave just-as-if the client had done an\nexplicit checkout before the Put.\n\nCheckout-unlocked and Checkin-unlocked imply and atomic operation.\n'PUT' becomes equivalent to \nCHECKOUT, PUT, CHECKIN.\n\nOK:\nCheckout-Locked, ! Checkin-Locked:\nLock, Put -- is the same as LOCK, CHECKOUT, PUT and the system requires\nan explicit CHECKIN.\n\nCheckout-Unlocked, ! Checkin-Unlocked:\nPUT is CHECKIN, PUT and the resource is left in exactly that state.\n\n! Checkout-Locked, Checkin-Locked:\nNow I really don't like this combination.  It introduces nastiness like\n\"CHECKOUT, PUT, LOCK, UNLOCK\", with the spec potentially implying that\nthe UNLOCK would require a CHECKIN.  It is OK if this state is\nexplicitly ruled illegal, or if the Checkin-Locked is defined so that it\nONLY comes into play if the CHECKOUT was done because of a\nCheckout-Locked action.\n\n! Checkout-Unlocked, Checkin-Unlocked:\nCHECKOUT, PUT becomes CHECKOUT, PUT, UNCHECKOUT.  That doesn't make\nsense to me, but I was planning on supporting it.  Note that it doesn't\nrequire a separate test case if putEntryStuff leaves the object in the\ncorrect internal state.\n\n============================\n\nOf the 8 possible states, 4 are 'obvious' 3 are 'funny' and 1 is a\nreally bad idea.  If you retained the current discription (since I think\nit might be easier to describe things the current way) but added the\nrestriction that auto-checkin must be the same value as auto-checkout\nthat would be OK with me.\n\n\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Lisa \n> Dusseault\n> Sent: Wednesday, July 11, 2001 9:41 PM\n> To: DeltaV\n> Subject: auto-checkout and auto-checkin\n> \n> \n> \n> I used to think I understood what the auto checkin/checkout \n> stuff did, and meant.  Now I think I don't.  The latest \n> changes to that section of the spec (might have been a while \n> ago) actually made it harder to handle.\n> \n> 1.  If I read the definition of auto-checkout, it's pretty \n> clear the checkout is triggered by a modification request, \n> but whether the trigger happens is dependent on the _state_ \n> of the resource.  Thus \"unlocked-update\" means \"if the \n> resource is unlocked when the trigger event happens, do a \n> checkout\".  But then the definition of auto-checkin is not \n> the same.  I would have thought \"unlocked-update\" meant \"when \n> the resource is unlocked do a checkin\", but that's different \n> than the definition of auto-checkout.  At any rate, whether \n> the tags mean the same thing in both properties is one \n> problem, but what both tags mean for auto-checkin is the real \n> problem.  The missing piece of information for auto-checkin \n> is what requests TRIGGER the auto-checkin behaviour.\n> \n> 2.  Is it really reasonable for a server to have \n> unlocked-update, but NOT locked-update?  Currently the spec \n> allows either value, both or neither. This is a total of four \n> states the client must understand.  One can be eliminated.\n> \n> 3.  Is it really reasonable for a server to have auto-checkin \n> behaviour but no auto-checkout behaviour?  E.g. have a \n> auto-checkin with \"unlocked-update\" but auto-checkout shows \n> nothing?  If it's not reasonable, then 3 additional states  \n> can be eliminated without the client having to worry about them.\n> \n> On the whole, I preferred the automatic checkin/checkout \n> stuff the way I remember it - there was less combinatorial \n> confusion, there were no unreasonable settings, and the \n> explanations were clearer.\n> \n> Lisa\n> \n> \n> \n\n\n\n", "id": "lists-006-10537330"}, {"subject": "Re: Finding the version of a resource in a Version-Controlled-Collect ion..", "content": "On Wed, Jul 11, 2001 at 10:28:27AM +0100, Tim Ellison wrote:\n...\n> > Collections are a bit weird in that asking for the collection actually\n> > gives you a tree of all the member resources (including nested\n> > collections etc.).\n> \n> Again I'm not sure what you mean by \"ask for\" a collection?\n> When you create a new version-controlled collection that is 'initialized'\n> from an existing collection version, the members of the version-controlled\n> collection will be bound to undefined versions of the version-histories (of\n> each member of the collection version).\n\n(By \"asked-for\" I was trying to long the long winded description of\ncreating a version controlled collection resource using VERSION-CONTROL.\nI will try to avoid loose wording in the future! - maybe!! :-)\n\nI had misunderstood. I had thought it bound them to the root version.\nOr maybe the behavour is different inside workspaces to outside workspaces.\nBut undefined I hope it means the server can pick whatever version it\nlikes rather than having 'undefined nebulous unbound resources in\na collection'.\n\nAlan\n\n\n\n", "id": "lists-006-10549425"}, {"subject": "Re: Finding the version of a resource in a Version-Controlled-Collect ion..", "content": "Alan Kent <ajk@mds.rmit.edu.au> wrote:\n\n> I had misunderstood. I had thought it bound them\n> to the root version.\n\nThat is what the draft currently says, but we agreed recently on the list\nto change that to 'server defined'. (OK?)\n\n> Or maybe the behavour is different inside workspaces\n> to outside workspaces.\n\nIt will be the same for both.\n\n> But undefined I hope it means the server can pick\n> whatever version it likes rather than having 'undefined\n> nebulous unbound resources in a collection'.\n\nYes, the former.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10558109"}, {"subject": "Re: UNCHECKOUT after automatic checkout", "content": "\"Lisa Dusseault\" <lisa@xythos.com> wrote:\n\n> Can a client do this sequence of commands to a single resource?\n>\n> 1. LOCK version-controlled resource\n\nThis would acquire the lock.\n\n> 2. verify that VCR has \"locked-update\" in DAV:auto-checkout and\n> \"locked-update\" in DAV:auto-checkin\n\nOk.\n\n> 3. PUT\n\nAssuming the lock token passed with the request was ok, this PUT\nmodification request to a locked version-controlled resource would cause:\n(1) the resource to be first checked-out, due to DAV:auto-checkout being\nDAV:locked-update,\n(2) the PUT method to be applied,\n(3) the resource to be checked-in, due to the resource being auto-checked\nout (in step (1)) and DAV:auto-checkin being DAV:locked-update.\n\n(i.e. CHECKOUT, PUT, CHECKIN)\n\nThe end result is a checked-in version-controlled resource and a new\nversion resource.\n\n> 4. UNCHECKOUT\n\nThis would fail with a\n<DAV:must-be-checked-out-version-controlled-resource>\n\n\n> Obviously this would have to be a versioning-aware client, relying\n> on the auto-checkout and auto-checkin behaviour of the server to do\n> the checkout, but able to override the server to cancel the checkout.\n\nIf the DAV:auto-checkin had not been DAV:locked-update then the client\ncould cancel the checkout.\n\n> The advantage of the scenario is that it is fewer commands.  I don't\n> see any reason that the spec would not allow this scenario -- I wanted\n> to point it out so that server implementors could be sure to test it.\n\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10566465"}, {"subject": "Re: auto-checkout and auto-checki", "content": "> I used to think I understood what the auto checkin/checkout\n> stuff did, and meant.  Now I think I don't.  The latest\n> changes to that section of the spec\n> (might have been a while ago) actually made it harder to handle.\n>\n> 1.  If I read the definition of auto-checkout, it's pretty\n> clear the checkout is triggered by a modification request,\n> but whether the trigger happens is dependent on the _state_\n> of the resource.\n\nRight, in particular whether the resource is checked-in or not and whether\nit is locked or not.\n\n> Thus \"unlocked-update\" means \"if the resource is unlocked when\n> the trigger event happens, do a checkout\".  But then the\n> definition of auto-checkin is not the same.  I would have\n> thought \"unlocked-update\" meant \"when the resource is unlocked\n> do a checkin\", but that's different than the definition of\n> auto-checkout.\n\nAuto-checkin means that *if* the resource was auto-checked-out then it\nshould also be auto-checked-in after the modification request (trigger)\nsubject to its locked state.\n\nIf the DAV:auto-checkin value is DAV:unlocked-update that likely means that\nthe client has locked the resource and is performing multiple modification\nrequests on it.  Rather than capture each modification as a version, the\nmodifications are grouped by the lifetime of the lock.  Once the lock is\nremoved (explicitly or by timeout) the group of changes are captured as a\nversion by an auto-checkin (again, it must have been auto-checked-out\nthough).\nIf the resource was not locked when it was modified a new version will be\ncaptured for each modification request.\n\nThe scenarios for DAV:auto-checkin with a value DAV:locked-update are less\nlikely.  Either the resource was locked when it was auto-checked-out and\nevery modification request should result in a version, or the resource was\nunlocked when it was auto-checked-out and it should be captured as a\nversion when locked and subsequently modified.\n\n> At any rate, whether the tags mean the same\n> thing in both properties is one problem, but what both tags mean\n> for auto-checkin is the real problem.  The missing piece of\n> information for auto-checkin is what requests TRIGGER the\n> auto-checkin behaviour.\n\nIt is still the modification request.  So imagine an unlocked version\ncontrolled resource with values\nDAV:auto-checkout -> DAV:unlocked-update\nDAV:auto-checkin -> DAV:locked-update\n\nClient issues:         Server does:        Version-controlled resource:\n                                           checked-in, unlocked\nPUT                    CHECKOUT            checked-out, unlocked\n                       PUT\nLOCK                   LOCK                checked-out, locked\nPUT                    PUT\n                       CHECKIN             checked-in, locked\nUNLOCK                 UNLOCK              checked-in, unlocked\n\n(Why would you do that?)\n\n> 2.  Is it really reasonable for a server to have unlocked-update,\n> but NOT locked-update?  Currently the spec allows either value,\n> both or neither.  This is a total of four states the client must\n> understand.  One can be eliminated.\n\nI agree that there are combinations that don't make much sense.\n\n> 3.  Is it really reasonable for a server to have auto-checkin\n> behaviour but no auto-checkout behaviour?  E.g. have a auto-\n> checkin with \"unlocked-update\" but auto-checkout shows nothing?\n> If it's not reasonable, then 3 additional states  can be\n> eliminated without the client having to worry about them.\n\nAuto-checkin means nothing without auto-checkout.\n\n> On the whole, I preferred the automatic checkin/checkout stuff\n> the way I remember it - there was less combinatorial confusion,\n> there were no unreasonable settings, and the explanations were\n> clearer.\n\nIt was simpler, but some folk complained that their use case was not\nsatisfied by it.  I recall the \"make the lifetime of the check-out the same\nas that of the lock\" as a reasonable request, but the others I forget.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10575830"}, {"subject": "RE: auto-checkout and auto-checki", "content": "\"John Hall\" <johnhall@evergo.net> wrote:\n\n> Well, a server is free to freeze these values.  The server\n> doesn't have to let the client muck with them, and if it\n> does allow the client to muck with them I assume it could\n> enforce whatever combinations it deems reasonable.\n\nYes, definitely.\n\n> Consider PUT.\n>\n> The code becomes:\n> putEntryStuff();\n> doPut()\n> putExitStuff();\n>\n> Where putEntryStuff will throw an exception if the PUT is\n> not allowed.\n>\n> Checkout-Locked, Checkin-Locked:\n> Lock, Put, Unlocked is the expected behavior.  Though Lock,\n> Put, CheckIn and Lock, Put, Uncheckout behave just-as-if\n> the client had done an explicit checkout before the Put.\n\nAssuming you start with an unlocked version-controlled resource...\nLOCK, PUT, CHECKIN      and\nLOCK, PUT, UNCHECKOUT\nWill both fail because the resource will already be auto-checked-in after\nthe PUT.\n\n> Checkout-unlocked and Checkin-unlocked imply and atomic\n> operation.\n> 'PUT' becomes equivalent to\n> CHECKOUT, PUT, CHECKIN.\n\nYes (assuming the version-controlled resource is checked-in and not\nlocked).\n\n> OK:\n> Checkout-Locked, ! Checkin-Locked:\n> Lock, Put -- is the same as LOCK, CHECKOUT, PUT and the\n> system requires an explicit CHECKIN.\n\nWhat does !checkin-locked mean?  do you mean checkin-unlocked (a.k.a.\nDAV:unlocked-update) or that it has no value?\n\n> Checkout-Unlocked, ! Checkin-Unlocked:\n> PUT is CHECKIN, PUT and the resource is left in exactly\n> that state.\n\nSorry, your notation is lost on me -- please can you restate it.\n\n> ! Checkout-Locked, Checkin-Locked:\n> Now I really don't like this combination.  It introduces\n> nastiness like\n> \"CHECKOUT, PUT, LOCK, UNLOCK\", with the spec potentially\n> implying that the UNLOCK would require a CHECKIN.  It is\n> OK if this state is explicitly ruled illegal, or if the\n> Checkin-Locked is defined so that it ONLY comes into play\n> if the CHECKOUT was done because of a Checkout-Locked\n> action.\n>\n> ! Checkout-Unlocked, Checkin-Unlocked:\n> CHECKOUT, PUT becomes CHECKOUT, PUT, UNCHECKOUT.  That\n> doesn't make sense to me, but I was planning on supporting\n> it.  Note that it doesn't require a separate test case\n> if putEntryStuff leaves the object in the correct internal\n> state.\n>\n> ============================\n>\n> Of the 8 possible states, 4 are 'obvious' 3 are 'funny' and 1 is a\n> really bad idea.  If you retained the current discription (since I think\n> it might be easier to describe things the current way) but added the\n> restriction that auto-checkin must be the same value as auto-checkout\n> that would be OK with me.\n\nThere's quite a list, you have to consider the initial version-controlled\nresource being locked or unlocked and checked-in or checked-out together\nwith the combination of valid values (which are DAV:locked-update,\nDAV:unlocked-update, both, or none).\n\nI recall Jim W. wrote out the table a while ago (sorry I can't go and look\nfor it right now).\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10587332"}, {"subject": "RE: Finding the version of a resource in a Version-Controlled-Col lect ion..", "content": "   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n\n   On Tue, Jul 10, 2001 at 10:28:50AM +0100, Peter Raymond wrote:\n\n   > Despite some excellent e-mail threads recently regarding\n   > Version-Controlled-Collections I am still not clear how to find\n   > the specific version of a resource which is referenced by a\n   > version of a collection resource.\n\n   I think the answer is you don't. A collection does not identify exact\n   versions of resources that are referenced. If it did, then every time\n   a member of the collection was versioned, the collection itself would\n   have to be versioned. Versioning the collection would in turn cause\n   its parent collection to be versioned, and so on up the tree. This is\n   not really acceptable, so collection histories do not identify specific\n   versions, only a version history.\n\nYes.\n\n   This felt weird to me at first, but it made sense eventually. I like\n   relating things back to CVS (because I use it a lot). In CVS, each\n   file has its own version history with version numbering. Not all files\n   in a directory have the same version numbers. So when you do a cvs update\n   or cvs checkout, you are actually asking each file individually for\n   'the latest version' or 'a version with this label'. You do not use\n   CVS to say 'get me version 1.2 of every file in a directory' because\n   the files have individual version numbering.\n\nAs Tim pointed out, you can ask for every version with a given label,\nbut I agree with your key point that CVS (like DeltaV) has each\nversion-controlled resource select its version, as opposed to having\nthe version be selected for it by some parent collection (i.e. you\ncan always select a specific version for any version-controlled resource,\njust as you can in DeltaV).\n\n   The same is true for collections. To do a VERSION-CONTROL in DeltaV,\n   for every single resource you get a version-controlled resource for,\n   its up to you to select the particular version you want.\n\nAlthough with baselines and activities, you can select the version\nfor a whole batch of resources (e.g. a collection and all of its\nmembers) in a single MERGE request.\n\n   At least that is my current understanding. Please not however that\n   I have not read up properly on activies and baselines yet, so the\n   above may be different when using those concepts. But I beleive the\n   above is correct with respect to the fundamentals of the DeltaV\n   versioning.\n\nYes, this all looks right to me.  The main impact baselines and\nactivities would have on this discussion is the fact that they\ncan be used to select the version for multiple resources in a single\nMERGE request.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10598171"}, {"subject": "RE: Postconditions with no XML elements defined", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   > The preconditions are statements that must be true for a method\n   > to succeed,\n\n   Sounds like if the precondition is not true the operation is \"Forbidden\",\n\n   > and the postconditions are statements that must be true immediately\nafter\n   the method has suceeded.\n\n   Sounds like there must be a \"Conflict\" if the postcondition cannot be\nmet.\n\n   If there are no strong objections, I propose that we adopt the simple\n   normative rule a precondition is returned with 403 and a postcondition is\n   returned with 409.\n\nI'd fall into the \"strong objection\" camp.  403 means the user should\nnot retry the operation, because it will never succeed.  This will\nsometimes be the case for both precondition and postcondition\nfailures.  409 means that there is something the user could do to the\nresource to make the operation succeed.  This will also sometimes be\nthe case for both precondition and postcondition failures.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10608395"}, {"subject": "RE: Deleting version", "content": "Are DeltaV servers then not required to support locking at all?  Lock-null\ncomes along with lock.  I can (barely) beleive that a server might implement\nDeltaV but not support locking.  In fact, you acknowledge in section 14 that\nlock-null may be implemented:\n\n\"Non-version-controlled bindings are not under version control, and\ntherefore can be added or deleted without checking out the\nversion-controlled collection.  This feature is essential for the support of\nlock null resources, since a lock null resource is a temporary internal\nmember of a collection that should only exist for the duration of the lock,\nand should not be captured in the version history of that collection.\"\n\nYou're doing what Greg (justly) accused you of and leaving things to be\ninferred, or out of the spec entirely.  If DeltaV says nothing, then\nimplementors and servers that do locking and deltaV will be left without\nguidance, on an issue over which the experts (heh) have argued.  Their\nimplementations will differ.\n\nWhy not state that MKCOLLECTION and MKACTIVITY can be used on lock-null\nresources if they would be legal otherwise?  If you object, then please make\nyour arguments against the concept, but do not allow the spec to remain\nsilent.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, June 06, 2001 8:07 AM\n> To: DeltaV\n> Subject: RE: Deleting versions\n>\n>\n> I agree that if a client is likely to get disconnected\n> in the middle of its MKWORKSPACE/LOCK request sequence, and if a server\n> lets you change the ACL's on a workspace but does not let\n> you create a workspace, and if a workspace can have its ACL's\n> updated by anyone other than the owner, then there is a use\n> case for issuing a MKWORKSPACE against a lock null resource.\n>\n> But as you said earlier, RFC 2518 only constrains what HTTP\n> and DAV methods can be applied to a lock null resource,\n> so a compliant DelataV server can support this use case if it wishes.\n> We can't say it MUST support this use case, since a DeltaV\n> server is not required to support lock null resources at all.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Lisa Dusseault [mailto:lisa@xythos.com]\n> Sent: Tuesday, June 05, 2001 7:43 PM\n> To: Clemm, Geoff; DeltaV\n> Subject: RE: Deleting versions\n>\n>\n> The problem is that the \"client that got there before them\" may have\n> permission to alter a workspace, but they may NOT have permission\n> to CREATE\n> a workspace.\n>\n> The problem is not that the other client locked it, but that they might\n> apply changes before you get a chance to prevent them!  I create\n> a Workspace\n> (or a resource, or a collection).  I want to then set the ACLs so that I'm\n> the only one that can alter this resource, because it's MINE.  But, in\n> between the MKWORKSPACE and the subsequent LOCK, the other client comes in\n> and sets ACLs so that they can write the workspace and I can't!  Ouch.\n>\n> Null resource went through similar discussions, and was kept for reasons\n> which apply to MKWORKSPACE the same way they apply to PUT, MKCOL.\n>\n> lisa\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > Sent: Tuesday, June 05, 2001 3:48 PM\n> > To: DeltaV\n> > Subject: RE: Deleting versions\n> >\n> >\n> >    From: Lisa Dusseault [mailto:lisa@xythos.com]\n> >\n> >    If somebody who's not supposed to, gets in and changes something in\n> >    between a MKWORKSPACE command and a ACL request, that's a serious\n> >    problem.  Null resources help avoid that.\n> >\n> >    It's not that somebody got their MKWORKSPACE request in ahead of\n> >    mine --that's not the purpose of null resources at all.\n> >\n> > My point was not that a lock can prevent somebody from\n> > creating the workspace ahead of you, but rather that\n> > someone locking \"your\" workspace is no different from\n> > someone creating a workspace by that name before you\n> > can lock that URL.\n> >\n> > In particular, we are discussing two alternative sequences:\n> >  LOCK/MKWORKSPACE/ACL/UNLOCK\n> > or\n> >  MKWORKSPACE/LOCK/ACL/UNLOCK\n> >\n> > In the first sequence, the LOCK may fail (because there already\n> > is a lock on that URL), so you tell the user \"that workspace is\n> > already in use by another user\".\n> >\n> > In the second sequence, either the MKWORKSPACE may fail (because\n> > somebody got in and created a workspace before you) or the LOCK\n> > may fail (because somebody got in and locked the workspace before\n> > you).  In either case, you still tell the user \"that workspace is\n> > already in use by another user\".\n> >\n> > So from the user's perspective, it doesn't matter whether\n> > or not their client did a LOCK/MKWORKSPACE or a\n> > MKWORKSPACE/LOCK.  Their request can fail because another\n> > client \"got there before them\".\n> >\n> > Cheers,\n> > Geoff\n\n\n\n", "id": "lists-006-1061112"}, {"subject": "RE: Postconditions with no XML elements defined", "content": "   From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n\n   Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n   > Tim says:\n   >\n   > > It simply means that DeltaV is using the definitions found in\n   > > RFC2616 and is not redefining their meanings.  In preactise this\n   > > means that server >implementers can choose within those guidelines,\n   > > but I think we should agree between ourselves which are which.\n   >\n   > Also sounds like a good idea, but could be a big job to review\n   > each pre/post condition and decide under what circumstances a\n   > 409 or a 403 should be returned.\n\n   I did that a while ago, and it was not such a big deal\n\nAlso, whether or not a particular response should be a 403 or a 409\ndepends on the particular request and on the implementation of the\nresource.  For example, with the DAV:preserve-versioning-properties\npostcondition and a MOVE request on a checked-out version-controlled\nresource, one server might not be able to preserver versioning\nproperties so it returns a 403 indicating the MOVE will always fail,\nwhile another server might only be able to MOVE only checked-in VCR's,\nso it returns a 409 (since the user could MOVE the resource after\nchecking it in).\n\nSo we could compile a non-normative list of what status codes are\nlikely to be returned by certain implementations, but a client writer\nshould not use this list (it should use the status code actually\nreturned), and a server writer should only use the list if it reflects\nthe implementation choices made by that server.  I would be strongly\nagainst including such a list in the protocol itself, since it would\nbe too easy for a client writer to hardwire these \"suggested\" return\ncodes into their implementation logic.\n\n   > While we are on the subject of pre/post conditions I also wonder\n   > if anyone can explain why the post condition XML elements are not\n   > worded as \"negatives\", but the preconditions are worded as\n   > \"negatives\".\n\n   They are not all that way.  The preconditions are statements that must be\n   true for a method to succeed, and the postconditions are statements that\n   must be true immediately after the method has suceeded.\n   ...\n   Don't think of them as error descriptions.\n\nYes.\n\n   > I am just intrigued as to why they got worded this way.  The status\n   > code already indicates that something is forbidden (403) or there\n   > is a conflict (409).  So you could actually argue that we should\n   > remove the \"negatives\" from all the elements (pre and post)...eg in\n   > the above example we should have:\n   >\n   > DAV:referenced-version\n   > DAV:predecessor-set\n\n   I prefer the more descriptive names.\n\nAs do I.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10616935"}, {"subject": "Question: after the current stat", "content": "Hello,\n\nI would like to ask, whether we can expect, that your internet draft\nwill be released as official RFC within the next six month.\nAre there any products (server and clients) which will implement the\nversioning protocol soon?\n\n\nMit freundlichen Gr??en / Best regards\n \nDr. Helmut Ackermann\n \n-----------------------------------------------------------\nResearch & Development\nGauss Interprise AG, \nWeidestr. 120a, \nD-22083 Hamburg\n \nPhone: +49-40-3250-1232\nEmail: mailto:helmut.ackermann@gauss-interprise.com\nWeb:   http://www.gauss-interprise.com/\n\n\n\n", "id": "lists-006-10627457"}, {"subject": "Re: Question: after the current stat", "content": "\"Dr. Helmut Ackermann\" <helmut.ackermann@gauss-interprise.com> wrote:\n\n> I would like to ask, whether we can expect, that your\n> internet draft will be released as official RFC within\n> the next six month.\n\nThe draft is currently in front of the IESG for consideration.  It will be\ngiven an RFC number if it is accepted on the standards track.  We have\nevery expectation that this will happen well within that time period.\n\n> Are there any products (server and clients) which will\n> implement the versioning protocol soon?\n\nA number of people have declared that they are implementing to the draft\n(with various options) -- there have been no product announcements.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10635433"}, {"subject": "RE: auto-checkout and auto-checki", "content": "Well, I intended \"! Checkin-Locked\" to mean that the value of\nauto-checkin did not include locked-update.\n\n\nHowever, it seems though I've been burned again.  I assumed that\n<auto-checkin><locked-update/></auto-checkin> meant something completely\ndifferent that it does.\n\nSo it would seem that my server supports:\n<auto-checkout><unlocked-update/><locked-update/></auto-checkout>\nAnd\n<auto-checkin><unlocked-update/></auto-checkin>\n\nAnd the logic is thus:\nPUT on a VCR Entry:\nIf the VCR is checked in AND no workking-resource has been created (no\nforking, remember) then check it out, else fail.\nIf you just checked it out, remember that you did an 'AUTO' checkout,\nand remember whether the resource was locked when\nYou did so.\n\n... Do the PUT ...\n\nPUT on a VCR Exit:\nIf you just did an AUTO checkout and the resource isn't locked then\ncheck it in.\n\nUNLOCK or Lock Expire:\nIf an AUTO checkout was done, and the resource was locked when it was\ndone, then do a checkin.\n\n \n\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Tim Ellison\n> Sent: Thursday, July 12, 2001 4:31 AM\n> To: 'DeltaV'\n> Subject: RE: auto-checkout and auto-checkin\n> \n> \n> \n> \"John Hall\" <johnhall@evergo.net> wrote:\n> \n> > Well, a server is free to freeze these values.  The server doesn't \n> > have to let the client muck with them, and if it does allow \n> the client \n> > to muck with them I assume it could enforce whatever \n> combinations it \n> > deems reasonable.\n> \n> Yes, definitely.\n> \n> > Consider PUT.\n> >\n> > The code becomes:\n> > putEntryStuff();\n> > doPut()\n> > putExitStuff();\n> >\n> > Where putEntryStuff will throw an exception if the PUT is\n> > not allowed.\n> >\n> > Checkout-Locked, Checkin-Locked:\n> > Lock, Put, Unlocked is the expected behavior.  Though Lock, Put, \n> > CheckIn and Lock, Put, Uncheckout behave just-as-if the client had \n> > done an explicit checkout before the Put.\n> \n> Assuming you start with an unlocked version-controlled resource...\n> LOCK, PUT, CHECKIN      and\n> LOCK, PUT, UNCHECKOUT\n> Will both fail because the resource will already be \n> auto-checked-in after the PUT.\n> \n> > Checkout-unlocked and Checkin-unlocked imply and atomic operation.\n> > 'PUT' becomes equivalent to\n> > CHECKOUT, PUT, CHECKIN.\n> \n> Yes (assuming the version-controlled resource is checked-in \n> and not locked).\n> \n> > OK:\n> > Checkout-Locked, ! Checkin-Locked:\n> > Lock, Put -- is the same as LOCK, CHECKOUT, PUT and the system \n> > requires an explicit CHECKIN.\n> \n> What does !checkin-locked mean?  do you mean checkin-unlocked (a.k.a.\n> DAV:unlocked-update) or that it has no value?\n> \n> > Checkout-Unlocked, ! Checkin-Unlocked:\n> > PUT is CHECKIN, PUT and the resource is left in exactly\n> > that state.\n> \n> Sorry, your notation is lost on me -- please can you restate it.\n> \n> > ! Checkout-Locked, Checkin-Locked:\n> > Now I really don't like this combination.  It introduces nastiness \n> > like \"CHECKOUT, PUT, LOCK, UNLOCK\", with the spec potentially\n> > implying that the UNLOCK would require a CHECKIN.  It is\n> > OK if this state is explicitly ruled illegal, or if the\n> > Checkin-Locked is defined so that it ONLY comes into play\n> > if the CHECKOUT was done because of a Checkout-Locked\n> > action.\n> >\n> > ! Checkout-Unlocked, Checkin-Unlocked:\n> > CHECKOUT, PUT becomes CHECKOUT, PUT, UNCHECKOUT.  That doesn't make \n> > sense to me, but I was planning on supporting it.  Note that it \n> > doesn't require a separate test case if putEntryStuff leaves the \n> > object in the correct internal state.\n> >\n> > ============================\n> >\n> > Of the 8 possible states, 4 are 'obvious' 3 are 'funny' and 1 is a \n> > really bad idea.  If you retained the current discription (since I \n> > think it might be easier to describe things the current \n> way) but added \n> > the restriction that auto-checkin must be the same value as \n> > auto-checkout that would be OK with me.\n> \n> There's quite a list, you have to consider the initial \n> version-controlled resource being locked or unlocked and \n> checked-in or checked-out together with the combination of \n> valid values (which are DAV:locked-update, \n> DAV:unlocked-update, both, or none).\n> \n> I recall Jim W. wrote out the table a while ago (sorry I \n> can't go and look for it right now).\n> \n> Regards,\n> Tim\n> \n> \n\n\n\n", "id": "lists-006-10643984"}, {"subject": "RE: UNCHECKOUT after automatic checkout", "content": "Obviously I misunderstood the meaning of \"locked-update\" in\n\"DAV:auto-checkin\".  See separate mail already sent on the confusion of that\nsection.\n\nWhat I'm most interested in is a server that will checkout/checkin if a\nclient does a PUT outside the context of a lock.  But it will\ncheckout/checkin only once for a series of PUT requests inside the context\nof a lock.  Tim says that would be the case if \"DAV:auto-checkin\" has a\nvalue of \"unlocked-update\".\n\nSo to confirm:  A client can legally perform this sequence of commands on a\nsingle resource:\n\n1. LOCK version-controlled resource\n2. verify that VCR has \"locked-update\" in DAV:auto-checkout and\n\"unlocked-update\" in DAV:auto-checkin\n3. PUT\n4. UNCHECKOUT\n\nOther than the confusion over the meaning of DAV:auto-checkin, the spec\nought to say that an automatic checkout can be checked-in or unchecked-out\nmanually.\n\nNext question reserved for a different mail!\n\nLisa\n\n>\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Tim Ellison\n> Sent: Thursday, July 12, 2001 3:48 AM\n> To: DeltaV\n> Subject: Re: UNCHECKOUT after automatic checkout?\n>\n>\n>\n> \"Lisa Dusseault\" <lisa@xythos.com> wrote:\n>\n> > Can a client do this sequence of commands to a single resource?\n> >\n> > 1. LOCK version-controlled resource\n>\n> This would acquire the lock.\n>\n> > 2. verify that VCR has \"locked-update\" in DAV:auto-checkout and\n> > \"locked-update\" in DAV:auto-checkin\n>\n> Ok.\n>\n> > 3. PUT\n>\n> Assuming the lock token passed with the request was ok, this PUT\n> modification request to a locked version-controlled resource would cause:\n> (1) the resource to be first checked-out, due to DAV:auto-checkout being\n> DAV:locked-update,\n> (2) the PUT method to be applied,\n> (3) the resource to be checked-in, due to the resource being auto-checked\n> out (in step (1)) and DAV:auto-checkin being DAV:locked-update.\n>\n> (i.e. CHECKOUT, PUT, CHECKIN)\n>\n> The end result is a checked-in version-controlled resource and a new\n> version resource.\n>\n> > 4. UNCHECKOUT\n>\n> This would fail with a\n> <DAV:must-be-checked-out-version-controlled-resource>\n>\n>\n> > Obviously this would have to be a versioning-aware client, relying\n> > on the auto-checkout and auto-checkin behaviour of the server to do\n> > the checkout, but able to override the server to cancel the checkout.\n>\n> If the DAV:auto-checkin had not been DAV:locked-update then the client\n> could cancel the checkout.\n>\n> > The advantage of the scenario is that it is fewer commands.  I don't\n> > see any reason that the spec would not allow this scenario -- I wanted\n> > to point it out so that server implementors could be sure to test it.\n>\n>\n> Regards,\n> Tim\n\n\n\n", "id": "lists-006-10656955"}, {"subject": "Manual checkout, automatic checkin", "content": "I'm interested in having a server which does smart versioning even in the\npresence of non-versioning clients.  Thus:\n\nServer will checkout/checkin if a client does a PUT outside the context of a\nlock.  Server will checkout/checkin only once for a series of PUT requests\ninside the context of a lock.\nServer supports CHECKOUT, CHECKIN, UNCHECKOUT for sophisticated clients.\n\nNow my problem is what behaviour will the client expect if the server\nsupports all these features, and the client does an UNLOCK or a PUT on a\nchecked-out resource?  E.g.\n\n - CHECKOUT foo\n - LOCK foo\n - PUT foo\n - UNLOCK foo  --> the resource should now still be checked out, right?\n\nSection 3.2.3. seems to state that an automatic checkin is only done if the\ncheckout was also automatic.  (That forces servers to keep track of how the\ncheckout was done, but that seems desirable considering the alternatives).\n\nBut Tim's latest mail said that automatic checkouts can be manually\noverridden or checked in.\n\nIs this intentional, or is it inconsistent?\n\nLisa\n\n\n\n", "id": "lists-006-10668348"}, {"subject": "RE: auto-checkout and auto-checki", "content": "> It was simpler, but some folk complained that their use case was not\n> satisfied by it.  I recall the \"make the lifetime of the\n> check-out the same\n> as that of the lock\" as a reasonable request, but the others I forget.\n\nThen let's clearly identify the use cases and satisfy them, or at least the\nimportant ones.  The current spec for the behaviour has now allowed for\nTHREE independent interpretations (Tim's, John's, mine) and puts a\nhorrendous burden on the client to understand the effect of any possible\ncombination that the server might have for these two properties and their\nthree or four possible values.\n\nI know of two use cases so far that I believe people are actually going to\nimplement:\n\nA.  No auto-versioning is done.\nB.  Server auto-versions once for every lock/unlock that included at least\none write operation.  Server auto-versions once for every write operation\nthat isn't part of a lock.\n\nI recall there was at least one other in way this used to be done (before\nbreaking it into two separate properties), but I don't have an old version\nof the draft handy.\n\nLisa\n\n\n\n", "id": "lists-006-10676309"}, {"subject": "RE: Postconditions with no XML elements defined", "content": "Lisa:\n   If there are no strong objections, I propose that we adopt the simple\n   normative rule a precondition is returned with 403 and a postcondition \nis\n   returned with 409.\n\nGeoff:\nI'd fall into the \"strong objection\" camp.  403 means the user should\nnot retry the operation, because it will never succeed.  This will\nsometimes be the case for both precondition and postcondition\nfailures.  409 means that there is something the user could do to the\nresource to make the operation succeed.  This will also sometimes be\nthe case for both precondition and postcondition failures.\n\nJim:\nI agree with Geoff. It would be nice to have a consistent, simple rule \ndistinguishing 403 and 409 that could be applied in all circumstances, but \nthis would not account for useful variability across, or perhaps even \nwithin servers. Interoperability won't suffer because the marshalling is \nthe same, both are client error condidtions, and the semantics of the \ndistinction between them is well specified by HTTP in a way that clients \ncan make use of.\n\n\n\n", "id": "lists-006-10684943"}, {"subject": "RE: auto-checkout and auto-checki", "content": "> -----Original Message-----\n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Lisa \n> Dusseault\n\n> The current spec for the \n> behaviour has now allowed for THREE independent \n> interpretations (Tim's, John's, mine) and puts a horrendous \n> burden on the client to understand the effect of any possible \n> combination that the server might have for these two \n> properties and their three or four possible values.\n\nI don't think the wording of the spec caused my error.  It was an\nassumption that 'obviously' such a feature would work such and such a\nway.\n\n\n\n", "id": "lists-006-10693478"}, {"subject": "RE: Postconditions with no XML elements defined", "content": "OK, I buy this reasoning.  Thanks.\n\nLisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> Sent: Thursday, July 12, 2001 10:32 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Postconditions with no XML elements defined?\n>\n>\n> Lisa:\n>    If there are no strong objections, I propose that we adopt the simple\n>    normative rule a precondition is returned with 403 and a postcondition\n> is\n>    returned with 409.\n>\n> Geoff:\n> I'd fall into the \"strong objection\" camp.  403 means the user should\n> not retry the operation, because it will never succeed.  This will\n> sometimes be the case for both precondition and postcondition\n> failures.  409 means that there is something the user could do to the\n> resource to make the operation succeed.  This will also sometimes be\n> the case for both precondition and postcondition failures.\n>\n> Jim:\n> I agree with Geoff. It would be nice to have a consistent, simple rule\n> distinguishing 403 and 409 that could be applied in all\n> circumstances, but\n> this would not account for useful variability across, or perhaps even\n> within servers. Interoperability won't suffer because the marshalling is\n> the same, both are client error condidtions, and the semantics of the\n> distinction between them is well specified by HTTP in a way that clients\n> can make use of.\n\n\n\n", "id": "lists-006-10701956"}, {"subject": "Re: Question: after the current stat", "content": "Dr. Helmut,\nIt is possible that the DeltaV specification will be promoted to proposed \nstandard within the next six months. The members of the working group are \ncertainly working towards that goal. See the DeltaV working group charter \nfor details at http://www.ietf.org/html.charters/deltav-charter.html.\n\nThere are a number of WebDAV versioning servers under development \nincluding a number of open source projects. You can find all the latest \ninformation about WebDAV at www.webdav.org. And thank you for you interest \nin DeltaV.\n\n\n\n\n\n\"Dr. Helmut Ackermann\" <helmut.ackermann@gauss-interprise.com>\nSent by: ietf-dav-versioning-request@w3.org\n07/09/2001 11:35 AM\nPlease respond to hac\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        Question: after the current state\n\n \n\nHello,\n\nI would like to ask, whether we can expect, that your internet draft\nwill be released as official RFC within the next six month.\nAre there any products (server and clients) which will implement the\nversioning protocol soon?\n\n\nMit freundlichen Gr??en / Best regards\n \nDr. Helmut Ackermann\n \n-----------------------------------------------------------\nResearch & Development\nGauss Interprise AG, \nWeidestr. 120a, \nD-22083 Hamburg\n \nPhone: +49-40-3250-1232\nEmail: mailto:helmut.ackermann@gauss-interprise.com\nWeb:   http://www.gauss-interprise.com/\n\n\n\n", "id": "lists-006-10711432"}, {"subject": "RE: Versioning and Lock Null resource", "content": "The resolution I recorded was that DeltaV would remain silent\nuntil the status of lock null resources was resolved by the\nWebDAV working group.  The most recent word on this in the\nWebDAV mailing list was:\n\n----------------------------------------------------------------------------\n-\n\nDEFER_LOCK_NULL_RESOURCES_IN_SPEC\n\nProposal to remove lock null resources from the spec until we are motivated\nto have them or something equivalent.  In the meantime, keep the spec\nsilent on the topic in order to avoid precluding LNR or the equivalent in a\nfuture version of WebDAV.\n------------------------------------------------------------------\n\nTo me, this supports the current resolution to remain silent in the\nDeltaV draft on the topic of lock null resources.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Thursday, July 12, 2001 12:28 AM\nTo: DeltaV\nSubject: Versioning and Lock Null resources\n\n\n\nI haven't seen a resolution to DeltaV's lock null resource issues.\n\nCan a client issue the following requests on a lock null resource:\n - VERSION-CONTROL\n - MKACTIVITY\n - MKWORKSPACE\n - BASELINE-CONTROL\n\nSpecifically, one might imagine a client trying to create a new versionable\nresource and work with it by attempting the following sequence:  LOCK,\nVERSION-CONTROL, CHECKOUT, PUT (etc), CHECKIN, UNLOCK\n\nLisa\n\n\n\n", "id": "lists-006-10720936"}, {"subject": "Auto update of VCR when checking an associated working resourc", "content": "(sorry for the long, and perhaps confusing title)\n\nOn the versioning teleconference call, 6/29/01, the participating working \ngroup members reached consensus on the following approach to updating a \nversion-controlled-resource on checkin of a working resource that was \ncreated by checking out the version-controlled-resource with \nDAV:apply-to-version.\n\nI would like get a sense if the rest of the working group agrees with this \nproposal. I think it makes sense as the result of checking out a VCR, \nmodifying what you checked out, and checking it back in is the same \nregardless of where and how the state of the updated resource was managed, \non the client or on the server, with or without a working resource. It \ndoes mean changes to the spec, but this seems to be within the boundary of \nwhat's reasonable to do now. What do you think?\n\nHere's the proposal from the teleconference:\n\nWhen you apply CHECKOUT directly to a version URL, the semantics of\nthe protocol are unchanged (so if you liked the old semantics and\ndidn't want any auto-update on checkin, you would always apply\nCHECKOUT directly to a version URL\n\nWhen you apply CHECKOUT with a DAV:apply-to-version flag to a VCR, you\ncreate a working resource whose DAV:checked-out version is the\nDAV:checked-in version of the VCR (as is required currently), but\nwhich now also has a protected DAV:auto-update property which contains\nthe URL of the VCR that was checked out.  (This requires one new\npostcondition for the CHECKOUT semantics in the working-resource\nfeature).\n\nThe MOVE operation is required to update the DAV:auto-update property\nif the VCR is moved (or it can fail the MOVE), so the DAV:auto-update\nproperty is always valid.  (This requires one new postcondition\nfor the MOVE semantics in the working-resource feature).\n\nWhen you CHECKIN a working resource with a DAV:auto-update property,\nthe CHECKIN fails if the DAV:checked-out property of the working\nresource does not match the DAV:checked-in property of the VCR.\nIf the CHECKIN succeeds, the VCR identified by the DAV:auto-update\nmust have been updated to have the content and dead properties\nof the new version, and the DAV:checked-in version of the VCR\nmust have been updated to identify the new version.  (This requires\none new precondition and one new postcondition for the CHECKIN\nsemantics in the working-resource feature).\n\n\n\n", "id": "lists-006-10729435"}, {"subject": "RE: Auto update of VCR when checking an associated working resourc", "content": "I'm in favour of this.\n\nOne addendum:  if the server does NOT support the UPDATE method, then the\nclient MUST include the DAV:auto-update property in the CHECKIN request.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> Sent: Thursday, July 12, 2001 1:37 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: Auto update of VCR when checking an associated working resource\n>\n>\n>\n> (sorry for the long, and perhaps confusing title)\n>\n> On the versioning teleconference call, 6/29/01, the participating working\n> group members reached consensus on the following approach to updating a\n> version-controlled-resource on checkin of a working resource that was\n> created by checking out the version-controlled-resource with\n> DAV:apply-to-version.\n>\n> I would like get a sense if the rest of the working group agrees\n> with this\n> proposal. I think it makes sense as the result of checking out a VCR,\n> modifying what you checked out, and checking it back in is the same\n> regardless of where and how the state of the updated resource was\n> managed,\n> on the client or on the server, with or without a working resource. It\n> does mean changes to the spec, but this seems to be within the\n> boundary of\n> what's reasonable to do now. What do you think?\n>\n> Here's the proposal from the teleconference:\n>\n> When you apply CHECKOUT directly to a version URL, the semantics of\n> the protocol are unchanged (so if you liked the old semantics and\n> didn't want any auto-update on checkin, you would always apply\n> CHECKOUT directly to a version URL\n>\n> When you apply CHECKOUT with a DAV:apply-to-version flag to a VCR, you\n> create a working resource whose DAV:checked-out version is the\n> DAV:checked-in version of the VCR (as is required currently), but\n> which now also has a protected DAV:auto-update property which contains\n> the URL of the VCR that was checked out.  (This requires one new\n> postcondition for the CHECKOUT semantics in the working-resource\n> feature).\n>\n> The MOVE operation is required to update the DAV:auto-update property\n> if the VCR is moved (or it can fail the MOVE), so the DAV:auto-update\n> property is always valid.  (This requires one new postcondition\n> for the MOVE semantics in the working-resource feature).\n>\n> When you CHECKIN a working resource with a DAV:auto-update property,\n> the CHECKIN fails if the DAV:checked-out property of the working\n> resource does not match the DAV:checked-in property of the VCR.\n> If the CHECKIN succeeds, the VCR identified by the DAV:auto-update\n> must have been updated to have the content and dead properties\n> of the new version, and the DAV:checked-in version of the VCR\n> must have been updated to identify the new version.  (This requires\n> one new precondition and one new postcondition for the CHECKIN\n> semantics in the working-resource feature).\n\n\n\n", "id": "lists-006-10739588"}, {"subject": "RE: AW: Removing the DAV:activity and DAV:version-history and DAV:baseline resource type value", "content": "Tim said:\n> So, if we are to continue this use of DAV:resourcetype it would be to give\n> clients a useful classification of a resource at a particular\n> point in time\n> that would give them a reasonable set of data for displaying an icon,\n> greying menu items and so on.  It should convey both versioning 'type' and\n> 'state' that is within the mandate of WebDAV.  The specification has\n> already called out a number of useful resource classifications\n> and they are\n> the ones that I proposed (DAV:checked-in _and_ DAV:checked-out may be\n> redundant).\n\nIn common usage, \"type\" is somewhere else along the range of persistence\nfrom \"state\".  A couple thoughts on how you can tell the difference:\n\n - When things can change state, it's because they're supposed to, so we\ngive a way to check out something that's checked in and vice versa.  WebDAV\ndoes NOT give a way to turn a collection into a regular resource -- clients\nhave to _remove_ the resource -- completely taking away its existence -- and\nreplace it with a resource of a different type.  The only sense in which\nthat operation \"changes the type\" of a collection is that it is an entity\nthat shares the same name as the previous entity -- but no other continuity.\nDeltaV _does_ blur the line by adding a VERSION-CONTROL method to turn a\nregular resource into a VCR, however, this method performs drastic surgery,\nwith the side effect of up to three resources being created.  Many servers\nwill only support version-controlled resources, and thus not allow the\ntransformation in either direction.\n\n - States are used as adjectives.   A \"checked-out version-controlled\nresource\" isn't a type, it's a type with a state modifier.  I think\nintuitively we use the language correctly:  we abbreviate VCR, VR, and VHR\nto define different types of resources, but we don't through the state\nadjectives in to have COVCR and CIVCR.\n\n - State changes more frequently than type.  A typical VCR will have its\nchecked-in and checked-out state change MUCH more frequently than its type.\n\nI understand that this is one of many situations where there is not a clear,\nfine line between two things.  You can certainly blur the distinction if you\nchoose by attacking any one of my arguments, or all.  That does not prove\nthat we should clump them together.  Humans are capable of fuzzy\ndistinctions, and these are useful to us, even if not to the software we\nwrite.\n\nMy argument is to apply common notions to decide what different types need\nto be called out in resourcetype.  IMHO, checked-in/checked-out is a state,\nnot a type.\n\nlisa\n\n\n\n", "id": "lists-006-1075165"}, {"subject": "RE: UNCHECKOUT after automatic checkout", "content": "Lisa wrote:\n> So to confirm:  A client can legally perform this sequence of \n> commands on a\n> single resource:\n> \n> 1. LOCK version-controlled resource\n> 2. verify that VCR has \"locked-update\" in DAV:auto-checkout and\n> \"unlocked-update\" in DAV:auto-checkin\n> 3. PUT\n> 4. UNCHECKOUT\n\nI agree this is legal.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10751797"}, {"subject": "RE: Auto update of VCR when checking an associated working resourc", "content": "Lisa wrote:\n> I'm in favour of this.\n>\n> One addendum:  if the server does NOT support the UPDATE method, then the\n> client MUST include the DAV:auto-update property in the CHECKIN request.\n\n(The DAV:auto-update property is on the working resource).  I don't want to\nmake it mandatory since there are cases where creating a version that does\nnot update the version-controlled resource is desirable.\nWithout UPDATE it would only be 'referenceable'(ahem) by the version URL.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10759016"}, {"subject": "RE: Manual checkout, automatic checkin", "content": "Lisa wrote:\n\n> Server will checkout/checkin if a client does a PUT outside the\n> context of a lock.\n\nSo that would be:\n  DAV:auto-checkout includes DAV:unlocked-update\n  DAV:auto-checkin includes DAV:unlocked-update\n\ni.e., if the resource is not locked but is checked-in, a PUT does a\nCHECKOUT, PUT, CHECKIN.\n\n> Server will checkout/checkin only once for a series of PUT requests\n> inside the context of a lock.\n\nSo that would be:\n  DAV:auto-checkout includes DAV:locked-update\n  DAV:auto-checkin includes DAV:unlocked-update\n\ni.e., if the resource is locked and checked-in, a PUT does a CHECKOUT, PUT.\nSubsequent PUTs are just PUT to the checked-out version-controlled resource,\nand some time later when the lock is removed by UNLOCK (or timeout) the\nresource is CHECKIN'd.\n\nSo to get both together you have the following properties' values:\n  <DAV:auto-checkout>\n     <DAV:unlocked-update/>\n     <DAV:locked-update/>\n  </DAV:auto-checkout>\n  <DAV:auto-checkin>\n     <DAV:unlocked-update/>\n  </DAV:auto-checkin>\n\n> Server supports CHECKOUT, CHECKIN, UNCHECKOUT for sophisticated clients.\n\nCool.\n\n> Now my problem is what behaviour will the client expect if the server\n> supports all these features, and the client does an UNLOCK or a PUT on a\n> checked-out resource?  E.g.\n\nAssume we start with an unlocked, checked-in version-controlled resource:\n\n>  - CHECKOUT foo\n\nResults in an unlocked, checked-out version-controlled resource.\n\n>  - LOCK foo\n\nIt's now a locked, checked-out version-controlled resource.\n\n>  - PUT foo\n\nStill locked and checked-out but with new content.\n\n>  - UNLOCK foo  --> the resource should now still be checked out, right?\n\nYes, it would simply be unlocked, checked-out with the new content.\n\n> Section 3.2.3. seems to state that an automatic checkin is only\n> done if the checkout was also automatic.  (That forces servers\n> to keep track of how the checkout was done, but that seems\n> desirable considering the alternatives).\n\nAgreed.\n\n> But Tim's latest mail said that automatic checkouts can be manually\n> overridden or checked in.\n>\n> Is this intentional, or is it inconsistent?\n\nIt is intentional.  Can you explain why you think it is inconsistent?\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10767144"}, {"subject": "RE: Auto update of VCR when checking an associated working resourc", "content": "One addendum: \nExplicitly point out that if the CHECKIN on the VCR fails, the client\nwould have to do a CHECKIN of the working resource followed by a MERGE\nor UPDATE to retry the operation.\n\n \n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Lisa \n> Dusseault\n> Sent: Thursday, July 12, 2001 2:57 PM\n> To: Jim Amsden; ietf-dav-versioning@w3.org\n> Subject: RE: Auto update of VCR when checking an associated \n> working resource \n> \n> \n> I'm in favour of this.\n> \n> One addendum:  if the server does NOT support the UPDATE \n> method, then the client MUST include the DAV:auto-update \n> property in the CHECKIN request.\n> \n> lisa\n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> > Sent: Thursday, July 12, 2001 1:37 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: Auto update of VCR when checking an associated working \n> > resource\n> >\n> >\n> >\n> > (sorry for the long, and perhaps confusing title)\n> >\n> > On the versioning teleconference call, 6/29/01, the participating \n> > working group members reached consensus on the following \n> approach to \n> > updating a version-controlled-resource on checkin of a working \n> > resource that was created by checking out the \n> > version-controlled-resource with DAV:apply-to-version.\n> >\n> > I would like get a sense if the rest of the working group \n> agrees with \n> > this proposal. I think it makes sense as the result of \n> checking out a \n> > VCR, modifying what you checked out, and checking it back in is the \n> > same regardless of where and how the state of the updated \n> resource was\n> > managed,\n> > on the client or on the server, with or without a working \n> resource. It\n> > does mean changes to the spec, but this seems to be within the\n> > boundary of\n> > what's reasonable to do now. What do you think?\n> >\n> > Here's the proposal from the teleconference:\n> >\n> > When you apply CHECKOUT directly to a version URL, the semantics of \n> > the protocol are unchanged (so if you liked the old semantics and \n> > didn't want any auto-update on checkin, you would always apply \n> > CHECKOUT directly to a version URL\n> >\n> > When you apply CHECKOUT with a DAV:apply-to-version flag to \n> a VCR, you \n> > create a working resource whose DAV:checked-out version is the \n> > DAV:checked-in version of the VCR (as is required currently), but \n> > which now also has a protected DAV:auto-update property \n> which contains \n> > the URL of the VCR that was checked out.  (This requires one new \n> > postcondition for the CHECKOUT semantics in the working-resource \n> > feature).\n> >\n> > The MOVE operation is required to update the \n> DAV:auto-update property \n> > if the VCR is moved (or it can fail the MOVE), so the \n> DAV:auto-update \n> > property is always valid.  (This requires one new postcondition for \n> > the MOVE semantics in the working-resource feature).\n> >\n> > When you CHECKIN a working resource with a DAV:auto-update \n> property, \n> > the CHECKIN fails if the DAV:checked-out property of the working \n> > resource does not match the DAV:checked-in property of the \n> VCR. If the \n> > CHECKIN succeeds, the VCR identified by the DAV:auto-update \n> must have \n> > been updated to have the content and dead properties of the new \n> > version, and the DAV:checked-in version of the VCR must have been \n> > updated to identify the new version.  (This requires one new \n> > precondition and one new postcondition for the CHECKIN semantics in \n> > the working-resource feature).\n> \n> \n> \n\n\n\n", "id": "lists-006-10776275"}, {"subject": "RE: Auto update of VCR when checking an associated working resourc", "content": "So are we back to saying that supporting Working Resource feature requires\nalso supporting UPDATE?  That's what I'm trying to avoid.  Is there a better\nway for these two features to not depend on each other?\n\nFurthermore, it's surprising to me, and perhaps to clients as well, that\nworking resource checkins and in-place checkins work so differently: one\nends up with the VCR pointing to the latest version at the end, and the\nother doesn't (by default).  I would expect the default behaviour of both of\nthese to be the same.\n\nPerhaps Jim's proposal could instead be worded so that auto-update was the\ndefault, and \"do not update\" is the exceptional behaviour that the client\nmust request.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Tim Ellison\n> Sent: Thursday, July 12, 2001 3:36 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Auto update of VCR when checking an associated working\n> resource\n>\n>\n> Lisa wrote:\n> > I'm in favour of this.\n> >\n> > One addendum:  if the server does NOT support the UPDATE\n> method, then the\n> > client MUST include the DAV:auto-update property in the CHECKIN request.\n>\n> (The DAV:auto-update property is on the working resource).  I\n> don't want to\n> make it mandatory since there are cases where creating a version that does\n> not update the version-controlled resource is desirable.\n> Without UPDATE it would only be 'referenceable'(ahem) by the version URL.\n>\n> Regards,\n> Tim\n\n\n\n", "id": "lists-006-10790327"}, {"subject": "RE: Auto update of VCR when checking an associated working resourc", "content": "\"Lisa Dusseault\" <lisa@xythos.com> wrote:\n\n> So are we back to saying that supporting Working Resource\n> feature requires also supporting UPDATE?  That's what I'm\n> trying to avoid.  Is there a better way for these two\n> features to not depend on each other?\n\nNo I'm not saying that.  I have an application in mind that creates\nversions and doesn't update any version-controlled resource.  It always\nreferences the versions by their version URL.  In this case there is no\nneed for DAV:auto-update or an UPDATE method, so I would object to making\nthem required.\n\n> Furthermore, it's surprising to me, and perhaps to clients\n> as well, that working resource checkins and in-place\n> checkins work so differently: one ends up with the VCR\n> pointing to the latest version at the end, and the other\n> doesn't (by default).  I would expect the default behaviour\n> of both of these to be the same.\n\nIn the case of a working resource created directly from a version, there is\nno version-controlled resource to update on CHECKIN.  So it doesn't seem\ntoo surpising to me, but whatever.\n\n> Perhaps Jim's proposal could instead be worded so that\n> auto-update was the default, and \"do not update\" is the\n> exceptional behaviour that the client must request.\n\nThat would require setting the DAV:auto-update value, or passing in the URL\nof the version-controlled resource during CHECKIN.  I prefer to leave the\nproposal as is.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-10800670"}, {"subject": "Semantics of supported-", "content": "I'll take the definition of supported-method-set for an example:\n\n\"This property identifies the methods that are supported by the resource.  A\nmethod is supported by a resource if an application of that method to that\nresource has the semantics defined by the features supported by that\nresource.\"\n\nThis is better than it used to be, but it's still not clear to me whether\nthis is dependent on state (which can get us into the ugly state vs. type\ndebate).\n\nE.g.  does CHECKIN show up for a checked-in VCR, or only for a checked-out\nVCR?  Does LOCK show up for a locked VCR, or only an unlocked VCR?\n\nI assume that the answer to this will be consistent for\nsupported-live-property-set and supported-report-set.\n\nLisa\n\n\n\n", "id": "lists-006-10810388"}, {"subject": "RE: Auto update of VCR when checking an associated working resourc", "content": "> > So are we back to saying that supporting Working Resource\n> > feature requires also supporting UPDATE?  That's what I'm\n> > trying to avoid.  Is there a better way for these two\n> > features to not depend on each other?\n>\n> No I'm not saying that.  I have an application in mind that creates\n> versions and doesn't update any version-controlled resource.  It always\n> references the versions by their version URL.  In this case there is no\n> need for DAV:auto-update or an UPDATE method, so I would object to making\n> them required.\n\nThat really badly serves the purposes of non-versioning clients.  The server\ncan't interact with those clients in your scenario, because those clients\nwould always just GET the VCR, and end up with the root version instead of\nthe latest versions.\n\nLet me phrase the problem in these terms, I must find a solution to: How do\nI write a server implementation that\n - supports Working Resources\n - supports non-versioning clients\n\nSome of the assumptions I've made in framing this problem are that\n - UPDATE is not supported\n - I may not be able to rely on versioning-aware clients to use the\nauto-update flag in CHECKIN.  I don't know how to send an error if they\ndon't use this flag.\n - It's the wrong thing to always show non-versioning clients the root\nversion.  They will never have the opportunity to see the latest version.\n\nLisa\n\n\n\n", "id": "lists-006-10818036"}, {"subject": "Auto Updat", "content": "Actually, it isn't quite that bad, Lisa.\n\nAssume that we use the auto-update feature as written.\n\nThen, a server that doesn't support UPDATE should fail the checkout of a\nversion vs. the checkout of a VCR.\n\nIn other words:\nCHECKOUT of VCR without <apply-to-version> does a IN-PLACE CHECKOUT.\nCHECKOUT of VCR with    <apply-to-version> does a WORKING-RESOURCE\nCHECKOUT, and UPDATE isn't required.\nCHECKOUT of Version MAY fail, if UPDATE isn't supported AND 'CHECKOUT\nwithout UPDATE' isn't supported.\n\nSo it would be nice to have a post condition on CHECKOUT of a VERSION\nwhich said:\n<checkout-of-version-forbidden>  \n- A Server that supports WORKING-RESOURCE but not UPDATE MAY prohibit\nthe checkout of a version.  Use CHECKOUT with <apply-to-version> on the\nVCR.\n\n\nThat postcondition makes the WORKING-RESOURCE with the <auto-update>\nproposal independent of UPDATE.  It would also make it clear that this\nparticular server did not believe in creating versions that did not\nupdate VCR's.\n\nNote: part of the problem is that Tim has an application in mind that\ncreates versions and doesn't update any version-controlled resource.\nOur imaginination isn't that large, and we aren't interested in\nsupporting that application.\n\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Lisa \n> Dusseault\n> \n> > > So are we back to saying that supporting Working Resource feature \n> > > requires also supporting UPDATE?  That's what I'm trying \n> to avoid.  \n> > > Is there a better way for these two features to not \n> depend on each \n> > > other?\n> >\n> > No I'm not saying that.  I have an application in mind that creates \n> > versions and doesn't update any version-controlled resource.  It \n> > always references the versions by their version URL.  In this case \n> > there is no need for DAV:auto-update or an UPDATE method, \n> so I would \n> > object to making them required.\n> \n> That really badly serves the purposes of non-versioning \n> clients.  The server can't interact with those clients in \n> your scenario, because those clients would always just GET \n> the VCR, and end up with the root version instead of the \n> latest versions.\n> \n> Let me phrase the problem in these terms, I must find a \n> solution to: How do I write a server implementation that\n>  - supports Working Resources\n>  - supports non-versioning clients\n> \n> Some of the assumptions I've made in framing this problem are that\n>  - UPDATE is not supported\n>  - I may not be able to rely on versioning-aware clients to \n> use the auto-update flag in CHECKIN.  I don't know how to \n> send an error if they don't use this flag.\n>  - It's the wrong thing to always show non-versioning clients \n> the root version.  They will never have the opportunity to \n> see the latest version.\n> \n> Lisa\n> \n> \n> \n\n\n\n", "id": "lists-006-10827407"}, {"subject": "Quick Question: Determine support of IN-PLACE CHECKOUT", "content": "If the server supports WORKING-RESOURCE, how does the client know that\nit also supports CHECKOUT-IN-PLACE (other than trying to do a CHECKOUT\non a VCR without <apply-to-version> and getting an undefined error?\n\nNote that WORKING-RESOURCE section #9 says that the OPTIONS must return\n\"working-resource\" but is silent on \"checkout\".  How can that be right,\nwhen you must use the verb CHECKOUT to use WORKING-RESOURCE?\n\nProposal:\n4.5:\nMUST include \"checkout-inplace\", \"checkin\", \"checkout\".\n\n9.5:\nMUST include \"working-resource\", \"checkin\", \"checkout\".\n\n\n\n", "id": "lists-006-10838490"}, {"subject": "Modified: Auto update of VCR when checking an associated working resourc", "content": "The modifications are intended to:\n1) Allow a client to recover if the auto-update fails.  By clearing the\nauto-update value, a second CHECKIN would work just like it does now,\nand the client would have to followup with a UPDATE or MERGE.\n2) My server would never fail the auto-update, because I don't allow\nforking.\n3) The new precondition is designed to let a client know that a server\nONLY supports WORKING-RESOURCES with the auto-update feature.\n\n===========================\n\nHere's the proposal from the teleconference:\n\nWhen you apply CHECKOUT directly to a version URL, the semantics of the\nprotocol are unchanged (so if you liked the old semantics and didn't\nwant any auto-update on checkin, you would always apply CHECKOUT\ndirectly to a version URL.  \n\n[johnhall: There is a new pre-condition: <checkout-of-version-forbidden>\n- A Server that supports WORKING-RESOURCE but not UPDATE MAY prohibit\nthe checkout of a version.  Use CHECKOUT with <apply-to-version> on the\nVCR.]\n\nWhen you apply CHECKOUT with a DAV:apply-to-version flag to a VCR, you\ncreate a working resource whose DAV:checked-out version is the\nDAV:checked-in version of the VCR (as is required currently), but which\nnow also has a protected DAV:auto-update property which contains the URL\nof the VCR that was checked out.  (This requires one new postcondition\nfor the CHECKOUT semantics in the working-resource feature).\n\nThe MOVE operation is required to update the DAV:auto-update property if\nthe VCR is moved (or it can fail the MOVE), so the DAV:auto-update\nproperty is always valid.  (This requires one new postcondition for the\nMOVE semantics in the working-resource feature).\n\nWhen you CHECKIN a working resource with a DAV:auto-update property, the\nCHECKIN fails if the DAV:checked-out property of the working resource\ndoes not match the DAV:checked-in property of the VCR. [johnhall: if the\nCHECKIN fails the auto-update field is cleared, returning the working\nresource to the condition it would have had if the CHECKOUT had been\napplied directly to a version URL.]  If the CHECKIN succeeds, the VCR\nidentified by the DAV:auto-update must have been updated to have the\ncontent and dead properties of the new version, and the DAV:checked-in\nversion of the VCR must have been updated to identify the new version.\n(This requires one new precondition and one new postcondition for the\nCHECKIN semantics in the working-resource feature).\n\n\n\n", "id": "lists-006-10847372"}, {"subject": "RE: auto-checkout and auto-checki", "content": "Clearly there is significant support for going back to\nDAV:auto-version (as opposed to DAV:auto-checkout,DAV:auto-checkin).\nIf nobody objects to going back to DAV:auto-version , I'm willing to\ndo so (I believe I was the most enthusiastic supporter of the original\nswitch to auto-checkout and auto-checkin).\n\nThe values for DAV:auto-version would be:\n\nDAV:always-checkout-always-checkin\nDAV:always-checkout-unlocked-checkin\nDAV:always-checkout\nDAV:locked-checkout\n\nNote: an auto-checkout of a locked resource is always\nchecked in when the lock is removed, unless it has already\nbeen automatically checked in or explicitly checked in \nor unchecked out.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10857766"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "If you believe that whether a resource is under version control or not, is a\nmatter of state, then leave it OUT of resourcetype.  It's not called\n\"resourcestate\".\n\nVersion, version History, and others are still types.\n\nBut draw a line somewhere.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, June 06, 2001 8:07 AM\n> To: DeltaV (E-mail)\n> Subject: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:bas eline resource type values\n>\n>\n> I think Tim's point was that if \"under version control\"\n> (e.g. \"version-controlled-resource\") is part of\n> the \"type\" of a resource, then \"checked-out\" and \"checked-in\"\n> would equally usefully be considered as part of the type\n> (since the significantly affect what methods can be\n> applied to that resource).\n>\n> In each case, you have the same resource (i.e. when you\n> put a resource under version control, it is the same resource\n> but has some additional live properties and methods you can\n> apply to it).\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n> Sent: Wednesday, June 06, 2001 6:27 AM\n> To: DeltaV (E-mail)\n> Subject: AW: Removing the DAV:activity and DAV:version-history and DAV\n> :baseline resource type values\n>\n>\n>\n>\n> > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von\n> > Tim_Ellison@uk.ibm.com\n> > [...]\n> >\n> > My view of the world...\n> >\n> > Here's the list of elements that could appear in a\n> DAV:resourcetype.  Some\n> > of these can be combined to provide a really meaningful\n> experience for the\n> > client.  Obviously, some combinations are invalid.\n> >      <DAV:checked-in/>\n> >      <DAV:checked-out/>\n> >      <DAV:collection/>\n> >      <DAV:working-resource/>\n> >      <DAV:version-controlled-resource/>\n> >      <DAV:version/>\n> >      <DAV:version-history/>\n> >      <DAV:workspace/>\n> >      <DAV:version-controlled-configuration/>\n> >      <DAV:baseline/>\n> >      <DAV:activity/>\n> >\n>\n> What is your rationale for checked-in/out in the type? I think\n> I have missed something in the spec, since it feels like a\n> property to me.\n>\n> > So,\n> > <DAV:resourcetype>\n> >      <DAV:activity/>\n> > </DAV:resourcetype\n> >\n> > would be good, that is, not surprisingly, an activity resource.\n> >\n> > <DAV:resourcetype>\n> >      <DAV:checked-out/>\n> >      <DAV:version-controlled-resource/>\n> >      <DAV:collection/>\n> >      <DAV:workspace/>\n> > </DAV:resourcetype>\n> >\n> > would be good too, it is a checked-out, version-controlled\n> resource for a\n> > workspace collection.  And so on.\n> >\n> > Tim\n> >\n> >\n\n\n\n", "id": "lists-006-1086377"}, {"subject": "... By the way ..", "content": "As I understand it, there is no way for a client to tell that a working\nresource has been created.\n\nVCR checked in, no working resources have been created.  Server doesn't\nallow forking.  Server supports WORKING-RESOURCE and CHECKOUT-INPLACE.\n\nClientA: CHECKOUT <apply-to-version> VCR.\n=> creates working resource and leaves VCR untouched.\n\nClientB: Since VCR is untouched, it is impossible to detect that CLientA\nhas performed their operation.  Therefore:\nCHECKOUT VCR\n\n=> 409 Conflict\n<checkout-of-checked-out-version-is-forbidden>\n\nIs there some way I'm missing that Client B could have seen this one\ncoming?\n\nCurrently, I don't support forking so only 1 checkout (INPLACE or\nWORKING) is allowed.  But if I did support multiple checkouts, I'd still\nkeep a count so I could tell Client B, that forking was 'discouraged',\nfor example.\n\nAre people implementing this without tracking the count of working\nresources created off the versions of a VCR?\n\n\n\n", "id": "lists-006-10865417"}, {"subject": "RE: Modified: Auto update of VCR when checking an associated work ing resourc", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   I'm in favour of this.\n\n   One addendum:  if the server does NOT support the UPDATE method, then the\n   client MUST include the DAV:auto-update property in the CHECKIN request.\n\nThe DAV:auto-update property is set at CHECKOUT time, not at CHECKIN\ntime.  (I assume when you say \"include the DAV:auto-update property\",\nyou meant \"include a value for the DAV:auto-update property\").\n\n   From: John Hall [mailto:johnhall@evergo.net]\n\n   One addendum: Explicitly point out that if the CHECKIN on the VCR\n   fails, the client would have to do a CHECKIN of the working\n   resource followed by a MERGE or UPDATE to retry the operation.\n\nI assume you meant \"if the CHECKIN of a working resource with\na DAV:auto-update property fails ...\".  The server must fail\na CHECKIN operation if the DAV:auto-update cannot be performed,\nso MERGE and UPDATE are not relevant here.\n\n   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   > From: Tim Ellison\n   > (The DAV:auto-update property is on the working resource).  I\n   > don't want to make it mandatory since there are cases where\n   > creating a version that does not update the version-controlled\n   > resource is desirable.  Without UPDATE it would only be\n   > 'referenceable'(ahem) by the version URL.\n\n   So are we back to saying that supporting Working Resource feature\n   requires also supporting UPDATE?  That's what I'm trying to avoid.\n   Is there a better way for these two features to not depend on each\n   other?\n\nTim is talking about the case where the CHECKOUT was applied to a\nversion URL, and therefore there is no DAV:auto-update property set on\nthe working resource.  This doesn't imply that the working resource\nfeature requires supporting UPDATE.  \n\n   Furthermore, it's surprising to me, and perhaps to clients as well,\n   that working resource checkins and in-place checkins work so\n   differently: one ends up with the VCR pointing to the latest\n   version at the end, and the other doesn't (by default).  I would\n   expect the default behaviour of both of these to be the same.\n\nOne of the primary use cases for a working resource is to allow you\nto create a \"hidden version\", i.e. a version that is not exposed at\na VCR.  This is the natural semantics for checking out a version,\nsince there is no VCR to be updated.  So I believe the protocol\ncurrently provides the \"hidden version\" functionality in a natural\nway.\n\n   Perhaps Jim's proposal could instead be worded so that auto-update\n   was the default, and \"do not update\" is the exceptional behaviour\n   that the client must request.\n\nAuto-update is the default (and only behavior) when you create a\nworking resource by checking out a VCR, and do-not-update is the\ndefault (and only behavior) when you create a working resource by\nchecking out a version.\n\n   From: Lisa Dusseault [mailto:lisa@xythos.com]\n   >\n   > I have an application in mind that creates versions and doesn't\n   > update any version-controlled resource.  It always references the\n   > versions by their version URL.  In this case there is no need for\n   > DAV:auto-update or an UPDATE method, so I would object to making\n   > them required.\n\nNote: Tim is saying that he would object to making DAV:auto-update\nrequired when a version is checked out, and that UPDATE is not required\nsince these are \"hidden\" versions (i.e. versions that will not appear\nin VCR space).  DAV:auto-update is of course required when you are\ncreating a working resource by checking out a VCR.\n\n   That really badly serves the purposes of non-versioning clients.\n   The server can't interact with those clients in your scenario,\n   because those clients would always just GET the VCR, and end up\n   with the root version instead of the latest versions.\n\nIf you want to expose the new states to a non-versioning client, you\nwould of course need to update the VCR, but Tim's scenario did not\ninvolve exposing the new states to non-versioning client.  He's just\nsaying that creating a new version without updating the VCR needs to\nbe possible.\n\n   Let me phrase the problem in these terms, I must find a solution to: How\ndo\n   I write a server implementation that\n    - supports Working Resources\nOK.\n    - supports non-versioning clients\nOK.\n   Some of the assumptions I've made in framing this problem are that\n    - UPDATE is not supported\nOK.\n    - I may not be able to rely on versioning-aware clients to use the\n   auto-update flag in CHECKIN.  I don't know how to send an error if they\n   don't use this flag.\n\nThis is an unreasonable assumption.  The protocol provides well\ndefined responses to well defined requests.  If a client choses\nnot to use the defined protocol, then they should not be surprised\nif they do not get the results defined by the protocol.  If they\nwant the functionality provided by the DAV:apply-to-version flag,\nthey need to use the DAV:apply-to-version flag.  A CHECKIN applied\nto a VCR without the DAV:apply-to-version flag produces\nan in-place checkout.  In-place checkout is the default behavior,\nbecause that is required to support auto-versioning for \nnon-versioning clients.\n\n    - It's the wrong thing to always show non-versioning clients the root\n   version.  They will never have the opportunity to see the latest version.\nThat of course depends on what your client wants to show non-versioning\nclients, but I would agree that a client sometimes wants to show\nnon-versioning clients the state of a non-root version.\n\n   From: John Hall [mailto:johnhall@evergo.net]\n\n   The modifications are intended to:\n   1) Allow a client to recover if the auto-update fails.  By clearing the\n   auto-update value, a second CHECKIN would work just like it does now,\n   and the client would have to followup with a UPDATE or MERGE.\n\nA client can do this by creating a non-auto-update working resource by\nchecking out the appropriate version, copying the auto-update working\nresource to the new working resource, and then checking in the\nnon-auto-update working resource.  I believe keeping the auto-update\nproperty protected (i.e. not modifiable by a client) is more important\nthan saving a round trip in this recovery use case.\n\n   2) My server would never fail the auto-update, because I don't allow\n   forking.\n\nThat is of course fine.\n\n   3) The new precondition is designed to let a client know that a server\n   ONLY supports WORKING-RESOURCES with the auto-update feature.\n\nThis can already be made clear by having CHECKOUT not appear in the\nDAV:supported-method-set of a version resource, and having a 405\nresponse if CHECKOUT is applied to a version resource.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10873600"}, {"subject": "RE: Quick Question: Determine support of IN-PLACE CHECKOUT", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   If the server supports WORKING-RESOURCE, how does the client know\n   that it also supports CHECKOUT-IN-PLACE (other than trying to do a\n   CHECKOUT on a VCR without <apply-to-version> and getting an\n   undefined error?\n\nBy checking whether the  checkout-in-place feature is supported.\n\n   Note that WORKING-RESOURCE section #9 says that the OPTIONS must\n   return \"working-resource\" but is silent on \"checkout\".  How can\n   that be right, when you must use the verb CHECKOUT to use\n   WORKING-RESOURCE?\n\nThis was why we renamed the \"checkout\" feature to be the\n\"checkout-in-place\" feature.\n\n   Proposal:\n   4.5:\n   MUST include \"checkout-inplace\", \"checkin\", \"checkout\".\n   9.5:\n   MUST include \"working-resource\", \"checkin\", \"checkout\".\n\nOK, I see the problem.  I missed a spot where \"checkout\"\nshould have been replaced by \"checkout-in-place\" (i.e.\nin section 4.5).  I'll fix that.  Note that \"checkin\" is no\nlonger a feature, and that \"checkout\" was never a feature\n(they are method names, not features).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10889395"}, {"subject": "RE: Modified: Auto update of VCR when checking an associated work ing resourc", "content": "Geoff took care of my concerns.  I withdraw my proposed modifications.\n\nI believe the solution works for us.\n\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n>    From: John Hall [mailto:johnhall@evergo.net]\n> \n> \n> A client can do this by creating a non-auto-update working \n> resource by checking out the appropriate version, copying the \n> auto-update working resource to the new working resource, and \n> then checking in the non-auto-update working resource.  I \n> believe keeping the auto-update property protected (i.e. not \n> modifiable by a client) is more important than saving a round \n> trip in this recovery use case.\n\nOK -- Fine with me.\n\n>    3) The new precondition is designed to let a client know \n> that a server\n>    ONLY supports WORKING-RESOURCES with the auto-update feature.\n> \n> This can already be made clear by having CHECKOUT not appear \n> in the DAV:supported-method-set of a version resource, and \n> having a 405 response if CHECKOUT is applied to a version resource.\n\nOk, I'll do it that way.  Once I look up what a 405 code is, since I'm\nnew to this.\n\n\n\n", "id": "lists-006-10898401"}, {"subject": "RE: ... By the way ..", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   As I understand it, there is no way for a client to tell that a\n   working resource has been created.\n\n   VCR checked in, no working resources have been created.  Server\n   doesn't allow forking.  Server supports WORKING-RESOURCE and\n   CHECKOUT-INPLACE.\n\n   ClientA: CHECKOUT <apply-to-version> VCR.\n   => creates working resource and leaves VCR untouched.\n\n   ClientB: Since VCR is untouched, it is impossible to detect that\n   CLientA has performed their operation.  Therefore:\n\n   CHECKOUT VCR\n   => 409 Conflict\n   <checkout-of-checked-out-version-is-forbidden>\n\n   Is there some way I'm missing that Client B could have seen this\n   one coming?\n\nUse the DAV:expand-property report to ask for the checkout-set and\ncheckout-fork properties of the checked-in version, i.e.:\n\n<D:expand-property xmlns:D=\"DAV:\">\n <D:property name=\"checked-in\">\n   <D:property name=\"checkout-set\"/>\n   <D:property name=\"checkout-fork\"/>\n </D:property>\n</D:expand-property>\n  \nIf the checkout-set is non-empty and checkout-fork is forbidden,\nyou know the checkout will fail.\n\n   Currently, I don't support forking so only 1 checkout (INPLACE or\n   WORKING) is allowed.  But if I did support multiple checkouts, I'd\n   still keep a count so I could tell Client B, that forking was\n   'discouraged', for example.\n\nYes, if the checkout-fork is discouraged, that would be something\nyou'd want to warn them about (and if they said \"do it anyway\", you\nwould know to include the DAV:fork-ok flag with the CHECKOUT).\n\n   Are people implementing this without tracking the count of working\n   resources created off the versions of a VCR?\n\nThe list of checkouts is important, which is why the server is\nrequired to maintain DAV:checkout-set.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10908156"}, {"subject": "RE: auto-checkout and auto-checki", "content": "Here is the text I would propose for the DAV:auto-version property:\n\n3.2.2DAV:auto-version\n\nIf the DAV:auto-version value is DAV:checkout-checkin, when a\nmodification request (such as PUT/PROPPATCH) is applied to a\nchecked-in version-controlled resource, the request is automatically\npreceded by a checkout and followed by a checkin operation.\n\nIf the DAV:auto-version value is DAV:checkout-unlocked-checkin, when a\nmodification request is applied to a checked-in version-controlled\nresource, the request is automatically preceded by a checkout\noperation.  If the resource is not write-locked, the request is\nautomatically followed by a checkin operation.\n\nIf the DAV:auto-version value is DAV:checkout, when a modification\nrequest is applied to a checked-in version-controlled resource, the\nrequest is automatically preceded by a checkout operation.\n\nIf the DAV:auto-version value is DAV:locked-checkout, when a\nmodification request is applied to a write-locked checked-in\nversion-controlled resource, the request is automatically preceded by\na checkout operation.\n\nIf a write-locked resource was automatically checked out, when the\nwrite lock is removed (such as from an UNLOCK or lock timeout), if the\nresource has not yet been checked in, the removal of the write lock is\nautomatically preceded by a checkin operation.\n\nA server MAY refuse to allow the value of the DAV:auto-checkout\nproperty to be modified.\n\n<!ELEMENT auto-checkout\n (checkout-checkin | checkout-unlocked-checkin | checkout | locked-checkout)\n>\n<!ELEMENT checkout-checkin EMPTY>\n<!ELEMENT checkout-unlocked-checkin EMPTY>\n<!ELEMENT checkout EMPTY>\n<!ELEMENT locked-checkout EMPTY>\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@Rational.Com]\nSent: Friday, July 13, 2001 7:11 PM\nTo: 'DeltaV'\nSubject: RE: auto-checkout and auto-checkin\n\n\nClearly there is significant support for going back to\nDAV:auto-version (as opposed to DAV:auto-checkout,DAV:auto-checkin).\nIf nobody objects to going back to DAV:auto-version , I'm willing to\ndo so (I believe I was the most enthusiastic supporter of the original\nswitch to auto-checkout and auto-checkin).\n\nThe values for DAV:auto-version would be:\n\nDAV:always-checkout-always-checkin\nDAV:always-checkout-unlocked-checkin\nDAV:always-checkout\nDAV:locked-checkout\n\nNote: an auto-checkout of a locked resource is always\nchecked in when the lock is removed, unless it has already\nbeen automatically checked in or explicitly checked in \nor unchecked out.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10917584"}, {"subject": "RE: auto-checkout and auto-checki", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n\n> Clearly there is significant support for going\n> back to DAV:auto-version ...\n\nReally?!  There were questions about the current auto- properties, but\nthose questions were answered.\n\nDo people support going back to the DAV:auto-version property?\n\n\nTim\n\n\n\n", "id": "lists-006-10927285"}, {"subject": "RE: auto-checkout and auto-checki", "content": "Oops.  I had \"auto-checkout\" in a couple of places where I meant\nto have \"auto-version\" (cut'n'paste can be risky :-).  Here's the\nfixed proposal:\n\n\n3.2.2DAV:auto-version\n\nIf the DAV:auto-version value is DAV:checkout-checkin, when a\nmodification request (such as PUT/PROPPATCH) is applied to a\nchecked-in version-controlled resource, the request is automatically\npreceded by a checkout and followed by a checkin operation.\n\nIf the DAV:auto-version value is DAV:checkout-unlocked-checkin, when a\nmodification request is applied to a checked-in version-controlled\nresource, the request is automatically preceded by a checkout\noperation.  If the resource is not write-locked, the request is\nautomatically followed by a checkin operation.\n\nIf the DAV:auto-version value is DAV:checkout, when a modification\nrequest is applied to a checked-in version-controlled resource, the\nrequest is automatically preceded by a checkout operation.\n\nIf the DAV:auto-version value is DAV:locked-checkout, when a\nmodification request is applied to a write-locked checked-in\nversion-controlled resource, the request is automatically preceded by\na checkout operation.\n\nIf a write-locked resource was automatically checked out, when the\nwrite lock is removed (such as from an UNLOCK or lock timeout), if the\nresource has not yet been checked in, the removal of the write lock is\nautomatically preceded by a checkin operation.\n\nA server MAY refuse to allow the value of the DAV:auto-version\nproperty to be modified.\n\n<!ELEMENT auto-versionout\n (checkout-checkin | checkout-unlocked-checkin | checkout | locked-checkout)\n>\n<!ELEMENT checkout-checkin EMPTY>\n<!ELEMENT checkout-unlocked-checkin EMPTY>\n<!ELEMENT checkout EMPTY>\n<!ELEMENT locked-checkout EMPTY>\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@Rational.Com]\nSent: Friday, July 13, 2001 7:11 PM\nTo: 'DeltaV'\nSubject: RE: auto-checkout and auto-checkin\n\n\nClearly there is significant support for going back to\nDAV:auto-version (as opposed to DAV:auto-checkout,DAV:auto-checkin).\nIf nobody objects to going back to DAV:auto-version , I'm willing to\ndo so (I believe I was the most enthusiastic supporter of the original\nswitch to auto-checkout and auto-checkin).\n\n\n\n", "id": "lists-006-10935253"}, {"subject": "RE: auto-checkout and auto-checki", "content": "Yes.  The auto-version property has fewer states and is well-explained.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Tim Ellison\n> Sent: Monday, July 16, 2001 3:11 AM\n> To: 'DeltaV'\n> Subject: RE: auto-checkout and auto-checkin\n> \n> \n> \n> \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> \n> > Clearly there is significant support for going\n> > back to DAV:auto-version ...\n> \n> Really?!  There were questions about the current auto- properties, but\n> those questions were answered.\n> \n> Do people support going back to the DAV:auto-version property?\n> \n> \n> Tim\n\n\n\n", "id": "lists-006-10944951"}, {"subject": "RE: auto-checkout and auto-checki", "content": ">>\n\nIf the DAV:auto-version value is DAV:checkout, when a modification\nrequest is applied to a checked-in version-controlled resource, the\nrequest is automatically preceded by a checkout operation.\n<<\nHow would a non-versioning aware client check this back in? \n\n\n\n", "id": "lists-006-10953716"}, {"subject": "RE: auto-checkout and auto-checki", "content": "They wouldn't.  I don't think we should define that state.  It is there\nbecause it mimic's the effect of\nThe old auto-checkout-unlocked without an auto-checkin-unlocked.\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Jim Amsden\n> Sent: Monday, July 16, 2001 5:06 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: auto-checkout and auto-checkin\n> \n> \n> >>\n> \n> If the DAV:auto-version value is DAV:checkout, when a \n> modification request is applied to a checked-in \n> version-controlled resource, the request is automatically \n> preceded by a checkout operation. << How would a \n> non-versioning aware client check this back in? \n> \n> \n> \n\n\n\n", "id": "lists-006-10961238"}, {"subject": "RE: auto-checkout and auto-checki", "content": "   > From:  Jim Amsden\n   > > If the DAV:auto-version value is DAV:checkout, when a \n   > > modification request is applied to a checked-in \n   > > version-controlled resource, the request is automatically \n   > > preceded by a checkout operation.\n\n   > How would a non-versioning aware client check this back in? \n\n   From: John Hall [mailto:johnhall@evergo.net]\n\n   They wouldn't.\n\nThat is correct.  The checkin would have to be done by a \nversioning-aware client.\n\n   I don't think we should define that state.  It is\n   there because it mimic's the effect of the old\n   auto-checkout-unlocked without an auto-checkin-unlocked.\n\nThis state is required for an important baseline use case.  In\nparticular, DAV:checkout will commonly be the DAV:auto-version value\nfor version-controlled configurations.  This allows a basic versioning\nclient to modify a version-controlled member of a baseline-controlled\ncollection (i.e. CHECKOUT/CHECKIN, UPDATE, MERGE) without creating a\nnew baseline for every CHECKIN/UPDATE/MERGE.  An advanced versioning\nclient would then be used to create a new baseline (by checking in the\nversion-controlled configuration).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-10970046"}, {"subject": "RE: auto-checkout and auto-checki", "content": "Other than mimicing auto-checkout-unlocked, what purpose would this option \nprovide? Looks like:\n- Versioning aware clients wouldn't need to use it, they can (should?) do \nthe checkout\n- Non-versioning aware clients could create checked out resources they \ncan't check back in\n\nWhat's the use case?\n\n\n\n\n\n\"John Hall\" <johnhall@evergo.net>\n07/17/2001 03:40 AM\n\n \n        To:     \"'Jim Amsden'\" <jamsden@us.ibm.com>, <ietf-dav-versioning@w3.org>\n        cc: \n        Subject:        RE: auto-checkout and auto-checkin\n\n \n\nThey wouldn't.  I don't think we should define that state.  It is there\nbecause it mimic's the effect of\nThe old auto-checkout-unlocked without an auto-checkin-unlocked.\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-reque       st@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Jim Amsden\n> Sent: Monday, July 16, 2001 5:06 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: auto-checkout and auto-checkin\n> \n> \n> >>\n> \n> If the DAV:auto-version value is DAV:checkout, when a \n> modification request is applied to a checked-in \n> version-controlled resource, the request is automatically \n> preceded by a checkout operation. << How would a \n> non-versioning aware client check this back in? \n> \n> \n> \n\n\n\n", "id": "lists-006-10978405"}, {"subject": "How Clients find out if they can perform a checkou", "content": "Trying to confirm how this should work based on Geoff's clarification...\n\nSo if a client wants to find out if they can check out a resource, they must\n\n1. If the server supports working-resource, gather information about whether\nthere exists one or more working-resources.  Finding out if the resource is\nchecked out to a working resource is tricky, because the DAV:checked-out\nproperty won't tell you this.  To discover if the resource is checked out to\na working resource, clients must query all versions.\n  a) get the DAV:version-tree report (REPORT VCR for DAV:version-tree).\n  b) If the DAV:version-tree report is not supported, get the URL to the VHR\n(PROPFIND VCR) and then get the list of versions from the VHR (PROPFIND VHR)\n  c) If DAV:expand-property report is supported, get the values of\ncheckout-fork and checkout-set for ALL versions (REPORT VCR for\nexpand-property)\n  d) If DAV:expand-property report is not supported, client must PROPFIND\neach version to see what the value of DAV:checkout-fork and DAV:checkout-set\nare.  This will result in N PROPFIND requests.\n  e) Probably the safest way to treat checkout-fork forbidden is for the\nclient to say that if it's forbidden anywhere, on any version, treat forks\nas forbidden overall.  I say this because I can't figure out what a server\ncould mean by having different values for checkout-forbidden, or what\nversion the client must check the value on.\n\n2.  If the server supports in-place checkout, gather information about\nwhether there is an in-place checkout.\n  a) Check to see if the DAV:checked-out property exists on the VCR\n(PROPFIND VCR).\n  b) If the DAV:checked-out property does exist, check the version named in\nthe property value to see if fork is allowed (PROPFIND checked-out version).\nThis extra request may not need to be made if step 1 has already been\nfollowed.\n\n3.  Now use the following logic:\n\nIf (server supports in-place checkout)\n  AND (server does not support working-resource)\n  AND (checked-out property does not exist on VCR)\n  then client can do in-place checkout.  Otherwise, they can't.  [?]\n\nIf (server does not support in-place checkout)\n  AND (server supports working-resource)\n  {ISN'T THIS SOMETHING LIKE CHECKOUT-SET?\n    If (checked-out property is empty on all versions)\n      then client can check out to a working-resource.\n    else if (checkout-fork is not forbidden)\n      then client can check out to a working-resource\n    else client cannot check out.\n  }\n\nIf (server supports in-place checkout)\n  AND (server supports working-resource)  NOTE: assume client prefers\nworking-resource\n  {\n    If (checked-out property does not exist on VCR)\n    {\n      If (checkout-set is empty on all versions)\n        then client can check out to a working-resource.\n      else\n      {\n        if (checkout-fork is forbidden)\n          client cannot do a checkout\n        else\n          client can check out to a working-resource\n      }\n    }\n    else\n    {\n      If (checkout-fork is forbidden)\n        client cannot do a checkout\n      else\n        client can check out to a working-resource.\n    }\n  }\n\nI don't think this logic will completely work because I'm afraid servers\nthat support both in-place checkout and working-resource may be inconsistent\nabout whether they allow both kinds of checkouts at the same time.  I don't\nknow how to discover whether that's allowed, and I don't think it's\nnecessarily covered by checkout-fork being forbidden.\n\nSummary:  this situation means that to find out if the client can check out\na resource, they may have to do as many requests as versions exist, plus a\nfew extra.  That's if expand-property is not available.  If expand-property\nis available, the client has to make the following requests just to find out\nif they can do a checkout.  I'm assuming the OPTIONS request has already\nbeen done to find out which if in-place-checkout and working-resource have\nbeen done.  I'm also assuming version-tree report is supported, because if\nit's not the system is more difficult.\n  LOCK VCR so that things don't change during the discovery process\n  PROPFIND VCR ask for checked-out property\n  REPORT VCR ask for version-tree\n  REPORT VCR ask for expand-property report for checkout-set and\ncheckout-fork\n\nDigression: If supported-method-set only shows CHECKOUT if a checkout is in\ntheory possible, then this might make things a lot easier for the client.  I\nhad thought that supported-method-set should show the methods that may be\nallowed on a resource depending on the server's functionality and the\nresource's type.  However, it occurs to me that it's also reasonable to say\nthat the supported-method-set should depend on the resource's state.  This\namounts to the question:  if a resource is unlocked, should\nsupported-method-set show UNLOCK or not?  I've brought this up before and\nhaven't seen an answer.\n\nAnother solution to this problem would be to introduce another protocol\nelement (vast groans from the audience) for CHECKOUT that says\nDO-NOT-CHECKOUT, just tell me if I COULD have checked it out.  Therefore, if\nthe checkout without the <do-not-checkout> would have succeeded, you get a\nOK.  If it wouldn't, you get the error that would have been generated on the\nCHECKOUT.\n\nLisa\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Sunday, July 15, 2001 7:35 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: ... By the way ...\n>\n>\n>\n>    From: John Hall [mailto:johnhall@evergo.net]\n>\n>    As I understand it, there is no way for a client to tell that a\n>    working resource has been created.\n>\n>    VCR checked in, no working resources have been created.  Server\n>    doesn't allow forking.  Server supports WORKING-RESOURCE and\n>    CHECKOUT-INPLACE.\n>\n>    ClientA: CHECKOUT <apply-to-version> VCR.\n>    => creates working resource and leaves VCR untouched.\n>\n>    ClientB: Since VCR is untouched, it is impossible to detect that\n>    CLientA has performed their operation.  Therefore:\n>\n>    CHECKOUT VCR\n>    => 409 Conflict\n>    <checkout-of-checked-out-version-is-forbidden>\n>\n>    Is there some way I'm missing that Client B could have seen this\n>    one coming?\n>\n> Use the DAV:expand-property report to ask for the checkout-set and\n> checkout-fork properties of the checked-in version, i.e.:\n>\n> <D:expand-property xmlns:D=\"DAV:\">\n>  <D:property name=\"checked-in\">\n>    <D:property name=\"checkout-set\"/>\n>    <D:property name=\"checkout-fork\"/>\n>  </D:property>\n> </D:expand-property>\n>\n> If the checkout-set is non-empty and checkout-fork is forbidden,\n> you know the checkout will fail.\n>\n>    Currently, I don't support forking so only 1 checkout (INPLACE or\n>    WORKING) is allowed.  But if I did support multiple checkouts, I'd\n>    still keep a count so I could tell Client B, that forking was\n>    'discouraged', for example.\n>\n> Yes, if the checkout-fork is discouraged, that would be something\n> you'd want to warn them about (and if they said \"do it anyway\", you\n> would know to include the DAV:fork-ok flag with the CHECKOUT).\n>\n>    Are people implementing this without tracking the count of working\n>    resources created off the versions of a VCR?\n>\n> The list of checkouts is important, which is why the server is\n> required to maintain DAV:checkout-set.\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-10988424"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and  DAV:ba  seline resource type value", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n>\n> So the part of me is responsible for earning a salary doesn't care,\n> but the part of me that wants the world to be a better place cares\n> deeply (:-).\n\nAh, didn't reckon on that schizophrenia thing.\n\n> I suggest that no DAV:resourcetype values are needed for the\n> DeltaV protocol extensions,\n\nAgreed.\n\n> but that I am willing to add any\n> set of (well-defined! :-) values on which the working group can\n> reach consensus.\n>\n> So from now on, I will only be asking for clarification on\n> the semantics of proposed new DAV:resourcetype values, rather\n> than repeating why I'm against adding any at all (:-).\n\nOnce the \"reasoned debate\" has concluded it can drift off into the\narchives.  Clearly this debate falls far short of RFC2026's description of\na basis for dispute which is \"(a) [an individual's] own views have not been\nadequately considered by the Working Group, or (b) the Working Group has\nmade an incorrect technical choice which places the quality and/or\nintegrity of the Working Group's product(s) in significant jeopardy\"\n\nTim\n\n\n\n", "id": "lists-006-1099613"}, {"subject": "RE: How Clients find out if they can perform a checkou", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   So if a client wants to find out if they can check out a resource,\n   they must ...\n\nYou can use the Allow header to indicate whether a particular method\ncould succeed, but this won't tell you whether it will succeed with\na particular argument list (e.g. with DAV:fork-ok).\n\nIn general, WebDAV does not provide for \"will this\nrequest succeed\" functionality, because the state of the server will\nchange between any query and the actual request, so there is little\npoint in trying to be overly precise about whether a particular\nrequest would have succeeded at some earlier time.  Your client can check\nto see if the CHECKOUT method is supported (or Allow'ed), and if it\nis, you allow a user to request it.  If the request fails, the error\ntoken will tell the client why, and it can report this to the user.\n\n   1. If the server supports working-resource, gather information\n   about whether there exists one or more working-resources.  Finding\n   out if the resource is checked out to a working resource is tricky,\n   because the DAV:checked-out property won't tell you this.  To\n   discover if the resource is checked out to a working resource,\n   clients must query all versions.\n\nA client has to checkout a particular version (which is the version\nwhose content defines the initial editor state of that client).  That\nis the version whose DAV:checkout-set and DAV:checkout-fork properties\nare relevant.\n\n     a) get the DAV:version-tree report (REPORT VCR for DAV:version-tree).\n     b) If the DAV:version-tree report is not supported, get the URL to the\nVHR\n   (PROPFIND VCR) and then get the list of versions from the VHR (PROPFIND\nVHR)\n\nThe DAV:version-tree report MUST be supported, so (b) is never needed.\n\n     c) If DAV:expand-property report is supported, get the values of\n   checkout-fork and checkout-set for ALL versions (REPORT VCR for\n   expand-property)\n     d) If DAV:expand-property report is not supported, client must PROPFIND\n   each version to see what the value of DAV:checkout-fork and\nDAV:checkout-set\n   are.  This will result in N PROPFIND requests.\n\nOnly a PROPFIND of the version that is being checked out is required.\n\n     e) Probably the safest way to treat checkout-fork forbidden is for the\n   client to say that if it's forbidden anywhere, on any version, treat\nforks\n   as forbidden overall.  I say this because I can't figure out what a\nserver\n   could mean by having different values for checkout-forbidden, or what\n   version the client must check the value on.\n\nYou always checkout a particular version (which becomes the\nDAV:checked-out version), and that is the version whose\nDAV:checkout-fork property indicates whether that version can be\nchecked out when its DAV:checkout-set or DAV:successor-set is\nnon-empty.\n\n   3.  Now use the following logic:\n\n[algorithm omitted]\n\n   I don't think this logic will completely work because I'm afraid\n   servers that support both in-place checkout and working-resource\n   may be inconsistent about whether they allow both kinds of\n   checkouts at the same time.   I don't know how to discover whether\n   that's allowed, and I don't think it's necessarily covered by\n   checkout-fork being forbidden.\n\nYou'd also have to discover whether things were locked and whether\nthere was enough disk space on the server, and whether the ACL's\npermitted the operation, and probably a variety of other things.\nAnd all these things can change by the time the user actually tries\nthe checkout.  Using just DAV:supported-method-set and the Allow\nheader is much simpler and sufficiently accurate.\n\n   Digression: If supported-method-set only shows CHECKOUT if a checkout is\nin\n   theory possible, then this might make things a lot easier for the client.\nI\n   had thought that supported-method-set should show the methods that may be\n   allowed on a resource depending on the server's functionality and the\n   resource's type.  However, it occurs to me that it's also reasonable to\nsay\n   that the supported-method-set should depend on the resource's state.\nThis\n   amounts to the question:  if a resource is unlocked, should\n   supported-method-set show UNLOCK or not?  I've brought this up before and\n   haven't seen an answer.\n\nIt's deliberately vague to give the server some leeway, but in\ngeneral \"supported\" means that the method might succeed on some\nstate of the resource, while the Allow set indicates whether\nthe method might succeed on the current state of the resource.\nI agree this is worth stating in the protocol (if people agree\nwith this characterization).\n\n   Another solution to this problem would be to introduce another protocol\n   element (vast groans from the audience) for CHECKOUT that says\n   DO-NOT-CHECKOUT, just tell me if I COULD have checked it out.  Therefore,\nif\n   the checkout without the <do-not-checkout> would have succeeded, you get\na\n   OK.  If it wouldn't, you get the error that would have been generated on\nthe\n   CHECKOUT.\n\nYes, that would result in a vast groan from this member of the\naudience, since it is virtually impossible to predict\nwithout actually trying the request whether or not access control\nviolations or server resource constraints will make the method fail,\nand even if it would fail at the time of the query, it does not mean\nit will fail a second later when some of these conditions may have\nchanged.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11006406"}, {"subject": "RE: How Clients find out if they can perform a checkou", "content": "> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n>\n>    From: Lisa Dusseault [mailto:lisa@xythos.com]\n> [...]\n>\n>    Digression: If supported-method-set only shows CHECKOUT if a\n>    checkout is in theory possible, then this might make things a lot\neasier for\n>    the client. I had thought that supported-method-set should show the\nmethods\n>    that may be allowed on a resource depending on the server's\nfunctionality and the\n>    resource's type.  However, it occurs to me that it's also reasonable to\n>    say that the supported-method-set should depend on the resource's\nstate.\n>    This amounts to the question:  if a resource is unlocked, should\n>    supported-method-set show UNLOCK or not?  I've brought this up\n>    before and haven't seen an answer.\n>\n> It's deliberately vague to give the server some leeway, but in\n> general \"supported\" means that the method might succeed on some\n> state of the resource, while the Allow set indicates whether\n> the method might succeed on the current state of the resource.\n> I agree this is worth stating in the protocol (if people agree\n> with this characterization).\n\nOh, let's not be too subtle in DeltaV, please.\n\nFrom RFC 2616, Ch. 14.7 \"Allow\", first sentence:\n\"The Allow entity-header field lists the set of methods supported by the\nresource identified by the Request-URI.\"\n\nNow, how could that be different from a \"supported-method-set\"?\n\n//Stefan\n\n\n\n", "id": "lists-006-11019807"}, {"subject": "RE: How Clients find out if they can perform a checkou", "content": "   From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n\n   > From: Geoff Clemm\n   > ... in general \"supported\" means that the method might succeed on\n   > some state of the resource, while the Allow set indicates whether\n   > the method might succeed on the current state of the resource.  I\n   > agree this is worth stating in the protocol (if people agree with\n   > this characterization).\n\n   Oh, let's not be too subtle in DeltaV, please.\n\n   From RFC 2616, Ch. 14.7 \"Allow\", first sentence:\n   \"The Allow entity-header field lists the set of methods supported by the\n   resource identified by the Request-URI.\"\n\n   Now, how could that be different from a \"supported-method-set\"?\n\nYou need to look at the other sections of RFC 2616 that discuss Allow.\nIn particular, in section 5.1.1:\n\n   The list of methods allowed by a resource can be specified in an\n   Allow header field (section 14.7). The return code of the response\n   always notifies the client whether a method is currently allowed on\n   a resource, since the set of allowed methods can change\n   dynamically.\n\nI believe this makes it clear that \"allow\" means \"might succeed on the\ncurrent state of the resource\" as opposed to \"might succeed on some\nstate of the resource\".  This distinction is very important, because\nthe latter would probably be used to determine what the menu for that\nresource would contain, while the former would be used to determine\nwhich entries in this menu should be \"greyed out\".\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11029843"}, {"subject": "RE: Semantics of supported-", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   I'll take the definition of supported-method-set for an example:\n\n   \"This property identifies the methods that are supported by the\n   resource.  A method is supported by a resource if an application of\n   that method to that resource has the semantics defined by the\n   features supported by that resource.\"\n\n   This is better than it used to be, but it's still not clear to me whether\n   this is dependent on state (which can get us into the ugly state vs. type\n   debate).\n\nThere have been some comments on this topic in another thread, but\nI'll switch over to this thread since it has a better subject line.\n\nAlthough the spec is currently (deliberately) silent on this issue, if\nwe were to say something, I'd advocate saying that whether or not a\nmethod appears in the DAV:supported-method-set of a resource MUST\nnot depend on the state of the resource.\n\nStefan objected to this, and I responded, so clearly there is not\nyet consensus on this issue (which is why the spec is currently\nsilent).  If consensus is achieved, I'd be happy to add the \nappropriate language to the spec.\n\nNote though that whatever we say, there is always an opportunity for a\nserver implementor doing something silly, i.e. by indicating that a\nmethod is supported, but *always* returning a failure of one of the\npostconditions.  There is no way to legislate against such an\nimplementation, but there also is no need to, because the users will\nrapidly convey their views on such a server back to the server\nimplementor.\n\n   E.g.  does CHECKIN show up for a checked-in VCR, or only for a\n   checked-out VCR?  Does LOCK show up for a locked VCR, or only an\n   unlocked VCR?\n\nThe rule I suggest above would imply that CHECKIN would show\nup in the DAV:supported-method-set of a VCR, whether or not it\nwas checked out (but would not appear in the list returned in\nan Allow header if the VCR was already checked in).\n\n   I assume that the answer to this will be consistent for\n   supported-live-property-set and supported-report-set.\n\nYes, I would advocate the answer being consistent, and would advocate\nthe \"not based on the state of the resource\" being the consistent\nanswer.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11039373"}, {"subject": "RE: How Clients find out if they can perform a checkou", "content": "> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net] \n> Sent: Tuesday, July 24, 2001 8:59 AM\n> To: 'Clemm, Geoff'; 'ietf-dav-versioning@w3.org'\n> Subject: RE: How Clients find out if they can perform a checkout\n> \n> \n> \n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of \n> Clemm, Geoff\n> > Sent: Monday, July 23, 2001 10:15 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: RE: How Clients find out if they can perform a checkout\n> > \n> > \n> >    From: Lisa Dusseault [mailto:lisa@xythos.com]\n> > \n> \n> > A client has to checkout a particular version (which is the\n> > version whose content defines the initial editor state of \n> > that client).  That is the version whose DAV:checkout-set and \n> > DAV:checkout-fork properties are relevant.\n> > \n> > Only a PROPFIND of the version that is being checked out is \n> required.\n> \n> You are assuming that a client does not need to know if ANY \n> version has been checked out, but only needs to know if THIS \n> version has been checked out.\n> \n> I'm not sure that a client that does not want to deal with \n> merges can stop there, when it hits a server that allows \n> forking and multiple checkouts.\n> \n> > Using just\n> > DAV:supported-method-set and the Allow header is much simpler \n> > and sufficiently accurate.\n> > \n> > It's deliberately vague to give the server some leeway, but\n> > in general \"supported\" means that the method might succeed on \n> > some state of the resource, while the Allow set indicates \n> > whether the method might succeed on the current state of the \n> > resource. I agree this is worth stating in the protocol (if \n> > people agree with this characterization).\n> \n> I think it is worth stating.\n> \n\n\n\n", "id": "lists-006-11048647"}, {"subject": "Note Wel", "content": "Greetings,\n\nThis is the revised text of the NOTE WELL statement.\n\n------------------------------------------------------\n\nNOTE WELL\n\nAll statements related to the activities of the IETF and addressed to\nthe IETF are subject to all provisions of Section 10 of RFC 2026, which\ngrants to the IETF and its participants certain licenses and rights in\nsuch statements.\n\nSuch statements include verbal statements in IETF meetings, as well as\nwritten and electronic communications made at any time or place, which\nare addressed to:\n\n    - the IETF plenary session,\n    - any IETF working group or portion thereof,\n    - the IESG, or any member thereof on behalf of the IESG,\n    - the IAB or any member thereof on behalf of the IAB,\n    - any IETF mailing list, including the IETF list itself,\n      any working group or design team list, or any other list\n      functioning under IETF auspices,\n    - the RFC Editor or the Internet-Drafts function\n\nStatements made outside of an IETF meeting, mailing list or other\nfunction, that are clearly not intended to be input to an IETF\nactivity, group or function, are not subject to these provisions.\n\n\n\n", "id": "lists-006-11060254"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas  eline resource type value", "content": "If you believe there is a useful line drawn between \"resource state\"\nand \"resource type\", then it is necessary to unambiguously define \"state\"\nand\n\"type\" (in particular, in a way that allows you to distinguish one\nfrom the other).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Wednesday, June 06, 2001 12:00 PM\nTo: Clemm, Geoff; DeltaV (E-mail)\nSubject: RE: Removing the DAV:activity and DAV:version-history and\nDAV:bas eline resource type values\n\n\nIf you believe that whether a resource is under version control or not, is a\nmatter of state, then leave it OUT of resourcetype.  It's not called\n\"resourcestate\".\n\nVersion, version History, and others are still types.\n\nBut draw a line somewhere.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, June 06, 2001 8:07 AM\n> To: DeltaV (E-mail)\n> Subject: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:bas eline resource type values\n>\n>\n> I think Tim's point was that if \"under version control\"\n> (e.g. \"version-controlled-resource\") is part of\n> the \"type\" of a resource, then \"checked-out\" and \"checked-in\"\n> would equally usefully be considered as part of the type\n> (since the significantly affect what methods can be\n> applied to that resource).\n>\n> In each case, you have the same resource (i.e. when you\n> put a resource under version control, it is the same resource\n> but has some additional live properties and methods you can\n> apply to it).\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n> Sent: Wednesday, June 06, 2001 6:27 AM\n> To: DeltaV (E-mail)\n> Subject: AW: Removing the DAV:activity and DAV:version-history and DAV\n> :baseline resource type values\n>\n>\n>\n>\n> > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von\n> > Tim_Ellison@uk.ibm.com\n> > [...]\n> >\n> > My view of the world...\n> >\n> > Here's the list of elements that could appear in a\n> DAV:resourcetype.  Some\n> > of these can be combined to provide a really meaningful\n> experience for the\n> > client.  Obviously, some combinations are invalid.\n> >      <DAV:checked-in/>\n> >      <DAV:checked-out/>\n> >      <DAV:collection/>\n> >      <DAV:working-resource/>\n> >      <DAV:version-controlled-resource/>\n> >      <DAV:version/>\n> >      <DAV:version-history/>\n> >      <DAV:workspace/>\n> >      <DAV:version-controlled-configuration/>\n> >      <DAV:baseline/>\n> >      <DAV:activity/>\n> >\n>\n> What is your rationale for checked-in/out in the type? I think\n> I have missed something in the spec, since it feels like a\n> property to me.\n>\n> > So,\n> > <DAV:resourcetype>\n> >      <DAV:activity/>\n> > </DAV:resourcetype\n> >\n> > would be good, that is, not surprisingly, an activity resource.\n> >\n> > <DAV:resourcetype>\n> >      <DAV:checked-out/>\n> >      <DAV:version-controlled-resource/>\n> >      <DAV:collection/>\n> >      <DAV:workspace/>\n> > </DAV:resourcetype>\n> >\n> > would be good too, it is a checked-out, version-controlled\n> resource for a\n> > workspace collection.  And so on.\n> >\n> > Tim\n> >\n> >\n\n\n\n", "id": "lists-006-1108467"}, {"subject": "RE: How Clients find out if they can perform a checkou", "content": "> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> \n>    From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n> \n>    > From: Geoff Clemm\n>    > ... in general \"supported\" means that the method might succeed on\n>    > some state of the resource, while the Allow set indicates whether\n>    > the method might succeed on the current state of the resource.  I\n>    > agree this is worth stating in the protocol (if people agree with\n>    > this characterization).\n> \n>    Oh, let's not be too subtle in DeltaV, please.\n> \n>    From RFC 2616, Ch. 14.7 \"Allow\", first sentence:\n>    \"The Allow entity-header field lists the set of methods \n> supported by the\n>    resource identified by the Request-URI.\"\n> \n>    Now, how could that be different from a \"supported-method-set\"?\n> \n> You need to look at the other sections of RFC 2616 that discuss Allow.\n> In particular, in section 5.1.1:\n> \n>    The list of methods allowed by a resource can be specified in an\n>    Allow header field (section 14.7). The return code of the response\n>    always notifies the client whether a method is currently allowed on\n>    a resource, since the set of allowed methods can change\n>    dynamically.\n> \n> I believe this makes it clear that \"allow\" means \"might succeed on the\n> current state of the resource\" as opposed to \"might succeed on some\n> state of the resource\".  This distinction is very important, because\n> the latter would probably be used to determine what the menu for that\n> resource would contain, while the former would be used to determine\n> which entries in this menu should be \"greyed out\".\n\nWell, you excluded how section 5.1.1 continues:\n\nAn origin server SHOULD return the status code 405 (Method\nNot Allowed) if the method is known by the origin server but\nnot allowed for the requested resource, and 501 (Not Implemented)\nif the method is unrecognized or not implemented by the origin\nserver.\n\nSo, if a resource is locked exclusively, this means that a LOCK request\nwill not succeed and should not be part of the Allow header. Fine, but\nthen RFC 2518 defines different response codes (namely 412 and 423) for\na LOCK on a locked resource, ignoring the SHOULD in RFC 2616.\n\nBut this may be bean counting...\n\nHowever, taking the client view again, the Allow header is not as\nuseful as you make it look. Apart from Apache/moddav, all servers\ninclude many more methods in the Allow header than one might expect.\nIIS and Sharemation, for example, both report MKCOL as allowed method\non a collection.\n\nSo I repeat: Let's not be too subtle in deltaV, please.\n\nUntil your mail, which started this thread, I regarded DAV:supported-\nmethod-set as an optimization, sparing clients the OPTIONS requests\non all resources which it got with PROPFIND/Depth 1.\n\n...which (OPTIONS) would have otherwise been necessary...\n\n...as DAV:supported-live-property-set does not tell the whole story...\n\n...as there is no DAV:resourcetype.\n\nThere! I said it! Dirty word, dirty word...\n\n//Stefan\n\n\n\n", "id": "lists-006-11098210"}, {"subject": "IETF 51 and DeltaV Breakout Session", "content": "I am VERY happy to let you know that the DeltaV specification has been \napproved by our Area Director, Ned Freed, and we will be scheduling an \nIETF-wide last call as soon as possible. We will also be checking with the \nWebDAV and HTTP working groups for any additional feedback. So to \ncellebrate this wonderful progress, and to leverage the momentum, I \npropose that we meet for a DeltaV breakout session all day Tuesday at IETF \n'51. I don't have a meeting place yet, so check the message board for an \nannouncement.\n\n The agenda will be to cover any remaining issues so we are prepared to \nproduce another Internet draft after the IETF-wide last call. Please \nsubmit your issues list to the mailing list soon so we can collect them \nbefore the breakout session. And thanks to everyone for the hard work that \nproduced such a quality specification!\n\nI've also updated the charter to reflect update milestones. It should be \nat http://www.ietf.org/html.charters/deltav-charter.html soon, but I've \nincluded it below for your review.\n\nWeb Versioning and Configuration Management (deltav) \n\nLast Modified: 12-July-01 \n\nChair(s):\n\nmailto:jamsden@us.ibm.com\n\nApplications Area Director(s): \n\nmailto:ned.freed@mrochek.com\nmailto:paf@cisco.com\n\nApplications Area Advisor: \n\nmailto:ned.freed@mrochek.com\n\nMailing Lists: \n\nGeneral Discussion:ietf-dav-versioning@w3.org \nTo Subscribe: ietf-dav-versioning-request@w3.org \nIn Body: subscribe \nArchive: http://lists.w3.org/Archives/Public/ietf-dav-versioning/ \n\nDescription of Working Group: \n\nThis working group will define extensions to HTTP and the WebDAV \nDistributed\nAuthoring Protocol necessary to enable distributed Web authoring tools to\nperform, in an interoperable manner, versioning and configuration \nmanagement of\nWeb resources. \n\nVersioning, parallel development, and configuration management are \nimportant\nfeatures for remote authoring of Web content. Version management is \nconcerned\nwith tracking and accessing the history of important states of a single \nWeb\nresource, such as a standalone Web page. Parallel development provides\nadditional resource availability in multi-user, distributed environments,\nallowing authors the choice of making independent changes on the same \nresource\nat the same time, later merging together those changes. Configuration\nmanagement addresses the problems of tracking and accessing multiple\ninterrelated resources over time as sets of resources, not simply \nindividual\nresources. Traditionally, artifacts of software development, including \ncode,\ndesign, test cases, requirements, help files, and more have been a focus \nof\nconfiguration management. Web sites, comprised of multiple inter-linked\nresources (HTML, graphics, sound, CGI, and others), are another important \nclass\nof complex information artifacts that benefit from the application of\nconfiguration management. \n\nThe WebDAV working group originally focused on defining version management\ncapabilities for remote authoring applications. However, it has become \nclear\nthat while versioning functionality alone is useful for a range of content\nauthoring scenarios involving one, or a small set of resources, versioning\nalone is insufficient for managing larger sets of content. Support for \nparallel\ndevelopment and simple remote configuration management of Web resources\nprovides needed functionality for managing larger sets of interrelated \ncontent\ndeveloped by multiple users at different locations. A standard protocol \nfor\naccesing such services will ensure interoperability between many clients \nand\nmany servers. \n\nA sub-group of the WebDAV working group has developed functional \nrequirements\nfor versioning and configuration management of Web content. These \nrequirements\nencompass the following capabilities, which shall be considered by this \nworking\ngroup: \n\nIN-SCOPE: \n\n       Naming and accessing resource versions and configurations \n       Creating new revisions of a resource \n       Placing a resource under version and configuration control \n       Parallel development \n       History retrieval \n       Differencing \n       Merging of revisions and configurations \n       Operations on configurations \n       Mapping resource versions and configurations to the URL namespace \n       Versioning support for downlevel HTTP and WebDAV clients \n\nFurther information on these objectives can be found in the document, \n\"Goals\nfor Web Versioning\". \n\nNOT IN SCOPE: \n\n       HTTP server to server communication protocols \n       Development process management, workflow, or change request \nmanagement \n       Versioning and configuration management via non-HTTP and WebDAV \nprotocols. \n       Implementation of functionality by non-origin proxies \n\nDeliverables \n\nThe following documents are expected to form the final output of this \nworking\ngroup. \n\n     1. A goals document, which describes the high-level functional \nrequirements\n        for remote versioning and configuration management, including\n        rationale. \n     2. A protocol specification, which describes new HTTP methods, \nheaders,\n        request bodies, response bodies, and WebDAV properties to\n        implement the remote versioning and configuration management \ngoals. \n\nGoals and Milestones:\n\n Oct 99   (Goals) Create final version of distributed versioning and\n          configuration management goals document. Submit for approval as\n          Informational RFC.\n\n Oct 99   (Specification, Model) Produce revised model document, and\n          distributed versioning and configuration management protocol\n          specification. Submit both as Internet Drafts.\n\n Nov 99   (Meeting, Specification, Model) Meet at Washington, DC IETF and \nhold\n          working group meeting to review the model document and\n          the distributed versioning and configuration management protocol\n          specification.\n\n Done     (Specification, Model, Traceability) Submit revised model \ndocument,\n          and distributed versioning and configuration management\n          protocol specification as Internet Drafts. Submit revised\n          traceability document as an Internet Draft.\n\n Mar 00   (Meeting, Specification, Model) Meet at Adelaide IETF and hold\n          working group meeting to review the model document and discuss\n          protocol design.\n\n Apr 00   (Specification, Model, Traceability) Submit revised model \ndocument,\n          distributed versioning and configuration management protocol\n          specification, and traceability document as Internet Drafts. \nHold\n          working group last call for comments on all drafts.\n\n May 00   (Specification, Model, Traceabiluty) Revise model document,\n          distributed versioning and configuration management \nspecification,\n          and traceability document based on WG last call comments, and \nsubmit\n          specification to the IESG for approval as a Proposed Standard \nRFC,\n          and submit the model and traceability documents to IESG\n          as Informational RFCs.\n\n Apr 01   Candidate DeltaV Internet Draft version 15 submitted to IETF\n          Application Area Directors for initial review\n\n Aug 01   (Meeting, Specification) Meet at London IETF '51, address \nremaining\n          protocol design issues and feedback from initial Area Directors'\n          review.\n\n Nov 01   If needed based on feedback from Area Directors' review, hold an\n          additional DeltaV Working Group Last Call\n\n Dec 01   Document Review for progression by Area Directors\n\n\nInternet-Drafts: \n\nVersioning Extensions to WebDAV draft-ietf-deltav-versioning-16.txt\n\nNo Request For Comments \n\n\n\n", "id": "lists-006-11109789"}, {"subject": "IETF '51 and WebDA", "content": "Just a reminder of the schedule for IETF '51:\n\nWebDAV Working Group Meeting: Monday, August 6, 3:30PM to 5:30, \nCadogan/Berkeley\nDeltaV breakout session, Tuesday 9:00AM to 5:00PM, location to be posted \non the message board\nDeltaV Working Group Meeting: Wedensday, August 8, 1:00PM to 3:00 PM, \nCadogan/Berkeley\n\nHope to see you there!\n\n\n\n", "id": "lists-006-11125705"}, {"subject": "RE: IETF '51 and WebDA", "content": "Please make sure the breakout session is at or near the conference hotel.\nThere are other meetings on Tuesday that may be of interest to WebDAV\nimplementors:  WebI, IP Storage.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> Sent: Wednesday, August 01, 2001 5:11 PM\n> To: ietf-dav-versioning@w3.org; w3c-dist-auth@w3c.org\n> Subject: IETF '51 and WebDAV\n>\n>\n> Just a reminder of the schedule for IETF '51:\n>\n> WebDAV Working Group Meeting: Monday, August 6, 3:30PM to 5:30,\n> Cadogan/Berkeley\n> DeltaV breakout session, Tuesday 9:00AM to 5:00PM, location to be posted\n> on the message board\n> DeltaV Working Group Meeting: Wedensday, August 8, 1:00PM to 3:00 PM,\n> Cadogan/Berkeley\n>\n> Hope to see you there!\n\n\n\n", "id": "lists-006-11133265"}, {"subject": "Appendix A &ndash;&ndash; Resource Classificatio", "content": "23.4 Why should VERSION-CONTROL be listed on a resource that is already\nunder version control?  It would be interesting if we allowed\nVERSION-CONTROL to remove a resource from version control, but we don't.\nIf VERSION-CONTROL only appears on versionable but non-versioned\nresources then that can communicate something interesting to the client.\n\n23.9 UNCHECKOUT (checkout-in-place) is missing.\n\n\n\n", "id": "lists-006-11142448"}, {"subject": "Supported-live-property-se", "content": "Just to confirm, is supported-live-property-set supposed to contain\nvendor-specific live properties as well?\n\nlisa\n\n\n\n", "id": "lists-006-11150226"}, {"subject": "RE: Appendix A &ndash;&ndash; Resource Classificatio", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   23.4 Why should VERSION-CONTROL be listed on a resource that is already\n   under version control?\n\nVERSION-CONTROL is defined as being a no-op on a version-controlled\nresource, but it is a supported method (it just is defined to do\nnothing).  This is done so a client does not have to be aware of\nwhether or not a server automatically puts a resource under version\ncontrol when it is created.\n\n   It would be interesting if we allowed\n   VERSION-CONTROL to remove a resource from version control, but we don't.\n\nThe post-conditions of an UNVERSION-CONTROL would be very different from\nthat of VERSION-CONTROL (the opposite, in fact), so using the same\nmethod name for both would be misleading.  It would be like having\nthe same method name for CHECKOUT and CHECKIN.\n\n   If VERSION-CONTROL only appears on versionable but non-versioned\n   resources then that can communicate something interesting to the client.\n\nThe same information is conveyed by seeing whether VERSION-CONTROL\nis supported, but the DAV:auto-version property is not.\n\n   23.9 UNCHECKOUT (checkout-in-place) is missing.\n\nIt appears in the drafts on our web site.  Are you sure you are\nlooking at section 23.9?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11157163"}, {"subject": "RE: Supported-live-property-se", "content": "Definitely yes.  As are vendor specific methods in\nDAV:supported-method-set and vendor specific reports\nin DAV:supported-report-set.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Thursday, August 02, 2001 7:18 PM\nTo: DeltaV\nSubject: Supported-live-property-set\n\n\n\nJust to confirm, is supported-live-property-set supposed to contain\nvendor-specific live properties as well?\n\nlisa\n\n\n\n", "id": "lists-006-11165701"}, {"subject": "RE: How Clients find out if they can perform a checkou", "content": "   From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n\n    RFC2518: An origin server SHOULD return the status code 405\n    (Method Not Allowed) if the method is known by the origin server\n    but not allowed for the requested resource, and 501 (Not\n    Implemented) if the method is unrecognized or not implemented by\n    the origin server.\n\n   So, if a resource is locked exclusively, this means that a LOCK\n   request will not succeed and should not be part of the Allow\n   header. Fine, but then RFC 2518 defines different response codes\n   (namely 412 and 423) for a LOCK on a locked resource, ignoring the\n   SHOULD in RFC 2616.\n\nI don't see a problem here.  RFC 2616 cannot be expected to predict\nthe extended status values that will be defined by an HTTP extension\nsuch as WebDAV.\n\n   But this may be bean counting...\n\nYes.  (:-).\n\n   However, taking the client view again, the Allow header is not as\n   useful as you make it look. Apart from Apache/moddav, all servers\n   include many more methods in the Allow header than one might expect.\n   IIS and Sharemation, for example, both report MKCOL as allowed method\n   on a collection.\n\nUsing the combination of the Allow header and the DAV:supported-method-set\nto do interesting things is of course only relevant when the server\nsupports the DAV:supported-method-set property.  \n\n   So I repeat: Let's not be too subtle in deltaV, please.\n\nI think the distinction between \"supported by some state of the\nresource\" and \"supported by the current state of the resource\"\nis not overly subtle.  But I don't really care all that much\n(and the spec currently is silent on the issue, so we can chose\nto defer this question).\n\n   Until your mail, which started this thread, I regarded DAV:supported-\n   method-set as an optimization, sparing clients the OPTIONS requests\n   on all resources which it got with PROPFIND/Depth 1.\n\nThat is certainly something it is useful for.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11173156"}, {"subject": "RE: How Clients find out if they can perform a checkou", "content": "> From: John Hall [mailto:johnhall@evergo.net] \n> \n> > From: Clemm, Geoff\n> \n> > A client has to checkout a particular version (which is the\n> > version whose content defines the initial editor state of \n> > that client).  That is the version whose DAV:checkout-set and \n> > DAV:checkout-fork properties are relevant.\n> > \n> > Only a PROPFIND of the version that is being checked out is \n> > required.\n> \n> You are assuming that a client does not need to know if ANY \n> version has been checked out, but only needs to know if THIS \n> version has been checked out.\n\nIt is a fact that (in the current protocol) that whether or not \nyou can check out a version or version-controlled resource is\nnot affected by whether some other version in the version history\nis checked out.  So it is more of a conclusion than an assumption.\n\n> I'm not sure that a client that does not want to deal with \n> merges can stop there, when it hits a server that allows \n> forking and multiple checkouts.\n\nThe fact that some other version has a checkout has no effect\non whether or not your checkout will create a fork that might\nrequire a merge.  That is determined solely from whether or not\nthe version you are checking out already has a descendent or\ncheckout.\n\n> > Using just\n> > DAV:supported-method-set and the Allow header is much simpler \n> > and sufficiently accurate.\n> > \n> > It's deliberately vague to give the server some leeway, but\n> > in general \"supported\" means that the method might succeed on \n> > some state of the resource, while the Allow set indicates \n> > whether the method might succeed on the current state of the \n> > resource. I agree this is worth stating in the protocol (if \n> > people agree with this characterization).\n> \n> I think it is worth stating.\n\nYup, but we first have to get Stefan to agree (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11182816"}, {"subject": "RE: How Clients find out if they can perform a checkou", "content": "> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> \n> > From: John Hall [mailto:johnhall@evergo.net] \n> > \n> > > From: Clemm, Geoff\n> > \n> [...]\n> > > Using just\n> > > DAV:supported-method-set and the Allow header is much simpler \n> > > and sufficiently accurate.\n> > > \n> > > It's deliberately vague to give the server some leeway, but\n> > > in general \"supported\" means that the method might succeed on \n> > > some state of the resource, while the Allow set indicates \n> > > whether the method might succeed on the current state of the \n> > > resource. I agree this is worth stating in the protocol (if \n> > > people agree with this characterization).\n> > \n> > I think it is worth stating.\n> \n> Yup, but we first have to get Stefan to agree (:-).\n\nLet's see what the \"most bang for less bugs\" principle can do \nfor this discussion:\n\nA client cannot retrieve the Allow header and the DAV:supported-method-set\nat the same time. It's always two (most likely three) requests. Depending \non the usage, not the implementation of the server, the two method sets\n reflect the same state of the resource - or not (I am talking about \nunlocked resources here since clients should not need to lock, just to \nfind out what they can do with it).\n\nSo, all your client knows after retrieving the two sets, is that at that\npoint in time it was:\na) possible right now to perform a checkout - or not (from Allow header),\nb) generally supported to checkout - or not (from supported-method-set)\n\nMy point is that a) is useless in a client-server protocol, and that\nb) is very useful. If CHECKOUT is supported, you only _know_ that\nit succeeds when you try it out. \n\nI propose to give the Allow set and the DAV:supported-method-set\nthe same definition, namely, that they include those methods which\nmay succeed on some state of the resource (e.g. the current definition\nof DAV:supported-method-set), at least for all WebDAV extension methods.\n\nWhat can be gained by this?\n1. Consistency and performance: it is possible to retrieve a consistent\n   view of what there is to know about a resource with one PROPFIND, with\n   varying depth even for a range of resources.\n2. Simpler implementations on server side. Servers do not\n   need to implement two sets of methods with one varying on every state\n   change.\n3. Easier (if that's possible) understanding of the deltaV spec, e.g.\n   one feature less.\n\nPoint 1. is my wholy grail. It makes clients faster and keeps them\nsimple. A client does one, single PROPFIND depth 1. Either it fails,\nwith error to user, or it has the complete information about a\ncollection and all of its members. This is very powerful use of\nWebDAV + XML. Try that with RPC or SOAP.\n\n//Stefan\n\nPS. Before someone asks: I think my definition does comply with Allow \nas described in RFC 2616. There is never a NOT IMPLEMENTED returned \nby a deltaV server on a method from DAV:supported-method-set.\n\n   \n\n\n\n", "id": "lists-006-11192850"}, {"subject": "RE: How Clients find out if they can perform a checkou", "content": "I find Stefan's arguments convincing, so I'll switch my vote to\n\"define supported and allowed to be the same thing\".  But I see good\narguments on both sides, so I will defer to whatever the working\ngroup wants to do here.  And if there is no consensus, I'll leave\nthe spec the way it is (i.e. making no statement on the issue, and\nleaving it up to the server implementer).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\nSent: Friday, August 03, 2001 5:12 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: How Clients find out if they can perform a checkout\n\n\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> \n> > From: John Hall [mailto:johnhall@evergo.net] \n> > \n> > > From: Clemm, Geoff\n> > \n> [...]\n> > > Using just\n> > > DAV:supported-method-set and the Allow header is much simpler \n> > > and sufficiently accurate.\n> > > \n> > > It's deliberately vague to give the server some leeway, but\n> > > in general \"supported\" means that the method might succeed on \n> > > some state of the resource, while the Allow set indicates \n> > > whether the method might succeed on the current state of the \n> > > resource. I agree this is worth stating in the protocol (if \n> > > people agree with this characterization).\n> > \n> > I think it is worth stating.\n> \n> Yup, but we first have to get Stefan to agree (:-).\n\nLet's see what the \"most bang for less bugs\" principle can do \nfor this discussion:\n\nA client cannot retrieve the Allow header and the DAV:supported-method-set\nat the same time. It's always two (most likely three) requests. Depending \non the usage, not the implementation of the server, the two method sets\n reflect the same state of the resource - or not (I am talking about \nunlocked resources here since clients should not need to lock, just to \nfind out what they can do with it).\n\nSo, all your client knows after retrieving the two sets, is that at that\npoint in time it was:\na) possible right now to perform a checkout - or not (from Allow header),\nb) generally supported to checkout - or not (from supported-method-set)\n\nMy point is that a) is useless in a client-server protocol, and that\nb) is very useful. If CHECKOUT is supported, you only _know_ that\nit succeeds when you try it out. \n\nI propose to give the Allow set and the DAV:supported-method-set\nthe same definition, namely, that they include those methods which\nmay succeed on some state of the resource (e.g. the current definition\nof DAV:supported-method-set), at least for all WebDAV extension methods.\n\nWhat can be gained by this?\n1. Consistency and performance: it is possible to retrieve a consistent\n   view of what there is to know about a resource with one PROPFIND, with\n   varying depth even for a range of resources.\n2. Simpler implementations on server side. Servers do not\n   need to implement two sets of methods with one varying on every state\n   change.\n3. Easier (if that's possible) understanding of the deltaV spec, e.g.\n   one feature less.\n\nPoint 1. is my wholy grail. It makes clients faster and keeps them\nsimple. A client does one, single PROPFIND depth 1. Either it fails,\nwith error to user, or it has the complete information about a\ncollection and all of its members. This is very powerful use of\nWebDAV + XML. Try that with RPC or SOAP.\n\n//Stefan\n\nPS. Before someone asks: I think my definition does comply with Allow \nas described in RFC 2616. There is never a NOT IMPLEMENTED returned \nby a deltaV server on a method from DAV:supported-method-set.\n\n   \n\n\n\n", "id": "lists-006-11204089"}, {"subject": "RE: How Clients find out if they can perform a checkou", "content": "Hi,\n\nMy vote is that we specify the behaviour of the Allow header in the\nspecification.  \nIf we say nothing then different server vendors may implement this in\ndifferent ways.\n\nI am in agreement that Allow should return the same method set as\nDAV:supported-method-set.  \nIf Allow returned the methods possible at the point in time the request was\nprocessed then \nwhat use would these be, the state of the resource may change by the time\nthe client goes to \nact on the information returned by the Allow header (unless the resource was\nlocked).\n  \nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (ADM)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: 03 August 2001 14:39\nTo: ietf-dav-versioning@w3.org\nSubject: RE: How Clients find out if they can perform a checkout\n\n\nI find Stefan's arguments convincing, so I'll switch my vote to\n\"define supported and allowed to be the same thing\".  But I see good\narguments on both sides, so I will defer to whatever the working\ngroup wants to do here.  And if there is no consensus, I'll leave\nthe spec the way it is (i.e. making no statement on the issue, and\nleaving it up to the server implementer).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\nSent: Friday, August 03, 2001 5:12 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: How Clients find out if they can perform a checkout\n\n\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> \n> > From: John Hall [mailto:johnhall@evergo.net] \n> > \n> > > From: Clemm, Geoff\n> > \n> [...]\n> > > Using just\n> > > DAV:supported-method-set and the Allow header is much simpler \n> > > and sufficiently accurate.\n> > > \n> > > It's deliberately vague to give the server some leeway, but\n> > > in general \"supported\" means that the method might succeed on \n> > > some state of the resource, while the Allow set indicates \n> > > whether the method might succeed on the current state of the \n> > > resource. I agree this is worth stating in the protocol (if \n> > > people agree with this characterization).\n> > \n> > I think it is worth stating.\n> \n> Yup, but we first have to get Stefan to agree (:-).\n\nLet's see what the \"most bang for less bugs\" principle can do \nfor this discussion:\n\nA client cannot retrieve the Allow header and the DAV:supported-method-set\nat the same time. It's always two (most likely three) requests. Depending \non the usage, not the implementation of the server, the two method sets\n reflect the same state of the resource - or not (I am talking about \nunlocked resources here since clients should not need to lock, just to \nfind out what they can do with it).\n\nSo, all your client knows after retrieving the two sets, is that at that\npoint in time it was:\na) possible right now to perform a checkout - or not (from Allow header),\nb) generally supported to checkout - or not (from supported-method-set)\n\nMy point is that a) is useless in a client-server protocol, and that\nb) is very useful. If CHECKOUT is supported, you only _know_ that\nit succeeds when you try it out. \n\nI propose to give the Allow set and the DAV:supported-method-set\nthe same definition, namely, that they include those methods which\nmay succeed on some state of the resource (e.g. the current definition\nof DAV:supported-method-set), at least for all WebDAV extension methods.\n\nWhat can be gained by this?\n1. Consistency and performance: it is possible to retrieve a consistent\n   view of what there is to know about a resource with one PROPFIND, with\n   varying depth even for a range of resources.\n2. Simpler implementations on server side. Servers do not\n   need to implement two sets of methods with one varying on every state\n   change.\n3. Easier (if that's possible) understanding of the deltaV spec, e.g.\n   one feature less.\n\nPoint 1. is my wholy grail. It makes clients faster and keeps them\nsimple. A client does one, single PROPFIND depth 1. Either it fails,\nwith error to user, or it has the complete information about a\ncollection and all of its members. This is very powerful use of\nWebDAV + XML. Try that with RPC or SOAP.\n\n//Stefan\n\nPS. Before someone asks: I think my definition does comply with Allow \nas described in RFC 2616. There is never a NOT IMPLEMENTED returned \nby a deltaV server on a method from DAV:supported-method-set.\n\n   \n\n\n\n", "id": "lists-006-11216441"}, {"subject": "RE: Deleting version", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   Are DeltaV servers then not required to support locking at all?\n\nCorrect.\n\n   Lock-null comes along with lock.\n\nNot from Microsoft (:-).  You get locking, but not lock-null's\nor depth locking with their IIS WebDAV server.  But I agree that\nthe protocol states that lock-null comes along with lock\n(at least, for the current rev of the DAV protocol :-).\n\n   I can (barely) beleive that a server might implement\n   DeltaV but not support locking.\n\nLast I heard, Greg had no intentions of implementing locking with\nhis DeltaV server.  We (i.e. Rational) are\nlikely to initially only support the limited\namount of locking expected by a Microsoft client (i.e. single\nresource locking, but no lock-nulls or depth locks).\n\n   In fact, you acknowledge in section 14 that\n   lock-null may be implemented:\n\n   \"Non-version-controlled bindings are not under version control, and\n   therefore can be added or deleted without checking out the\n   version-controlled collection.  This feature is essential for the\n   support of lock null resources, since a lock null resource is a\n   temporary internal member of a collection that should only exist\n   for the duration of the lock, and should not be captured in the\n   version history of that collection.\"\n\nYes, it is essential that the DeltaV protocol be compatible with\nthe locking protocol (if it isn't, please let me know!).  But that\ndoesn't mean it should depend on or be otherwise concerned with it.\nTo the contrary, ensuring that the versioning protocol is orthogonal\nto the locking protocol allows the versioning and locking protocols\nto evolve independently.  Any explicit statement in the versioning\nprotocol about the locking protocol risks a conflict with a\nstatement made in later versions of the locking protocol.\n\n   You're doing what Greg (justly) accused you of and leaving things to be\n   inferred, or out of the spec entirely.  If DeltaV says nothing, then\n   implementors and servers that do locking and deltaV will be left without\n   guidance, on an issue over which the experts (heh) have argued.  Their\n   implementations will differ.\n\nIf an implementor wants to find out about locking, they should go to\nthe (current version of) the locking protocol.  We don't want to rev\nthe versioning protocol every time the locking protocol changes.  So\nif there is some subtle locking/versioning interaction, then I agree\nthat should be identified in the versioning protocol (in particular,\nthe interaction between lock null resources and versioned collections\nis such a case, and therefore is identified).\n\nSo let's get some feedback from the working group: \nWho thinks that the ability to apply MKWORKSPACE or MKACTIVITY\nis a versioning/locking interaction that merits explicit\nmention in the versioning protocol?  (I think we can take it\nas given that Lisa thinks \"yes\" and I think \"no\").\n\nAs with the DAV:resourcetype thread, I've made all the points\nI wanted to make, so I'll leave it up to working group consensus.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1122833"}, {"subject": "RE: How Clients find out if they can perform a checkou", "content": "> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> > I'm not sure that a client that does not want to deal with\n> > merges can stop there, when it hits a server that allows \n> > forking and multiple checkouts.\n> \n> The fact that some other version has a checkout has no effect \n> on whether or not your checkout will create a fork that might \n> require a merge.  That is determined solely from whether or \n> not the version you are checking out already has a descendent \n> or checkout.\n\n\nI don't think that is true.\nSay that the latest checked out version is #5.\n\nUser A checks out version #2 using working resource, intending to create\na new version and then UPDATE the VCR with the newly created version.\n\nUser B looks at version #5.  Version #5 has no current descendents, so\njust looking at Version #5 User B is unaware that User A also has a\ncheckout that could cause a merge / update problem.  To prevent this in\nan independent way, the client would have to check all previous versions\nto make sure they were not checked out.\n\nI can easily think of clients that would not want to check out version\n#5 if ANY other version were checked out.\n\n\n\n", "id": "lists-006-11230902"}, {"subject": "Fixing wording mistake in my example", "content": "I made a mistake below, I meant to say that version #5 was checked in.\nI corrected it below.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of John Hall\n> Sent: Friday, August 03, 2001 10:50 AM\n> To: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\n> Subject: RE: How Clients find out if they can perform a checkout\n> \n> \n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of \n> Clemm, Geoff\n> > > I'm not sure that a client that does not want to deal with merges \n> > > can stop there, when it hits a server that allows forking and \n> > > multiple checkouts.\n> > \n> > The fact that some other version has a checkout has no effect\n> > on whether or not your checkout will create a fork that might \n> > require a merge.  That is determined solely from whether or \n> > not the version you are checking out already has a descendent \n> > or checkout.\n> \n> \n> I don't think that is true.\n> Say that the latest checked in version is #5.\n> \n> User A checks out version #2 using working resource, \n> intending to create\n> a new version and then UPDATE the VCR with the newly created version.\n> \n> User B looks at version #5.  Version #5 has no current descendents, so\n> just looking at Version #5 User B is unaware that User A also has a\n> checkout that could cause a merge / update problem.  To \n> prevent this in\n> an independent way, the client would have to check all \n> previous versions\n> to make sure they were not checked out.\n> \n> I can easily think of clients that would not want to check out version\n> #5 if ANY other version were checked out.\n> \n> \n> \n\n\n\n", "id": "lists-006-11240566"}, {"subject": "RE: How Clients find out if they can perform a checkou", "content": "> From: John Hall [mailto:johnhall@evergo.net]\n\n> > From: Clemm, Geoff\n> > The fact that some other version has a checkout has no effect\n> > on whether or not your checkout will create a fork that might \n> > require a merge.  That is determined solely from whether or \n> > not the version you are checking out already has a descendent \n> > or checkout.\n> \n> I don't think that is true.\n> Say that the latest checked in version is #5.\n> \n> User A checks out version #2 using working resource, intending to\n> create a new version and then UPDATE the VCR with the newly created\n> version.\n\nNote that if User A is using a linear-versioning server, he will not\nbe able to check in because that would create a branch.  He would\nfirst have to merge his working resource with whatever is the latest\nversion before he could checkin.  If he is using a forking server,\nhe will have to decide at checkin time whether to just checkin\n(and thereby overwriting whatever is currently there) or first\ndo a merge (and thereby not overwrite what is there).  In either\ncase, User A set up the merge scenario by checking out a non-tip\nversion.\n\n> User B looks at version #5.  Version #5 has no current descendents,\n> so just looking at Version #5 User B is unaware that User A also has\n> a checkout that could cause a merge / update problem. To prevent\n> this in an independent way, the client would have to check all\n> previous versions to make sure they were not checked out.\n\nThere is nothing User B can do to prevent the merge/update problem.\nIt was created when User A checked out a non-tip version.  If User A\nchecks out version 5, since it is a tip version, he is guaranteed\nthat he is not causing a merge/update problem.  The only way for a\nserver to prevent the merge/update problem is to not allow forking\non checkout.  In this case, User A would not have been allowed to\ncheckout version 2 in the first place.\n\n> I can easily think of clients that would not want to check out version\n> #5 if ANY other version were checked out.\n\nThe only reason I can imagine for this would be if you wanted to\nserialize access to the resource.  But then you would just use\nthe locking protocol (i.e. LOCK the vcr before checking it out,\nand UNLOCK'ing it after you checkin).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11251552"}, {"subject": "Use of attribute", "content": "Is there some reason why DeltaV deviates from every prior instance of WebDAV\nproperty representation in XML? Not only does the current syntax make\nunnecessary use of attributes, which DAV has traditionally discouraged, but\nit reinvents something for which we already have a mechanism in DAV.\n\nTo be consistent with how 2518 does PROPFIND, PROPPATCH, etc. I would have\nexpected:\n  <D:supported-live-property-set xmlns:D=\"DAV:\"\nxmlns:x=\"http://www.xythos.com/schemas/StorageServer\"/>\n     <D:getcontentlength/>\n     <D:getcontentlanguage/>\n     <x:quota/>\n     <x:size/>\n     ...\n  </D:supported-live-property-set>\n\nBut the DeltaV draft requires the following syntax:\n  <supported-live-property-set>\n     <supported-live-property name=\"getcontentlength\" namespace=\"DAV:\"/>\n     <supported-live-property name=\"getcontentlanguage\" namespace=\"DAV:\"/>\n     <supported-live-property name=\"quota\"\nnamespace=\"http://www.xythos.com/schemas/StorageServer\"/>\n     <supported-live-property name=\"size\"\nnamespace=\"http://www.xythos.com/schemas/StorageServer\"/>\n     ...\n  </supported-live-property-set>\n\nIs there some merit to doing things this way that isn't immediately obvious?\nThe DeltaV syntax is rather more bloated and far less obvious. Moreover, it\nmakes it impossible for people to reuse the code they already have for\nparsing DAV property lists. This is not a feature.\n\nAside from consistency and stylistic considerations, the syntax in the draft\nis just plain broke. The DTD for supported-live-property set hardwires the\nnamespace to DAV:\n\n<!ATTLIST supported-live-property namespace NMTOKEN \"DAV:\">\n\nThis makes it impossible to render vendor-specific extensions (thus\nrendering my above example technically illegal). I assume this is an error\nsince just yesterday Geoff claimed that vendor-specific extensions were to\nappear in supported-live-property-set.\n\nLisa\n\n\n\n", "id": "lists-006-11261406"}, {"subject": "RE: Use of attribute", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: Saturday, August 04, 2001 7:34 AM\n> To: DeltaV\n> Subject: Use of attributes\n>\n>\n> Is there some reason why DeltaV deviates from every prior\n> instance of WebDAV\n> property representation in XML? Not only does the current syntax make\n> unnecessary use of attributes, which DAV has traditionally\n> discouraged, but\n> it reinvents something for which we already have a mechanism in DAV.\n>\n> To be consistent with how 2518 does PROPFIND, PROPPATCH, etc. I would have\n> expected:\n>   <D:supported-live-property-set xmlns:D=\"DAV:\"\n> xmlns:x=\"http://www.xythos.com/schemas/StorageServer\"/>\n>      <D:getcontentlength/>\n>      <D:getcontentlanguage/>\n>      <x:quota/>\n>      <x:size/>\n>      ...\n>   </D:supported-live-property-set>\n>\n> But the DeltaV draft requires the following syntax:\n>   <supported-live-property-set>\n>      <supported-live-property name=\"getcontentlength\" namespace=\"DAV:\"/>\n>      <supported-live-property name=\"getcontentlanguage\" namespace=\"DAV:\"/>\n>      <supported-live-property name=\"quota\"\n> namespace=\"http://www.xythos.com/schemas/StorageServer\"/>\n>      <supported-live-property name=\"size\"\n> namespace=\"http://www.xythos.com/schemas/StorageServer\"/>\n>      ...\n>   </supported-live-property-set>\n>\n> Is there some merit to doing things this way that isn't\n> immediately obvious?\n> The DeltaV syntax is rather more bloated and far less obvious.\n> Moreover, it\n> makes it impossible for people to reuse the code they already have for\n> parsing DAV property lists. This is not a feature.\n>\n> Aside from consistency and stylistic considerations, the syntax\n> in the draft\n> is just plain broke. The DTD for supported-live-property set hardwires the\n> namespace to DAV:\n>\n> <!ATTLIST supported-live-property namespace NMTOKEN \"DAV:\">\n>\n> This makes it impossible to render vendor-specific extensions (thus\n> rendering my above example technically illegal). I assume this is an error\n> since just yesterday Geoff claimed that vendor-specific extensions were to\n> appear in supported-live-property-set.\n\nYou might want to check a similar thread from April:\n\n<http://lists.w3.org/Archives/Public/w3c-dist-auth/2001AprJun/0038.html>\n\n\n\n", "id": "lists-006-11271082"}, {"subject": "RE: Use of attribute", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   To be consistent with how 2518 does PROPFIND, PROPPATCH, etc. I would\nhave\n   expected:\n     <D:supported-live-property-set xmlns:D=\"DAV:\"\n   xmlns:x=\"http://www.xythos.com/schemas/StorageServer\"/>\n<D:getcontentlength/>\n<x:quota/>\n...\n     </D:supported-live-property-set>\n\n   But the DeltaV draft requires the following syntax:\n     <supported-live-property-set>\n<supported-live-property name=\"getcontentlength\" namespace=\"DAV:\"/>\n<supported-live-property name=\"quota\"\n   namespace=\"http://www.xythos.com/schemas/StorageServer\"/>\n...\n     </supported-live-property-set>\n\n   Is there some merit to doing things this way that isn't immediately\n   obvious?\n\nThis was done at the request of the folks who care about syntactic\nvalidation (e.g. DTD or XML-Schema).  It is expected that this\nreport will be extended with other interesting metadata about the\nsupported live properties (e.g. DAV:is-computed).  By using the\nDAV:supported-live-property node, this can be declared as:\n\n<!ELEMENT supported-live-property (is-computed?)>\n\n\n   Aside from consistency and stylistic considerations, the syntax in the\ndraft\n   is just plain broke. The DTD for supported-live-property set hardwires\nthe\n   namespace to DAV:\n\n   <!ATTLIST supported-live-property namespace NMTOKEN \"DAV:\">\n\nThis does not hardwire the namespace to be \"DAV:\", it just specifies\nthat the \"DAV:\" is the default if no explicit namespace attribute is\nspecified.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11281763"}, {"subject": "RE: Use of attribute", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Sunday, August 05, 2001 7:50 PM\n> To: DeltaV\n> Subject: RE: Use of attributes\n>\n>\n>    From: Lisa Dusseault [mailto:lisa@xythos.com]\n>\n>    To be consistent with how 2518 does PROPFIND, PROPPATCH, etc. I would\n> have\n>    expected:\n>      <D:supported-live-property-set xmlns:D=\"DAV:\"\n>    xmlns:x=\"http://www.xythos.com/schemas/StorageServer\"/>\n> <D:getcontentlength/>\n> <x:quota/>\n> ...\n>      </D:supported-live-property-set>\n>\n>    But the DeltaV draft requires the following syntax:\n>      <supported-live-property-set>\n> <supported-live-property name=\"getcontentlength\" namespace=\"DAV:\"/>\n> <supported-live-property name=\"quota\"\n>    namespace=\"http://www.xythos.com/schemas/StorageServer\"/>\n> ...\n>      </supported-live-property-set>\n>\n>    Is there some merit to doing things this way that isn't immediately\n>    obvious?\n>\n> This was done at the request of the folks who care about syntactic\n> validation (e.g. DTD or XML-Schema).  It is expected that this\n> report will be extended with other interesting metadata about the\n> supported live properties (e.g. DAV:is-computed).  By using the\n> DAV:supported-live-property node, this can be declared as:\n>\n> <!ELEMENT supported-live-property (is-computed?)>\n\nThat could have easily been done by adding it in the form of:\n\n<x:quota xmlns:D=\"DAV:\" D:is-computed=\"true\" />\n\n>    Aside from consistency and stylistic considerations, the syntax in the\n> draft\n>    is just plain broke. The DTD for supported-live-property set hardwires\n> the\n>    namespace to DAV:\n>\n>    <!ATTLIST supported-live-property namespace NMTOKEN \"DAV:\">\n>\n> This does not hardwire the namespace to be \"DAV:\", it just specifies\n> that the \"DAV:\" is the default if no explicit namespace attribute is\n> specified.\n\nNow that you mention that: this breaks reporting of live properties that\nactually happen to be in no namespace at all (no, I wouldn't suggest using\nthings like that, but ...).\n\nI assume that currently no server uses DTDs to validate. Which raises the\nquestion how they should process element where the attribute is missing:\n\na) assuming the property is in the DAV: namespace,\nb) assuming it's in no namespace.\n\nFor consistency, I'd prefer b). If it's a), that should be clearly stated\nsomewhere (and a way to report properties in \"no\" namespace -- such as\nnamespace=\"\" -- should be documented).\n\nJulian\n\n\n\n", "id": "lists-006-11290828"}, {"subject": "RE: Use of attribute", "content": "Note: I personally don't care much one way or the other on this\ntopic, so I'm just reporting on the rationale that went into the\ncurrent choice.\n\n   From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n\n   > From: Clemm, Geoff\n   >    From: Lisa Dusseault [mailto:lisa@xythos.com]\n   >\n   >    But the DeltaV draft requires the following syntax:\n   >      <supported-live-property-set>\n   > <supported-live-property name=\"getcontentlength\" namespace=\"DAV:\"/>\n   > <supported-live-property name=\"quota\"\n   >    namespace=\"http://www.xythos.com/schemas/StorageServer\"/>\n   > ...\n   >      </supported-live-property-set>\n   >\n   >    Is there some merit to doing things this way that isn't immediately\n   >    obvious?\n   >\n   > This was done at the request of the folks who care about syntactic\n   > validation (e.g. DTD or XML-Schema).  It is expected that this\n   > report will be extended with other interesting metadata about the\n   > supported live properties (e.g. DAV:is-computed).  By using the\n   > DAV:supported-live-property node, this can be declared as:\n   >\n   > <!ELEMENT supported-live-property (is-computed?)>\n\n   That could have easily been done by adding it in the form of:\n\n   <x:quota xmlns:D=\"DAV:\" D:is-computed=\"true\" />\n\nFor a simple extension like D:is-computed, yes, but not all\nextensions will have values that easily map into a simple string.\n\n   >    Aside from consistency and stylistic considerations, the syntax in\nthe\n   > draft\n   >    is just plain broke. The DTD for supported-live-property set\nhardwires\n   > the\n   >    namespace to DAV:\n   >\n   >    <!ATTLIST supported-live-property namespace NMTOKEN \"DAV:\">\n   >\n   > This does not hardwire the namespace to be \"DAV:\", it just specifies\n   > that the \"DAV:\" is the default if no explicit namespace attribute is\n   > specified.\n\n   Now that you mention that: this breaks reporting of live properties\n   that actually happen to be in no namespace at all (no, I wouldn't\n   suggest using things like that, but ...).\n\n   I assume that currently no server uses DTDs to validate. Which\n   raises the question how they should process element where the\n   attribute is missing:\n\n   a) assuming the property is in the DAV: namespace,\n   b) assuming it's in no namespace.\n\n   For consistency, I'd prefer b).\n\nSince (as you indicate) one should not place properties in\nthe default namespace, having the default be something that\nwe discourage and is likely to not occur, does not make much\nsense to me.\n\n   If it's a), that should be clearly stated somewhere \n\nThe fact that the default is the DAV: namespace is specified\nin the DTD declaration in the protocol.  We could repeat that\nin text I suppose.\n\n   (and a way to report properties in \"no\" namespace -- such as\n   namespace=\"\" -- should be documented).\n\nHow else could it be represented?  Since we do not want to encourage\nanyone to place properties in the default namespace, I'd be inclined\nto leave this unstated, as a way of discouraging this bad practice.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11301818"}, {"subject": "RE: Use of attribute", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Monday, August 06, 2001 5:22 AM\n> To: DeltaV\n> Subject: RE: Use of attributes\n>\n>\n> Note: I personally don't care much one way or the other on this\n> topic, so I'm just reporting on the rationale that went into the\n> current choice.\n>\n> ...\n>\n>    That could have easily been done by adding it in the form of:\n>\n>    <x:quota xmlns:D=\"DAV:\" D:is-computed=\"true\" />\n>\n> For a simple extension like D:is-computed, yes, but not all\n> extensions will have values that easily map into a simple string.\n\n<x:quota><D:is-computed xmlns:D=\"DAV:\">...</D:is-computed></x:quota>\n\n> ...\n>\n>    Now that you mention that: this breaks reporting of live properties\n>    that actually happen to be in no namespace at all (no, I wouldn't\n>    suggest using things like that, but ...).\n>\n>    I assume that currently no server uses DTDs to validate. Which\n>    raises the question how they should process element where the\n>    attribute is missing:\n>\n>    a) assuming the property is in the DAV: namespace,\n>    b) assuming it's in no namespace.\n>\n>    For consistency, I'd prefer b).\n>\n> Since (as you indicate) one should not place properties in\n> the default namespace, having the default be something that\n> we discourage and is likely to not occur, does not make much\n> sense to me.\n\nIt would make the spec more logical.\n\nSo, among those who have implemented clients that use\nsupported-live-property-set -- how many of you are currently treating a\nmissing namespace name as being \"DAV:\"? I'd say that the current wording\nalmost *guarantees* that clients will implement this wrongly.\n\n>    If it's a), that should be clearly stated somewhere\n>\n> The fact that the default is the DAV: namespace is specified\n> in the DTD declaration in the protocol.  We could repeat that\n> in text I suppose.\n\nYes, but the DTD as it stands can't be used for validation (1. DTDs and\nnamespaces don't work well together, 2. there are only DTD *fragments*).\nTherefore I'd say that the DTD excepts can't be normative.\n\n>    (and a way to report properties in \"no\" namespace -- such as\n>    namespace=\"\" -- should be documented).\n>\n> How else could it be represented?  Since we do not want to encourage\n> anyone to place properties in the default namespace, I'd be inclined\n\n...in no namespace...\n\n> to leave this unstated, as a way of discouraging this bad practice.\n\nI think this is wrong. The spec needs to be clear. Omitting something\nbecause you want to discourage it doesn't seem to be the right approach.\n\n\n\n", "id": "lists-006-11312840"}, {"subject": "Re: Appendix A &ndash;&ndash; Resource Classificatio", "content": "John,\nVERSION-CONTROL is permissible on a resource that is already under version \ncontrol to allow clients that use VERSION-CONTROL to interoperate with \nservers that automatically put all resources under version control without \nrequiring any special cases. It is a a no-op in this case.\n\n\n\n\n\"John Hall\" <johnhall@evergo.net>\nSent by: ietf-dav-versioning-request@w3.org\n08/02/2001 02:35 PM\n\n \n        To:     <ietf-dav-versioning@w3.org>\n        cc: \n        Subject:        Appendix A -- Resource Classification\n\n \n\n\n23.4 Why should VERSION-CONTROL be listed on a resource that is already\nunder version control?  It would be interesting if we allowed\nVERSION-CONTROL to remove a resource from version control, but we don't.\nIf VERSION-CONTROL only appears on versionable but non-versioned\nresources then that can communicate something interesting to the client.\n\n23.9 UNCHECKOUT (checkout-in-place) is missing.\n\n\n\n", "id": "lists-006-11323528"}, {"subject": "DeltaV breakout session at IETF 5", "content": "Since Geoff can't make it on Tuesday, let's have the breakout on Wedensday \ninstead. We can meet in the AM to collect issues for disucssion, break for \nthe meeting at 3:00, and then have followup as needed in the evening. \nSorry for the late notice. My email wasn't working over the weekend.\n\n\n\n", "id": "lists-006-11332684"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas  eline resource type value", "content": "No, no, no!!!!\n\nWe're not asking software to automatically distinguish what we call a\ndifference in type, vs what we call a difference in state.  That kind of\ndecision-making is, at present, a human activity.  We're capable of saying\n\"checkin/checkout is a change of state, not type\", even if software cannot.\n\nGeoff, don't be obtuse about this.  We can make fuzzy distinctions, because\nwe're humans designing the deltaV spec in order that the way it works makes\nsense to us.  Help us make DeltaV make sense to _humans_.  AND THEN humans\ncan write the programs that interoperate with each other.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, June 06, 2001 9:48 AM\n> To: DeltaV (E-mail)\n> Subject: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:bas eline resource type values\n>\n>\n> If you believe there is a useful line drawn between \"resource state\"\n> and \"resource type\", then it is necessary to unambiguously define \"state\"\n> and\n> \"type\" (in particular, in a way that allows you to distinguish one\n> from the other).\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Lisa Dusseault [mailto:lisa@xythos.com]\n> Sent: Wednesday, June 06, 2001 12:00 PM\n> To: Clemm, Geoff; DeltaV (E-mail)\n> Subject: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:bas eline resource type values\n>\n>\n> If you believe that whether a resource is under version control\n> or not, is a\n> matter of state, then leave it OUT of resourcetype.  It's not called\n> \"resourcestate\".\n>\n> Version, version History, and others are still types.\n>\n> But draw a line somewhere.\n>\n> lisa\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > Sent: Wednesday, June 06, 2001 8:07 AM\n> > To: DeltaV (E-mail)\n> > Subject: RE: Removing the DAV:activity and DAV:version-history and\n> > DAV:bas eline resource type values\n> >\n> >\n> > I think Tim's point was that if \"under version control\"\n> > (e.g. \"version-controlled-resource\") is part of\n> > the \"type\" of a resource, then \"checked-out\" and \"checked-in\"\n> > would equally usefully be considered as part of the type\n> > (since the significantly affect what methods can be\n> > applied to that resource).\n> >\n> > In each case, you have the same resource (i.e. when you\n> > put a resource under version control, it is the same resource\n> > but has some additional live properties and methods you can\n> > apply to it).\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n> > Sent: Wednesday, June 06, 2001 6:27 AM\n> > To: DeltaV (E-mail)\n> > Subject: AW: Removing the DAV:activity and DAV:version-history and DAV\n> > :baseline resource type values\n> >\n> >\n> >\n> >\n> > > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von\n> > > Tim_Ellison@uk.ibm.com\n> > > [...]\n> > >\n> > > My view of the world...\n> > >\n> > > Here's the list of elements that could appear in a\n> > DAV:resourcetype.  Some\n> > > of these can be combined to provide a really meaningful\n> > experience for the\n> > > client.  Obviously, some combinations are invalid.\n> > >      <DAV:checked-in/>\n> > >      <DAV:checked-out/>\n> > >      <DAV:collection/>\n> > >      <DAV:working-resource/>\n> > >      <DAV:version-controlled-resource/>\n> > >      <DAV:version/>\n> > >      <DAV:version-history/>\n> > >      <DAV:workspace/>\n> > >      <DAV:version-controlled-configuration/>\n> > >      <DAV:baseline/>\n> > >      <DAV:activity/>\n> > >\n> >\n> > What is your rationale for checked-in/out in the type? I think\n> > I have missed something in the spec, since it feels like a\n> > property to me.\n> >\n> > > So,\n> > > <DAV:resourcetype>\n> > >      <DAV:activity/>\n> > > </DAV:resourcetype\n> > >\n> > > would be good, that is, not surprisingly, an activity resource.\n> > >\n> > > <DAV:resourcetype>\n> > >      <DAV:checked-out/>\n> > >      <DAV:version-controlled-resource/>\n> > >      <DAV:collection/>\n> > >      <DAV:workspace/>\n> > > </DAV:resourcetype>\n> > >\n> > > would be good too, it is a checked-out, version-controlled\n> > resource for a\n> > > workspace collection.  And so on.\n> > >\n> > > Tim\n> > >\n> > >\n\n\n\n", "id": "lists-006-1133600"}, {"subject": "RE: auto-checkout and auto-checki", "content": "I assume there's also an empty value for servers that don't do\nauto-versioning?  Or does the property disappear?\n\nI still haven't seen a draft with this replaced.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Monday, July 16, 2001 4:55 AM\n> To: 'DeltaV'\n> Subject: RE: auto-checkout and auto-checkin\n>\n>\n> Oops.  I had \"auto-checkout\" in a couple of places where I meant\n> to have \"auto-version\" (cut'n'paste can be risky :-).  Here's the\n> fixed proposal:\n>\n>\n> 3.2.2DAV:auto-version\n>\n> If the DAV:auto-version value is DAV:checkout-checkin, when a\n> modification request (such as PUT/PROPPATCH) is applied to a\n> checked-in version-controlled resource, the request is automatically\n> preceded by a checkout and followed by a checkin operation.\n>\n> If the DAV:auto-version value is DAV:checkout-unlocked-checkin, when a\n> modification request is applied to a checked-in version-controlled\n> resource, the request is automatically preceded by a checkout\n> operation.  If the resource is not write-locked, the request is\n> automatically followed by a checkin operation.\n>\n> If the DAV:auto-version value is DAV:checkout, when a modification\n> request is applied to a checked-in version-controlled resource, the\n> request is automatically preceded by a checkout operation.\n>\n> If the DAV:auto-version value is DAV:locked-checkout, when a\n> modification request is applied to a write-locked checked-in\n> version-controlled resource, the request is automatically preceded by\n> a checkout operation.\n>\n> If a write-locked resource was automatically checked out, when the\n> write lock is removed (such as from an UNLOCK or lock timeout), if the\n> resource has not yet been checked in, the removal of the write lock is\n> automatically preceded by a checkin operation.\n>\n> A server MAY refuse to allow the value of the DAV:auto-version\n> property to be modified.\n>\n> <!ELEMENT auto-versionout\n>  (checkout-checkin | checkout-unlocked-checkin | checkout |\n> locked-checkout)\n> >\n> <!ELEMENT checkout-checkin EMPTY>\n> <!ELEMENT checkout-unlocked-checkin EMPTY>\n> <!ELEMENT checkout EMPTY>\n> <!ELEMENT locked-checkout EMPTY>\n>\n>\n> -----Original Message-----\n> From: Clemm, Geoff [mailto:gclemm@Rational.Com]\n> Sent: Friday, July 13, 2001 7:11 PM\n> To: 'DeltaV'\n> Subject: RE: auto-checkout and auto-checkin\n>\n>\n> Clearly there is significant support for going back to\n> DAV:auto-version (as opposed to DAV:auto-checkout,DAV:auto-checkin).\n> If nobody objects to going back to DAV:auto-version , I'm willing to\n> do so (I believe I was the most enthusiastic supporter of the original\n> switch to auto-checkout and auto-checkin).\n\n\n\n", "id": "lists-006-11339476"}, {"subject": "Feature request for CHECKIN/OUT extensio", "content": "Feature request for CHECKIN/OUT extension\n\nIn many cases, a versioning-aware client might want to display/include the\nURI of the version it's editing *while* it's edited. For instance, a\nversioning\naware editor might include this as meta-information, or the author of a\ndocument might want to know the URI of the version *before* it's checked in.\nA well-known example is the W3C way of referring to document versions in\nrecommendations: it contains HREFs to \"the current version\", to \"this\nversion\"\nand to the \"previous version\". Something like this is currently impossible\nwith deltaV, as the version URI is determined at the time of CHECKIN.\n\nProposal:\n\n1) Extend CHECKOUT to optionally return an \"expected CHECKIN URI\".\n2) Extend CHECKIN to optionally use the \"expected CHECKIN URI\", failing the\nrequest if it's not possible to checkin the resource with the desired\nversion URI (in which case a new \"expected CHECKIN URI\" is returned).\n\nSome possible strategies:\n\n1) Pass the information as proprietary live properties.\n2) Pass the information as properties in the DAV: namespace, and define the\nbehaviour in the deltaV spec.\n3) (preferred) Pass the information in the request/response bodies of\nCHECKIN / CHECKOUT, such as:\n\nCHECKOUT method:\n\n>>REQUEST\n\n  CHECKOUT /foo.html HTTP/1.1\n  Host: www.webdav.org\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkout xmlns:D=\"DAV:\">\n    <D:compute-expected-version-URI />\n  </D:checkout>\n\n\n>>RESPONSE\n\n  HTTP/1.1 200 OK\n  Cache-Control: no-cache\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkout xmlns:D=\"DAV:\">\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:expected-ver\nsion-URI>\n  </D:checkout>\n\n  (Note that we would need to define an (optional) response body for\nCHECKOUT).\n\n\nCHECKIN method:\n\n\n>>REQUEST\n\n  CHECKIN /foo.html HTTP/1.1\n  Host: www.webdav.org\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkin xmlns:D=\"DAV:\">\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:expected-ver\nsion-URI>\n  </D:checkin>\n\n>>RESPONSE\n\n  HTTP/1.1 201 Created\n  Location: http://repo.webdav.org/his/23/ver/32\n  Cache-Control: no-cache\n\n  or\n\n>>RESPONSE\n\n  HTTP/1.1 409 Forbidden\n  Cache-Control: no-cache\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:error xmlns:D=\"DAV:\">\n    <D:cannot-assign-expected-version-URI />\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/33</D:expected-ver\nsion-URI>\n  </D:error>\n\n\n\n", "id": "lists-006-11350495"}, {"subject": "RE: Use of attribute", "content": "   > From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n   >    That could have easily been done by adding it in the form of:\n   >\n   >    <x:quota xmlns:D=\"DAV:\" D:is-computed=\"true\" />\n\n   > From: Clemm, Geoff\n   > For a simple extension like D:is-computed, yes, but not all\n   > extensions will have values that easily map into a simple string.\n\n   <x:quota><D:is-computed xmlns:D=\"DAV:\">...</D:is-computed></x:quota>\n\nThe problem is how do you declare where this new D:iscomputed\nnode can appear?  Since it can appear on any property type,\nit can appear as a child of any node.  But if you have a\nD:supported-live-property node, you can declare that D:is-computed is a\nchild of D:supported-live-property.  Note that this is not a\nDTD specific issue, but applies to any attempt to declare the\nsyntax (e.g. XML-Schema).\n\n   So, among those who have implemented clients that use\n   supported-live-property-set -- how many of you are currently\n   treating a missing namespace name as being \"DAV:\"? I'd say that the\n   current wording almost *guarantees* that clients will implement\n   this wrongly.\n\nWell, \"guarantee\" seems a bit strong ... I'd think at least one implementor\nwould be aware of the ATTLIST semantics.  But I agree with your point.\nThe spec should be clear, and if the ATTLIST semantics is not widely\nunderstood, we need to make it clear what was intended.\n\nProbably, the best way to go is to replace the old syntax, i.e.:\n\n  <D:supported-live-property-set>\n    <D:supported-live-property>\n      <D:name> <D:getcontentlanguage/> </D:name>\n    </D:supported-live-property>\n    <D:supported-live-property>\n      <D:name> <X:quota/> </D:name>\n  </supported-live-property-set>\n\nNote: All this got started when we encountered problems with\nD:supported-method ... those values are not conveniently\nrepresented as xml nodes, which let to the attribute approach.\nD:supported-live-property and D:supported-report were changed\njust to be consistent with D:supported-method.  But we could\neasily change D:supported-live-property and D:supported-report\nback, and just use attributes for D:supported-method.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11361832"}, {"subject": "RE: Use of attribute", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Monday, August 06, 2001 5:40 PM\n> To: DeltaV\n> Subject: RE: Use of attributes\n> \n> ...\n>\n> Probably, the best way to go is to replace the old syntax, i.e.:\n> \n>   <D:supported-live-property-set>\n>     <D:supported-live-property>\n>       <D:name> <D:getcontentlanguage/> </D:name>\n>     </D:supported-live-property>\n>     <D:supported-live-property>\n>       <D:name> <X:quota/> </D:name>\n>   </supported-live-property-set>\n\nWhy do we need <D:name>? Wouldn't\n\n<D:supported-live-property-set>\n     <D:supported-live-property>\n     <D:getcontentlanguage/>\n     </D:supported-live-property>\n     <D:supported-live-property>\n       <X:quota/>\n     </D:supported-live-property>\n</D:supported-live-property-set>\n \n\n\n\n", "id": "lists-006-11371631"}, {"subject": "RE: Use of attribute", "content": "> Since (as you indicate) one should not place properties in\n> the default namespace, having the default be something that\n> we discourage and is likely to not occur, does not make much\n> sense to me.\n\nI think what Julian pointed out is different.  A live property in the NULL\nnamespace would need to be represented.  XML allows elements to have no\nnamespace.  DAV did not forbid this.\n\n> The fact that the default is the DAV: namespace is specified\n> in the DTD declaration in the protocol.  We could repeat that\n> in text I suppose.\n\nThat's not true, and I would object to that if it were true.  Anything can\nbe the default namespace, or you don't need to have one.  The default\nnamespace is declared in each document.  E.g.\n\n  <mydoc xmlns=\"foo\" xmlns:D=\"DAV:\">\n    <D:prop><D:getcontentlength/></D:prop>\n    <more-stuff-in-default-ns>\n  </mydoc>\n\nIn the above example, the foo namespace is the default.  None of these is\nthe NULL namespace.\n\n  <mydoc xmlns:D=\"DAV:\">\n    <D:prop><D:getcontentlength/></D:prop>\n    <more-stuff-in-default-ns>\n  </mydoc>\n\nIn the second example, the default namespace is in the NULL namespace. There\nare two elements in the NULL namespace.\n\nBoth DAV clients and servers must be able to accept DAV request/response\nbodies where DAV: is the default namespace, where some other namespace is\nthe default namespace, and where the null namespace is the default\nnamespace.  Both clients and servers need to be able to handle extensions\nthat are in the null namespace.\n\nlisa\n\n\n\n", "id": "lists-006-11380451"}, {"subject": "RE: How Clients find out if they can perform a checkou", "content": "I agree with Stefan. I see little to be gained distinguishing between the\nAllow header and DAV:supported-method-set. In any case, clients must use\nthe information obtained from the server cautiously as the state may change\nfrom one request to the next. That is, a client can use information from\nthe server to adjust its UI in order to indicate available functionality to\nits users, but it should be prepared to be wrong and recover gracefully. On\nthe web, you find out what you can do by trying and seeing.\n\n\n\n                                                                                                                        \n                    \"Stefan Eissing\"                                                                                    \n                    <stefan.eissing@greenbyt       To:     <ietf-dav-versioning@w3.org>                                 \n                    es.de>                         cc:                                                                  \n                    Sent by:                       Subject:     RE: How Clients find out if they can perform a checkout \n                    ietf-dav-versioning-requ                                                                            \n                    est@w3.org                                                                                          \n                                                                                                                        \n                                                                                                                        \n                    08/03/2001 05:12 AM                                                                                 \n                                                                                                                        \n                                                                                                                        \n\n\n\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n>\n> > From: John Hall [mailto:johnhall@evergo.net]\n> >\n> > > From: Clemm, Geoff\n> >\n> [...]\n> > > Using just\n> > > DAV:supported-method-set and the Allow header is much simpler\n> > > and sufficiently accurate.\n> > >\n> > > It's deliberately vague to give the server some leeway, but\n> > > in general \"supported\" means that the method might succeed on\n> > > some state of the resource, while the Allow set indicates\n> > > whether the method might succeed on the current state of the\n> > > resource. I agree this is worth stating in the protocol (if\n> > > people agree with this characterization).\n> >\n> > I think it is worth stating.\n>\n> Yup, but we first have to get Stefan to agree (:-).\n\nLet's see what the \"most bang for less bugs\" principle can do\nfor this discussion:\n\nA client cannot retrieve the Allow header and the DAV:supported-method-set\nat the same time. It's always two (most likely three) requests. Depending\non the usage, not the implementation of the server, the two method sets\n reflect the same state of the resource - or not (I am talking about\nunlocked resources here since clients should not need to lock, just to\nfind out what they can do with it).\n\nSo, all your client knows after retrieving the two sets, is that at that\npoint in time it was:\na) possible right now to perform a checkout - or not (from Allow header),\nb) generally supported to checkout - or not (from supported-method-set)\n\nMy point is that a) is useless in a client-server protocol, and that\nb) is very useful. If CHECKOUT is supported, you only _know_ that\nit succeeds when you try it out.\n\nI propose to give the Allow set and the DAV:supported-method-set\nthe same definition, namely, that they include those methods which\nmay succeed on some state of the resource (e.g. the current definition\nof DAV:supported-method-set), at least for all WebDAV extension methods.\n\nWhat can be gained by this?\n1. Consistency and performance: it is possible to retrieve a consistent\n   view of what there is to know about a resource with one PROPFIND, with\n   varying depth even for a range of resources.\n2. Simpler implementations on server side. Servers do not\n   need to implement two sets of methods with one varying on every state\n   change.\n3. Easier (if that's possible) understanding of the deltaV spec, e.g.\n   one feature less.\n\nPoint 1. is my wholy grail. It makes clients faster and keeps them\nsimple. A client does one, single PROPFIND depth 1. Either it fails,\nwith error to user, or it has the complete information about a\ncollection and all of its members. This is very powerful use of\nWebDAV + XML. Try that with RPC or SOAP.\n\n//Stefan\n\nPS. Before someone asks: I think my definition does comply with Allow\nas described in RFC 2616. There is never a NOT IMPLEMENTED returned\nby a deltaV server on a method from DAV:supported-method-set.\n\n\n\n", "id": "lists-006-11389206"}, {"subject": "DeltaV breakout sessio", "content": "Let's meet at 9:00 AM Wedensday morning in the lobby of the Hilton. \nDepending on the group size, we can probably just squat nearby pretty \ncomfortably. Hope to see many of you there. \n\n\n\n", "id": "lists-006-11402716"}, {"subject": "RE: Use of attribute", "content": "The reason you describe for putting the info in attributes isn't required;\nyou could just have easily made the extended information children of <prop>,\nnext to the property name.\n\nI don't know why the method string wasn't expressed as PCDATA, but it's fine\nto invent new stuff for new situations.  Expressing props in XML is an old\nsituation.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Monday, August 06, 2001 8:40 AM\n> To: DeltaV\n> Subject: RE: Use of attributes\n>\n>\n>\n>    > From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n>    >    That could have easily been done by adding it in the form of:\n>    >\n>    >    <x:quota xmlns:D=\"DAV:\" D:is-computed=\"true\" />\n>\n>    > From: Clemm, Geoff\n>    > For a simple extension like D:is-computed, yes, but not all\n>    > extensions will have values that easily map into a simple string.\n>\n>    <x:quota><D:is-computed xmlns:D=\"DAV:\">...</D:is-computed></x:quota>\n>\n> The problem is how do you declare where this new D:iscomputed\n> node can appear?  Since it can appear on any property type,\n> it can appear as a child of any node.  But if you have a\n> D:supported-live-property node, you can declare that D:is-computed is a\n> child of D:supported-live-property.  Note that this is not a\n> DTD specific issue, but applies to any attempt to declare the\n> syntax (e.g. XML-Schema).\n>\n>    So, among those who have implemented clients that use\n>    supported-live-property-set -- how many of you are currently\n>    treating a missing namespace name as being \"DAV:\"? I'd say that the\n>    current wording almost *guarantees* that clients will implement\n>    this wrongly.\n>\n> Well, \"guarantee\" seems a bit strong ... I'd think at least one\n> implementor\n> would be aware of the ATTLIST semantics.  But I agree with your point.\n> The spec should be clear, and if the ATTLIST semantics is not widely\n> understood, we need to make it clear what was intended.\n>\n> Probably, the best way to go is to replace the old syntax, i.e.:\n>\n>   <D:supported-live-property-set>\n>     <D:supported-live-property>\n>       <D:name> <D:getcontentlanguage/> </D:name>\n>     </D:supported-live-property>\n>     <D:supported-live-property>\n>       <D:name> <X:quota/> </D:name>\n>   </supported-live-property-set>\n>\n> Note: All this got started when we encountered problems with\n> D:supported-method ... those values are not conveniently\n> represented as xml nodes, which let to the attribute approach.\n> D:supported-live-property and D:supported-report were changed\n> just to be consistent with D:supported-method.  But we could\n> easily change D:supported-live-property and D:supported-report\n> back, and just use attributes for D:supported-method.\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-11409570"}, {"subject": "RE: Feature request for CHECKIN/OUT extensio", "content": "Well, I personally expect the CHECKIN URI to be the same as the CHECKOUT\nURL.\n\nNote that when using working resources (where this is a concern) that we\nhave a proposal with the following characteristics:\n\nA CHECKOUT of a VCR with a <apply-to-version> will cause the working\nresource to track the VCR from which it came, and a subsequent CHECKIN\nof the working resource will checkin the working resource and update the\nvcr.\n\nThat seemed to be what you were after, or did you hope for a broader\nability to do something like this?\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of \n> Julian F. Reschke\n> Sent: Monday, August 06, 2001 7:50 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Feature request for CHECKIN/OUT extension\n> \n> \n> Feature request for CHECKIN/OUT extension\n> \n> In many cases, a versioning-aware client might want to \n> display/include the URI of the version it's editing *while* \n> it's edited. For instance, a versioning aware editor might \n> include this as meta-information, or the author of a document \n> might want to know the URI of the version *before* it's \n> checked in. A well-known example is the W3C way of referring \n> to document versions in\n> recommendations: it contains HREFs to \"the current version\", \n> to \"this version\" and to the \"previous version\". Something \n> like this is currently impossible with deltaV, as the version \n> URI is determined at the time of CHECKIN.\n> \n> Proposal:\n> \n> 1) Extend CHECKOUT to optionally return an \"expected CHECKIN URI\".\n> 2) Extend CHECKIN to optionally use the \"expected CHECKIN \n> URI\", failing the request if it's not possible to checkin the \n> resource with the desired version URI (in which case a new \n> \"expected CHECKIN URI\" is returned).\n> \n> Some possible strategies:\n> \n> 1) Pass the information as proprietary live properties.\n> 2) Pass the information as properties in the DAV: namespace, \n> and define the behaviour in the deltaV spec.\n> 3) (preferred) Pass the information in the request/response \n> bodies of CHECKIN / CHECKOUT, such as:\n> \n> CHECKOUT method:\n> \n> >>REQUEST\n> \n>   CHECKOUT /foo.html HTTP/1.1\n>   Host: www.webdav.org\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx\n> \n>   <D:checkout xmlns:D=\"DAV:\">\n>     <D:compute-expected-version-URI />\n>   </D:checkout>\n> \n> \n> >>RESPONSE\n> \n>   HTTP/1.1 200 OK\n>   Cache-Control: no-cache\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx\n> \n>   <D:checkout xmlns:D=\"DAV:\">\n> \n> <D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</\nD:expected-ver\n> sion-URI>\n>   </D:checkout>\n> \n>   (Note that we would need to define an (optional) response \n> body for CHECKOUT).\n> \n> \n> CHECKIN method:\n> \n> \n> >>REQUEST\n> \n>   CHECKIN /foo.html HTTP/1.1\n>   Host: www.webdav.org\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx\n> \n>   <D:checkin xmlns:D=\"DAV:\">\n> \n> <D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</\nD:expected-ver\n> sion-URI>\n>   </D:checkin>\n> \n> >>RESPONSE\n> \n>   HTTP/1.1 201 Created\n>   Location: http://repo.webdav.org/his/23/ver/32\n>   Cache-Control: no-cache\n> \n>   or\n> \n> >>RESPONSE\n> \n>   HTTP/1.1 409 Forbidden\n>   Cache-Control: no-cache\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx\n> \n>   <D:error xmlns:D=\"DAV:\">\n>     <D:cannot-assign-expected-version-URI />\n> \n> <D:expected-version-URI>http://repo.webdav.org/his/23/ver/33</\nD:expected-ver\n> sion-URI>\n>   </D:error>\n> \n> \n> \n> \n> \n\n\n\n", "id": "lists-006-11420555"}, {"subject": "RE: Feature request for CHECKIN/OUT extensio", "content": "Perhaps you could explain what benefit this \"expected version URL\"\nwould provide.  In the W3C, you have a human meaningful URL, which\nDeltaV would call the version-controlled resource.  The resource\nat this URL has a property that points at the latest immutable version,\nwhich DeltaV calls the DAV:checked-in version.  I am not aware of\nthe W3C having a URL for \"the next version that will be created\".\n\nMany versioning repositories do not allocate the version URL\nuntil the version is actually created, and therefore would not\nsupport the \"expected version\" feature.  In particular, for a repository\nthat supports branching and unreserved checkouts, the client\nthat gets a particular version URL depends on which client\nchecks in first.  I would be reluctant to add\na feature like this which will cause interoperability problems,\nunless there is a compelling use case that requires it.\n\nCheers,\nGeoff\n \n\n-----Original Message-----\nFrom: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\nSent: Monday, August 06, 2001 10:50 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Feature request for CHECKIN/OUT extension\n\n\nFeature request for CHECKIN/OUT extension\n\nIn many cases, a versioning-aware client might want to display/include the\nURI of the version it's editing *while* it's edited. For instance, a\nversioning\naware editor might include this as meta-information, or the author of a\ndocument might want to know the URI of the version *before* it's checked in.\nA well-known example is the W3C way of referring to document versions in\nrecommendations: it contains HREFs to \"the current version\", to \"this\nversion\"\nand to the \"previous version\". Something like this is currently impossible\nwith deltaV, as the version URI is determined at the time of CHECKIN.\n\nProposal:\n\n1) Extend CHECKOUT to optionally return an \"expected CHECKIN URI\".\n2) Extend CHECKIN to optionally use the \"expected CHECKIN URI\", failing the\nrequest if it's not possible to checkin the resource with the desired\nversion URI (in which case a new \"expected CHECKIN URI\" is returned).\n\nSome possible strategies:\n\n1) Pass the information as proprietary live properties.\n2) Pass the information as properties in the DAV: namespace, and define the\nbehaviour in the deltaV spec.\n3) (preferred) Pass the information in the request/response bodies of\nCHECKIN / CHECKOUT, such as:\n\nCHECKOUT method:\n\n>>REQUEST\n\n  CHECKOUT /foo.html HTTP/1.1\n  Host: www.webdav.org\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkout xmlns:D=\"DAV:\">\n    <D:compute-expected-version-URI />\n  </D:checkout>\n\n\n>>RESPONSE\n\n  HTTP/1.1 200 OK\n  Cache-Control: no-cache\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkout xmlns:D=\"DAV:\">\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:expected-ver\nsion-URI>\n  </D:checkout>\n\n  (Note that we would need to define an (optional) response body for\nCHECKOUT).\n\n\nCHECKIN method:\n\n\n>>REQUEST\n\n  CHECKIN /foo.html HTTP/1.1\n  Host: www.webdav.org\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkin xmlns:D=\"DAV:\">\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:expected-ver\nsion-URI>\n  </D:checkin>\n\n>>RESPONSE\n\n  HTTP/1.1 201 Created\n  Location: http://repo.webdav.org/his/23/ver/32\n  Cache-Control: no-cache\n\n  or\n\n>>RESPONSE\n\n  HTTP/1.1 409 Forbidden\n  Cache-Control: no-cache\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:error xmlns:D=\"DAV:\">\n    <D:cannot-assign-expected-version-URI />\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/33</D:expected-ver\nsion-URI>\n  </D:error>\n\n\n\n", "id": "lists-006-11433477"}, {"subject": "RE: auto-checkout and auto-checki", "content": "I have a working draft that addresses the following issues that\nhave been raised since draft-16:\n\n-Added XML token for various postconditions (Peter).\n-1.6: Clarified when 403 and 409 are to be used (Peter).\n-3.2.2: Replaced DAV:auto-checkout and DAV:auto-checkin with\nDAV:auto-version (Lisa).\n-8.2: Clarified the different between LABEL/set and LABEL/add\n(Peter).\n-8.2: Changed DAV:must-not-be-checked-out to DAV:must-be-checked-in\n-12.6: Changed DAV:create-empty-baseline postcondition to be\nDAV:create-new-baseline (Peter).\n-12.6: Fixed DAV:must-have-no-version-controlled-members text\n(Edgar).\n\nUnfortunately, I currently have no connectivity to the DeltaV web site\n(apparently a virus-related IT issue), so I cannot post the working draft\nyet, but the wording on DAV:auto-version is just the one I posted to the\nworking group.\n\nWith regard to Lisa's specific question, I was assuming that an empty\nvalue for the DAV:auto-version property would indicate no auto-versioning\nfunctionality for that resource.  I notice that we are missing a \"?\" in\nthe DTD, which I will add so that an empty value is allowed.  Does\nanyone prefer an explicit DAV:none value for this case instead?\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Monday, August 06, 2001 10:05 AM\nTo: Clemm, Geoff; 'DeltaV'\nSubject: RE: auto-checkout and auto-checkin\n\n\nI assume there's also an empty value for servers that don't do\nauto-versioning?  Or does the property disappear?\n\nI still haven't seen a draft with this replaced.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Monday, July 16, 2001 4:55 AM\n> To: 'DeltaV'\n> Subject: RE: auto-checkout and auto-checkin\n>\n>\n> Oops.  I had \"auto-checkout\" in a couple of places where I meant\n> to have \"auto-version\" (cut'n'paste can be risky :-).  Here's the\n> fixed proposal:\n>\n>\n> 3.2.2DAV:auto-version\n>\n> If the DAV:auto-version value is DAV:checkout-checkin, when a\n> modification request (such as PUT/PROPPATCH) is applied to a\n> checked-in version-controlled resource, the request is automatically\n> preceded by a checkout and followed by a checkin operation.\n>\n> If the DAV:auto-version value is DAV:checkout-unlocked-checkin, when a\n> modification request is applied to a checked-in version-controlled\n> resource, the request is automatically preceded by a checkout\n> operation.  If the resource is not write-locked, the request is\n> automatically followed by a checkin operation.\n>\n> If the DAV:auto-version value is DAV:checkout, when a modification\n> request is applied to a checked-in version-controlled resource, the\n> request is automatically preceded by a checkout operation.\n>\n> If the DAV:auto-version value is DAV:locked-checkout, when a\n> modification request is applied to a write-locked checked-in\n> version-controlled resource, the request is automatically preceded by\n> a checkout operation.\n>\n> If a write-locked resource was automatically checked out, when the\n> write lock is removed (such as from an UNLOCK or lock timeout), if the\n> resource has not yet been checked in, the removal of the write lock is\n> automatically preceded by a checkin operation.\n>\n> A server MAY refuse to allow the value of the DAV:auto-version\n> property to be modified.\n>\n> <!ELEMENT auto-versionout\n>  (checkout-checkin | checkout-unlocked-checkin | checkout |\n> locked-checkout)\n> >\n> <!ELEMENT checkout-checkin EMPTY>\n> <!ELEMENT checkout-unlocked-checkin EMPTY>\n> <!ELEMENT checkout EMPTY>\n> <!ELEMENT locked-checkout EMPTY>\n>\n>\n> -----Original Message-----\n> From: Clemm, Geoff [mailto:gclemm@Rational.Com]\n> Sent: Friday, July 13, 2001 7:11 PM\n> To: 'DeltaV'\n> Subject: RE: auto-checkout and auto-checkin\n>\n>\n> Clearly there is significant support for going back to\n> DAV:auto-version (as opposed to DAV:auto-checkout,DAV:auto-checkin).\n> If nobody objects to going back to DAV:auto-version , I'm willing to\n> do so (I believe I was the most enthusiastic supporter of the original\n> switch to auto-checkout and auto-checkin).\n\n\n\n", "id": "lists-006-11445561"}, {"subject": "New name for variant of DAV:auto-versio", "content": "I was confused by the name \"locked-checkout\" in the values of\nauto-version -- it seemed to me that the server would never do an automatic\ncheckin if it had this value, but the text says it does.\n\nLet's sacrifice brevity for clarity, and call this value\n\"locked-checkout-unlocked-checkin\".\n\nlisa\n\n\n\n", "id": "lists-006-11457808"}, {"subject": "Problems with locking and DeltaV resource", "content": "Let's say as a client I want to protect my version-controlled resource (VCR)\nand associated working resource (WR) from being edited by other users while\nI check it out and edit it.  One might think the user could issue:\n\n - LOCK VCR\n - CHECKOUT VCR\n - LOCK WR\n ...\n\nThis won't work, however.  There is a window when other users can lock my\nWR, edit it, etc, before I manage to lock it.   Having another client \"take\nover\" my WR is a situation which I think most clients will want to prevent,\nor will not know how to handle, or both.\n\nAny way of dealing with this?\n\nlisa\n\n\n\n", "id": "lists-006-11465133"}, {"subject": "RE: Feature request for CHECKIN/OUT extensio", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of John Hall\n> Sent: Tuesday, August 07, 2001 12:12 AM\n> To: 'Julian F. Reschke'\n> Cc: ietf-dav-versioning@w3.org\n> Subject: RE: Feature request for CHECKIN/OUT extension\n>\n>\n> Well, I personally expect the CHECKIN URI to be the same as the CHECKOUT\n> URL.\n\nWhen using the checkout-in-place feature, the URI of the VCR (that the\nclient is editing) will not be the same as the URI of the version that is\ncreated upon CHECKIN, right?\n\n> Note that when using working resources (where this is a concern) that we\n> have a proposal with the following characteristics:\n\nMaybe there was a misunderstanding here -- I was proposing this for\ncheckout-in-place, not for working resources.\n\n> A CHECKOUT of a VCR with a <apply-to-version> will cause the working\n> resource to track the VCR from which it came, and a subsequent CHECKIN\n> of the working resource will checkin the working resource and update the\n> vcr.\n>\n> That seemed to be what you were after, or did you hope for a broader\n> ability to do something like this?\n\nIt doesn't provide the client the ability to display / insert the URI of the\nversion that *will* be created upon CHECKIN into the document, or am I\nmissing something?\n\n\n\n", "id": "lists-006-11472774"}, {"subject": "RE: Feature request for CHECKIN/OUT extensio", "content": "> From: John Hall [mailto:johnhall@evergo.net]\n> Sent: Tuesday, August 07, 2001 6:58 PM\n> To: 'Julian F. Reschke'\n> Cc: ietf-dav-versioning@w3.org\n> Subject: RE: Feature request for CHECKIN/OUT extension\n>\n> ...\n>\n> Ok, I misunderstood.\n>\n> But I don't think this is very useful for a cross-platform client, and I\n> think there is another way to do it.\n>\n> In the checkout-in-place scenario, you do something like this:\n>\n> CHECKOUT /foo.txt\n> PUT      /foo.txt\n> PUT      /foo.txt\n> CHECKIN  /foo.txt\n>\n> As far as I'm concerned, the only URL the client should be displaying is\n> /foo.txt.  However, you want to know the URI that references the VERSION\n> being created above, independent of the VCR /foo.txt.\n>\n> You can get that value by asking for the checked-out property.  But on\n\nNo, I don't think so. This will get me the URL of the version I checked out,\nnot the URL of the version that will be created upon CHECKIN.\n\n> my system you are going to get something that looks like\n> /_xy-2-1100.4301.docStore1.  Version URL's on my system are most\n> definitely not designed to be human readable, and are not intended for\n> display.  I've seen other URLs that a different server generates that\n> look like /_flaturlspace_/4023-e214 ... You get the idea.\n\nThis is fine. I don't have any problems with that format.\n\n> You could ask for the version-name.  On my system you'd get a string\n> like 'foo.txt (V5)'.  The version-name is meant to be human readable and\n> useful for display, unlike the internal URL.\n>\n> And Geoff is quite right.  Though I could (and will if you ask for\n> checked-out) give you the Version URL, I can easily imagine a system\n> that generates a different (permanent) one when it checks it in.\n\nAnd it's that permanent one I'm interested in. No matter how ugly it looks.\n\n\n\n", "id": "lists-006-11482931"}, {"subject": "Comments regarding locking &amp; auto-checkin..", "content": "Hi,\n\nSection 3.2.2 when DAV:auto-checkout is DAV:locked-update and a lock\ntimes out the specification\nsays a implicit CHECKIN operation will happen.  This just seems a little\nodd.\n\nFor example imagine user Fred is sitting in his client application LOCKS\na document and starts work on\nit, he takes his time working on the doc and his LOCK times out, so\nsuddenly his incomplete work will be\nchecked back in without him knowing.  I guess when he goes to unlock the\ndocument (as he is not aware\nthat his lock was timed out) he would get an error saying something like\n\"You don't have a lock on this\ndocument (invalid lock token)\".\n\nOther options for the behaviour of timed out locks would be:\n\n1)  Just cancel his lock (but not auto checkin).\n     This would avoid checking in Freds incomplete work but would leave\nFred equally confused when he\n     tries to unlock and is told that he has not got the document\nlocked.\n\n2)  Do not timeout locks for auto versioning clients.\n     This would keep Fred happy since he keeps the lock but it totally\ndefeats the point of lock timeouts.\n     Do any clients set lock timeouts to be anything other than\nInfinity?  I have not seen any use of lock\n     timeouts yet.\n\n3)  Find some way to inform the client that the lock has timed-out.\n     Since HTTP is request/response driven we can't just send a message\nto Fred to inform him the lock\n     has timed out (he needs to request something first).  So the only\nimplementation I can think of would\n     be for the client to send some kinda lock keep-alives.\n\nI guess my preference is for option 1 but when Fred unlocks we should\nreturn some specific error so\nat least the client knows that the unlock failed because the token\nspecified was timed-out (rather than\njust an invalid token).\n\nWhat do other people think? Do lock timeouts actually get used (if not\nwe should remove them from the spec).\nWe were talking in the WebDAV (RFC2518) meeting yesterday about allowing\nsome principal other than the\nlock owner to unlock a resource so removing lock timeouts would not mean\nthe lock is unbreakable.\n\nRegards,\nPeter Raymond - MERANT.\n\n\n\n", "id": "lists-006-11493130"}, {"subject": "RE: Deleting version", "content": "Lisa wrote:\n>Are DeltaV servers then not required to support locking at all?\n\nFWIW, Greg Stein stated that Subversion wasn't going to support locking for\nversion-controlled-resources\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0614.html\n\n\nI wasn't planning on supporing locks on VCRs either (in version 1).  Didn't\nfind a requirement in Delta-V stating \"MUST also support a  WebDAV class 2\nserver\"\n\nSteve Speicher\n\n\n\"Lisa Dusseault\" <lisa@xythos.com>@w3.org on 06/06/2001 12:00:20 PM\n\nSent by:  ietf-dav-versioning-request@w3.org\n\n\nTo:   \"Clemm, Geoff\" <gclemm@rational.com>, \"DeltaV\"\n      <ietf-dav-versioning@w3.org>\ncc:\nSubject:  RE: Deleting versions\n\n\n Lock-null\ncomes along with lock.  I can (barely) beleive that a server might\nimplement\nDeltaV but not support locking.  In fact, you acknowledge in section 14\nthat\nlock-null may be implemented:\n\n\"Non-version-controlled bindings are not under version control, and\ntherefore can be added or deleted without checking out the\nversion-controlled collection.  This feature is essential for the support\nof\nlock null resources, since a lock null resource is a temporary internal\nmember of a collection that should only exist for the duration of the lock,\nand should not be captured in the version history of that collection.\"\n\nYou're doing what Greg (justly) accused you of and leaving things to be\ninferred, or out of the spec entirely.  If DeltaV says nothing, then\nimplementors and servers that do locking and deltaV will be left without\nguidance, on an issue over which the experts (heh) have argued.  Their\nimplementations will differ.\n\nWhy not state that MKCOLLECTION and MKACTIVITY can be used on lock-null\nresources if they would be legal otherwise?  If you object, then please\nmake\nyour arguments against the concept, but do not allow the spec to remain\nsilent.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, June 06, 2001 8:07 AM\n> To: DeltaV\n> Subject: RE: Deleting versions\n>\n>\n> I agree that if a client is likely to get disconnected\n> in the middle of its MKWORKSPACE/LOCK request sequence, and if a server\n> lets you change the ACL's on a workspace but does not let\n> you create a workspace, and if a workspace can have its ACL's\n> updated by anyone other than the owner, then there is a use\n> case for issuing a MKWORKSPACE against a lock null resource.\n>\n> But as you said earlier, RFC 2518 only constrains what HTTP\n> and DAV methods can be applied to a lock null resource,\n> so a compliant DelataV server can support this use case if it wishes.\n> We can't say it MUST support this use case, since a DeltaV\n> server is not required to support lock null resources at all.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Lisa Dusseault [mailto:lisa@xythos.com]\n> Sent: Tuesday, June 05, 2001 7:43 PM\n> To: Clemm, Geoff; DeltaV\n> Subject: RE: Deleting versions\n>\n>\n> The problem is that the \"client that got there before them\" may have\n> permission to alter a workspace, but they may NOT have permission\n> to CREATE\n> a workspace.\n>\n> The problem is not that the other client locked it, but that they might\n> apply changes before you get a chance to prevent them!  I create\n> a Workspace\n> (or a resource, or a collection).  I want to then set the ACLs so that\nI'm\n> the only one that can alter this resource, because it's MINE.  But, in\n> between the MKWORKSPACE and the subsequent LOCK, the other client comes\nin\n> and sets ACLs so that they can write the workspace and I can't!  Ouch.\n>\n> Null resource went through similar discussions, and was kept for reasons\n> which apply to MKWORKSPACE the same way they apply to PUT, MKCOL.\n>\n> lisa\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > Sent: Tuesday, June 05, 2001 3:48 PM\n> > To: DeltaV\n> > Subject: RE: Deleting versions\n> >\n> >\n> >    From: Lisa Dusseault [mailto:lisa@xythos.com]\n> >\n> >    If somebody who's not supposed to, gets in and changes something in\n> >    between a MKWORKSPACE command and a ACL request, that's a serious\n> >    problem.  Null resources help avoid that.\n> >\n> >    It's not that somebody got their MKWORKSPACE request in ahead of\n> >    mine --that's not the purpose of null resources at all.\n> >\n> > My point was not that a lock can prevent somebody from\n> > creating the workspace ahead of you, but rather that\n> > someone locking \"your\" workspace is no different from\n> > someone creating a workspace by that name before you\n> > can lock that URL.\n> >\n> > In particular, we are discussing two alternative sequences:\n> >  LOCK/MKWORKSPACE/ACL/UNLOCK\n> > or\n> >  MKWORKSPACE/LOCK/ACL/UNLOCK\n> >\n> > In the first sequence, the LOCK may fail (because there already\n> > is a lock on that URL), so you tell the user \"that workspace is\n> > already in use by another user\".\n> >\n> > In the second sequence, either the MKWORKSPACE may fail (because\n> > somebody got in and created a workspace before you) or the LOCK\n> > may fail (because somebody got in and locked the workspace before\n> > you).  In either case, you still tell the user \"that workspace is\n> > already in use by another user\".\n> >\n> > So from the user's perspective, it doesn't matter whether\n> > or not their client did a LOCK/MKWORKSPACE or a\n> > MKWORKSPACE/LOCK.  Their request can fail because another\n> > client \"got there before them\".\n> >\n> > Cheers,\n> > Geoff\n\n\n\n", "id": "lists-006-1149595"}, {"subject": "RE: ... By the way ..", "content": "So in our discussion today at the IETF, we realized that the version-history\nreport can also be used to see all values of <checkout-set> and\n<checkout-fork> for a single version-history.   This means that\nexpand-history report isn't needed to support this, only version-history\nreport which is already required.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Sunday, July 15, 2001 7:35 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: ... By the way ...\n>\n>\n>\n>    From: John Hall [mailto:johnhall@evergo.net]\n>\n>    As I understand it, there is no way for a client to tell that a\n>    working resource has been created.\n>\n>    VCR checked in, no working resources have been created.  Server\n>    doesn't allow forking.  Server supports WORKING-RESOURCE and\n>    CHECKOUT-INPLACE.\n>\n>    ClientA: CHECKOUT <apply-to-version> VCR.\n>    => creates working resource and leaves VCR untouched.\n>\n>    ClientB: Since VCR is untouched, it is impossible to detect that\n>    CLientA has performed their operation.  Therefore:\n>\n>    CHECKOUT VCR\n>    => 409 Conflict\n>    <checkout-of-checked-out-version-is-forbidden>\n>\n>    Is there some way I'm missing that Client B could have seen this\n>    one coming?\n>\n> Use the DAV:expand-property report to ask for the checkout-set and\n> checkout-fork properties of the checked-in version, i.e.:\n>\n> <D:expand-property xmlns:D=\"DAV:\">\n>  <D:property name=\"checked-in\">\n>    <D:property name=\"checkout-set\"/>\n>    <D:property name=\"checkout-fork\"/>\n>  </D:property>\n> </D:expand-property>\n>\n> If the checkout-set is non-empty and checkout-fork is forbidden,\n> you know the checkout will fail.\n>\n>    Currently, I don't support forking so only 1 checkout (INPLACE or\n>    WORKING) is allowed.  But if I did support multiple checkouts, I'd\n>    still keep a count so I could tell Client B, that forking was\n>    'discouraged', for example.\n>\n> Yes, if the checkout-fork is discouraged, that would be something\n> you'd want to warn them about (and if they said \"do it anyway\", you\n> would know to include the DAV:fork-ok flag with the CHECKOUT).\n>\n>    Are people implementing this without tracking the count of working\n>    resources created off the versions of a VCR?\n>\n> The list of checkouts is important, which is why the server is\n> required to maintain DAV:checkout-set.\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-11502864"}, {"subject": "Issues/questions regarding sections 3, 4 and 5..", "content": "Hi,\n\nAfter reading through sections 3 & 4 & 5 (with a group of other MERANT\nstaff) here is a list\nof issues/questions  (some of these issues are editorial and simply need\nclarification\nin the spec, others are real issues/questions).\n\n\n\n[Editorial]\n\nIn the specification some of the sections eg, 10.1,10.2 have no white\nspace after the\nsection number, others (eg section 9.7,1.6 do have a single space). Some\nsections, eg 13.10\nare followed by multiple whitespace characters.  I think this is caused\nby conversion from\nMicrosoft Word to ASCII.  We should correct this before submitting the\ndraft.\n\n\n\n[Editorial]\n\nSection 3.1.4, the last sentence does not seem to make sense, it reads:\n\n\"A live property is supported by a resource if that property has the\nsemantics defined for\nthat property\"\n\nThe property always has the semantics defined for that property.  Now we\nhave the\nproperty-o-rama we could replace that definition with something like:\n\n\"A live property is supported by a resource as specified in Appendix A\n(section 23).\"\n\n\n\n[Issue/Editorial]\n\nSection 3.9 the specification says that when a resource is automatically\nchecked out:\n\n\"the DAV:checked-in property MUST be empty\"\n\nShould it be empty or should it be removed, I read this statement as\nmeaning that\nDAV:supported-live-property-set would still contain DAV:checked-in and\nthat a PROPFIND\non DAV:checked-in would return an empty value. I thought we were going\nto remove the\nDAV:checked-in property from the supported-property list when the\nresource is checked-out.\nThe specification should be consistent with respect to which properties\nare removed and which\nare empty in the various states of the resource since it is crucial for\nthe whole \"check the\nproperties to find out what type of resource this is\" system to work.\n\nThis also applies to section 4.4 where it talks about properties being\n\"no longer set\".\n\n\n\n[Editorial]\n\nSection 4.4 starts to talk about the UNCHECKOUT on a Working Resource.\nI think this text\nwould make more sense if it was in \"Working Resource Feature\" section 8.\n\n\n\n\n[Issue]\n\nSection 4.3 states for CHECKIN that :\n\n\"The response for a successful request MUST include a Location header\".\n\nThe only time deltav talks about the location header is for CHECKIN of a\nVCR and CHECKOUT\nof a working resource (section 9.3).  Why is this only on those methods?\nWhat is the use case for it\n(does it simply save the client from having to PROPFIND the\nDAV:checked-in?).  I ask this because\nthe Location header is not returned by other methods that create\nresources,  eg UNLOCK etc for\nauto-versioning clients (eg when automatically checking in).\n\nI suggest we either remove the feature or use it consistently eg\nwhenever a new resource\nis created return the Location header.\n\n\n\n[Issue]\n\nSection 5.4.1 since this report is on a collection I would like a Depth\nheader defined.\nAgain I think we should be consistent (to avoid speical-case coding).\nAny method that gets properties\nof a collection should take a Depth header.\n\n\n[Issue]\n\nSection 5.5 defines this mechanism where OPTIONS can be used to find a\npossible location\nin the namespace that is to be used for version histories.  I assume\nthis is so a client can indicate\nin a GUI if a collection is a collection of version histories or a\nclient could choose not to display\nthat part of the namespace.\n\nIt seems odd that this is only available for version histories, these\nare not the only resource that have\n\"server-defined\" URLs.  For example would the clients want a OPTIONS\nrequest to indicate where\nin the namespace will be used to reference versions as opposed to\nversion controlled resources?\nThe same arguments as in section 5.5 applies to versions, they may not\nbe stored on the same server etc.\n\nI also think an example of the OPTIONS method being used for this would\nbe good as it is quite different\nfrom other uses of OPTIONS.\n\n\n[Editorial/Issue]\n\nReading section 5.6 it took us quite a while to decide how to delete the\nlast version from a version history.\nI think the answer is \"you don't\" you must delete the version history\nitself in order to delete the last version.\nDid we interpret this correctly?  Do you think we should clarify this in\nthe spec?\n\n\nI look forward to seeing some of you at the deltav sessions in London\ntomorrow.\n\nRegards,\nPeter Raymond - MERANT\n\n\n\n", "id": "lists-006-11513507"}, {"subject": "Diagram showing the effect of baseline-control..", "content": "Hi,\n\nDuring one of the IETF deltav breakout sessions I was \"challenged\" to try to\nfind a way to\ndraw ASCII art to show the resources and relationships involved in baseline\ncreation\n(and still have it fit in 72 columns).  The idea being we could include this\nin the specification\nto clarify the relationship between baseline-controlled collections,\nversion-controlled\nconfigurations, and baselines etc.\n\nHere are my two possible candidates (I think I prefer the first one):\n\n\n  +-------------+ \n  |Baseline-    |     DAV:version-controlled-configuration\n  |Controlled   |----------+ \n  |Collection   |          |\n  |             |          |\n  |/src/applet  |          |\n  +-------------+          |\n                           |\n                           |\n  +---------------+        |\n  |Version-       |--------+ \n  |Controlled     |     DAV:baseline-controlled-collection\n  |Configuration  |\n  |               |\n  |/vcc/src/1     |----+ DAV:checked-in \n  +---------------+    |\n                       | \n                       |\n                       | \n                       |\n                       |   +-----------+ \n                       +-->|Baseline   | DAV:baseline-collection\n                           |           |----+\n                           |           |    |\n                       +-->|/blh/1/b1  |    |\n +---------+           |   +-----------+    |\n |Baseline |           |                    |\n |History  |-----------+                    |    +-----------------+\n |         | DAV:root-version               |    |Collection       |\n |/blh/1   |                                |    |                 |\n +---------+                                +--->|/blh1/1/b1/bc    |\n                                                 +-----------------+\n\nHere is my second attempt.....\n\n  +-------------------------------------+\n  |Baseline-Controlled Collection       |\n  |                                     |\n  |/src/applet                          |\n  |-------------------------------------|\n  |DAV:version-controlled-configuration |-----+\n  +-------------------------------------+     |\n                                              |\n                                              |\n  +-----------------------------------+       |\n  |Version-Controlled Configuration   |       |\n  |                                   |       |\n  |/vcc/src/1                         |       |\n  |-----------------------------------|       |\n  |DAV:baseline-controlled-collection |-------+\n  |-----------------------------------|\n  |DAV:checked-in                     |----+\n  +-----------------------------------+    |\n                                           |\n                                           |\n  +-----------------+                      |\n  |Baseline History |                      v\n  |                 |       +-----------------------+\n  |/blh/1           |       |Baseline               |\n  |-----------------|       |                       |\n  |DAV:root-version |------>|/blh1/1/b1             |\n  +-----------------+       |-----------------------|\n                            |DAV:baseline-collection|------+\n                            +-----------------------+      |\n                                                           v\n                                                     +--------------+\n                                                     |Collection    |\n                                                     |              |\n                                                     |/blh1/1/b1/bc |\n                                                     +--------------+\n\n\nFor either diagram I would suggest some surrounding text something like:\n\n\n\"This diagram shows the collection identified by /src/applet has been \nplaced under baseline control, creating a new version-controlled \nconfiguration (/vcc/src/1), new baseline history (/blh/1), new baseline \n(/blh/1/b1) and a new collection (/blh/1/b1/bc).  The new collection has \nmembers whose checked-in versions capture the state of the /src/applet \ncollection at the time the baseline-control method was processed.\nWhen /vcc/src/1 is checked-out and checked-in new baselines and\ncollections are created to take another snapshot of the checked-in state\nof the resources in /src/applet.\"\n\n\nDoes the group have any preference as to either of these, do you think it\nhelps clarify the baseline feature?  Did I get anything wrong?\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (ADM)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-11525383"}, {"subject": "Comments on locking and auto-checkin..", "content": "Hi,\n\nIn section 3.2.2 when DAV:auto-checkout is DAV:locked-update and a lock\ntimes out the specification\nsays a implicit CHECKIN operation will happen.  This just seems a little\nodd.\n\nFor example imagine user Fred is sitting in his client application LOCKS\na document and starts work on\nit, he takes his time working on the doc and his LOCK times out, so\nsuddenly his incomplete work will be\nchecked back in without him knowing.  I guess when he goes to unlock the\ndocument (as he is not aware\nthat his lock was timed out) he would get an error saying something like\n\"You don't have a lock on this\ndocument (invalid lock token)\".\n\nOther options for the behaviour of timed out locks would be:\n\n1)  Just cancel his lock (but not auto checkin).\n     This would avoid checking in Freds incomplete work but would leave\nFred equally confused when he\n     tries to unlock and is told that he has not got the document\nlocked.\n\n2)  Do not timeout locks for auto versioning clients.\n     This would keep Fred happy since he keeps the lock but it totally\ndefeats the point of lock timeouts.\n     Do any clients set lock timeouts to be anything other than\nInfinity?  I have not seen any use of lock\n     timeouts yet.\n\n3)  Find some way to inform the client that the lock has timed-out.\n     Since HTTP is request/response driven we can't just send a message\nto Fred to inform him the lock\n     has timed out (he needs to request something first).  So the only\nimplementation I can think of would\n     be for the client to send some kinda lock keep-alives.\n\nI guess my preference is for option 1 but when Fred unlocks we should\nreturn some specific error so\nat least the client knows that the unlock failed because the token\nspecified was timed-out (rather than\njust an invalid token).\n\nWhat do other people think? Do lock timeouts actually get used (if not\nwe should remove them from the spec).\nWe were talking in the WebDAV (RFC2518) meeting yesterday about allowing\nsome principal other than the\nlock owner to unlock a resource so removing lock timeouts would not mean\nthe lock is unbreakable.\n\nRegards,\nPeter Raymond - MERANT.\n\n\n\n", "id": "lists-006-11537667"}, {"subject": "RE: Feature request for CHECKIN/OUT extensio", "content": "Geoff,\n\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Monday, August 06, 2001 8:07 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Feature request for CHECKIN/OUT extension\n>\n>\n> Perhaps you could explain what benefit this \"expected version URL\"\n> would provide.  In the W3C, you have a human meaningful URL, which\n> DeltaV would call the version-controlled resource.  The resource\n\nIn W3C we have both:\n\n1) the URI of the version controlled resource, for instance\n<http://www.w3.org/TR/xslt> points to the \"latest\" version of the XSLT\nrecommendation.\n\n2) we also have URIs for the equivalents of the checked-in versions, for\ninstance <http://www.w3.org/TR/1999/REC-xslt-19991116> will always refer to\nthe XSLT recommendation published on Nov 16, 1999. *Right now*, it refers to\nthe same document.\n\nNote that the document referred by\n<http://www.w3.org/TR/1999/REC-xslt-19991116> *contains* this URI as part of\nit's content. Under deltaV this means that a client must be able to know the\nURI of the version (when checked-in) before actually doing the CHECKIN to\naccomplish the same.\n\n> at this URL has a property that points at the latest immutable version,\n> which DeltaV calls the DAV:checked-in version.  I am not aware of\n> the W3C having a URL for \"the next version that will be created\".\n\nI didn't say that (hopefully :-).\n\n> Many versioning repositories do not allocate the version URL\n> until the version is actually created, and therefore would not\n> support the \"expected version\" feature.  In particular, for a repository\n\nSure. So does ours. But it generally will use an (internally) well-defined\nmechanism to allocate the next URI, so a server possibly could pass the\ninformation about the *expected* next checkin URI to the client unpon\ncheckout. If it can't provide it, it doesn't need to (and a client will have\nto live with this). If it does provide it, but upon CHECKIN the server\ndecides it can't use that URI after all, the client will get an error\nmessage (allowing him to recover).\n\n> that supports branching and unreserved checkouts, the client\n> that gets a particular version URL depends on which client\n> checks in first.  I would be reluctant to add\n> a feature like this which will cause interoperability problems,\n> unless there is a compelling use case that requires it.\n\n1) If the feature is implemented as outlined below, it shouldn't cause\ninteroperability problems. Servers can signal that they can't determine the\n\"expected checkin URI\". If they do, they are also free not to accept this\nURI upon CHECKIN (and to produce a new one). This would happen in the case\nyou mentioned.\n\n2) I think I have given the use case. It basically requires that a\nchecked-in version can carry it's own URI (of the checked in version) in\nit's content. This is a mandatory requirement for the versioning system we\nhave to expose through WebDAV, so we have to either define a proprietary way\nto achieve this, or the protocol needs an extension. We think this use case\nmay apply to many others, and this is why we are trying to get a discussion\nand possibly a consensus here...\n\nRegards, Julian\n\n> -----Original Message-----\n> From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n> Sent: Monday, August 06, 2001 10:50 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Feature request for CHECKIN/OUT extension\n>\n>\n> Feature request for CHECKIN/OUT extension\n>\n> In many cases, a versioning-aware client might want to display/include the\n> URI of the version it's editing *while* it's edited. For instance, a\n> versioning\n> aware editor might include this as meta-information, or the author of a\n> document might want to know the URI of the version *before* it's\n> checked in.\n> A well-known example is the W3C way of referring to document versions in\n> recommendations: it contains HREFs to \"the current version\", to \"this\n> version\"\n> and to the \"previous version\". Something like this is currently impossible\n> with deltaV, as the version URI is determined at the time of CHECKIN.\n>\n> Proposal:\n>\n> 1) Extend CHECKOUT to optionally return an \"expected CHECKIN URI\".\n> 2) Extend CHECKIN to optionally use the \"expected CHECKIN URI\",\n> failing the\n> request if it's not possible to checkin the resource with the desired\n> version URI (in which case a new \"expected CHECKIN URI\" is returned).\n>\n> Some possible strategies:\n>\n> 1) Pass the information as proprietary live properties.\n> 2) Pass the information as properties in the DAV: namespace, and\n> define the\n> behaviour in the deltaV spec.\n> 3) (preferred) Pass the information in the request/response bodies of\n> CHECKIN / CHECKOUT, such as:\n>\n> CHECKOUT method:\n>\n> >>REQUEST\n>\n>   CHECKOUT /foo.html HTTP/1.1\n>   Host: www.webdav.org\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx\n>\n>   <D:checkout xmlns:D=\"DAV:\">\n>     <D:compute-expected-version-URI />\n>   </D:checkout>\n>\n>\n> >>RESPONSE\n>\n>   HTTP/1.1 200 OK\n>   Cache-Control: no-cache\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx\n>\n>   <D:checkout xmlns:D=\"DAV:\">\n>\n> <D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:ex\n> pected-ver\n> sion-URI>\n>   </D:checkout>\n>\n>   (Note that we would need to define an (optional) response body for\n> CHECKOUT).\n>\n>\n> CHECKIN method:\n>\n>\n> >>REQUEST\n>\n>   CHECKIN /foo.html HTTP/1.1\n>   Host: www.webdav.org\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx\n>\n>   <D:checkin xmlns:D=\"DAV:\">\n>\n> <D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:ex\n> pected-ver\n> sion-URI>\n>   </D:checkin>\n>\n> >>RESPONSE\n>\n>   HTTP/1.1 201 Created\n>   Location: http://repo.webdav.org/his/23/ver/32\n>   Cache-Control: no-cache\n>\n>   or\n>\n> >>RESPONSE\n>\n>   HTTP/1.1 409 Forbidden\n>   Cache-Control: no-cache\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx\n>\n>   <D:error xmlns:D=\"DAV:\">\n>     <D:cannot-assign-expected-version-URI />\n>\n> <D:expected-version-URI>http://repo.webdav.org/his/23/ver/33</D:ex\n> pected-ver\n> sion-URI>\n>   </D:error>\n>\n>\n>\n>\n>\n\n\n\n", "id": "lists-006-11547244"}, {"subject": "List of areas in the specification where properties are empty/not  se", "content": "Hi,\n\nI raised in an earlier e-mail that the specification still talked about\nproperties\nbeing empty or not set instead of being removed.  In one of the deltav\nsessions I\nwas asked to scour the spec and find all affected areas.\nI think the list is:\n\nSection 3.9 in the additional postconditions (DAV:auto-checkout) for PUT,\nthe spec \nsays \"the DAV:checked-in property MUST be empty\". I propose it should\ninstead read\n\"the DAV:checked-in property MUST be removed\".\n\nSection 4.4 in the additional postconditions (DAV:cancel-checked-out) for\nUNCHECKOUT, \nthe spec says \"and the DAV:checked-out property no longer is set\".  I\npropose it\nshould read \"and the DAV:checked-out property is removed\".\n\nSection 11.2 the description of the MERGE method says \"a version-controlled\nresource\nwith a non-empty DAV:merge-set\". I propose it should read \"a\nversion-controlled\nresource with a DAV:merge-set property\".\n\nSection 11.6 in the additional preconditions (DAV:merge-must-be-complete)\nfor CHECKIN,\nthe spec says \"The DAV:merge-set and DAV:auto-merge-set of the checked-out\nresource\nMUST be empty\".  I propose it should read \"The checked-out resource MUST not\nhave the \nDAV:merge-set or DAV:auto-merge-set properties\".\n\nSomewhere in the spec perhaps we should state that when a property is\nremoved from a \nresource it is no longer returned by PROPFIND or in any <DAV:prop> response\nfrom\nany method.\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (ADM)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-11563879"}, {"subject": "RE: Feature request for CHECKIN/OUT extensio", "content": "> From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de] \n> \n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of John Hall\n> > Sent: Tuesday, August 07, 2001 12:12 AM\n> > To: 'Julian F. Reschke'\n> > Cc: ietf-dav-versioning@w3.org\n> > Subject: RE: Feature request for CHECKIN/OUT extension\n> >\n> >\n> > Well, I personally expect the CHECKIN URI to be the same as the \n> > CHECKOUT URL.\n> \n> When using the checkout-in-place feature, the URI of the VCR \n> (that the client is editing) will not be the same as the URI \n> of the version that is created upon CHECKIN, right?\n\n\nOk, I misunderstood.\n\nBut I don't think this is very useful for a cross-platform client, and I\nthink there is another way to do it.\n\nIn the checkout-in-place scenario, you do something like this:\n\nCHECKOUT /foo.txt\nPUT      /foo.txt\nPUT      /foo.txt\nCHECKIN  /foo.txt\n\nAs far as I'm concerned, the only URL the client should be displaying is\n/foo.txt.  However, you want to know the URI that references the VERSION\nbeing created above, independent of the VCR /foo.txt.\n\nYou can get that value by asking for the checked-out property.  But on\nmy system you are going to get something that looks like\n/_xy-2-1100.4301.docStore1.  Version URL's on my system are most\ndefinitely not designed to be human readable, and are not intended for\ndisplay.  I've seen other URLs that a different server generates that\nlook like /_flaturlspace_/4023-e214 ... You get the idea.\n\nYou could ask for the version-name.  On my system you'd get a string\nlike 'foo.txt (V5)'.  The version-name is meant to be human readable and\nuseful for display, unlike the internal URL.\n\nAnd Geoff is quite right.  Though I could (and will if you ask for\nchecked-out) give you the Version URL, I can easily imagine a system\nthat generates a different (permanent) one when it checks it in.\n\n\n\n", "id": "lists-006-11572901"}, {"subject": "webdav interoperability event: slide presentatio", "content": "[caught in spam trap -rrs]\n\n From: \"Larry Masinter\" <masinter@adobe.com>\n To: <ietf-dav-versioning@w3.org>\n Old-Date: Tue, 7 Aug 2001 15:37:18 -0700\n Message-ID: <NDBBKEBDLFENBJCGFOIJAEHJFGAA.masinter@adobe.com>\n\nI linked the slides for my presentation at IETF about\nthe interop event into\n\n  http://www.webdav.org/users/masinter/\n\nsee\n\n  http://www.webdav.org/users/masinter/interop/report-slides.pdf\n\n\n\n", "id": "lists-006-11583797"}, {"subject": "RE: Feature request for CHECKIN/OUT extensio", "content": "It seems he wants CHECKOUT to return a location header for\ncheckout-in-place.\n\nSince I just changed my code when I noticed that CHECKIN in\ncheckin-in-place generated a location header, this wouldn't be hard for\nme to do.\n\nBut the problem remains for all those servers that *don't* know what the\nvalue is permanently.  I guess you could always give them the temporary\none -- like you generate a temporary one for working resources.\n\nNote: I don't care if this is there are not.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of \n> Julian F. Reschke\n> Sent: Tuesday, August 07, 2001 12:04 AM\n> To: Clemm, Geoff; ietf-dav-versioning@w3.org\n> Subject: RE: Feature request for CHECKIN/OUT extension\n> \n> \n> Geoff,\n> \n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > Sent: Monday, August 06, 2001 8:07 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: RE: Feature request for CHECKIN/OUT extension\n> >\n> >\n> > Perhaps you could explain what benefit this \"expected version URL\" \n> > would provide.  In the W3C, you have a human meaningful URL, which \n> > DeltaV would call the version-controlled resource.  The resource\n> \n> In W3C we have both:\n> \n> 1) the URI of the version controlled resource, for instance \n> <http://www.w3.org/TR/xslt> points to the \"latest\" version of \n> the XSLT recommendation.\n> \n> 2) we also have URIs for the equivalents of the checked-in \n> versions, for instance \n> <http://www.w3.org/TR/1999/REC-xslt-19991116> will always \n> refer to the XSLT recommendation published on Nov 16, 1999. \n> *Right now*, it refers to the same document.\n> \n> Note that the document referred by \n> <http://www.w3.org/TR/1999/REC-xslt-19991116> *contains* this \n> URI as part of it's content. Under deltaV this means that a \n> client must be able to know the URI of the version (when \n> checked-in) before actually doing the CHECKIN to accomplish the same.\n> \n> > at this URL has a property that points at the latest immutable \n> > version, which DeltaV calls the DAV:checked-in version.  I am not \n> > aware of the W3C having a URL for \"the next version that will be \n> > created\".\n> \n> I didn't say that (hopefully :-).\n> \n> > Many versioning repositories do not allocate the version \n> URL until the \n> > version is actually created, and therefore would not support the \n> > \"expected version\" feature.  In particular, for a repository\n> \n> Sure. So does ours. But it generally will use an (internally) \n> well-defined mechanism to allocate the next URI, so a server \n> possibly could pass the information about the *expected* next \n> checkin URI to the client unpon checkout. If it can't provide \n> it, it doesn't need to (and a client will have to live with \n> this). If it does provide it, but upon CHECKIN the server \n> decides it can't use that URI after all, the client will get \n> an error message (allowing him to recover).\n> \n> > that supports branching and unreserved checkouts, the \n> client that gets \n> > a particular version URL depends on which client checks in \n> first.  I \n> > would be reluctant to add a feature like this which will cause \n> > interoperability problems, unless there is a compelling use \n> case that \n> > requires it.\n> \n> 1) If the feature is implemented as outlined below, it \n> shouldn't cause interoperability problems. Servers can signal \n> that they can't determine the \"expected checkin URI\". If they \n> do, they are also free not to accept this URI upon CHECKIN \n> (and to produce a new one). This would happen in the case you \n> mentioned.\n> \n> 2) I think I have given the use case. It basically requires \n> that a checked-in version can carry it's own URI (of the \n> checked in version) in it's content. This is a mandatory \n> requirement for the versioning system we have to expose \n> through WebDAV, so we have to either define a proprietary way \n> to achieve this, or the protocol needs an extension. We think \n> this use case may apply to many others, and this is why we \n> are trying to get a discussion and possibly a consensus here...\n> \n> Regards, Julian\n> \n> > -----Original Message-----\n> > From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n> > Sent: Monday, August 06, 2001 10:50 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: Feature request for CHECKIN/OUT extension\n> >\n> >\n> > Feature request for CHECKIN/OUT extension\n> >\n> > In many cases, a versioning-aware client might want to \n> display/include \n> > the URI of the version it's editing *while* it's edited. \n> For instance, \n> > a versioning aware editor might include this as \n> meta-information, or \n> > the author of a document might want to know the URI of the version \n> > *before* it's checked in.\n> > A well-known example is the W3C way of referring to \n> document versions in\n> > recommendations: it contains HREFs to \"the current \n> version\", to \"this\n> > version\"\n> > and to the \"previous version\". Something like this is \n> currently impossible\n> > with deltaV, as the version URI is determined at the time \n> of CHECKIN.\n> >\n> > Proposal:\n> >\n> > 1) Extend CHECKOUT to optionally return an \"expected CHECKIN URI\".\n> > 2) Extend CHECKIN to optionally use the \"expected CHECKIN URI\", \n> > failing the request if it's not possible to checkin the \n> resource with \n> > the desired version URI (in which case a new \"expected \n> CHECKIN URI\" is \n> > returned).\n> >\n> > Some possible strategies:\n> >\n> > 1) Pass the information as proprietary live properties.\n> > 2) Pass the information as properties in the DAV: namespace, and \n> > define the behaviour in the deltaV spec.\n> > 3) (preferred) Pass the information in the request/response \n> bodies of\n> > CHECKIN / CHECKOUT, such as:\n> >\n> > CHECKOUT method:\n> >\n> > >>REQUEST\n> >\n> >   CHECKOUT /foo.html HTTP/1.1\n> >   Host: www.webdav.org\n> >   Content-Type: text/xml; charset=\"utf-8\"\n> >   Content-Length: xxxx\n> >\n> >   <D:checkout xmlns:D=\"DAV:\">\n> >     <D:compute-expected-version-URI />\n> >   </D:checkout>\n> >\n> >\n> > >>RESPONSE\n> >\n> >   HTTP/1.1 200 OK\n> >   Cache-Control: no-cache\n> >   Content-Type: text/xml; charset=\"utf-8\"\n> >   Content-Length: xxxx\n> >\n> >   <D:checkout xmlns:D=\"DAV:\">\n> >\n> > <D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:ex\n> > pected-ver\n> > sion-URI>\n> >   </D:checkout>\n> >\n> >   (Note that we would need to define an (optional) response \n> body for \n> > CHECKOUT).\n> >\n> >\n> > CHECKIN method:\n> >\n> >\n> > >>REQUEST\n> >\n> >   CHECKIN /foo.html HTTP/1.1\n> >   Host: www.webdav.org\n> >   Content-Type: text/xml; charset=\"utf-8\"\n> >   Content-Length: xxxx\n> >\n> >   <D:checkin xmlns:D=\"DAV:\">\n> >\n> > <D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:ex\n> > pected-ver\n> > sion-URI>\n> >   </D:checkin>\n> >\n> > >>RESPONSE\n> >\n> >   HTTP/1.1 201 Created\n> >   Location: http://repo.webdav.org/his/23/ver/32\n> >   Cache-Control: no-cache\n> >\n> >   or\n> >\n> > >>RESPONSE\n> >\n> >   HTTP/1.1 409 Forbidden\n> >   Cache-Control: no-cache\n> >   Content-Type: text/xml; charset=\"utf-8\"\n> >   Content-Length: xxxx\n> >\n> >   <D:error xmlns:D=\"DAV:\">\n> >     <D:cannot-assign-expected-version-URI />\n> >\n> > <D:expected-version-URI>http://repo.webdav.org/his/23/ver/33</D:ex\n> > pected-ver\n> > sion-URI>\n> >   </D:error>\n> >\n> >\n> >\n> >\n> >\n> \n> \n\n\n\n", "id": "lists-006-11591532"}, {"subject": "RE: Comments regarding locking &amp; auto-checkin..", "content": "I believe that the current behavior is the desired and expected\nbehavior.\n\nWhen Fred LOCKS the document and starts working on it, he knows very\nwell that each and every change he makes is seen by everyone\nimmediately.  The fact that it is then checked in because he went to\nlunch would not seem to be a problem.  At worst he just has more\nversions in the version history, but no versions that he didn't intend\nto make available.\n\nNow the client program, if continuously operating, should be refreshing\nthe lock.  If it isn't, then when it is restarted I assume it needs to\ncheck if the lock exists and reaquire it if not.\n\nThe worst case is that if the client wasn't written with this in mind,\nit will just start doing PUT's with an invalid IF header lock token.  \n\nIs a PUT supposed to be rejected if the IF header provided specifies an\ninvalid lock token and the resource is not locked?\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Peter Raymond\n> Sent: Tuesday, August 07, 2001 4:03 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Comments regarding locking & auto-checkin...\n> \n> \n> Hi,\n> \n> Section 3.2.2 when DAV:auto-checkout is DAV:locked-update and \n> a lock times out the specification says a implicit CHECKIN \n> operation will happen.  This just seems a little odd.\n> \n> For example imagine user Fred is sitting in his client \n> application LOCKS a document and starts work on it, he takes \n> his time working on the doc and his LOCK times out, so \n> suddenly his incomplete work will be checked back in without \n> him knowing.  I guess when he goes to unlock the document (as \n> he is not aware that his lock was timed out) he would get an \n> error saying something like \"You don't have a lock on this \n> document (invalid lock token)\".\n> \n> Other options for the behaviour of timed out locks would be:\n> \n> 1)  Just cancel his lock (but not auto checkin).\n>      This would avoid checking in Freds incomplete work but \n> would leave Fred equally confused when he\n>      tries to unlock and is told that he has not got the \n> document locked.\n> \n> 2)  Do not timeout locks for auto versioning clients.\n>      This would keep Fred happy since he keeps the lock but \n> it totally defeats the point of lock timeouts.\n>      Do any clients set lock timeouts to be anything other \n> than Infinity?  I have not seen any use of lock\n>      timeouts yet.\n> \n> 3)  Find some way to inform the client that the lock has timed-out.\n>      Since HTTP is request/response driven we can't just send \n> a message to Fred to inform him the lock\n>      has timed out (he needs to request something first).  So \n> the only implementation I can think of would\n>      be for the client to send some kinda lock keep-alives.\n> \n> I guess my preference is for option 1 but when Fred unlocks \n> we should return some specific error so at least the client \n> knows that the unlock failed because the token specified was \n> timed-out (rather than just an invalid token).\n> \n> What do other people think? Do lock timeouts actually get \n> used (if not we should remove them from the spec). We were \n> talking in the WebDAV (RFC2518) meeting yesterday about \n> allowing some principal other than the lock owner to unlock a \n> resource so removing lock timeouts would not mean the lock is \n> unbreakable.\n> \n> Regards,\n> Peter Raymond - MERANT.\n> \n\n\n\n", "id": "lists-006-11610877"}, {"subject": "RE: Feature request for CHECKIN/OUT extensio", "content": "Hi John,\n\nas I said earlier -- if a server can't compute that URI -- no problem, a\nportable client will have to live with this.\n\nThe point being: *if* a server is able to supply this information, I'd\nprefer this information to be available in a portable way.\n\n> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net]\n> Sent: Thursday, August 09, 2001 6:32 PM\n> To: 'Julian F. Reschke'; 'Clemm, Geoff'; ietf-dav-versioning@w3.org\n> Subject: RE: Feature request for CHECKIN/OUT extension\n>\n>\n> It seems he wants CHECKOUT to return a location header for\n> checkout-in-place.\n>\n> Since I just changed my code when I noticed that CHECKIN in\n> checkin-in-place generated a location header, this wouldn't be hard for\n> me to do.\n>\n> But the problem remains for all those servers that *don't* know what the\n> value is permanently.  I guess you could always give them the temporary\n> one -- like you generate a temporary one for working resources.\n>\n> Note: I don't care if this is there are not.\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of\n> > Julian F. Reschke\n> > Sent: Tuesday, August 07, 2001 12:04 AM\n> > To: Clemm, Geoff; ietf-dav-versioning@w3.org\n> > Subject: RE: Feature request for CHECKIN/OUT extension\n> >\n> >\n> > Geoff,\n> >\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > > Sent: Monday, August 06, 2001 8:07 PM\n> > > To: ietf-dav-versioning@w3.org\n> > > Subject: RE: Feature request for CHECKIN/OUT extension\n> > >\n> > >\n> > > Perhaps you could explain what benefit this \"expected version URL\"\n> > > would provide.  In the W3C, you have a human meaningful URL, which\n> > > DeltaV would call the version-controlled resource.  The resource\n> >\n> > In W3C we have both:\n> >\n> > 1) the URI of the version controlled resource, for instance\n> > <http://www.w3.org/TR/xslt> points to the \"latest\" version of\n> > the XSLT recommendation.\n> >\n> > 2) we also have URIs for the equivalents of the checked-in\n> > versions, for instance\n> > <http://www.w3.org/TR/1999/REC-xslt-19991116> will always\n> > refer to the XSLT recommendation published on Nov 16, 1999.\n> > *Right now*, it refers to the same document.\n> >\n> > Note that the document referred by\n> > <http://www.w3.org/TR/1999/REC-xslt-19991116> *contains* this\n> > URI as part of it's content. Under deltaV this means that a\n> > client must be able to know the URI of the version (when\n> > checked-in) before actually doing the CHECKIN to accomplish the same.\n> >\n> > > at this URL has a property that points at the latest immutable\n> > > version, which DeltaV calls the DAV:checked-in version.  I am not\n> > > aware of the W3C having a URL for \"the next version that will be\n> > > created\".\n> >\n> > I didn't say that (hopefully :-).\n> >\n> > > Many versioning repositories do not allocate the version\n> > URL until the\n> > > version is actually created, and therefore would not support the\n> > > \"expected version\" feature.  In particular, for a repository\n> >\n> > Sure. So does ours. But it generally will use an (internally)\n> > well-defined mechanism to allocate the next URI, so a server\n> > possibly could pass the information about the *expected* next\n> > checkin URI to the client unpon checkout. If it can't provide\n> > it, it doesn't need to (and a client will have to live with\n> > this). If it does provide it, but upon CHECKIN the server\n> > decides it can't use that URI after all, the client will get\n> > an error message (allowing him to recover).\n> >\n> > > that supports branching and unreserved checkouts, the\n> > client that gets\n> > > a particular version URL depends on which client checks in\n> > first.  I\n> > > would be reluctant to add a feature like this which will cause\n> > > interoperability problems, unless there is a compelling use\n> > case that\n> > > requires it.\n> >\n> > 1) If the feature is implemented as outlined below, it\n> > shouldn't cause interoperability problems. Servers can signal\n> > that they can't determine the \"expected checkin URI\". If they\n> > do, they are also free not to accept this URI upon CHECKIN\n> > (and to produce a new one). This would happen in the case you\n> > mentioned.\n> >\n> > 2) I think I have given the use case. It basically requires\n> > that a checked-in version can carry it's own URI (of the\n> > checked in version) in it's content. This is a mandatory\n> > requirement for the versioning system we have to expose\n> > through WebDAV, so we have to either define a proprietary way\n> > to achieve this, or the protocol needs an extension. We think\n> > this use case may apply to many others, and this is why we\n> > are trying to get a discussion and possibly a consensus here...\n> >\n> > Regards, Julian\n> >\n> > > -----Original Message-----\n> > > From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n> > > Sent: Monday, August 06, 2001 10:50 AM\n> > > To: ietf-dav-versioning@w3.org\n> > > Subject: Feature request for CHECKIN/OUT extension\n> > >\n> > >\n> > > Feature request for CHECKIN/OUT extension\n> > >\n> > > In many cases, a versioning-aware client might want to\n> > display/include\n> > > the URI of the version it's editing *while* it's edited.\n> > For instance,\n> > > a versioning aware editor might include this as\n> > meta-information, or\n> > > the author of a document might want to know the URI of the version\n> > > *before* it's checked in.\n> > > A well-known example is the W3C way of referring to\n> > document versions in\n> > > recommendations: it contains HREFs to \"the current\n> > version\", to \"this\n> > > version\"\n> > > and to the \"previous version\". Something like this is\n> > currently impossible\n> > > with deltaV, as the version URI is determined at the time\n> > of CHECKIN.\n> > >\n> > > Proposal:\n> > >\n> > > 1) Extend CHECKOUT to optionally return an \"expected CHECKIN URI\".\n> > > 2) Extend CHECKIN to optionally use the \"expected CHECKIN URI\",\n> > > failing the request if it's not possible to checkin the\n> > resource with\n> > > the desired version URI (in which case a new \"expected\n> > CHECKIN URI\" is\n> > > returned).\n> > >\n> > > Some possible strategies:\n> > >\n> > > 1) Pass the information as proprietary live properties.\n> > > 2) Pass the information as properties in the DAV: namespace, and\n> > > define the behaviour in the deltaV spec.\n> > > 3) (preferred) Pass the information in the request/response\n> > bodies of\n> > > CHECKIN / CHECKOUT, such as:\n> > >\n> > > CHECKOUT method:\n> > >\n> > > >>REQUEST\n> > >\n> > >   CHECKOUT /foo.html HTTP/1.1\n> > >   Host: www.webdav.org\n> > >   Content-Type: text/xml; charset=\"utf-8\"\n> > >   Content-Length: xxxx\n> > >\n> > >   <D:checkout xmlns:D=\"DAV:\">\n> > >     <D:compute-expected-version-URI />\n> > >   </D:checkout>\n> > >\n> > >\n> > > >>RESPONSE\n> > >\n> > >   HTTP/1.1 200 OK\n> > >   Cache-Control: no-cache\n> > >   Content-Type: text/xml; charset=\"utf-8\"\n> > >   Content-Length: xxxx\n> > >\n> > >   <D:checkout xmlns:D=\"DAV:\">\n> > >\n> > > <D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:ex\n> > > pected-ver\n> > > sion-URI>\n> > >   </D:checkout>\n> > >\n> > >   (Note that we would need to define an (optional) response\n> > body for\n> > > CHECKOUT).\n> > >\n> > >\n> > > CHECKIN method:\n> > >\n> > >\n> > > >>REQUEST\n> > >\n> > >   CHECKIN /foo.html HTTP/1.1\n> > >   Host: www.webdav.org\n> > >   Content-Type: text/xml; charset=\"utf-8\"\n> > >   Content-Length: xxxx\n> > >\n> > >   <D:checkin xmlns:D=\"DAV:\">\n> > >\n> > > <D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:ex\n> > > pected-ver\n> > > sion-URI>\n> > >   </D:checkin>\n> > >\n> > > >>RESPONSE\n> > >\n> > >   HTTP/1.1 201 Created\n> > >   Location: http://repo.webdav.org/his/23/ver/32\n> > >   Cache-Control: no-cache\n> > >\n> > >   or\n> > >\n> > > >>RESPONSE\n> > >\n> > >   HTTP/1.1 409 Forbidden\n> > >   Cache-Control: no-cache\n> > >   Content-Type: text/xml; charset=\"utf-8\"\n> > >   Content-Length: xxxx\n> > >\n> > >   <D:error xmlns:D=\"DAV:\">\n> > >     <D:cannot-assign-expected-version-URI />\n> > >\n> > > <D:expected-version-URI>http://repo.webdav.org/his/23/ver/33</D:ex\n> > > pected-ver\n> > > sion-URI>\n> > >   </D:error>\n> > >\n> > >\n> > >\n> > >\n> > >\n> >\n> >\n>\n>\n\n\n\n", "id": "lists-006-11622897"}, {"subject": "RE: Feature request for CHECKIN/OUT extensio", "content": "   From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n\n   [The use case] requires that a checked-in version can carry it's\n   own URI (of the checked in version) in its content. This is a\n   mandatory requirement for the versioning system we have to expose\n   through WebDAV, so we have to either define a proprietary way to\n   achieve this, or the protocol needs an extension. We think this use\n   case may apply to many others, and this is why we are trying to get\n   a discussion and possibly a consensus here...\n\nOK, that makes it clearer.  Most systems I know of use RCS-style\nkeyword expansion to achieve this effect, so that the server can\nprovide this functionality uniformly, rather than depending on\nthe client to do so.  But there certainly are advantages to the\napproach you suggest (i.e. explicit insertion by the client).\n\nMy preference, though, would be to defer standardizing this \nparticular feature, since the spec is already quite complex\nand it is an orthogonal feature that could be provided later\nif experience indicates that this \"client side\" metadata insertion\nis preferred over \"server side\" keyword expansion.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11644506"}, {"subject": "RE: Use of attribute", "content": "   From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n\n   > From: Clemm, Geoff\n   >\n   > Probably, the best way to go is to replace the old syntax, i.e.:\n   > \n   >   <D:supported-live-property-set>\n   >     <D:supported-live-property>\n   >       <D:name> <D:getcontentlanguage/> </D:name>\n   >     </D:supported-live-property>\n   >     <D:supported-live-property>\n   >       <D:name> <X:quota/> </D:name>\n   >   </supported-live-property-set>\n\n   Why do we need <D:name>? Wouldn't\n\n   <D:supported-live-property-set>\n<D:supported-live-property>\n   <D:getcontentlanguage/>\n</D:supported-live-property>\n<D:supported-live-property>\n   <X:quota/>\n</D:supported-live-property>\n   </D:supported-live-property-set>\n\nThis would make it unsafe to define extensions to the\nD:supported-live-property content, because you would risk\ncolliding with the name of a live property.  The D:name\nintermediate node ensures that there is no such collision.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11653417"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "It is important to distinguish descriptive text that we\nadd to the protocol document (which is read by humans, and which\ncan take advantage of the fuzzy distinctions that humans can make),\nfrom protocol elements, which are used by the software (clients\nand servers) we write.  We use the terms \"working resource\" and\n\"version controlled resource\" and \"checked out resource\" when we\norganize and document the protocol for human readers.  The question\nat hand is whether those fuzzy distinctions are appropriate for use\nat runtime by software that we write (i.e. clients and servers).\n\nI'll also observe that there is a certain level of fuzziness\nthat is not useful to even a human (i.e. is more likely to be\nmisunderstood than it is to make clear).\n\nAs for the issue of obtuseness (and who is displaying it),\nI'll probably avoid that subject altogether (:-).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Wednesday, June 06, 2001 1:01 PM\nTo: Clemm, Geoff; DeltaV (E-mail)\nSubject: RE: Removing the DAV:activity and DAV:version-history and\nDAV:bas eline resource type values\n\n\nNo, no, no!!!!\n\nWe're not asking software to automatically distinguish what we call a\ndifference in type, vs what we call a difference in state.  That kind of\ndecision-making is, at present, a human activity.  We're capable of saying\n\"checkin/checkout is a change of state, not type\", even if software cannot.\n\nGeoff, don't be obtuse about this.  We can make fuzzy distinctions, because\nwe're humans designing the deltaV spec in order that the way it works makes\nsense to us.  Help us make DeltaV make sense to _humans_.  AND THEN humans\ncan write the programs that interoperate with each other.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, June 06, 2001 9:48 AM\n> To: DeltaV (E-mail)\n> Subject: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:bas eline resource type values\n>\n>\n> If you believe there is a useful line drawn between \"resource state\"\n> and \"resource type\", then it is necessary to unambiguously define \"state\"\n> and\n> \"type\" (in particular, in a way that allows you to distinguish one\n> from the other).\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Lisa Dusseault [mailto:lisa@xythos.com]\n> Sent: Wednesday, June 06, 2001 12:00 PM\n> To: Clemm, Geoff; DeltaV (E-mail)\n> Subject: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:bas eline resource type values\n>\n>\n> If you believe that whether a resource is under version control\n> or not, is a\n> matter of state, then leave it OUT of resourcetype.  It's not called\n> \"resourcestate\".\n>\n> Version, version History, and others are still types.\n>\n> But draw a line somewhere.\n>\n> lisa\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > Sent: Wednesday, June 06, 2001 8:07 AM\n> > To: DeltaV (E-mail)\n> > Subject: RE: Removing the DAV:activity and DAV:version-history and\n> > DAV:bas eline resource type values\n> >\n> >\n> > I think Tim's point was that if \"under version control\"\n> > (e.g. \"version-controlled-resource\") is part of\n> > the \"type\" of a resource, then \"checked-out\" and \"checked-in\"\n> > would equally usefully be considered as part of the type\n> > (since the significantly affect what methods can be\n> > applied to that resource).\n> >\n> > In each case, you have the same resource (i.e. when you\n> > put a resource under version control, it is the same resource\n> > but has some additional live properties and methods you can\n> > apply to it).\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n> > Sent: Wednesday, June 06, 2001 6:27 AM\n> > To: DeltaV (E-mail)\n> > Subject: AW: Removing the DAV:activity and DAV:version-history and DAV\n> > :baseline resource type values\n> >\n> >\n> >\n> >\n> > > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von\n> > > Tim_Ellison@uk.ibm.com\n> > > [...]\n> > >\n> > > My view of the world...\n> > >\n> > > Here's the list of elements that could appear in a\n> > DAV:resourcetype.  Some\n> > > of these can be combined to provide a really meaningful\n> > experience for the\n> > > client.  Obviously, some combinations are invalid.\n> > >      <DAV:checked-in/>\n> > >      <DAV:checked-out/>\n> > >      <DAV:collection/>\n> > >      <DAV:working-resource/>\n> > >      <DAV:version-controlled-resource/>\n> > >      <DAV:version/>\n> > >      <DAV:version-history/>\n> > >      <DAV:workspace/>\n> > >      <DAV:version-controlled-configuration/>\n> > >      <DAV:baseline/>\n> > >      <DAV:activity/>\n> > >\n> >\n> > What is your rationale for checked-in/out in the type? I think\n> > I have missed something in the spec, since it feels like a\n> > property to me.\n> >\n> > > So,\n> > > <DAV:resourcetype>\n> > >      <DAV:activity/>\n> > > </DAV:resourcetype\n> > >\n> > > would be good, that is, not surprisingly, an activity resource.\n> > >\n> > > <DAV:resourcetype>\n> > >      <DAV:checked-out/>\n> > >      <DAV:version-controlled-resource/>\n> > >      <DAV:collection/>\n> > >      <DAV:workspace/>\n> > > </DAV:resourcetype>\n> > >\n> > > would be good too, it is a checked-out, version-controlled\n> > resource for a\n> > > workspace collection.  And so on.\n> > >\n> > > Tim\n> > >\n> > >\n\n\n\n", "id": "lists-006-1165767"}, {"subject": "RE: A different perspective on versioning cf Delta", "content": "   From: luciano.quadraccia@centrelink.gov.au\n\n   The reason why I am writing to you is that we have implemented a\n   version control system for our mainframe software, where our\n   versioning model has many similarities to DeltaV, but differs\n   significantly in the emphasis it gives to releases.  If possible I\n   would like to explore with you the advantages of our model, and I\n   am very interested in your opinion and whether you believe DeltaV\n   caters for our requirements.\n\nI believe the answer is yes, and will try to indicate below how your\nsystem could be modeled with the DeltaV protocol.  I'll CC this to\nthe DeltaV mailing list, since it provides a good example of how\nDeltaV can be used to expose a variety of versioning models.\n\n   For most\n   changes, the full development cycle takes 3-6 months from initial\n   analysis to implementation.\n\nI will assume that by \"implementation\", you mean what I would consider\n\"deployment\" (i.e. deploying the system for use by the end users).\nNormally, I would use \"implementation\" to mean \"writing the code\",\nbut we'll use your definition for this message.\n\n   Most of these changes have legislated\n   fixed implementation dates.  This means that at any point in time\n   there will be many software modules that have been changed and are\n   scheduled to be implemented with different releases.\n\nIn DeltaV, your \"release\" would be modelled as an \"activity\".\nIn addition, each release would have a set of labels, with one label for\neach QA level.  For example, for release A you would have\nlabels: RelA-fully-tested, RelA-barely-tested, RelA-not-tested.\n\n   It is not uncommon for 20 different releases to be defined and\n   active simultaneously, and it is possible that a module has to be\n   changed within a release and across the releases, and many\n   development teams could easily be developing changes simultaneously\n   for 3 or more releases.\n\nI assume \"changed within a release\" means the change is only made\nin that release, while \"changed across releases\" means the change is\nmade in that release and all (or some selected) subsequent releases.\n\n   Centrelinks' versioning system: (I have tried to use the same\n   terminology you use, but please excuse me if, because of my limited\n   understanding of DeltaV, I use it incorrectly.)\n\n   A release is the set of all revisions that are scheduled to be\n   implemented together at a particular date/time.\n\nYou would add the \"implementation-date\" as a property on the activity\nthat corresponds to the release.  Because of the way you use QA levels,\nyou would select the versions for a release with labels, rather than\ndefining a single line of descent with the activity.\n\n   Centrelink's main difference with DeltaV is that our versioning\n   model provides specific support for the release.  In particular,\n   our version control system, loosely called the Centrelink\n   Repository, maintains a version tree of releases, whereas DeltaV\n   maintains a version tree for each versionable resource.\n\nYou would model this release tree in DeltaV as a \"preceding-release\"\nproperty on the activities that you use to model releases.\n\n   I understand the concept of releases can be implemented in DeltaV\n   by the use of labels.  And I understand that there are facilities\n   in DeltaV for the label to be moved automatically from revision to\n   revision.  However, the whole approach seems to be adhoc, requiring\n   the developer to do lots of bookkeeping so as to be sure of the\n   exact role for each revision.  This is because from DeltaV's point\n   of view there is no differentiation between the revisions, and each\n   is given equivalent level of importance.  Centrelink's approach\n   requires much less effort for the developer.\n\nA users gesture that says \"set this QA level for this version\" would\nbe mapped into a \"set this label for this version\".  So a developer\nwould not see anything different when DeltaV was used to communicate\nbetween your client and your server.\n\n   Centrelink's system is aware of which revisions have been\n   implemented and are in production, the QA level achieved by each\n   revision (eg fully tested, barely tested, not tested), and the\n   release in which each revision belongs.\n\nThere would be a label for each QA level and release, e.g. one\n\"RelA-fully-tested\", \"RelA-barely-tested\", \"RelA-not-tested\",\n\"RelB-fully-tested\", etc.\n\n   Production revisions\n   cannot be changed: they can only be superceded by revisions which\n   have attained the highest QA level.\n\nDeltaV versions can never changed, but labels can be reassigned,\nwhich provides the \"supercedes\" functionality.\n\n   This can happen only when a\n   release is implemented: all revisions at the highest QA level\n   replace the production revisions.\n\nThis would be done by assigning the appropriate labels to those\nrevisions.\n\n   If for that release revisions\n   exist at any other QA level then the implementation is not allowed\n   to proceed.\n\nThis restriction is one that is not required by DeltaV, but certainly\ncould be enforced by your server.\n\n   Earlier production revisions are no longer tracked by\n   the system (though copies are placed in an archive for historical\n   reasons, with sufficient metadata that describes the ancestry of\n   each).\n\nDeltaV does not differentiate between \"tracked\" and \"archived\"\nversions, but your server could automatically archive the\nappropriate versions.\n\n   Similarly, at each QA level, a revision cannot be changed\n   directly except for revisions at the lowest possible level, \"not\n   tested\".\n\nIn DeltaV, no version can be changed, but I believe what you want\nhere is to indicate that a different version is at a particular\nQA state for a particular release, and that can certainly be done\nby moving the appropriate label each time the QA state is changed,\nor each time a version is \"moved\" to a new release.\n\n   Thus, for each versionable resource, the system is\n   tracking only the latest revision at each QA level, for each\n   release.\n\nIn DeltaV, this is modeled as only labeling the latest\nversion that has a given QA level in a given release.\nFor example, when the user indicates that a new version\nis fully-tested for RelA, the RelA-fully-tested label is\nmoved to that version.\n\n   This makes it very simple for developers, and there is\n   never any confusion about which revision the person should be\n   working on.  Fundamentally we implemented a simple rule (others\n   might wish to vary the rule, but the concept is the same), where,\n   in a particular release the only revision that can be edited is:\n\n- the one at the lowest QA level in that release, or\n- if there is none, then\n     - the one that has reached the maximum possible QA level and\n     -  is in the release closest to and is an ancestor of the\ncurrent\n   release in the release tree, or\n- if none, then the production revision.\n\nIn DeltaV, this would be modeled as a restriction on what version\ncan be checked out.  This is not required by DeltaV, but could\ncertainly be enforced by your server.\n\n   From that point on, the system is equivalent to DeltaV, so that a\n   change in an earlier release effectively causes a branch for a\n   revision in the later release, labelling it \"broken\", later forcing\n   a merge between the two revisions.\n\nYes.  DeltaV doesn't require you to explicitly mark a version as\n\"broken\" since this information is available from the version history,\nbut you certainly could introduce a \"broken\" property for this\n(it would be a property, not a label, since a label can only select\none version from a version history, while multiple versions in a\nversion history can be \"broken\").\n\n   The developer logs in to the version control system and selects the\n   release to work in.  (The system remembers this in the user's\n   profile).  All changes the developer makes are automatically\n   labelled (in DeltaV terms) as \"not tested\".\n\nActually, for release A, they would need to be labeled\n\"RelA-not-tested\", not just \"not-tested\", since each release can\nselect a different version as its \"not-tested\" version.\n\n   When the developer is\n   satisfied with the changes and has done some unit testing, the\n   developer, or the supervisor, can promote the module to the next QA\n   level \"barely tested\".  And the same is repeated for the next QA\n   level (we have 3 QA levels, and occasionally there is talk of\n   creating a 4th).  This seems equivalent to assigning labels in\n   DeltaV, but in Centrelink this is done in the context of changes to\n   QA levels, and always within the same release.\n\nThe \"release context\" needs to be included in the label name,\ne.g. \"RelA-not-tested\".\n\n   The  developer  can  also move revisions from one release to another.\n\nThis would be modeled in DeltaV by assigning a different label to the\nsame version, e.g. you move a version to the RelY release by adding a\nRelY-not-tested label to it.\n\n   Also the administrator can move a whole release from one place in\n   the version tree to another.\n\nThis is done by using the Depth header on the LABEL request, so that\nyou can label all revisions in a release with the appropriate label\nfor the new release.\n\n   The system applies the same rules as when a change is made to a\n   revision in an earlier release, so when this move happens the\n   system marks as \"broken\" the appropriate revisions in descendent\n   releases.\n\nAs above, with DeltaV, there is no need to mark versions as \"broken\",\nsince the version tree tells you whether or not a merge is required,\nbut adding an explicit \"broken\" property would be fine.\n\n   Diagram:  Version  history of foo.html.   Say that at a particular point\nin\n   time there are 7 revisions as shown in the diagram.\n\n Revision name, for QA level reached:\n      Release name:    Fully tested   barely tested   not tested\n      =============    ============   =============   ==========\n      Production        V1\n |               |\n |               |\n      A: June 2001      V2--------------V3--------------V4\n |               |\n |               |\n      B: Sept 2001      V5--------------V6--------------V7\n\nThis is not what DeltaV would call a version history.  In DeltaV,\nthe version \"history\" contains a record of which version was created\nfrom which other version.  What you describe above is a \"quality\nlevel\" tree, showing which version is \"better\" than which other\nversion.  These relationships would be captured by the\nlabels, and not be what DeltaV calls the \"version history\".\n\n   This  diagram  shows that revision V2 is a direct descendant of V1, V3 is\na\n   descendant of V2, V4 is a descendant of V3, V5 is a descendant of V2.\n   Each of the following scenarios is based on this initial state.\n\n   Scenario 1: A user logged in to release B can only edit V7.  The\n   changes are made in place and the earlier edition of V7 is\n   destroyed.\n\nSince you identify a version by a release-QAlevel label, it would\nappear to a user that the older version is gone when the label is\nmoved.  If you really \"destroy\" that earlier version (as opposed to\narchiving it), then your server would be required to update the\npredecessor/successor relationships that referenced the destroyed\nversion.\n\n   If the user thinks V7 is worth retaining, he would\n   promote it to \"barely tested\", thereby replacing V6 (which is\n   copied to the archive), and the changed revision would be V8,\n\nIn DeltaV, \"replace\" here just means moving the RelB-barely-tested\nlabel from V6 to V7.  Your server can automatically archive V6, if it\nwishes to do so.\n\n   so the diagram would look like:\n\n      Production        V1\n |               |\n |               |\n      A: June 2001      V2--------------V3--------------V4\n |               |\n |               |\n      B: Sept 2001      V5--------------V7--------------V8\n\n   This demonstrates that the system is only tracking the \"tip\" at\n   each QA level (though, with some effort, the user can extract more\n   information from the archive).\n\nThis is what allows you to use DeltaV labels to model your system.\n\n   If  the  user  deems the V8 changes to be a failure he can\n   delete it and revert to using V7.  Similarly if V7 fails, he can go back\nto\n   V5.   We  found  this  model to work very well and it is extremely rare\nfor\n   someone to have to go to the archive to pull out a different revision.\n\n\"Going back\" would be modeled in DeltaV by moving the appropriate label.\n\n   Scenario  2: If instead V5, V6 and V7 do not exist yet, a user logged in\nto\n   release  B  can  only edit V2, and the revised module would be labelled\nNot\n   Tested.  So we get:\n\n      Production        V1\n |               |\n |               |\n      A: June 2001      V2--------------V3--------------V4\n |               |\n |               |\n      B: Sept 2001       -------------------------------V5\n\n   Scenario  3:  If a user promotes V3 to \"fully tested\", then the new\ndiagram\n   is:\n\n      Production        V1\n |               |\n |               |\n      A: June 2001      V3------------------------------V4\n |               |\n |               |\n      B: Sept 2001      V5-broken-------V6-broken-------V7-broken\n\n   Note  that  V2  has been archived, and that V5, V6 and V7 have been\nlabeled\n   \"broken\" as they are not descendants of V3.\n\nIn DeltaV, the predecessor relationship would tell you whether or not\na particular version is \"broken\", i.e. a version is broken if\nfully-tested version from the preceding release is not an ancestor\nof the versions in the release.\n\n   Scenario  4:  If  release  A  slips  to October, then this is equivalent\nto\n   moving  Release B and inserting it in the tree in front of Release A.\nThis\n   causes  the  revisions in Release A to be marked as broken. The diagram\nnow\n   is:\n\n      Production        V1\n |               |\n |               |\n      B: Sept 2001      V5--------------V7--------------V8\n |               |\n |               |\n      A: Oct 2001       V2-broken-------V3-broken-------V4-broken\n\nThe same rule from above applies here, namely that a version is \"broken\"\nif the fully-tested version from the preceding release is not an\nancestor of the versions in the release.\n\n   I hope I have described enough to give you a feeling for our model.\n   We believe this same model should work equally well for the web,\n   where we fear we could end up having hundreds of thousands of\n   modules.  Our system is already capable of handling changes to tens\n   of thousands of modules, whereas we suspect that the effort to\n   maintain the individual version trees for each resource to be\n   overwhelming at our current rate of change.\n\nThe only overhead that DeltaV would place is that it would require\nyour server to maintain the DAV:predessor-set for a version, which\ndoes not appear to be something you do today.  This is actually\nvery easy to do (i.e. you only update it when you create or delete\na version), so I don't think it would be hard for you to maintain\nthis information.\n\n   Sometimes it is put to me that Centrelink is different, and its\n   requirements are different, so that our model is not applicable to\n   other organisations.  However I don't agree with that, as I believe\n   our model is applicable anywhere there are large numbers of items\n   that change and where the changes have interrelationships so that\n   certain changes have to be synchronised, or at least released in a\n   particular sequence.  Further, I believe that the web is making\n   this requirement stronger, with more frequent incremental releases,\n   thereby increasing the need for a versioning model similar to ours.\n\nThere are several versioning systems that provide a model similar to\nthis (especially the systems that are based on relational databases,\nsince the \"release/QA-level\" model maps easily into a couple of \ncolumns in the relational database).  There are alternative models\nthat some users find either simpler or more powerful, but DeltaV\nwas designed to support a variety of versioning models, including\nones like the CentreLink model.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11661937"}, {"subject": "RE: Feature request for CHECKIN/OUT extensio", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Thursday, August 09, 2001 10:50 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Feature request for CHECKIN/OUT extension\n>\n>\n>    From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n>\n>    [The use case] requires that a checked-in version can carry it's\n>    own URI (of the checked in version) in its content. This is a\n>    mandatory requirement for the versioning system we have to expose\n>    through WebDAV, so we have to either define a proprietary way to\n>    achieve this, or the protocol needs an extension. We think this use\n>    case may apply to many others, and this is why we are trying to get\n>    a discussion and possibly a consensus here...\n>\n> OK, that makes it clearer.  Most systems I know of use RCS-style\n> keyword expansion to achieve this effect, so that the server can\n> provide this functionality uniformly, rather than depending on\n> the client to do so.  But there certainly are advantages to the\n> approach you suggest (i.e. explicit insertion by the client).\n\nAlso, keyword expansion doesn't work very well with non-text formats, right?\n\n> My preference, though, would be to defer standardizing this\n> particular feature, since the spec is already quite complex\n> and it is an orthogonal feature that could be provided later\n> if experience indicates that this \"client side\" metadata insertion\n> is preferred over \"server side\" keyword expansion.\n\nWell, I myself don't have the choice to defer it. I'm looking for the best\nway to integrate it into our deltaV implementation... Maybe we could at\nleast consider to define the root element of an optional response body for\nCHECKOUT (because that would IMHO be the best way to return additional\ninformation to the client)?\n\nRegards, Julian\n\n\n\n", "id": "lists-006-11685717"}, {"subject": "RE: Problems with locking and DeltaV resource", "content": "It is likely that a server that supports working resources will\nhave ACL's on the working resource that only allows modification\nof the working resource by the principal that created the working\nresource.  Also, another client is extremely unlikely to encounter\nthe working resource, since it has been given a new (virtually\nguaranteed to be obscure) URL.  So the window between when the\nworking resource is created and when the working resource is locked\nis likely to be of extremely low risk.\n\nCheers,\nGeoff \n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Wednesday, August 08, 2001 8:55 AM\nTo: DeltaV\nSubject: Problems with locking and DeltaV resources\n\n\n\nLet's say as a client I want to protect my version-controlled resource (VCR)\nand associated working resource (WR) from being edited by other users while\nI check it out and edit it.  One might think the user could issue:\n\n - LOCK VCR\n - CHECKOUT VCR\n - LOCK WR\n ...\n\nThis won't work, however.  There is a window when other users can lock my\nWR, edit it, etc, before I manage to lock it.   Having another client \"take\nover\" my WR is a situation which I think most clients will want to prevent,\nor will not know how to handle, or both.\n\nAny way of dealing with this?\n\nlisa\n\n\n\n", "id": "lists-006-11696540"}, {"subject": "RE: Feature request for CHECKIN/OUT extensio", "content": "Yes, defining the name for the response body for all the methods\nwould be a good thing, to allow for this kind of extensibility.\nDoes anyone object?\n\nMy convention has been to have the request body for request XXX be\nDAV:xxx, and the response body be DAV:xxx-response.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n\nWell, I myself don't have the choice to defer it. I'm looking for the best\nway to integrate it into our deltaV implementation... Maybe we could at\nleast consider to define the root element of an optional response body for\nCHECKOUT (because that would IMHO be the best way to return additional\ninformation to the client)?\n\nRegards, Julian\n\n\n\n", "id": "lists-006-11705066"}, {"subject": "Re-send of baseline-control diagram", "content": "Hi,\n\nSome members of the group were unable to read my ASCII diagrams of\nbaseline-control etc.  So I am resending them as attached text files.\n\nI think I prefer the diagram contained in diagram1.txt...\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (ADM)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n\n\n\n\n\ntext/plain attachment: diagram1.txt\n\ntext/plain attachment: diagram2.txt\n\n\n\n\n", "id": "lists-006-11713292"}, {"subject": "RE: Comments regarding locking &amp; auto-checkin..", "content": "Hi,\n\nThanks John, you are right, the automatic check-in is fine.\nAnother issue which was raised at the London IETF was what would\nhappen if the CHECKIN failed perhaps because forking properties\nwould disallow it?  And also I raised a question asking if a more\nexplicit error code should be returned when an If header specifies\na lock which has timed-out rather than an invalid lock, I believe\nthat at the moment a client cannot tell the difference.\n\nRegards,\nPeter Raymond - MERANT.\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: 09 August 2001 17:44\nTo: 'Peter Raymond'; ietf-dav-versioning@w3.org\nSubject: RE: Comments regarding locking & auto-checkin...\n\n\nI believe that the current behavior is the desired and expected\nbehavior.\n\nWhen Fred LOCKS the document and starts working on it, he knows very\nwell that each and every change he makes is seen by everyone\nimmediately.  The fact that it is then checked in because he went to\nlunch would not seem to be a problem.  At worst he just has more\nversions in the version history, but no versions that he didn't intend\nto make available.\n\nNow the client program, if continuously operating, should be refreshing\nthe lock.  If it isn't, then when it is restarted I assume it needs to\ncheck if the lock exists and reaquire it if not.\n\nThe worst case is that if the client wasn't written with this in mind,\nit will just start doing PUT's with an invalid IF header lock token.  \n\nIs a PUT supposed to be rejected if the IF header provided specifies an\ninvalid lock token and the resource is not locked?\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Peter Raymond\n> Sent: Tuesday, August 07, 2001 4:03 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Comments regarding locking & auto-checkin...\n> \n> \n> Hi,\n> \n> Section 3.2.2 when DAV:auto-checkout is DAV:locked-update and \n> a lock times out the specification says a implicit CHECKIN \n> operation will happen.  This just seems a little odd.\n> \n> For example imagine user Fred is sitting in his client \n> application LOCKS a document and starts work on it, he takes \n> his time working on the doc and his LOCK times out, so \n> suddenly his incomplete work will be checked back in without \n> him knowing.  I guess when he goes to unlock the document (as \n> he is not aware that his lock was timed out) he would get an \n> error saying something like \"You don't have a lock on this \n> document (invalid lock token)\".\n> \n> Other options for the behaviour of timed out locks would be:\n> \n> 1)  Just cancel his lock (but not auto checkin).\n>      This would avoid checking in Freds incomplete work but \n> would leave Fred equally confused when he\n>      tries to unlock and is told that he has not got the \n> document locked.\n> \n> 2)  Do not timeout locks for auto versioning clients.\n>      This would keep Fred happy since he keeps the lock but \n> it totally defeats the point of lock timeouts.\n>      Do any clients set lock timeouts to be anything other \n> than Infinity?  I have not seen any use of lock\n>      timeouts yet.\n> \n> 3)  Find some way to inform the client that the lock has timed-out.\n>      Since HTTP is request/response driven we can't just send \n> a message to Fred to inform him the lock\n>      has timed out (he needs to request something first).  So \n> the only implementation I can think of would\n>      be for the client to send some kinda lock keep-alives.\n> \n> I guess my preference is for option 1 but when Fred unlocks \n> we should return some specific error so at least the client \n> knows that the unlock failed because the token specified was \n> timed-out (rather than just an invalid token).\n> \n> What do other people think? Do lock timeouts actually get \n> used (if not we should remove them from the spec). We were \n> talking in the WebDAV (RFC2518) meeting yesterday about \n> allowing some principal other than the lock owner to unlock a \n> resource so removing lock timeouts would not mean the lock is \n> unbreakable.\n> \n> Regards,\n> Peter Raymond - MERANT.\n> \n\n\n\n", "id": "lists-006-11720932"}, {"subject": "Re: Issues/questions regarding sections 3, 4 and 5..", "content": "Hi Peter,\n\nI'm going to skip most of the editorial points you make and comment on some\nof the issues you raised:\n\n> Section 3.1.4, the last sentence does not seem to make\n> sense, it reads:\n>\n> \"A live property is supported by a resource if that\n> property has the semantics defined for that property\"\n>\n> The property always has the semantics defined for that property.\n\nThis is a (somewhat desperate) attempt to define the supported properties.\nThe point is that if the property is 'live' i.e., its semantics are\nenforced by the server, and those semantics are those defined by this\ndocument, then it is a 'supported' property in the DeltaV sense.\n\nAlternative wording is invited.\n\n> [Issue/Editorial]\n>\n> Section 3.9 the specification says that when a resource\n> is automatically checked out:\n>\n> \"the DAV:checked-in property MUST be empty\"\n> ...\n\nI think we have agreed that the properties should be removed (not just made\nempty).\n\n> [Issue]\n>\n> Section 4.3 states for CHECKIN that :\n>\n> \"The response for a successful request MUST include a\n> Location header\".\n>\n> The only time deltav talks about the location header is\n> for CHECKIN of a VCR and CHECKOUT of a working resource\n> (section 9.3).  Why is this only on those methods?\n> What is the use case for it (does it simply save the\n> client from having to PROPFIND the DAV:checked-in?).\n\nThe Location: header is required in the response to a successful check-in\nof a version-controlled resource to indicate which version was created by\nthe CHECKIN.  Without the Location: header there would be a race condition\nbetween the client checking in the resource and PROPFINDing the\nDAV:checked-in property with other clients that may be checking-out the\nversion-controlled resource or UPDATEing it, that would loose that\ninformation.\n\nThe Location: header is required in the response to a successful CHECKOUT\nof a version to indicate to the client the server defined working resource\nURL.\n\n> I ask this because the Location header is not returned\n> by other methods that create resources,  eg UNLOCK etc\n\n(UNLOCK will not create a resource)  In general, the methods that create\nresources do so at user-defined URLs (e.g., PUT, MKCOL, MOVE, etc.\n\n> for auto-versioning clients (eg when automatically\n> checking in).\n\nAuto-versioning clients, by definition would not know about any extensions\nwe would define for them.\n\n> I suggest we either remove the feature or use it\n> consistently eg whenever a new resource is created\n> return the Location header.\n>\n> [Issue]\n>\n> Section 5.4.1 since this report is on a collection I would\n> like a Depth header defined.\n> Again I think we should be consistent (to avoid speical-case\n> coding). Any method that gets properties of a collection\n> should take a Depth header.\n\nAll REPORTs may take a Depth: header (see versioning-16 Sec. 3.6)\n\n> [Issue]\n>\n> Section 5.5 defines this mechanism where OPTIONS can be\n> used to find a possible location in the namespace that\n> is to be used for version histories.  I assume this is so\n> a client can indicate in a GUI if a collection is a\n> collection of version histories or a client could choose\n> not to display that part of the namespace.\n\nThat was not the motivation for providing this information.  In general,\nthe version histories will be maintained in server-defined URL space which\nis likely to not conflict with user URLs.  The mechanism was provided to\ngive clients the ability to locate version histories 'from scratch'.  This\nis required when clients remove all the version-controlled resources that\nrefer to (versions in a particular) version history.  Since without any\nversion-controlled resources all that remains is the version histories and\nversions, which are all at server-defined URLs, they can become 'orphaned'.\nThis mechanism gives clients a way to find them again.\n\n> It seems odd that this is only available for version\n> histories, these are not the only resource that have\n> \"server-defined\" URLs.  For example would the clients\n> want a OPTIONS request to indicate where in the\n> namespace will be used to reference versions as opposed\n> to version controlled resources?\n> The same arguments as in section 5.5 applies to versions,\n> they may not be stored on the same server etc.\n\nThere was no attempt to refine the description of the server storage to\nthis level of detail.  That's not to say a particular server cannot include\nsuch information, only that it is not required for versioning clients and\nservers to interoperate.\n\n> I also think an example of the OPTIONS method being used\n> for this would be good as it is quite different from other\n> uses of OPTIONS.\n\nACK.\n\n> [Editorial/Issue]\n>\n> Reading section 5.6 it took us quite a while to decide how\n> to delete the last version from a version history.\n> I think the answer is \"you don't\" you must delete the version\n> history itself in order to delete the last version.\n> Did we interpret this correctly?\n\nYes, that is correct.  Just one of the riddles for the careful reader<g>.\n\n> Do you think we should clarify this in the spec?\n\nYes.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-11734528"}, {"subject": "RE: Comments on locking and auto-checkin..", "content": "You ask if lock timeouts are actually used -- Xythos WFS does use them.\n\nlisa\n\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Peter Raymond\nSent: Tuesday, August 07, 2001 7:19 AM\nTo: 'ietf-dav-versioning@w3.org'\nSubject: Comments on locking and auto-checkin...\n\n\nHi,\nIn section 3.2.2 when DAV:auto-checkout is DAV:locked-update and a lock\ntimes out the specification\nsays a implicit CHECKIN operation will happen.  This just seems a little\nodd.\nFor example imagine user Fred is sitting in his client application LOCKS\na document and starts work on\nit, he takes his time working on the doc and his LOCK times out, so\nsuddenly his incomplete work will be\nchecked back in without him knowing.  I guess when he goes to unlock the\ndocument (as he is not aware\nthat his lock was timed out) he would get an error saying something like\n\"You don't have a lock on this\ndocument (invalid lock token)\".\nOther options for the behaviour of timed out locks would be:\n1)  Just cancel his lock (but not auto checkin).\n     This would avoid checking in Freds incomplete work but would leave\nFred equally confused when he\n     tries to unlock and is told that he has not got the document\nlocked.\n2)  Do not timeout locks for auto versioning clients.\n     This would keep Fred happy since he keeps the lock but it totally\ndefeats the point of lock timeouts.\n     Do any clients set lock timeouts to be anything other than\nInfinity?  I have not seen any use of lock\n     timeouts yet.\n3)  Find some way to inform the client that the lock has timed-out.\n     Since HTTP is request/response driven we can't just send a message\nto Fred to inform him the lock\n     has timed out (he needs to request something first).  So the only\nimplementation I can think of would\n     be for the client to send some kinda lock keep-alives.\nI guess my preference is for option 1 but when Fred unlocks we should\nreturn some specific error so\nat least the client knows that the unlock failed because the token\nspecified was timed-out (rather than\njust an invalid token).\nWhat do other people think? Do lock timeouts actually get used (if not\nwe should remove them from the spec).\nWe were talking in the WebDAV (RFC2518) meeting yesterday about allowing\nsome principal other than the\nlock owner to unlock a resource so removing lock timeouts would not mean\nthe lock is unbreakable.\nRegards,\nPeter Raymond - MERANT.\n\n\n\n", "id": "lists-006-11747324"}, {"subject": "RE: Comments regarding locking &amp; auto-checkin..", "content": "John asks:\nIs a PUT supposed to be rejected if the IF header provided specifies an\ninvalid lock token and the resource is not locked?\n\nThe if header would likely be ignored since the resource isn't locked and\nthere's no token to check. But servers could implement this as a failed If\nheader since it doesn't match the resource. Looks like a clarification\nmight be needed in the spec.\n\n\n\n", "id": "lists-006-11757770"}, {"subject": "Re: Comments regarding locking &amp; auto-checkin..", "content": "Peter,\nPerhaps it is unfortunate that locking and checking/checkout are coupled\nresulting in potentially undesirable behavior on lock timeouts, but this is\nan unavoidable consequence of supporting non-versioning, but locking aware\nclients. The purpose of the lock is similar to checkout - it indicates a\nuser intends to modify a resource and protects those modifications from\nbeing overwritten by other users. To maintain these semantics, unlocking,\neither by the user using UNLOCK, or the server through lock timeouts, or\nany other means (e.g., unlock by another authenticated user) should not\nresult in lost updates. The consequence of checking in something that isn't\nready for wider viewing on lock timeour is less drastic than having the\nchanges overwritten by some other user. So I suggest we leave the spec as\nis, and users and clients should be sure to use appropriate lock timeout\nvalues.\n\n\n\n                                                                                                                         \n                    Peter Raymond                                                                                        \n                    <Peter.Raymond@merant.co       To:     ietf-dav-versioning@w3.org                                    \n                    m>                             cc:                                                                   \n                    Sent by:                       Subject:     Comments regarding locking & auto-checkin...             \n                    ietf-dav-versioning-requ                                                                             \n                    est@w3.org                                                                                           \n                                                                                                                         \n                                                                                                                         \n                    08/07/2001 07:03 AM                                                                                  \n                                                                                                                         \n                                                                                                                         \n\n\n\nHi,\n\nSection 3.2.2 when DAV:auto-checkout is DAV:locked-update and a lock\ntimes out the specification\nsays a implicit CHECKIN operation will happen.  This just seems a little\nodd.\n\nFor example imagine user Fred is sitting in his client application LOCKS\na document and starts work on\nit, he takes his time working on the doc and his LOCK times out, so\nsuddenly his incomplete work will be\nchecked back in without him knowing.  I guess when he goes to unlock the\ndocument (as he is not aware\nthat his lock was timed out) he would get an error saying something like\n\"You don't have a lock on this\ndocument (invalid lock token)\".\n\nOther options for the behaviour of timed out locks would be:\n\n1)  Just cancel his lock (but not auto checkin).\n     This would avoid checking in Freds incomplete work but would leave\nFred equally confused when he\n     tries to unlock and is told that he has not got the document\nlocked.\n\n2)  Do not timeout locks for auto versioning clients.\n     This would keep Fred happy since he keeps the lock but it totally\ndefeats the point of lock timeouts.\n     Do any clients set lock timeouts to be anything other than\nInfinity?  I have not seen any use of lock\n     timeouts yet.\n\n3)  Find some way to inform the client that the lock has timed-out.\n     Since HTTP is request/response driven we can't just send a message\nto Fred to inform him the lock\n     has timed out (he needs to request something first).  So the only\nimplementation I can think of would\n     be for the client to send some kinda lock keep-alives.\n\nI guess my preference is for option 1 but when Fred unlocks we should\nreturn some specific error so\nat least the client knows that the unlock failed because the token\nspecified was timed-out (rather than\njust an invalid token).\n\nWhat do other people think? Do lock timeouts actually get used (if not\nwe should remove them from the spec).\nWe were talking in the WebDAV (RFC2518) meeting yesterday about allowing\nsome principal other than the\nlock owner to unlock a resource so removing lock timeouts would not mean\nthe lock is unbreakable.\n\nRegards,\nPeter Raymond - MERANT.\n\n\n\n", "id": "lists-006-11765509"}, {"subject": "Allow: header and supported method", "content": "During the working group meeting we agreed to note this issue on the list:\n\nWhat does the (HTTP/1.1 defined) Allow: header mean? and should it be the\nsame as the (DeltaV defined) DAV:supported-method-set property?\n\nThe meeting attendees agreed that \"allowed\" and \"supported\" should mean the\nsame thing, and concensus was that both should report methods that will\nsucceed for some state of the resource, not necessarily the current state.\n\nFor example, a version-controlled resource can be checked-out or checked-in\nand therefore only one of CHECKOUT or CHECKIN will succeed for a given\nstate of a version-controlled resource.  It is proposed that, for\nversion-controlled resources, \"Allow:\" and \"DAV:supported-method-set\"\ninclude both CHECKIN and CHECKOUT (amongst others).\n\nSend any objections to the list.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-11778215"}, {"subject": "IETF-51 DeltaV WG meeting minute", "content": "Delta-V Working Group Meeting (1pm Wednesday August 8th, 2001)\nIETF'51 London, England\n\nIntroduction by Jim Amsden, including status of working group document.\nIETF-wide last call imminent and well on the path to Proposed Standard.\nGeoff presented the changes made to the draft since versioning-16:\n- Overview of DAV:auto-version values.  Noted that DAV:locked-checkout\nimplies unlock checkin.\n- The supported live properties are marshalled as XML attributes, the\nproposal is to switch them back to name elements.  However, method names\nmay contain characters that are not valid as XML element names, so they\nwill stay as attribute values, and there is no namespace to report.\n- Remove DAV:ok as a defined value for the check-out fork and check-in\nfork, and just leave the DAV:forbidden and DAV:discouraged values.  Servers\nshould just check for these flags.  This means that forking is ok if the\nvalue is empty (or DAV:ok).\n- Similarly, an empty value for DAV:auto-version means that there is no\nauto-versioning happening for that resource.\n- Change the specification to say that servers SHOULD implement the expand\nproperty report, and move the description of the report earlier in the\ndocument to illustrate that it is not an advanced feature.\n- Should clarify the relationship between the DAV:supported-method-set and\nthe Allow: header.\nShould it report for the current state of the resource ? or for any state\nof the resource?  Current consensus is that 'supported' means for any\nstate.  Should we clarify what the Allow: header means?  E.g. for a\nversion-controlled resource, does Allow: include both CHECKIN and CHECKOUT\nor only ever just one of them?\nNote that we still require the supported-methods property to permit depth\nqueries.\nCall for consensus within the room on what \"allow\" and \"supported\" means ?\nagreed that they should mean the same thing.  Proposed that it means will\nsucceed on some state of the resource, and not necessarily the current\nstate.\n- When a version-controlled resource is auto-checked-out, an explicit\nUNLOCK request will fail if the version-controlled resource cannot be\nauto-checked-in.  However, when the server removes the lock (when the lock\nexpires) what is the server allowed to do on CHECKIN failure?  (a) leave\nthe resource checked-out and unlocked, (b) fail the lock timeout, and leave\nthe resource checked-out and locked, (c) something else?\nDiscussion of coupling UNLOCK and CHECKIN ? how can a versioning aware\nclient do the UNLOCK if the CHECKIN will fail?  No resolution in the\nmeeting.\n- Discussion of adding extra data to the error conditions.\n- Replace locate history\n- Remove the PROPFIND semantics from UPDATE and MERGE (or justify its use\nin the specification).\n- Discussion of procedure for IESG last call.  Ned stated that there\nappears to be no major issues outstanding with the latest draft of the\ndocument, so Geoff will put produce versioning-17 sometime next week and\nlet that go forward for IESG last call.\n- Lisa presented a proposal for identifying a subset of DeltaV for document\nversioning without forking.  It would include core, in-place check-out and\nmaybe working resources package.  It will be DeltaV compliant.\n- Lisa stated that she has outstanding issues with\nsupported-live-properties.  The group agreed to compromise by stating that\nthe specification will state that DAV:supported-live-properties MUST\ninclude the supported DeltaV and WebDAV live properties and SHOULD include\nother server-defined live properties.\n- Lisa also requested an UNVERSION capability to remove the history\nresource and versions and working resources and leave the\nversion-controlled resources as regular versionable resources.  Maybe even\nleave working resources as versionable resources.\n- Question: What happens to version-controlled resources when a history\nresource is DELETEd?  Should say in the spec?\n- Future work should consider variant management and document work flow and\nchange request management.  Put out a request for participants in the\nWebDAV working group.\n- WebDAV inter-op events should include DeltaV (rather than have a separate\nDeltaV event).\n- Expected progression from here:  Geoff writes versioning-17; one week to\nget through queue into draft; Ned gives Steve the ok to send versioning-17\nto IESG last call; last call period is two weeks (min.); then it goes onto\nthe IESG agenda for becoming a Proposed Standard (IESG meets every two\nweeks).  The RFC editor output requires careful author review.  Close down\nthe working group.  After six months consider going for draft standard\nwhich requires two clients and two servers with distinct code bases to\ninter-op.  Finally go for full standard some time after that.\n- Meeting closed at 2:45pm\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n\n", "id": "lists-006-11786959"}, {"subject": "Re: Allow: header and supported method", "content": "Please excuse a newbie question:\n\nSurely for a server looking after versioned resources, asking it\n\"What If?\" questions based on its current state is a bit useless?\n\nI mean, if I have a checked-out resource, and I don't have an\nexclusive write-lock on the resource, then requests to the server\nsuch as \"If I try and commit, will I be able to?\" can only\nbe usefully answered by the server with: \"I don't know, unless\nyou try.\"\n\nIs there a more subtle issue I'm missing?\n\nBen\n\nOn Tue, Aug 14, 2001 at 09:53:36AM +0100, Tim Ellison wrote:\n> During the working group meeting we agreed to note this issue on the list:\n> \n> What does the (HTTP/1.1 defined) Allow: header mean? and should it be the\n> same as the (DeltaV defined) DAV:supported-method-set property?\n> \n> The meeting attendees agreed that \"allowed\" and \"supported\" should mean the\n> same thing, and concensus was that both should report methods that will\n> succeed for some state of the resource, not necessarily the current state.\n> \n> For example, a version-controlled resource can be checked-out or checked-in\n> and therefore only one of CHECKOUT or CHECKIN will succeed for a given\n> state of a version-controlled resource.  It is proposed that, for\n> version-controlled resources, \"Allow:\" and \"DAV:supported-method-set\"\n> include both CHECKIN and CHECKOUT (amongst others).\n> \n> Send any objections to the list.\n> \n> Regards,\n> Tim\n> \n\n\n\n", "id": "lists-006-11799095"}, {"subject": "RE: IETF-51 DeltaV WG meeting minute", "content": "Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n> In the meeting notes you sent we said:\n>\n> - Remove DAV:ok as a defined value for the check-out fork and check-in\n> fork, and just leave the DAV:forbidden and DAV:discouraged values.\nServers\n> should just check for these flags.? This means that forking is ok if the\n> value is empty (or DAV:ok).\n>\n> - Similarly, an empty value for DAV:auto-version means that there is no\n> auto-versioning happening for that resource.\n>\n> This seems counter to the conversations on empty properties and removing\n> properties.? Rather than having empty values do you think it's a good\n> idea to remove the DAV:auto-version, DAV:checkout-fork, DAV:checkin-fork\n> properties to indicate no auto-versioning and that forking is allowed?\n\n[I was only minuting what was said in the meeting<g>]  But I agree that the\nempt property value and the missing property should both be interpreted as\nyou say.  The server implementation would simply look for (in forking) the\nDAV:discouraged or DAV:forbidden tags and react accordingly if they are\nfound.  Ignoring other tags such as DAV:ok and DAV:foobar will provide\nfuture extensibility.  Clearly those tags will not be found if the property\nvalue is empty.\n\n> This would allow a supported-live-property set to indicate if forking\n> or auto-versioning is enabled.\n\nServers will report the live properties as supported even if they are not\ncurrently set on the resource (assuming the server really does support them\nof course).  So inclusion in the DAV:supported-live-properties-set will not\nhelp distinguish between unset and empty properties.\n\n> I guess I am not sure when it's best to have empty properties, versus\n> removing the property (pros and cons of both).? But one thing I do know\n> is that it would be good if we were consistent in the spec.\n\nI think it is sufficient for the spec to state what it means when the\nproperty includes a given value, without having to distinguish between\nmissing and empty properties.  However, to make the document readable and\nunambiguous I support the (purely editorial) change to refer to the\nproperties being removed.\n\n> Can you remember if there was some reason why we said the property\n> would be empty as opposed to being removed?\n\nI don't think that there is any distinction to be made.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-11807895"}, {"subject": "Re: Allow: header and supported method", "content": "Ben Evans <ben.evans@parasolsolutions.com> wrote:\n\n> Surely for a server looking after versioned resources,\n> asking it \"What If?\" questions based on its current\n> state is a bit useless?\n\nI agree, and I think that is why people were happy enough to say that the\nresponse includes methods that are valid for different states of the same\nresource.\n\n> I mean, if I have a checked-out resource, and I don't\n> have an exclusive write-lock on the resource, then\n> requests to the server such as \"If I try and commit,\n> will I be able to?\" can only be usefully answered by\n> the server with: \"I don't know, unless you try.\"\n\nYes, and there are other examples.  You could have changed the state of the\nresource (or DELETEd it for that matter) between me asking for the allowed\nmethods and then actually issuing it.\n\n> Is there a more subtle issue I'm missing?\n\nDon't think so, other than to say the principal use of the supported-*-sets\nis to allow for resource 'classification' which is typically required for\nhigh-level UIs to choose icons, grey-out or enable menu options, and so on.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-11818141"}, {"subject": "Checked out vs checked-i", "content": "I was answering some questions about the checked-in and checked-out\nproperties, and how they can exist, or not...  It required careful rereading\nof several related but distant sections of the draft.  I believe I corrected\nsome of my own misapprehensions and those of the person asking questions\nabout DeltaV.  I ended up figuring that examples were the best way to\nillustrate my understanding of these properties.\n\nCase 1: neither property exists\n\nThis case is definitely possible when the resource isn't under version\ncontrol.  However, is it possible to see this state when the resource is\nunder version control?  I think not.  Is this a good way for clients to see\nif a resource is under version control?  Is it preferable to use\nsupported-method-set or this?  It's an important question, because it may\nmean that supported-method-set is not a required property for simple\ndocument versioning (DeltaV subset).\n\nCase 2: checked-in exists\nEg:\n<D:checked-in><D:href>http://server.com/_foo.doc_v8</D:href></D:checked-in>\n\nHere, the VCR is reflecting the content and dead properties of a version in\nits version history.  It is checked in, and it is not checked out in-place.\nThere may however exist working resources that are the result of checking\nout past versions of this resource.  E.g. if version _foo.doc_v5 is checked\nout to a working resource, this fact wouldn't be reflected in the checked-in\nor checked-out properties.  We've reviewed this behaviour in previous email\nconversations, where we discussed how a client could find out if any check\nouts existed -- they must look for the checkout-set property on all versions\nin the version history, as well as the checked-out property on the VCR.\n\nCase 3: checked-out exists\nEg:\n<D:checked-out><D:href>http://server.com/_foo.doc_v8</D:href></D:checked-out\n>\n\nNow the VCR is checked-out, and the value of the property indicates what\nversion was checked out.  Further, this indicates that the resource is\nchecked out in-place.  That's because if there was a checkout to a working\nresource, that would be indicated in properties on the version resource, not\nproperties on the VCR.  There may also exist working resources that are the\nresult of checking out previous versions, in addition to the in-place\ncheckout.\n\nCase 4: checked-out and checked-in both exist -- Impossible\n\nThis case should be impossible because of the text in the draft, section\n1.3: \"A resource under version control is either in a \"checked-in\" or\n\"checked-out\" state, and the version control constraints apply only while\nthe resource is in the checked-in state.\"\n\nThis text, however, is very misleading.  I think the misdirection comes from\nthe fact that the phrase \"check out\" is used both for in-place checkouts and\nfor working resources.  It would be more accurate to say:\n\n\"A resource under version control is either in a checked-in state or in a\nchecked-out in-place state.  It may also have any number of working\nresources resulting from \"checking out\" older versions to working resources,\nregardless of whether it is in the checked-in state or in the checked-out\nin-place state\".\n\nAnother broader fix to the document would be to reserve the words \"check\nout\" and \"checked-out\" to the in-place checkout.  Creation of a working\nresource could be indicated by different language that does not conflict.\n\nPlease confirm my understanding of this and clarify the draft.\n\nLisa\n\n\n\n", "id": "lists-006-11826775"}, {"subject": "RE: Deleting version", "content": "Geoff,\n\nlast time I checked, MS Office was creating lock-null resources when doing a\n\"save as\" on an open document (for which Office already had a lock).\n\nJulian\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, June 06, 2001 6:48 PM\n> To: DeltaV\n> Subject: RE: Deleting versions\n>\n>\n>    From: Lisa Dusseault [mailto:lisa@xythos.com]\n>\n>    Are DeltaV servers then not required to support locking at all?\n>\n> Correct.\n>\n>    Lock-null comes along with lock.\n>\n> Not from Microsoft (:-).  You get locking, but not lock-null's\n> or depth locking with their IIS WebDAV server.  But I agree that\n> the protocol states that lock-null comes along with lock\n> (at least, for the current rev of the DAV protocol :-).\n>\n>    I can (barely) beleive that a server might implement\n>    DeltaV but not support locking.\n>\n> Last I heard, Greg had no intentions of implementing locking with\n> his DeltaV server.  We (i.e. Rational) are\n> likely to initially only support the limited\n> amount of locking expected by a Microsoft client (i.e. single\n> resource locking, but no lock-nulls or depth locks).\n>\n>    In fact, you acknowledge in section 14 that\n>    lock-null may be implemented:\n>\n>    \"Non-version-controlled bindings are not under version control, and\n>    therefore can be added or deleted without checking out the\n>    version-controlled collection.  This feature is essential for the\n>    support of lock null resources, since a lock null resource is a\n>    temporary internal member of a collection that should only exist\n>    for the duration of the lock, and should not be captured in the\n>    version history of that collection.\"\n>\n> Yes, it is essential that the DeltaV protocol be compatible with\n> the locking protocol (if it isn't, please let me know!).  But that\n> doesn't mean it should depend on or be otherwise concerned with it.\n> To the contrary, ensuring that the versioning protocol is orthogonal\n> to the locking protocol allows the versioning and locking protocols\n> to evolve independently.  Any explicit statement in the versioning\n> protocol about the locking protocol risks a conflict with a\n> statement made in later versions of the locking protocol.\n>\n>    You're doing what Greg (justly) accused you of and leaving things to be\n>    inferred, or out of the spec entirely.  If DeltaV says nothing, then\n>    implementors and servers that do locking and deltaV will be\n> left without\n>    guidance, on an issue over which the experts (heh) have argued.  Their\n>    implementations will differ.\n>\n> If an implementor wants to find out about locking, they should go to\n> the (current version of) the locking protocol.  We don't want to rev\n> the versioning protocol every time the locking protocol changes.  So\n> if there is some subtle locking/versioning interaction, then I agree\n> that should be identified in the versioning protocol (in particular,\n> the interaction between lock null resources and versioned collections\n> is such a case, and therefore is identified).\n>\n> So let's get some feedback from the working group:\n> Who thinks that the ability to apply MKWORKSPACE or MKACTIVITY\n> is a versioning/locking interaction that merits explicit\n> mention in the versioning protocol?  (I think we can take it\n> as given that Lisa thinks \"yes\" and I think \"no\").\n>\n> As with the DAV:resourcetype thread, I've made all the points\n> I wanted to make, so I'll leave it up to working group consensus.\n>\n> Cheers,\n> Geoff\n>\n>\n\n\n\n", "id": "lists-006-1183082"}, {"subject": "RE: Use of attribute", "content": "Shouldn't that be the <D:prop> element -- already used in PROPFIND response\nand PROPPATCH request bodies -- rather than the <D:name> element?\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Thursday, August 09, 2001 1:50 PM\n> To: DeltaV\n> Subject: RE: Use of attributes\n>\n>\n>\n>    From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n>\n>    > From: Clemm, Geoff\n>    >\n>    > Probably, the best way to go is to replace the old syntax, i.e.:\n>    >\n>    >   <D:supported-live-property-set>\n>    >     <D:supported-live-property>\n>    >       <D:name> <D:getcontentlanguage/> </D:name>\n>    >     </D:supported-live-property>\n>    >     <D:supported-live-property>\n>    >       <D:name> <X:quota/> </D:name>\n>    >   </supported-live-property-set>\n>\n>    Why do we need <D:name>? Wouldn't\n>\n>    <D:supported-live-property-set>\n> <D:supported-live-property>\n>    <D:getcontentlanguage/>\n> </D:supported-live-property>\n> <D:supported-live-property>\n>    <X:quota/>\n> </D:supported-live-property>\n>    </D:supported-live-property-set>\n>\n> This would make it unsafe to define extensions to the\n> D:supported-live-property content, because you would risk\n> colliding with the name of a live property.  The D:name\n> intermediate node ensures that there is no such collision.\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-11837209"}, {"subject": "Behavior of PUT on unlocked resource with invalid IF header ..", "content": "If we reject it, then a client could detect that their previously active\nlock had expired.\n\nSo ... I'm wondering if the spec should require the rejection.  I'm also\nwondering if my implementation should reject it even in the spec is\nsilent.\n\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Jim Amsden\nSent: Sunday, August 12, 2001 5:24 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Comments regarding locking & auto-checkin...\n\n\nJohn asks:\nIs a PUT supposed to be rejected if the IF header provided specifies an\ninvalid lock token and the resource is not locked?\n\nThe if header would likely be ignored since the resource isn't locked\nand there's no token to check. But servers could implement this as a\nfailed If header since it doesn't match the resource. Looks like a\nclarification might be needed in the spec.\n\n\n\n", "id": "lists-006-11846777"}, {"subject": "RE: Checked out vs checked-i", "content": "I agree with all of your interpretations of the protocol.\n\nThe term \"checked-out\" refers to the state of a resource,\nnamely, whether or not the resource has a DAV:checked-out property.\nI do not believe that this is ambiguous.  I do believe that \nsomeone coming to the draft with a different definition of\n\"checked-out\" than we use might need to be more careful when\nthey read the document, but that will be true of any terminology\nwe pick (short of making up new terms for everything).\n\nYou cannot use \"has a checked-out or a checked-in property\" to\ndetermine whether or not a resource is under version control,\nbecause a working resource has a checked-out property but is\nnot a version-controlled resource.  \n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Tuesday, August 14, 2001 1:43 PM\nTo: DeltaV\nSubject: Checked out vs checked-in\n\n\n\nI was answering some questions about the checked-in and checked-out\nproperties, and how they can exist, or not...  It required careful rereading\nof several related but distant sections of the draft.  I believe I corrected\nsome of my own misapprehensions and those of the person asking questions\nabout DeltaV.  I ended up figuring that examples were the best way to\nillustrate my understanding of these properties.\n\nCase 1: neither property exists\n\nThis case is definitely possible when the resource isn't under version\ncontrol.  However, is it possible to see this state when the resource is\nunder version control?  I think not.  Is this a good way for clients to see\nif a resource is under version control?  Is it preferable to use\nsupported-method-set or this?  It's an important question, because it may\nmean that supported-method-set is not a required property for simple\ndocument versioning (DeltaV subset).\n\nCase 2: checked-in exists\nEg:\n<D:checked-in><D:href>http://server.com/_foo.doc_v8</D:href></D:checked-in>\n\nHere, the VCR is reflecting the content and dead properties of a version in\nits version history.  It is checked in, and it is not checked out in-place.\nThere may however exist working resources that are the result of checking\nout past versions of this resource.  E.g. if version _foo.doc_v5 is checked\nout to a working resource, this fact wouldn't be reflected in the checked-in\nor checked-out properties.  We've reviewed this behaviour in previous email\nconversations, where we discussed how a client could find out if any check\nouts existed -- they must look for the checkout-set property on all versions\nin the version history, as well as the checked-out property on the VCR.\n\nCase 3: checked-out exists\nEg:\n<D:checked-out><D:href>http://server.com/_foo.doc_v8</D:href></D:checked-out\n>\n\nNow the VCR is checked-out, and the value of the property indicates what\nversion was checked out.  Further, this indicates that the resource is\nchecked out in-place.  That's because if there was a checkout to a working\nresource, that would be indicated in properties on the version resource, not\nproperties on the VCR.  There may also exist working resources that are the\nresult of checking out previous versions, in addition to the in-place\ncheckout.\n\nCase 4: checked-out and checked-in both exist -- Impossible\n\nThis case should be impossible because of the text in the draft, section\n1.3: \"A resource under version control is either in a \"checked-in\" or\n\"checked-out\" state, and the version control constraints apply only while\nthe resource is in the checked-in state.\"\n\nThis text, however, is very misleading.  I think the misdirection comes from\nthe fact that the phrase \"check out\" is used both for in-place checkouts and\nfor working resources.  It would be more accurate to say:\n\n\"A resource under version control is either in a checked-in state or in a\nchecked-out in-place state.  It may also have any number of working\nresources resulting from \"checking out\" older versions to working resources,\nregardless of whether it is in the checked-in state or in the checked-out\nin-place state\".\n\nAnother broader fix to the document would be to reserve the words \"check\nout\" and \"checked-out\" to the in-place checkout.  Creation of a working\nresource could be indicated by different language that does not conflict.\n\nPlease confirm my understanding of this and clarify the draft.\n\nLisa\n\n\n\n", "id": "lists-006-11855218"}, {"subject": "RE: Use of attribute", "content": "I don't really care very much, but D:prop takes a list of children,\nwhile D:name only takes one. Also D:name is used in both supported\nproperties and supported reports, while D:prop is only used for\nlists of properties.\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Tuesday, August 14, 2001 1:53 PM\nTo: Clemm, Geoff; DeltaV\nSubject: RE: Use of attributes\n\n\nShouldn't that be the <D:prop> element -- already used in PROPFIND response\nand PROPPATCH request bodies -- rather than the <D:name> element?\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Thursday, August 09, 2001 1:50 PM\n> To: DeltaV\n> Subject: RE: Use of attributes\n>\n>\n>\n>    From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n>\n>    > From: Clemm, Geoff\n>    >\n>    > Probably, the best way to go is to replace the old syntax, i.e.:\n>    >\n>    >   <D:supported-live-property-set>\n>    >     <D:supported-live-property>\n>    >       <D:name> <D:getcontentlanguage/> </D:name>\n>    >     </D:supported-live-property>\n>    >     <D:supported-live-property>\n>    >       <D:name> <X:quota/> </D:name>\n>    >   </supported-live-property-set>\n>\n>    Why do we need <D:name>? Wouldn't\n>\n>    <D:supported-live-property-set>\n> <D:supported-live-property>\n>    <D:getcontentlanguage/>\n> </D:supported-live-property>\n> <D:supported-live-property>\n>    <X:quota/>\n> </D:supported-live-property>\n>    </D:supported-live-property-set>\n>\n> This would make it unsafe to define extensions to the\n> D:supported-live-property content, because you would risk\n> colliding with the name of a live property.  The D:name\n> intermediate node ensures that there is no such collision.\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-11866775"}, {"subject": "RE: Allow: header and supported method", "content": "From a server point of view, you're correct -- it's impossible to be right\nall the time.  So it's tempting to say \"forget it\", if it's not correct why\nbother.\n\nHowever, from a client point of view, this information is helpful even if\nit's only right 85% of the time or more.  It makes for a vastly more usable\nGUI if this kind of information is available. The reason is that GUI clients\ntypically have buttons and menu choices for things like \"checkout\", \"check\nin\", \"view version history\".  Both buttons and menu items can and should be\ngreyed out if the action they do is unavailable currently.  Alternatively,\nthe state of the resource can be displayed in a directory listing, where\nsuch information helps the client decide what to do with the resource.\n\nFor state changes in particular, I'll point you to a GUI I've been working\non for a couple years:  the www.sharemation.com user interface.  It displays\na lock image that is red if the lock is taken by somebody else, green if the\nlock is taken by you, and grey if it's not locked.  Although this\ninformation may be out of date the instant the client sees it, it is\n_probably_ still good.  And it's made locking much easier to use: I won't\neven try to edit a file that I can immediately see is locked by somebody\nelse.\n\nYou can see a subtler instance of this effect in Windows Explorer, even with\nWeb Folders viewing DAV repositories: in the detailed view of files, you see\nthe size and the last-modified information about a file.  Wouldn't you think\nit's useless to display this since at any time it might change?  Obviously\nnot.\n\nFor a third example from a versioning product: take WinCVS.  It shows\nbuttons in the toolbar for you to add a new file to version control.  But\nthis button is greyed out unless the focus of the user (the selected file)\nis on a new file.  Should WinCVS not even attempt to grey out the button?\nAfter all, WinCVS could show the button as active, thus leading the user to\nbelieve they can add the file, but when they try it they find there is a\nconflicting file already added by another user and they're forbidden to take\nthat action.  I find the way it works to be sufficient since the likelihood\nof a problem is low. Here is a case where the greyed-out button is usually\ncorrect, and that's enough for most users most of the time.\n\nNow, you could argue that this whole attempt at providing information on\nwhat a user can do is misguided and we should all be using command-line\ninterfaces anyway.  ;)  But those who want to provide this information have\na valid need.\n\nLisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Ben Evans\n> Sent: Tuesday, August 14, 2001 4:46 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: Allow: header and supported methods\n>\n>\n>\n> Please excuse a newbie question:\n>\n> Surely for a server looking after versioned resources, asking it\n> \"What If?\" questions based on its current state is a bit useless?\n>\n> I mean, if I have a checked-out resource, and I don't have an\n> exclusive write-lock on the resource, then requests to the server\n> such as \"If I try and commit, will I be able to?\" can only\n> be usefully answered by the server with: \"I don't know, unless\n> you try.\"\n>\n> Is there a more subtle issue I'm missing?\n>\n> Ben\n>\n> On Tue, Aug 14, 2001 at 09:53:36AM +0100, Tim Ellison wrote:\n> > During the working group meeting we agreed to note this issue\n> on the list:\n> >\n> > What does the (HTTP/1.1 defined) Allow: header mean? and should\n> it be the\n> > same as the (DeltaV defined) DAV:supported-method-set property?\n> >\n> > The meeting attendees agreed that \"allowed\" and \"supported\"\n> should mean the\n> > same thing, and concensus was that both should report methods that will\n> > succeed for some state of the resource, not necessarily the\n> current state.\n> >\n> > For example, a version-controlled resource can be checked-out\n> or checked-in\n> > and therefore only one of CHECKOUT or CHECKIN will succeed for a given\n> > state of a version-controlled resource.  It is proposed that, for\n> > version-controlled resources, \"Allow:\" and \"DAV:supported-method-set\"\n> > include both CHECKIN and CHECKOUT (amongst others).\n> >\n> > Send any objections to the list.\n> >\n> > Regards,\n> > Tim\n> >\n\n\n\n", "id": "lists-006-11876523"}, {"subject": "RE: Allow: header and supported method", "content": "One problem with Lisa's summary below is when the UI shows an operation as \nunavailable when it actually is. For example, the UI might show a resource \nas locked by someone else (red in Lisa's tool), but the lock may have \ntimed our, or the user may have released the lock. In this case, the UI is \npreventing the user from doing something that is actually possible. The \ncorrect solution to this problem is distributed event notification which \nis something we should consider adding to WebDAV at some point. You may \neven see proprietary versions of this capability in some vendor servers. \nIn the meantime, your client UI should have a very prominent \"Refresh\" \nbutton, and users should make good use of it to be sure the UI is as \nup-to-date as possible.\n\nAnyone interested in a new WebDAV working group to add event notification? \nWe could call it DAVE.\n\n\n\n\n\n\n\"Lisa Dusseault\" <lisa@xythos.com>\nSent by: ietf-dav-versioning-request@w3.org\n08/14/2001 07:14 PM\n\n \n        To:     \"Ben Evans\" <ben.evans@parasolsolutions.com>, <ietf-dav-versioning@w3.org>\n        cc: \n        Subject:        RE: Allow: header and supported methods\n\n \n\nFrom a server point of view, you're correct -- it's impossible to be right\nall the time.  So it's tempting to say \"forget it\", if it's not correct \nwhy\nbother.\n\nHowever, from a client point of view, this information is helpful even if\nit's only right 85% of the time or more.  It makes for a vastly more \nusable\nGUI if this kind of information is available. The reason is that GUI \nclients\ntypically have buttons and menu choices for things like \"checkout\", \"check\nin\", \"view version history\".  Both buttons and menu items can and should \nbe\ngreyed out if the action they do is unavailable currently.  Alternatively,\nthe state of the resource can be displayed in a directory listing, where\nsuch information helps the client decide what to do with the resource.\n\nFor state changes in particular, I'll point you to a GUI I've been working\non for a couple years:  the www.sharemation.com user interface.  It \ndisplays\na lock image that is red if the lock is taken by somebody else, green if \nthe\nlock is taken by you, and grey if it's not locked.  Although this\ninformation may be out of date the instant the client sees it, it is\n_probably_ still good.  And it's made locking much easier to use: I won't\neven try to edit a file that I can immediately see is locked by somebody\nelse.\n\nYou can see a subtler instance of this effect in Windows Explorer, even \nwith\nWeb Folders viewing DAV repositories: in the detailed view of files, you \nsee\nthe size and the last-modified information about a file.  Wouldn't you \nthink\nit's useless to display this since at any time it might change?  Obviously\nnot.\n\nFor a third example from a versioning product: take WinCVS.  It shows\nbuttons in the toolbar for you to add a new file to version control.  But\nthis button is greyed out unless the focus of the user (the selected file)\nis on a new file.  Should WinCVS not even attempt to grey out the button?\nAfter all, WinCVS could show the button as active, thus leading the user \nto\nbelieve they can add the file, but when they try it they find there is a\nconflicting file already added by another user and they're forbidden to \ntake\nthat action.  I find the way it works to be sufficient since the \nlikelihood\nof a problem is low. Here is a case where the greyed-out button is usually\ncorrect, and that's enough for most users most of the time.\n\nNow, you could argue that this whole attempt at providing information on\nwhat a user can do is misguided and we should all be using command-line\ninterfaces anyway.  ;)  But those who want to provide this information \nhave\na valid need.\n\nLisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Ben Evans\n> Sent: Tuesday, August 14, 2001 4:46 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: Allow: header and supported methods\n>\n>\n>\n> Please excuse a newbie question:\n>\n> Surely for a server looking after versioned resources, asking it\n> \"What If?\" questions based on its current state is a bit useless?\n>\n> I mean, if I have a checked-out resource, and I don't have an\n> exclusive write-lock on the resource, then requests to the server\n> such as \"If I try and commit, will I be able to?\" can only\n> be usefully answered by the server with: \"I don't know, unless\n> you try.\"\n>\n> Is there a more subtle issue I'm missing?\n>\n> Ben\n>\n> On Tue, Aug 14, 2001 at 09:53:36AM +0100, Tim Ellison wrote:\n> > During the working group meeting we agreed to note this issue\n> on the list:\n> >\n> > What does the (HTTP/1.1 defined) Allow: header mean? and should\n> it be the\n> > same as the (DeltaV defined) DAV:supported-method-set property?\n> >\n> > The meeting attendees agreed that \"allowed\" and \"supported\"\n> should mean the\n> > same thing, and concensus was that both should report methods that \nwill\n> > succeed for some state of the resource, not necessarily the\n> current state.\n> >\n> > For example, a version-controlled resource can be checked-out\n> or checked-in\n> > and therefore only one of CHECKOUT or CHECKIN will succeed for a given\n> > state of a version-controlled resource.  It is proposed that, for\n> > version-controlled resources, \"Allow:\" and \"DAV:supported-method-set\"\n> > include both CHECKIN and CHECKOUT (amongst others).\n> >\n> > Send any objections to the list.\n> >\n> > Regards,\n> > Tim\n> >\n\n\n\n", "id": "lists-006-11889465"}, {"subject": "RE: Allow: header and supported method", "content": "I would like to resolve this issue for DeltaV as follows:\n\nThe DAV:supported-method values are not state based, and are explicitly\ndefined as such in the DeltaV protocol.\n\nThe semantics of the Allow header is unchanged from how it is defined\nin 2616 (so DeltaV doesn't say anything about it, one way or the other).\nThen if at some point there is consensus that Allow should be state\nbased, this change can be made independent of the DeltaV specification.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Amsden [mailto:jamsden@us.ibm.com]\nSent: Tuesday, August 14, 2001 7:42 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Allow: header and supported methods\n\n\nOne problem with Lisa's summary below is when the UI shows an operation as \nunavailable when it actually is. For example, the UI might show a resource \nas locked by someone else (red in Lisa's tool), but the lock may have \ntimed our, or the user may have released the lock. In this case, the UI is \npreventing the user from doing something that is actually possible. The \ncorrect solution to this problem is distributed event notification which \nis something we should consider adding to WebDAV at some point. You may \neven see proprietary versions of this capability in some vendor servers. \nIn the meantime, your client UI should have a very prominent \"Refresh\" \nbutton, and users should make good use of it to be sure the UI is as \nup-to-date as possible.\n\nAnyone interested in a new WebDAV working group to add event notification? \nWe could call it DAVE.\n\n\n\n\n\n\n\"Lisa Dusseault\" <lisa@xythos.com>\nSent by: ietf-dav-versioning-request@w3.org\n08/14/2001 07:14 PM\n\n \n        To:     \"Ben Evans\" <ben.evans@parasolsolutions.com>,\n<ietf-dav-versioning@w3.org>\n        cc: \n        Subject:        RE: Allow: header and supported methods\n\n \n\nFrom a server point of view, you're correct -- it's impossible to be right\nall the time.  So it's tempting to say \"forget it\", if it's not correct \nwhy\nbother.\n\nHowever, from a client point of view, this information is helpful even if\nit's only right 85% of the time or more.  It makes for a vastly more \nusable\nGUI if this kind of information is available. The reason is that GUI \nclients\ntypically have buttons and menu choices for things like \"checkout\", \"check\nin\", \"view version history\".  Both buttons and menu items can and should \nbe\ngreyed out if the action they do is unavailable currently.  Alternatively,\nthe state of the resource can be displayed in a directory listing, where\nsuch information helps the client decide what to do with the resource.\n\nFor state changes in particular, I'll point you to a GUI I've been working\non for a couple years:  the www.sharemation.com user interface.  It \ndisplays\na lock image that is red if the lock is taken by somebody else, green if \nthe\nlock is taken by you, and grey if it's not locked.  Although this\ninformation may be out of date the instant the client sees it, it is\n_probably_ still good.  And it's made locking much easier to use: I won't\neven try to edit a file that I can immediately see is locked by somebody\nelse.\n\nYou can see a subtler instance of this effect in Windows Explorer, even \nwith\nWeb Folders viewing DAV repositories: in the detailed view of files, you \nsee\nthe size and the last-modified information about a file.  Wouldn't you \nthink\nit's useless to display this since at any time it might change?  Obviously\nnot.\n\nFor a third example from a versioning product: take WinCVS.  It shows\nbuttons in the toolbar for you to add a new file to version control.  But\nthis button is greyed out unless the focus of the user (the selected file)\nis on a new file.  Should WinCVS not even attempt to grey out the button?\nAfter all, WinCVS could show the button as active, thus leading the user \nto\nbelieve they can add the file, but when they try it they find there is a\nconflicting file already added by another user and they're forbidden to \ntake\nthat action.  I find the way it works to be sufficient since the \nlikelihood\nof a problem is low. Here is a case where the greyed-out button is usually\ncorrect, and that's enough for most users most of the time.\n\nNow, you could argue that this whole attempt at providing information on\nwhat a user can do is misguided and we should all be using command-line\ninterfaces anyway.  ;)  But those who want to provide this information \nhave\na valid need.\n\nLisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Ben Evans\n> Sent: Tuesday, August 14, 2001 4:46 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: Allow: header and supported methods\n>\n>\n>\n> Please excuse a newbie question:\n>\n> Surely for a server looking after versioned resources, asking it\n> \"What If?\" questions based on its current state is a bit useless?\n>\n> I mean, if I have a checked-out resource, and I don't have an\n> exclusive write-lock on the resource, then requests to the server\n> such as \"If I try and commit, will I be able to?\" can only\n> be usefully answered by the server with: \"I don't know, unless\n> you try.\"\n>\n> Is there a more subtle issue I'm missing?\n>\n> Ben\n>\n> On Tue, Aug 14, 2001 at 09:53:36AM +0100, Tim Ellison wrote:\n> > During the working group meeting we agreed to note this issue\n> on the list:\n> >\n> > What does the (HTTP/1.1 defined) Allow: header mean? and should\n> it be the\n> > same as the (DeltaV defined) DAV:supported-method-set property?\n> >\n> > The meeting attendees agreed that \"allowed\" and \"supported\"\n> should mean the\n> > same thing, and concensus was that both should report methods that \nwill\n> > succeed for some state of the resource, not necessarily the\n> current state.\n> >\n> > For example, a version-controlled resource can be checked-out\n> or checked-in\n> > and therefore only one of CHECKOUT or CHECKIN will succeed for a given\n> > state of a version-controlled resource.  It is proposed that, for\n> > version-controlled resources, \"Allow:\" and \"DAV:supported-method-set\"\n> > include both CHECKIN and CHECKOUT (amongst others).\n> >\n> > Send any objections to the list.\n> >\n> > Regards,\n> > Tim\n> >\n\n\n\n", "id": "lists-006-11904751"}, {"subject": "RE: New name for variant of DAV:auto-versio", "content": "DAV:locked-checkout does not automatically follow the update\nmethod with a checkin.\n\nYou probably are thinking of the \"checkin on when the lock is\nremoved\" behavior, which is true for all write-locked auto-checked-out\nresources, not just ones resulting from DAV:locked-checkout.\nSince this behavior always applies, it does not\nneed to be specified in the individual auto-version values.\nIn fact, it would be misleading to specify it in just one of\nthe values, since that might mislead people into thinking it\nonly applies for that one value.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Wednesday, August 08, 2001 8:14 AM\nTo: DeltaV\nSubject: New name for variant of DAV:auto-version\n\n\n\nI was confused by the name \"locked-checkout\" in the values of\nauto-version -- it seemed to me that the server would never do an automatic\ncheckin if it had this value, but the text says it does.\n\nLet's sacrifice brevity for clarity, and call this value\n\"locked-checkout-unlocked-checkin\".\n\nlisa\n\n\n\n", "id": "lists-006-11920709"}, {"subject": "RE: Allow: header and supported method", "content": "We've run into a bunch of cases where people want distributed\nevent notification, and will probably be adding something proprietary\nin the next few years.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> Sent: Tuesday, August 14, 2001 4:42 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Allow: header and supported methods\n>\n>\n> One problem with Lisa's summary below is when the UI shows an\n> operation as\n> unavailable when it actually is. For example, the UI might show a\n> resource\n> as locked by someone else (red in Lisa's tool), but the lock may have\n> timed our, or the user may have released the lock. In this case,\n> the UI is\n> preventing the user from doing something that is actually possible. The\n> correct solution to this problem is distributed event notification which\n> is something we should consider adding to WebDAV at some point. You may\n> even see proprietary versions of this capability in some vendor servers.\n> In the meantime, your client UI should have a very prominent \"Refresh\"\n> button, and users should make good use of it to be sure the UI is as\n> up-to-date as possible.\n>\n> Anyone interested in a new WebDAV working group to add event\n> notification?\n> We could call it DAVE.\n>\n>\n>\n>\n>\n>\n> \"Lisa Dusseault\" <lisa@xythos.com>\n> Sent by: ietf-dav-versioning-request@w3.org\n> 08/14/2001 07:14 PM\n>\n>\n>         To:     \"Ben Evans\" <ben.evans@parasolsolutions.com>,\n> <ietf-dav-versioning@w3.org>\n>         cc:\n>         Subject:        RE: Allow: header and supported methods\n>\n>\n>\n> From a server point of view, you're correct -- it's impossible to be right\n> all the time.  So it's tempting to say \"forget it\", if it's not correct\n> why\n> bother.\n>\n> However, from a client point of view, this information is helpful even if\n> it's only right 85% of the time or more.  It makes for a vastly more\n> usable\n> GUI if this kind of information is available. The reason is that GUI\n> clients\n> typically have buttons and menu choices for things like \"checkout\", \"check\n> in\", \"view version history\".  Both buttons and menu items can and should\n> be\n> greyed out if the action they do is unavailable currently.  Alternatively,\n> the state of the resource can be displayed in a directory listing, where\n> such information helps the client decide what to do with the resource.\n>\n> For state changes in particular, I'll point you to a GUI I've been working\n> on for a couple years:  the www.sharemation.com user interface.  It\n> displays\n> a lock image that is red if the lock is taken by somebody else, green if\n> the\n> lock is taken by you, and grey if it's not locked.  Although this\n> information may be out of date the instant the client sees it, it is\n> _probably_ still good.  And it's made locking much easier to use: I won't\n> even try to edit a file that I can immediately see is locked by somebody\n> else.\n>\n> You can see a subtler instance of this effect in Windows Explorer, even\n> with\n> Web Folders viewing DAV repositories: in the detailed view of files, you\n> see\n> the size and the last-modified information about a file.  Wouldn't you\n> think\n> it's useless to display this since at any time it might change?  Obviously\n> not.\n>\n> For a third example from a versioning product: take WinCVS.  It shows\n> buttons in the toolbar for you to add a new file to version control.  But\n> this button is greyed out unless the focus of the user (the selected file)\n> is on a new file.  Should WinCVS not even attempt to grey out the button?\n> After all, WinCVS could show the button as active, thus leading the user\n> to\n> believe they can add the file, but when they try it they find there is a\n> conflicting file already added by another user and they're forbidden to\n> take\n> that action.  I find the way it works to be sufficient since the\n> likelihood\n> of a problem is low. Here is a case where the greyed-out button is usually\n> correct, and that's enough for most users most of the time.\n>\n> Now, you could argue that this whole attempt at providing information on\n> what a user can do is misguided and we should all be using command-line\n> interfaces anyway.  ;)  But those who want to provide this information\n> have\n> a valid need.\n>\n> Lisa\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Ben Evans\n> > Sent: Tuesday, August 14, 2001 4:46 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: Re: Allow: header and supported methods\n> >\n> >\n> >\n> > Please excuse a newbie question:\n> >\n> > Surely for a server looking after versioned resources, asking it\n> > \"What If?\" questions based on its current state is a bit useless?\n> >\n> > I mean, if I have a checked-out resource, and I don't have an\n> > exclusive write-lock on the resource, then requests to the server\n> > such as \"If I try and commit, will I be able to?\" can only\n> > be usefully answered by the server with: \"I don't know, unless\n> > you try.\"\n> >\n> > Is there a more subtle issue I'm missing?\n> >\n> > Ben\n> >\n> > On Tue, Aug 14, 2001 at 09:53:36AM +0100, Tim Ellison wrote:\n> > > During the working group meeting we agreed to note this issue\n> > on the list:\n> > >\n> > > What does the (HTTP/1.1 defined) Allow: header mean? and should\n> > it be the\n> > > same as the (DeltaV defined) DAV:supported-method-set property?\n> > >\n> > > The meeting attendees agreed that \"allowed\" and \"supported\"\n> > should mean the\n> > > same thing, and concensus was that both should report methods that\n> will\n> > > succeed for some state of the resource, not necessarily the\n> > current state.\n> > >\n> > > For example, a version-controlled resource can be checked-out\n> > or checked-in\n> > > and therefore only one of CHECKOUT or CHECKIN will succeed for a given\n> > > state of a version-controlled resource.  It is proposed that, for\n> > > version-controlled resources, \"Allow:\" and \"DAV:supported-method-set\"\n> > > include both CHECKIN and CHECKOUT (amongst others).\n> > >\n> > > Send any objections to the list.\n> > >\n> > > Regards,\n> > > Tim\n> > >\n>\n>\n>\n>\n>\n\n\n\n", "id": "lists-006-11929274"}, {"subject": "Versioning without versions", "content": "I joined the DeltaV mailing list only recently after the Interop event, however, I would like to\nmake some comments to the DAVE proposal.\n\n[Jim Amsden wrote]\n> The correct solution to this problem is distributed event notification which\n> is something we should consider adding to WebDAV at some point. You may\n> even see proprietary versions of this capability in some vendor servers.\n> In the meantime, your client UI should have a very prominent \"Refresh\"\n> button, and users should make good use of it to be sure the UI is as\n> up-to-date as possible.\n>\n> Anyone interested in a new WebDAV working group to add event notification?\n> We could call it DAVE.\n\nActually, event notification would open many new opportunities and it could possibly turn the\ncurrent philosophy of maintaining prohibitions (LOCK, CHECKOUT) into a new approach towards\nsupporting collaboration (event notification, awareness).\n\nAdditionally, this could be the right time to replace the current two-dimensional resource model\n(url + version) by a more natural three-dimensional model (url + principal + time). Please note that\nthe three-dimensional model would make locking, checking in/out as well as versions superfluous. It\nwould make multiple team members working on one source file the normal case as it is already today\nin software development projects where I am involved in. Obviously merging resources becomes more\nand more important in such a szenario. Maybe a specification could also provide some framework for\nthis activity?\n\nEckhard\n\n\n\n", "id": "lists-006-11946352"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, June 06, 2001 5:07 PM\n> To: DeltaV (E-mail)\n> Subject: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:bas eline resource type values\n>\n> Just as a reminder, DAV:version-controlled-resource, DAV:version,\n> DAV:working-resource, DAV:checked-in, and DAV:checked-out as a value\n> in DAV:resourcetype will make that resource appear to be a folder in\n> the (large number of) Microsoft WebDAV clients that are currently\n> deployed.  Now I know that Microsoft's misreading of the spec is\n> reprehensible to the extreme, but for those of us that have to deal\n> with that unfortunate reality, we may be forced for market reasons to\n> leave out those particular DAV:resourcetype values from our server\n> implementations until that bug has been fixed in a widely deployed\n> replacement for those buggy clients.\n>\n> Can anyone from Microsoft that is following this list give us a clue\n> as to whether this bug will be fixed anytime soon?\n\nGeoff,\n\ncould you expand a bit on what the bug is? Are they treating anything with a\nnon-empty resourcetype as collection?\n\n\n\n", "id": "lists-006-1195270"}, {"subject": "RE: Allow: header and supported method", "content": "I'd also be interested in working on this.  I've got a long history of\nfighting this battle -- NOTIFY, IMPP bofs, GENA involvement, proprietary\nimplemenations, etc.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Eric Sedlar\n> Sent: Wednesday, August 15, 2001 8:04 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Allow: header and supported methods\n>\n>\n> We've run into a bunch of cases where people want distributed\n> event notification, and will probably be adding something proprietary\n> in the next few years.\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> > Sent: Tuesday, August 14, 2001 4:42 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: RE: Allow: header and supported methods\n> >\n> >\n> > One problem with Lisa's summary below is when the UI shows an\n> > operation as\n> > unavailable when it actually is. For example, the UI might show a\n> > resource\n> > as locked by someone else (red in Lisa's tool), but the lock may have\n> > timed our, or the user may have released the lock. In this case,\n> > the UI is\n> > preventing the user from doing something that is actually possible. The\n> > correct solution to this problem is distributed event notification which\n> > is something we should consider adding to WebDAV at some point. You may\n> > even see proprietary versions of this capability in some vendor servers.\n> > In the meantime, your client UI should have a very prominent \"Refresh\"\n> > button, and users should make good use of it to be sure the UI is as\n> > up-to-date as possible.\n> >\n> > Anyone interested in a new WebDAV working group to add event\n> > notification?\n> > We could call it DAVE.\n> >\n> >\n> >\n> >\n> >\n> >\n> > \"Lisa Dusseault\" <lisa@xythos.com>\n> > Sent by: ietf-dav-versioning-request@w3.org\n> > 08/14/2001 07:14 PM\n> >\n> >\n> >         To:     \"Ben Evans\" <ben.evans@parasolsolutions.com>,\n> > <ietf-dav-versioning@w3.org>\n> >         cc:\n> >         Subject:        RE: Allow: header and supported methods\n> >\n> >\n> >\n> > From a server point of view, you're correct -- it's impossible\n> to be right\n> > all the time.  So it's tempting to say \"forget it\", if it's not correct\n> > why\n> > bother.\n> >\n> > However, from a client point of view, this information is\n> helpful even if\n> > it's only right 85% of the time or more.  It makes for a vastly more\n> > usable\n> > GUI if this kind of information is available. The reason is that GUI\n> > clients\n> > typically have buttons and menu choices for things like\n> \"checkout\", \"check\n> > in\", \"view version history\".  Both buttons and menu items can and should\n> > be\n> > greyed out if the action they do is unavailable currently.\n> Alternatively,\n> > the state of the resource can be displayed in a directory listing, where\n> > such information helps the client decide what to do with the resource.\n> >\n> > For state changes in particular, I'll point you to a GUI I've\n> been working\n> > on for a couple years:  the www.sharemation.com user interface.  It\n> > displays\n> > a lock image that is red if the lock is taken by somebody else, green if\n> > the\n> > lock is taken by you, and grey if it's not locked.  Although this\n> > information may be out of date the instant the client sees it, it is\n> > _probably_ still good.  And it's made locking much easier to\n> use: I won't\n> > even try to edit a file that I can immediately see is locked by somebody\n> > else.\n> >\n> > You can see a subtler instance of this effect in Windows Explorer, even\n> > with\n> > Web Folders viewing DAV repositories: in the detailed view of files, you\n> > see\n> > the size and the last-modified information about a file.  Wouldn't you\n> > think\n> > it's useless to display this since at any time it might change?\n>  Obviously\n> > not.\n> >\n> > For a third example from a versioning product: take WinCVS.  It shows\n> > buttons in the toolbar for you to add a new file to version\n> control.  But\n> > this button is greyed out unless the focus of the user (the\n> selected file)\n> > is on a new file.  Should WinCVS not even attempt to grey out\n> the button?\n> > After all, WinCVS could show the button as active, thus leading the user\n> > to\n> > believe they can add the file, but when they try it they find there is a\n> > conflicting file already added by another user and they're forbidden to\n> > take\n> > that action.  I find the way it works to be sufficient since the\n> > likelihood\n> > of a problem is low. Here is a case where the greyed-out button\n> is usually\n> > correct, and that's enough for most users most of the time.\n> >\n> > Now, you could argue that this whole attempt at providing information on\n> > what a user can do is misguided and we should all be using command-line\n> > interfaces anyway.  ;)  But those who want to provide this information\n> > have\n> > a valid need.\n> >\n> > Lisa\n> >\n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Ben Evans\n> > > Sent: Tuesday, August 14, 2001 4:46 AM\n> > > To: ietf-dav-versioning@w3.org\n> > > Subject: Re: Allow: header and supported methods\n> > >\n> > >\n> > >\n> > > Please excuse a newbie question:\n> > >\n> > > Surely for a server looking after versioned resources, asking it\n> > > \"What If?\" questions based on its current state is a bit useless?\n> > >\n> > > I mean, if I have a checked-out resource, and I don't have an\n> > > exclusive write-lock on the resource, then requests to the server\n> > > such as \"If I try and commit, will I be able to?\" can only\n> > > be usefully answered by the server with: \"I don't know, unless\n> > > you try.\"\n> > >\n> > > Is there a more subtle issue I'm missing?\n> > >\n> > > Ben\n> > >\n> > > On Tue, Aug 14, 2001 at 09:53:36AM +0100, Tim Ellison wrote:\n> > > > During the working group meeting we agreed to note this issue\n> > > on the list:\n> > > >\n> > > > What does the (HTTP/1.1 defined) Allow: header mean? and should\n> > > it be the\n> > > > same as the (DeltaV defined) DAV:supported-method-set property?\n> > > >\n> > > > The meeting attendees agreed that \"allowed\" and \"supported\"\n> > > should mean the\n> > > > same thing, and concensus was that both should report methods that\n> > will\n> > > > succeed for some state of the resource, not necessarily the\n> > > current state.\n> > > >\n> > > > For example, a version-controlled resource can be checked-out\n> > > or checked-in\n> > > > and therefore only one of CHECKOUT or CHECKIN will succeed\n> for a given\n> > > > state of a version-controlled resource.  It is proposed that, for\n> > > > version-controlled resources, \"Allow:\" and\n> \"DAV:supported-method-set\"\n> > > > include both CHECKIN and CHECKOUT (amongst others).\n> > > >\n> > > > Send any objections to the list.\n> > > >\n> > > > Regards,\n> > > > Tim\n> > > >\n> >\n> >\n> >\n> >\n> >\n\n\n\n", "id": "lists-006-11955220"}, {"subject": "Re: Allow: header and supported method", "content": "Lisa,\n\nIf I'm understanding you correctly, what you're talking about is the\nsame thing as what Adobe Acrobat 5 seems to do - it appears to send a\nlot of extra PROPFIND and GET requests to a DAV server to convince\nitself that the file it has is the same as the one on the server,\nbefore doing a PUT.\n\nSo what we're saying is that it can't be *certain* that it still has a\nlock, but the extra information is better than not having it.\n\nThe slight snag with this comes over low bandwidth links. The extra\nrequests (especially the GETs) can really add lag - especially if the\ntypical file for versioning is a 1M pdf file.\n\nPersonally, I'd like well-behaved (and especially potentially mobile)\nclients to have an advanced option to not try and keep the status\nupdated (and to be able to tell the server that it didn't want to\nreceive event notification, in a hypothetical event notification\nextension, and that it was happy with pot-luck on whether the ops it\nthinks it can do, it can actually do).\n\nBen\n\nOn Tue, Aug 14, 2001 at 04:14:43PM -0700, Lisa Dusseault wrote:\n> >From a server point of view, you're correct -- it's impossible to be right\n> all the time.  So it's tempting to say \"forget it\", if it's not correct why\n> bother.\n> \n> However, from a client point of view, this information is helpful even if\n> it's only right 85% of the time or more.  It makes for a vastly more usable\n> GUI if this kind of information is available. The reason is that GUI clients\n> typically have buttons and menu choices for things like \"checkout\", \"check\n> in\", \"view version history\".  Both buttons and menu items can and should be\n> greyed out if the action they do is unavailable currently.  Alternatively,\n> the state of the resource can be displayed in a directory listing, where\n> such information helps the client decide what to do with the resource.\n> \n> For state changes in particular, I'll point you to a GUI I've been working\n> on for a couple years:  the www.sharemation.com user interface.  It displays\n> a lock image that is red if the lock is taken by somebody else, green if the\n> lock is taken by you, and grey if it's not locked.  Although this\n> information may be out of date the instant the client sees it, it is\n> _probably_ still good.  And it's made locking much easier to use: I won't\n> even try to edit a file that I can immediately see is locked by somebody\n> else.\n> \n> You can see a subtler instance of this effect in Windows Explorer, even with\n> Web Folders viewing DAV repositories: in the detailed view of files, you see\n> the size and the last-modified information about a file.  Wouldn't you think\n> it's useless to display this since at any time it might change?  Obviously\n> not.\n> \n> For a third example from a versioning product: take WinCVS.  It shows\n> buttons in the toolbar for you to add a new file to version control.  But\n> this button is greyed out unless the focus of the user (the selected file)\n> is on a new file.  Should WinCVS not even attempt to grey out the button?\n> After all, WinCVS could show the button as active, thus leading the user to\n> believe they can add the file, but when they try it they find there is a\n> conflicting file already added by another user and they're forbidden to take\n> that action.  I find the way it works to be sufficient since the likelihood\n> of a problem is low. Here is a case where the greyed-out button is usually\n> correct, and that's enough for most users most of the time.\n> \n> Now, you could argue that this whole attempt at providing information on\n> what a user can do is misguided and we should all be using command-line\n> interfaces anyway.  ;)  But those who want to provide this information have\n> a valid need.\n> \n> Lisa\n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Ben Evans\n> > Sent: Tuesday, August 14, 2001 4:46 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: Re: Allow: header and supported methods\n> >\n> >\n> >\n> > Please excuse a newbie question:\n> >\n> > Surely for a server looking after versioned resources, asking it\n> > \"What If?\" questions based on its current state is a bit useless?\n> >\n> > I mean, if I have a checked-out resource, and I don't have an\n> > exclusive write-lock on the resource, then requests to the server\n> > such as \"If I try and commit, will I be able to?\" can only\n> > be usefully answered by the server with: \"I don't know, unless\n> > you try.\"\n> >\n> > Is there a more subtle issue I'm missing?\n> >\n> > Ben\n> >\n> > On Tue, Aug 14, 2001 at 09:53:36AM +0100, Tim Ellison wrote:\n> > > During the working group meeting we agreed to note this issue\n> > on the list:\n> > >\n> > > What does the (HTTP/1.1 defined) Allow: header mean? and should\n> > it be the\n> > > same as the (DeltaV defined) DAV:supported-method-set property?\n> > >\n> > > The meeting attendees agreed that \"allowed\" and \"supported\"\n> > should mean the\n> > > same thing, and concensus was that both should report methods that will\n> > > succeed for some state of the resource, not necessarily the\n> > current state.\n> > >\n> > > For example, a version-controlled resource can be checked-out\n> > or checked-in\n> > > and therefore only one of CHECKOUT or CHECKIN will succeed for a given\n> > > state of a version-controlled resource.  It is proposed that, for\n> > > version-controlled resources, \"Allow:\" and \"DAV:supported-method-set\"\n> > > include both CHECKIN and CHECKOUT (amongst others).\n> > >\n> > > Send any objections to the list.\n> > >\n> > > Regards,\n> > > Tim\n> > >\n> \n\n\n\n", "id": "lists-006-11974238"}, {"subject": "label encodin", "content": "I think the text that states label headers should be encoded in UTF-8\nshould be duplicated in or moved to the label feature section.  It is\ncurrently burried in Section 16.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-11988525"}, {"subject": "RE: Issues/questions regarding sections 3, 4 and 5..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   After reading through sections 3 & 4 & 5 (with a group of other\n   MERANT staff) here is a list of issues/questions (some of these\n   issues are editorial and simply need clarification in the spec,\n   others are real issues/questions).\n\nI agree with Tim's responses to the issues.  I'll limit my responses\nto the editorial comments he didn't cover.\n\n   In the specification some of the sections eg, 10.1,10.2 have no\n   white space after the section number, others (eg section 9.7,1.6 do\n   have a single space). Some sections, eg 13.10 are followed by\n   multiple whitespace characters.  I think this is caused by\n   conversion from Microsoft Word to ASCII.  We should correct this\n   before submitting the draft.\n\nYes, I will be doing this (I used to do this for the internet drafts,\nbut after around draft 6, decided it was not a productive use of my\ntime :-).\n\n   Section 4.4 starts to talk about the UNCHECKOUT on a Working\n   Resource.  I think this text would make more sense if it was in\n   \"Working Resource Feature\" section 8.\n\nDone.\n\n   Section 5.5 defines this mechanism where OPTIONS can be used to\n   find a possible location in the namespace that is to be used for\n   version histories.\n\n   I also think an example of the OPTIONS method being used for this\n   would be good as it is quite different from other uses of OPTIONS.\n\nDone.\n\n   Reading section 5.6 it took us quite a while to decide how to\n   delete the last version from a version history.  I think the answer\n   is \"you don't\" you must delete the version history itself in order\n   to delete the last version.  Did we interpret this correctly?  Do\n   you think we should clarify this in the spec?\n\nDone.\n\nThanks for the review!\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-11995582"}, {"subject": "RE: Issues/questions regarding sections 3, 4 and 5..", "content": "   From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n\n   > Section 5.4.1 since this report is on a collection I would\n   > like a Depth header defined.\n   > Again I think we should be consistent (to avoid speical-case\n   > coding). Any method that gets properties of a collection\n   > should take a Depth header.\n\n   All REPORTs may take a Depth: header (see versioning-16 Sec. 3.6)\n\nYes, but I think Peter's point was that the Depth header is\nmissing in the example.  It is in fact missing ... I've added\nit.  Thanks for noticing!\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12005108"}, {"subject": "RE: Diagram showing the effect of baseline-control..", "content": "Thanks, Peter!  I decided I liked version 2 better than version 1\n(I think it did a better job of displaying bi-directional relationships).\nI of course had to muck around with it at least a bit (:-), and here's\nwhat I ended up with:\n\n  +-------------------------------------+\n  |Baseline-Controlled Collection       |<------+\n  |/src                                 |       |\n  |-------------------------------------|       |\n  |DAV:version-controlled-configuration +---+   |\n  +-------------------------------------+   |   |\n                                            |   |\n                                            |   |\n  +-------------------------------------+   |   |\n  |Version-Controlled Configuration     |<--+   |\n  |/repo/vcc/128                        |       |\n  |-------------------------------------|       |\n  |DAV:baseline-controlled-collection   +-------+\n  |-------------------------------------|\n  |DAV:checked-in                       +-------+\n  +-------------------------------------+       |\n  |DAV:version-history                  +---+   |\n  +-------------------------------------+   |   |\n                                            |   |\n                                            |   |\n  +------------------------+                |   |\n  |Baseline History        |<---------------+   |\n  |/repo/blh/13            |                    |\n  |------------------------+                    |\n  |DAV:version-set         +----------------+   |\n  +------------------------+    |   |   |   |   |\n                                v   |   v   v   |\n                                    |           |\n  +------------------------+        |           |\n  |Baseline                |<-------+-----------+\n  |/repo/blh/13/ver/8      |\n  |------------------------+     +--------------+\n  |DAV:baseline-collection +---->|Collection    |\n  +------------------------+     |/repo/bc/15   |\n                                 +--------------+\n\nLet me know if this is OK.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Thursday, August 09, 2001 7:41 AM\nTo: gclemm@Rational.Com; jamsden@us.ibm.com; Tim_ellison@uk.ibm.com\nSubject: FW: Diagram showing the effect of baseline-control...\n\n\nJust incase the IETF mailing lists are still having trouble... \n-----Original Message----- \nFrom: Peter Raymond \nSent: 09 August 2001 12:33 \nTo: 'ietf-dav-versioning@w3.org' \nSubject: Diagram showing the effect of baseline-control... \n\n\nHi, \nDuring one of the IETF deltav breakout sessions I was \"challenged\" to try to\nfind a way to \ndraw ASCII art to show the resources and relationships involved in baseline\ncreation \n(and still have it fit in 72 columns).  The idea being we could include this\nin the specification \nto clarify the relationship between baseline-controlled collections,\nversion-controlled \nconfigurations, and baselines etc. \nHere are my two possible candidates (I think I prefer the first one): \n\n\n  +-------------+ \n  |Baseline-    |     DAV:version-controlled-configuration \n  |Controlled   |----------+ \n  |Collection   |          | \n  |             |          | \n  |/src/applet  |          | \n  +-------------+          | \n                           | \n                           | \n  +---------------+        | \n  |Version-       |--------+ \n  |Controlled     |     DAV:baseline-controlled-collection \n  |Configuration  | \n  |               | \n  |/vcc/src/1     |----+ DAV:checked-in \n  +---------------+    | \n                       | \n                       | \n                       | \n                       | \n                       |   +-----------+ \n                       +-->|Baseline   | DAV:baseline-collection \n                           |           |----+ \n                           |           |    | \n                       +-->|/blh/1/b1  |    | \n +---------+           |   +-----------+    | \n |Baseline |           |                    | \n |History  |-----------+                    |    +-----------------+ \n |         | DAV:root-version               |    |Collection       | \n |/blh/1   |                                |    |                 | \n +---------+                                +--->|/blh1/1/b1/bc    | \n                                                 +-----------------+ \nHere is my second attempt..... \n  +-------------------------------------+ \n  |Baseline-Controlled Collection       | \n  |                                     | \n  |/src/applet                          | \n  |-------------------------------------| \n  |DAV:version-controlled-configuration |-----+ \n  +-------------------------------------+     | \n                                              | \n                                              | \n  +-----------------------------------+       | \n  |Version-Controlled Configuration   |       | \n  |                                   |       | \n  |/vcc/src/1                         |       | \n  |-----------------------------------|       | \n  |DAV:baseline-controlled-collection |-------+ \n  |-----------------------------------| \n  |DAV:checked-in                     |----+ \n  +-----------------------------------+    | \n                                           | \n                                           | \n  +-----------------+                      | \n  |Baseline History |                      v \n  |                 |       +-----------------------+ \n  |/blh/1           |       |Baseline               | \n  |-----------------|       |                       | \n  |DAV:root-version |------>|/blh1/1/b1             | \n  +-----------------+       |-----------------------| \n                            |DAV:baseline-collection|------+ \n                            +-----------------------+      | \n                                                           v \n                                                     +--------------+ \n                                                     |Collection    | \n                                                     |              | \n                                                     |/blh1/1/b1/bc | \n                                                     +--------------+ \n\n\nFor either diagram I would suggest some surrounding text something like: \n\n\n\"This diagram shows the collection identified by /src/applet has been \nplaced under baseline control, creating a new version-controlled \nconfiguration (/vcc/src/1), new baseline history (/blh/1), new baseline \n(/blh/1/b1) and a new collection (/blh/1/b1/bc).  The new collection has \nmembers whose checked-in versions capture the state of the /src/applet \ncollection at the time the baseline-control method was processed. \nWhen /vcc/src/1 is checked-out and checked-in new baselines and \ncollections are created to take another snapshot of the checked-in state \nof the resources in /src/applet.\" \n\n\nDoes the group have any preference as to either of these, do you think it \nhelps clarify the baseline feature?  Did I get anything wrong? \nRegards, \n-- \nPeter Raymond - MERANT \nTechnical Architect (ADM) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n\n\n\n", "id": "lists-006-12013235"}, {"subject": "RE: List of areas in the specification where properties are empty /not  se", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   Section 3.9 in the additional postconditions (DAV:auto-checkout)\n   for PUT, the spec says \"the DAV:checked-in property MUST be\n   empty\". I propose it should instead read \"the DAV:checked-in\n   property MUST be removed\".\n\nDone.\n\n   Section 4.4 in the additional postconditions\n   (DAV:cancel-checked-out) for UNCHECKOUT, the spec says \"and the\n   DAV:checked-out property no longer is set\".  I propose it should\n   read \"and the DAV:checked-out property is removed\".\n\nDone.\n\n   Section 11.2 the description of the MERGE method says \"a\n   version-controlled resource with a non-empty DAV:merge-set\". I\n   propose it should read \"a version-controlled resource with a\n   DAV:merge-set property\".\n   Section 11.6 in the additional preconditions\n   (DAV:merge-must-be-complete) for CHECKIN, the spec says \"The\n   DAV:merge-set and DAV:auto-merge-set of the checked-out resource\n   MUST be empty\".  I propose it should read \"The checked-out resource\n   MUST not have the DAV:merge-set or DAV:auto-merge-set properties\".\n   Somewhere in the spec perhaps we should state that when a property\n   is removed from a resource it is no longer returned by PROPFIND or\n   in any <DAV:prop> response from any method.\n\nA client might resolve one merge at a time, which means it\nwill be successively PROPPATCH'ing shorter strings into the\nDAV:merge-set property.  I'd like to allow it to PROPPATCH\nthe empty string into the DAV:merge-set, and have it mean\nthe same thing as removing the DAV:merge-set.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12029861"}, {"subject": "RE: Comments regarding locking &amp; auto-checkin..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   Another issue which was raised at the London IETF was what would \n   happen if the CHECKIN failed perhaps because forking properties \n   would disallow it?\n\nThe protocol currently states that the CHECKIN is a postcondition\nof the UNLOCK, which means the UNLOCK MUST fail if the checkin\ncannot succeed.  I'll add a note to this section to indicate that\nthis applies both to an explicit UNLOCK as well as to an implicit\nunlock resulting from the lock timing out.\n\n   And also I raised a question asking if a more \n   explicit error code should be returned when an If header specifies \n   a lock which has timed-out rather than an invalid lock, I believe \n   that at the moment a client cannot tell the difference. \n\nI'll comment on this in a note to the WebDAV mailing list, since\nthis is a WebDAV question, rather than a DeltaV question.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12038863"}, {"subject": "RE: IETF-51 DeltaV WG meeting minute", "content": "   From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n\n   Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n   > I guess I am not sure when it's best to have empty properties, versus\n   > removing the property (pros and cons of both).? But one thing I do know\n   > is that it would be good if we were consistent in the spec.\n\n   I think it is sufficient for the spec to state what it means when the\n   property includes a given value, without having to distinguish between\n   missing and empty properties.  However, to make the document readable and\n   unambiguous I support the (purely editorial) change to refer to the\n   properties being removed.\n\nI agree.\n\n   > Can you remember if there was some reason why we said the property\n   > would be empty as opposed to being removed?\n\n   I don't think that there is any distinction to be made.\n\nI agree.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12047040"}, {"subject": "RE: label encodin", "content": "Done.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\nSent: Wednesday, August 15, 2001 12:31 PM\nTo: ietf-dav-versioning@w3.org\nSubject: label encoding\n\n\nI think the text that states label headers should be encoded in UTF-8\nshould be duplicated in or moved to the label feature section.  It is\ncurrently burried in Section 16.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12055268"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "Yes, that is what has been reported.\n\nAlthough if I am wrong about the lack of support for lock-null\nresources, maybe I'm wrong about this too ... I hope not!\n(I don't suppose two wrongs make a right in this case? :-)\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\nSent: Wednesday, June 06, 2001 5:57 PM\nTo: Clemm, Geoff; DeltaV (E-mail)\nSubject: RE: Removing the DAV:activity and DAV:version-history and\nDAV:bas eline resource type values\n\n\ncould you expand a bit on what the bug is? Are they treating anything with a\nnon-empty resourcetype as collection?\n\n\n\n", "id": "lists-006-1205663"}, {"subject": "RE: Allow: header and supported method", "content": "I agree with Geoff, but I don't think this covers Lisa's issues below.\nThese issues arrise not from examining supported properties, but by\nactually looking at their values.\n\n\n\n                                                                                                                        \n                    \"Clemm, Geoff\"                                                                                      \n                    <gclemm@rational.com>          To:     ietf-dav-versioning@w3.org                                   \n                    Sent by:                       cc:                                                                  \n                    ietf-dav-versioning-requ       Subject:     RE: Allow: header and supported methods                 \n                    est@w3.org                                                                                          \n                                                                                                                        \n                                                                                                                        \n                    08/14/2001 11:50 PM                                                                                 \n                                                                                                                        \n                                                                                                                        \n\n\n\nI would like to resolve this issue for DeltaV as follows:\n\nThe DAV:supported-method values are not state based, and are explicitly\ndefined as such in the DeltaV protocol.\n\nThe semantics of the Allow header is unchanged from how it is defined\nin 2616 (so DeltaV doesn't say anything about it, one way or the other).\nThen if at some point there is consensus that Allow should be state\nbased, this change can be made independent of the DeltaV specification.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Amsden [mailto:jamsden@us.ibm.com]\nSent: Tuesday, August 14, 2001 7:42 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Allow: header and supported methods\n\n\nOne problem with Lisa's summary below is when the UI shows an operation as\nunavailable when it actually is. For example, the UI might show a resource\nas locked by someone else (red in Lisa's tool), but the lock may have\ntimed our, or the user may have released the lock. In this case, the UI is\npreventing the user from doing something that is actually possible. The\ncorrect solution to this problem is distributed event notification which\nis something we should consider adding to WebDAV at some point. You may\neven see proprietary versions of this capability in some vendor servers.\nIn the meantime, your client UI should have a very prominent \"Refresh\"\nbutton, and users should make good use of it to be sure the UI is as\nup-to-date as possible.\n\nAnyone interested in a new WebDAV working group to add event notification?\nWe could call it DAVE.\n\n\n\n\n\n\n\"Lisa Dusseault\" <lisa@xythos.com>\nSent by: ietf-dav-versioning-request@w3.org\n08/14/2001 07:14 PM\n\n\n        To:     \"Ben Evans\" <ben.evans@parasolsolutions.com>,\n<ietf-dav-versioning@w3.org>\n        cc:\n        Subject:        RE: Allow: header and supported methods\n\n\n\nFrom a server point of view, you're correct -- it's impossible to be right\nall the time.  So it's tempting to say \"forget it\", if it's not correct\nwhy\nbother.\n\nHowever, from a client point of view, this information is helpful even if\nit's only right 85% of the time or more.  It makes for a vastly more\nusable\nGUI if this kind of information is available. The reason is that GUI\nclients\ntypically have buttons and menu choices for things like \"checkout\", \"check\nin\", \"view version history\".  Both buttons and menu items can and should\nbe\ngreyed out if the action they do is unavailable currently.  Alternatively,\nthe state of the resource can be displayed in a directory listing, where\nsuch information helps the client decide what to do with the resource.\n\nFor state changes in particular, I'll point you to a GUI I've been working\non for a couple years:  the www.sharemation.com user interface.  It\ndisplays\na lock image that is red if the lock is taken by somebody else, green if\nthe\nlock is taken by you, and grey if it's not locked.  Although this\ninformation may be out of date the instant the client sees it, it is\n_probably_ still good.  And it's made locking much easier to use: I won't\neven try to edit a file that I can immediately see is locked by somebody\nelse.\n\nYou can see a subtler instance of this effect in Windows Explorer, even\nwith\nWeb Folders viewing DAV repositories: in the detailed view of files, you\nsee\nthe size and the last-modified information about a file.  Wouldn't you\nthink\nit's useless to display this since at any time it might change?  Obviously\nnot.\n\nFor a third example from a versioning product: take WinCVS.  It shows\nbuttons in the toolbar for you to add a new file to version control.  But\nthis button is greyed out unless the focus of the user (the selected file)\nis on a new file.  Should WinCVS not even attempt to grey out the button?\nAfter all, WinCVS could show the button as active, thus leading the user\nto\nbelieve they can add the file, but when they try it they find there is a\nconflicting file already added by another user and they're forbidden to\ntake\nthat action.  I find the way it works to be sufficient since the\nlikelihood\nof a problem is low. Here is a case where the greyed-out button is usually\ncorrect, and that's enough for most users most of the time.\n\nNow, you could argue that this whole attempt at providing information on\nwhat a user can do is misguided and we should all be using command-line\ninterfaces anyway.  ;)  But those who want to provide this information\nhave\na valid need.\n\nLisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Ben Evans\n> Sent: Tuesday, August 14, 2001 4:46 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: Allow: header and supported methods\n>\n>\n>\n> Please excuse a newbie question:\n>\n> Surely for a server looking after versioned resources, asking it\n> \"What If?\" questions based on its current state is a bit useless?\n>\n> I mean, if I have a checked-out resource, and I don't have an\n> exclusive write-lock on the resource, then requests to the server\n> such as \"If I try and commit, will I be able to?\" can only\n> be usefully answered by the server with: \"I don't know, unless\n> you try.\"\n>\n> Is there a more subtle issue I'm missing?\n>\n> Ben\n>\n> On Tue, Aug 14, 2001 at 09:53:36AM +0100, Tim Ellison wrote:\n> > During the working group meeting we agreed to note this issue\n> on the list:\n> >\n> > What does the (HTTP/1.1 defined) Allow: header mean? and should\n> it be the\n> > same as the (DeltaV defined) DAV:supported-method-set property?\n> >\n> > The meeting attendees agreed that \"allowed\" and \"supported\"\n> should mean the\n> > same thing, and concensus was that both should report methods that\nwill\n> > succeed for some state of the resource, not necessarily the\n> current state.\n> >\n> > For example, a version-controlled resource can be checked-out\n> or checked-in\n> > and therefore only one of CHECKOUT or CHECKIN will succeed for a given\n> > state of a version-controlled resource.  It is proposed that, for\n> > version-controlled resources, \"Allow:\" and \"DAV:supported-method-set\"\n> > include both CHECKIN and CHECKOUT (amongst others).\n> >\n> > Send any objections to the list.\n> >\n> > Regards,\n> > Tim\n> >\n\n\n\n", "id": "lists-006-12062617"}, {"subject": "Making resources unversione", "content": "At the DeltaV meeting in London, we discussed how to make a resource\nunversioned.  We determined that the current method currently proposed in\nsection 2.2.1 of draft 16  (COPY the latest version of the resource to a new\nlocation, then DELETE the old versioned resource, then MOVE to rename the\nnew unversioned resource to the old name) is broken, for the following\nreasons:\n - It's not guaranteed to work, but not guaranteed to fail if it doesn't\nwork.\n   E.g. the server might automatically create a new versioned resource.  No\nway for the client to tell in advance.\n - Log files, permissions, etc. are lost in this series of moves\n - Permissions could prevent the completion of this sequence of events and\nleave the documents in a poor intermediate state.  With a single request, a\npermissions failure leaves the client in the same state as it was before it\nstarted.\n - basically, it's a side-effect, not a designed behaviour, and relies on\nseveral non-atomic operations working together\n\nWe discussed replacing that with the recommendation \"delete the VHR to\nremove a resource from version control\".  This has fewer problems because\nit's at least a single atomic request.  However it also has weaknesses, some\nof which I didn't remember quickly enough to bring up in the meeting:\n - it could break situations where more than one VCR points to the same VHR,\na scenario which has specifically been discussed as being permitted by\nDeltaV.  Would it make all those VCRs no longer versioned?\n - it requires clients and particularly servers to support an entire\noptional chapter of DeltaV, and a new resource type with all its live\nproperties, just to get the ability to remove a resource from version\ncontrol.\n - the spec would have to deal with the order of delete operations.  To\ndelete a resource and all its versions, must the client delete the VHR first\nthen the now-recently-unversioned resource?  Is deleting the VCR when the\nVHR still exists forbidden?\n\nA specific syntax for making something unversioned is still the cleanest way\nto go, because when you design a specific syntax for a specific job you're\nmore likely to be able to make it work.  But in the absence of that, the\ndraft should at least be brought up-to-date with the most current\nVHR-deleting recommendation.\n\nlisa\n\n\n\n", "id": "lists-006-12080988"}, {"subject": "RE: Making resources unversione", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   At the DeltaV meeting in London, we discussed how to make a\n   resource unversioned.  We determined that the current method\n   currently proposed in section 2.2.1 of draft 16 (COPY the latest\n   version of the resource to a new location, then DELETE the old\n   versioned resource, then MOVE to rename the new unversioned\n   resource to the old name) is broken\n\nThe conclusion reached at the DeltaV meeting was not that this method\nwas broken, but rather that although there would be some benefits to\nan explicit UNVERSION-CONTROL method (such as the ones Lisa identifies\nin her message), there was not sufficient support for this new method\nwithin the working group to add it to the protocol.  The\nUNVERSION-CONTROL method is just one of many possibly useful features\nthat did not receive sufficient support to be added at this point.\nWhen the DeltaV protocol goes from proposed standard to draft\nstandard, there will be an opportunity to pick up new features that\nhave proven to be needed, and drop features that have proven to not be\nneeded.  The recent consensus has been that the protocol is\nsufficiently complex that it is appropriate to defer any new feature\nthat does not conflict with existing semantics (i.e. a new feature that\ncan subsequently be added without conflicting with what is currently\ndefined in the protocol).\n\n   We discussed replacing that with the recommendation \"delete the VHR\n   to remove a resource from version control\".  However it\n   also has weaknesses, some of which I didn't remember quickly enough\n   to bring up in the meeting:\n\n   - it could break situations where more than one VCR points to the\n   same VHR, a scenario which has specifically been discussed as being\n   permitted by DeltaV.  Would it make all those VCRs no longer\n   versioned?\n\nYes, this problem was raised in followup discussions following the\nworking group meeting.  A server could reasonably refuse to allow the\ndeletion of a version history in this case, remove all of those VCR's\nfrom version control, or leave them all dangling.  Following those\ndiscussions, it was concluded that the \"delete version history\" was\nnot an appropriate way to remove a resource from version control, and\ntherefore the method that is described in the current protocol (COPY\nto temp, MOVE to original URL) is the best way to achieve this result\nin the current protocol.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12090273"}, {"subject": "Re: Diagram showing the effect of baseline-control..", "content": "Hi Geoff,\n\nYou changes to the diagram mainly look fine, the main difference is that your\ndiagram shows multiple baselines (eg versions in the version-set), mine was\ntrying\nto show the state after the initial BASELINE-CONTROL in which case there would\nonly\nbe the root-version and one version in the version-set.\n\nRegards,\nPeter Raymond - MERANT.\n\n\"Clemm, Geoff\" wrote:\n\n> Thanks, Peter!  I decided I liked version 2 better than version 1\n> (I think it did a better job of displaying bi-directional relationships).\n> I of course had to muck around with it at least a bit (:-), and here's\n> what I ended up with:\n>\n>   +-------------------------------------+\n>   |Baseline-Controlled Collection       |<------+\n>   |/src                                 |       |\n>   |-------------------------------------|       |\n>   |DAV:version-controlled-configuration +---+   |\n>   +-------------------------------------+   |   |\n>                                             |   |\n>                                             |   |\n>   +-------------------------------------+   |   |\n>   |Version-Controlled Configuration     |<--+   |\n>   |/repo/vcc/128                        |       |\n>   |-------------------------------------|       |\n>   |DAV:baseline-controlled-collection   +-------+\n>   |-------------------------------------|\n>   |DAV:checked-in                       +-------+\n>   +-------------------------------------+       |\n>   |DAV:version-history                  +---+   |\n>   +-------------------------------------+   |   |\n>                                             |   |\n>                                             |   |\n>   +------------------------+                |   |\n>   |Baseline History        |<---------------+   |\n>   |/repo/blh/13            |                    |\n>   |------------------------+                    |\n>   |DAV:version-set         +----------------+   |\n>   +------------------------+    |   |   |   |   |\n>                                 v   |   v   v   |\n>                                     |           |\n>   +------------------------+        |           |\n>   |Baseline                |<-------+-----------+\n>   |/repo/blh/13/ver/8      |\n>   |------------------------+     +--------------+\n>   |DAV:baseline-collection +---->|Collection    |\n>   +------------------------+     |/repo/bc/15   |\n>                                  +--------------+\n>\n> Let me know if this is OK.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n> Sent: Thursday, August 09, 2001 7:41 AM\n> To: gclemm@Rational.Com; jamsden@us.ibm.com; Tim_ellison@uk.ibm.com\n> Subject: FW: Diagram showing the effect of baseline-control...\n>\n> Just incase the IETF mailing lists are still having trouble...\n> -----Original Message-----\n> From: Peter Raymond\n> Sent: 09 August 2001 12:33\n> To: 'ietf-dav-versioning@w3.org'\n> Subject: Diagram showing the effect of baseline-control...\n>\n> Hi,\n> During one of the IETF deltav breakout sessions I was \"challenged\" to try to\n> find a way to\n> draw ASCII art to show the resources and relationships involved in baseline\n> creation\n> (and still have it fit in 72 columns).  The idea being we could include this\n> in the specification\n> to clarify the relationship between baseline-controlled collections,\n> version-controlled\n> configurations, and baselines etc.\n> Here are my two possible candidates (I think I prefer the first one):\n>\n>   +-------------+\n>   |Baseline-    |     DAV:version-controlled-configuration\n>   |Controlled   |----------+\n>   |Collection   |          |\n>   |             |          |\n>   |/src/applet  |          |\n>   +-------------+          |\n>                            |\n>                            |\n>   +---------------+        |\n>   |Version-       |--------+\n>   |Controlled     |     DAV:baseline-controlled-collection\n>   |Configuration  |\n>   |               |\n>   |/vcc/src/1     |----+ DAV:checked-in\n>   +---------------+    |\n>                        |\n>                        |\n>                        |\n>                        |\n>                        |   +-----------+\n>                        +-->|Baseline   | DAV:baseline-collection\n>                            |           |----+\n>                            |           |    |\n>                        +-->|/blh/1/b1  |    |\n>  +---------+           |   +-----------+    |\n>  |Baseline |           |                    |\n>  |History  |-----------+                    |    +-----------------+\n>  |         | DAV:root-version               |    |Collection       |\n>  |/blh/1   |                                |    |                 |\n>  +---------+                                +--->|/blh1/1/b1/bc    |\n>                                                  +-----------------+\n> Here is my second attempt.....\n>   +-------------------------------------+\n>   |Baseline-Controlled Collection       |\n>   |                                     |\n>   |/src/applet                          |\n>   |-------------------------------------|\n>   |DAV:version-controlled-configuration |-----+\n>   +-------------------------------------+     |\n>                                               |\n>                                               |\n>   +-----------------------------------+       |\n>   |Version-Controlled Configuration   |       |\n>   |                                   |       |\n>   |/vcc/src/1                         |       |\n>   |-----------------------------------|       |\n>   |DAV:baseline-controlled-collection |-------+\n>   |-----------------------------------|\n>   |DAV:checked-in                     |----+\n>   +-----------------------------------+    |\n>                                            |\n>                                            |\n>   +-----------------+                      |\n>   |Baseline History |                      v\n>   |                 |       +-----------------------+\n>   |/blh/1           |       |Baseline               |\n>   |-----------------|       |                       |\n>   |DAV:root-version |------>|/blh1/1/b1             |\n>   +-----------------+       |-----------------------|\n>                             |DAV:baseline-collection|------+\n>                             +-----------------------+      |\n>                                                            v\n>                                                      +--------------+\n>                                                      |Collection    |\n>                                                      |              |\n>                                                      |/blh1/1/b1/bc |\n>                                                      +--------------+\n>\n> For either diagram I would suggest some surrounding text something like:\n>\n> \"This diagram shows the collection identified by /src/applet has been\n> placed under baseline control, creating a new version-controlled\n> configuration (/vcc/src/1), new baseline history (/blh/1), new baseline\n> (/blh/1/b1) and a new collection (/blh/1/b1/bc).  The new collection has\n> members whose checked-in versions capture the state of the /src/applet\n> collection at the time the baseline-control method was processed.\n> When /vcc/src/1 is checked-out and checked-in new baselines and\n> collections are created to take another snapshot of the checked-in state\n> of the resources in /src/applet.\"\n>\n> Does the group have any preference as to either of these, do you think it\n> helps clarify the baseline feature?  Did I get anything wrong?\n> Regards,\n> --\n> Peter Raymond - MERANT\n> Technical Architect (ADM)\n> Tel: +44 (0)1727 813362\n> Fax: +44 (0)1727 869804\n> mailto:Peter.Raymond@merant.com\n> WWW: http://www.merant.com\n\n\n\n", "id": "lists-006-12100018"}, {"subject": "Versions being deleted during a MERGE..", "content": "Hi,\n\nI just noticed a potential problem with versions being used for a merge\noperation\nbeing deleted during the merge.\n\nSection 11 says a checked-out resource has a DAV:merge-set identifying\nversions\nto be merged.  DELETE (section 11.5) says it will remove entries from\nthe\nmerge-set.  Shouldn't the server disallow the DELETE, someone somewhere\nis in the\nmiddle of a merge using this version, also there would be a race\ncondition if someone\ndeletes the version while the client is processing the DAV:merge-set of\na checked-out\nresource.\n\nRegards,\nPeter Raymond - MERANT\n\n\n\n", "id": "lists-006-12116800"}, {"subject": "Why have separate DAV:checked-in and DAV:checked-out", "content": "Hi,\n\nI was thinking about the issue of properties being removed or empty\ndepending on the\nstate of the resource and the effect this has on PROPFIND and\nsupported-property-set\netc.  It struck me as odd that the protocol defines DAV:checked-in and\nDAV:checked-out\nas two separate properties, rather than having one property to identify\nthe version and\nanother to identify the state (eg is it checked-in or checked-out).\nI would have thought something like the following would be more logical,\nthis way the\nproperties are always present:\n\n3.2.1DAV:version (protected)\n\nThis property appears on a version-controlled resource, and identifies a\nversion that\nhas the same content and dead properties as the version-controlled\nresource.\n\n<!ELEMENT version (href)>\n\n\n3.2.2DAV:status (protected)\n\nThis property appears on a version-controlled resource, and identifies\nthe state of\nthat resource (checked-in or checked-out).  This property is changed\nwhen the resource\nis checked out or checked-in.\n\n<!ELEMENT status ANY>\nANY value: A single element which can be either a DAV:checked-in element\nor a\nDAV:checked-out element.\n\n<!ELEMENT checked-in EMPTY>\n<!ELEMENT checked-out EMPTY>\n\n\nIs there a good reason why the above is not desirable or why the current\nbehaviour\nis better?\n\nRegards,\nPeter Raymond - MERANT.\n\n\n\n", "id": "lists-006-12125096"}, {"subject": "Re: Allow: header and supported method", "content": "We'd have to introduce push technology into HTTP.\n\n\n\n\n\nPeter Raymond <Peter.Raymond@merant.com>\n08/19/2001 08:15 AM\n\n \n        To:     Jim Amsden <jamsden@us.ibm.com>\n        cc:     Eric.Sedlar@oracle.com\n        Subject:        Re: Allow: header and supported methods\n\n \n\nHi Jim,\n\nJim Amsden wrote:\n\n> Anyone interested in a new WebDAV working group to add event \nnotification?\n> We could call it DAVE.\n\nSounds like fun and certainly something I would be interested in.\n\nBut, how would we do that over HTTP? Since the protocol is \nrequest-response based the client\nwould\nhave to be polling at regular intervals asking if any events of interest \nhave occurred.\nWould this perform well?\n\nRegards,\nPeter Raymond - MERANT.\n\n\n\n", "id": "lists-006-12133589"}, {"subject": "RE: Versions being deleted during a MERGE..", "content": "A server is of course free to refuse the DELETE request,\nand indicate as its reason that it didn't want to satisfy\nthe postcondition that would remove that version URL from\nthe DAV:merge-set.\n\nNote thought that even if the server allows the deletion,\nthere is no race condition here, though,\njust some dangling version URL's that will return 404's\nwhen accessed.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Sunday, August 19, 2001 8:22 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Versions being deleted during a MERGE...\n\n\nHi,\n\nI just noticed a potential problem with versions being used for a merge\noperation\nbeing deleted during the merge.\n\nSection 11 says a checked-out resource has a DAV:merge-set identifying\nversions\nto be merged.  DELETE (section 11.5) says it will remove entries from\nthe\nmerge-set.  Shouldn't the server disallow the DELETE, someone somewhere\nis in the\nmiddle of a merge using this version, also there would be a race\ncondition if someone\ndeletes the version while the client is processing the DAV:merge-set of\na checked-out\nresource.\n\nRegards,\nPeter Raymond - MERANT\n\n\n\n", "id": "lists-006-12142544"}, {"subject": "MK* and lock-null (was: Re: Deleting versions", "content": "On Wed, Jun 06, 2001 at 12:47:45PM -0400, Clemm, Geoff wrote:\n>...\n> So let's get some feedback from the working group: \n> Who thinks that the ability to apply MKWORKSPACE or MKACTIVITY\n> is a versioning/locking interaction that merits explicit\n> mention in the versioning protocol?  (I think we can take it\n> as given that Lisa thinks \"yes\" and I think \"no\").\n\nI think that we should explicitly specify that (contrary to RFC 2518), a\nMKWORKSPACE or MKACTIVITY can be applied to a locknull resource.\n\nSince allowing them to apply is contrary to 2518, then we need to explicitly\nmention that fact. If we don't, then readers will assume that you cannot use\nthose methods on a lock-null.\n\nAnd yes: this should raise an issue for 2518 to loosen that language in\nsome way. (cc'ing Jim explicitly to ensure this is captured)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-1214918"}, {"subject": "RE: Why have separate DAV:checked-in and DAV:checked-out", "content": "The semantics of DAV:checked-in and DAV:checked-out are so\ndifferent, that it would be misleading to unify them into\na single property.  DAV:checked-in says \"this version is a\ncopy of the current state of this resource, and you can use\nthis version URL if you want to remember or pass around a\nreference to this current state.  The DAV:checked-out just\nsays \"here is a state that is arbitrarily different from the\ncurrent state of the resource, but does reflect the last\nstate of this resource prior to the current state that is\ncaptured in the version history.  So other than the fact\nthat they both contain version URL's, there is no semantic\nsimilarity between these two properties.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Sunday, August 19, 2001 8:23 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Why have separate DAV:checked-in and DAV:checked-out?\n\n\nHi,\n\nI was thinking about the issue of properties being removed or empty\ndepending on the\nstate of the resource and the effect this has on PROPFIND and\nsupported-property-set\netc.  It struck me as odd that the protocol defines DAV:checked-in and\nDAV:checked-out\nas two separate properties, rather than having one property to identify\nthe version and\nanother to identify the state (eg is it checked-in or checked-out).\nI would have thought something like the following would be more logical,\nthis way the\nproperties are always present:\n\n3.2.1DAV:version (protected)\n\nThis property appears on a version-controlled resource, and identifies a\nversion that\nhas the same content and dead properties as the version-controlled\nresource.\n\n<!ELEMENT version (href)>\n\n\n3.2.2DAV:status (protected)\n\nThis property appears on a version-controlled resource, and identifies\nthe state of\nthat resource (checked-in or checked-out).  This property is changed\nwhen the resource\nis checked out or checked-in.\n\n<!ELEMENT status ANY>\nANY value: A single element which can be either a DAV:checked-in element\nor a\nDAV:checked-out element.\n\n<!ELEMENT checked-in EMPTY>\n<!ELEMENT checked-out EMPTY>\n\n\nIs there a good reason why the above is not desirable or why the current\nbehaviour\nis better?\n\nRegards,\nPeter Raymond - MERANT.\n\n\n\n", "id": "lists-006-12151611"}, {"subject": "Re: Versions being deleted during a MERGE..", "content": "Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n> Hi,\n>\n> I just noticed a potential problem with versions being\n> used for a merge operation being deleted during the merge.\n>\n> Section 11 says a checked-out resource has a DAV:merge-set\n> identifying versions to be merged.  DELETE (section 11.5)\n> says it will remove entries from the merge-set.  Shouldn't\n> the server disallow the DELETE, someone somewhere is in\n> the middle of a merge using this version, also there would\n> be a race condition if someone deletes the version while\n> the client is processing the DAV:merge-set of a checked-out\n> resource.\n\nI think the spec is correct that the server should allow the DELETE.  We\ncan debate the 'work-flow' aspect of merging and may come to different\nconclusions, however, from a protocol point of view, I think a client\nshould be allowed to delete a version during someone else's (and especially\ntheir own) merge.  DELETE will not be the only potential point of conflict\nduring a merge since the merge request and the resolution of conflicts is\nnot atomic.  There can be no \"safe\" merge without locking down all the\naffected resources and their version histories.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12161726"}, {"subject": "Re: Why have separate DAV:checked-in and DAV:checked-out", "content": "Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n> Hi,\n>\n> I was thinking about the issue of properties being removed\n> or empty depending on the state of the resource and the\n> effect this has on PROPFIND and supported-property-set\n> etc.  It struck me as odd that the protocol defines\n> DAV:checked-in and DAV:checked-out as two separate\n> properties, rather than having one property to identify\n> the version and another to identify the state (eg is it\n> checked-in or checked-out). I would have thought something\n> like the following would be more logical, this way the\n> properties are always present:\n>\n> 3.2.1DAV:version (protected)\n>\n> This property appears on a version-controlled resource,\n> and identifies a version that has the same content and\n> dead properties as the version-controlled resource.\n>\n> <!ELEMENT version (href)>\n\nWell, it has the same content and dead properties as a checked-in\nversion-controlled resource, since when the version-controlled resource is\nchecked-out the content and dead proeprties can be modified.  So the\ndescription you gave would have to be conditional, or state that the\nchecked-out version-controlled resource was based on...\n\n> 3.2.2DAV:status (protected)\n>\n> This property appears on a version-controlled resource,\n> and identifies the state of that resource (checked-in\n> or checked-out).  This property is changed when the resource\n> is checked out or checked-in.\n>\n> <!ELEMENT status ANY>\n> ANY value: A single element which can be either a\n> DAV:checked-in element or a DAV:checked-out element.\n>\n> <!ELEMENT checked-in EMPTY>\n> <!ELEMENT checked-out EMPTY>\n\nThis would require retrieving the property and parsing it to determine the\nchecked-in status rather than using the PROPFIND propname construct -- a\nminor distinction I grant you.\n\n> Is there a good reason why the above is not desirable or\n> why the current behaviour is better?\n\nI'd be a bit concerned that the description for DAV:version would be\ncomplex since it's meaning would be dependent upon the value in DAV:status.\nI also thought that separate properties would allow an expand property\nreport to naturally terminate if the property is missing -- but have no use\ncase to back it up.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12170620"}, {"subject": "Re: Making resources unversione", "content": "Lisa,\n\nThere did not seem to be sufficient support from the working group to \nwarrant introducing an unversion method at this time. I can see you \nconcerns though, and suggest this would be an appropriate topic to bring \nup again when we move DeltaV from Proposed to Draft standard after there \nhas been more implement experience for both clients and servers. In the \nmeantime, see the additional comments below where I've attempted to \naddress some workarounds for your concerns based on the current protocol.\n\n\n\n\n\n\"Lisa Dusseault\" <lisa@xythos.com>\nSent by: ietf-dav-versioning-request@w3.org\n08/18/2001 01:27 AM\n\n \n        To:     \"DeltaV\" <ietf-dav-versioning@w3.org>\n        cc: \n        Subject:        Making resources unversioned\n\n \n\n\nAt the DeltaV meeting in London, we discussed how to make a resource\nunversioned.  We determined that the current method currently proposed in\nsection 2.2.1 of draft 16  (COPY the latest version of the resource to a \nnew\nlocation, then DELETE the old versioned resource, then MOVE to rename the\nnew unversioned resource to the old name) is broken, for the following\nreasons:\n - It's not guaranteed to work, but not guaranteed to fail if it doesn't\nwork.\n   E.g. the server might automatically create a new versioned resource. No\nway for the client to tell in advance.\n<jra>\nTrue, but it might not be as bad as it at first seams. If the copy fails, \nthen the system state isn't changed. Note that using a copy explicitly \nallows the user to select which version is to be the unversioned resource, \nnot just the latest version. \n\nIf the delete of the history resource fails, then the copy is still there \ncreating the new unversioned resource. The move to rename can still be \ndone since any VCR that has the same name can be deleted even if the \nhistory resource wasn't deleted.\n\nIf the server automatically creates a new versioned resource, then its a \nserver that does not support unversioned resources, or has been configured \nas such. This sounds like the correct behavior.\n\nSo the user gets what they wanted, and chances are if a delete of the \nhistory resource fails, so would an unversion which would have to at a \nminimum do the delete.\n</jra>\n\n - Log files, permissions, etc. are lost in this series of moves\n<jra>\nDon't know what log files you are referring to, but they would have to be \nserver or application dependent anyway. Your server would have to handle \nits own extensions, and clients can easily deal with the permissions given \nthe ACL spec.\n</jra>\n - Permissions could prevent the completion of this sequence of events and\nleave the documents in a poor intermediate state.  With a single request, \na\npermissions failure leaves the client in the same state as it was before \nit\nstarted.\n<jra>\nSame as the first issue with the same comments.\n</jra>\n - basically, it's a side-effect, not a designed behaviour, and relies on\nseveral non-atomic operations working together\n\nWe discussed replacing that with the recommendation \"delete the VHR to\nremove a resource from version control\".  This has fewer problems because\nit's at least a single atomic request.  However it also has weaknesses, \nsome\nof which I didn't remember quickly enough to bring up in the meeting:\n - it could break situations where more than one VCR points to the same \nVHR,\na scenario which has specifically been discussed as being permitted by\nDeltaV.  Would it make all those VCRs no longer versioned?\n - it requires clients and particularly servers to support an entire\noptional chapter of DeltaV, and a new resource type with all its live\nproperties, just to get the ability to remove a resource from version\ncontrol.\n<jra>\nIn reality, clients already have to support history resources in order to \nsupport DeltaV semantics. The only thing that's optional is to provide a \nserver generated URL for them, and expose their properties. This option \nwas included because of one vendor who did not want to have to generate \nthe URLs. However, all DeltaV servers have to support generated URLs at \nleast for versions, have to be able to support live and protected DeltaV \nproperties, and have to provide information on the history of versioned \nresources for the reports. So I don't think support for a history resource \nis adding much burden to a DeltaV server, and the notion of a history \nresource is so fundamental to versioning that I think it should be \nrequired.\n</jra>\n\n - the spec would have to deal with the order of delete operations.  To\ndelete a resource and all its versions, must the client delete the VHR \nfirst\nthen the now-recently-unversioned resource?  Is deleting the VCR when the\nVHR still exists forbidden?\n\nA specific syntax for making something unversioned is still the cleanest \nway\nto go, because when you design a specific syntax for a specific job you're\nmore likely to be able to make it work.  But in the absence of that, the\ndraft should at least be brought up-to-date with the most current\nVHR-deleting recommendation.\n<jra>\nThe delete semantics of history resources may not be something the \nprotocol should define. Servers implementations may make it impossible to \nremove all working resources and/or VCRs. Some may not be able to handle \ndangling references in VCRs. Some may choose to disallow the operation \naltogether. This looks like something that will require some \nimplementation experience. Since unversion would have to address the same \nissues, we probably should wait to get this implementation experience.\n</jra>\n\nlisa\n\n\n\n", "id": "lists-006-12180420"}, {"subject": "Re: Versions being deleted during a MERGE..", "content": "Peter,\nThe delete from the merge-set is deleting the version URL from the \nmerge-set, not deleting the version itself. This just indicates the user \nis done doing the merge from that entry.\n\n\n\n\n\nPeter Raymond <Peter.Raymond@merant.com>\nSent by: ietf-dav-versioning-request@w3.org\n08/19/2001 08:21 AM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        Versions being deleted during a MERGE...\n\n \n\nHi,\n\nI just noticed a potential problem with versions being used for a merge\noperation\nbeing deleted during the merge.\n\nSection 11 says a checked-out resource has a DAV:merge-set identifying\nversions\nto be merged.  DELETE (section 11.5) says it will remove entries from\nthe\nmerge-set.  Shouldn't the server disallow the DELETE, someone somewhere\nis in the\nmiddle of a merge using this version, also there would be a race\ncondition if someone\ndeletes the version while the client is processing the DAV:merge-set of\na checked-out\nresource.\n\nRegards,\nPeter Raymond - MERANT\n\n\n\n", "id": "lists-006-12193623"}, {"subject": "Re: Versions being deleted during a MERGE..", "content": "Hi,\n\nJim Amsden wrote:\n\n> The delete from the merge-set is deleting the version URL from the\n> merge-set, not deleting the version itself. This just indicates the user\n> is done doing the merge from that entry.\n\nThe specification says (in section 11.5) that if a version is deleted it\nwill\nbe removed from the merge-set.  This is what I was talking about.\nA user may have begun an interactive merge (resolving conflicts in\nindividual\nfiles) and the specification says another user may come along and delete one\n\nof those files involved in the merge.\n\nSee Tims recent e-mail where he suggests I lock everything involved in the\nmerge before starting....this seems OK.\n\nRegards,\nPeter Raymond - MERANT.\n\n\n\n>\n> Peter Raymond <Peter.Raymond@merant.com>\n> Sent by: ietf-dav-versioning-request@w3.org\n> 08/19/2001 08:21 AM\n>\n>\n>         To:     ietf-dav-versioning@w3.org\n>         cc:\n>         Subject:        Versions being deleted during a MERGE...\n>\n>\n>\n> Hi,\n>\n> I just noticed a potential problem with versions being used for a merge\n> operation\n> being deleted during the merge.\n>\n> Section 11 says a checked-out resource has a DAV:merge-set identifying\n> versions\n> to be merged.  DELETE (section 11.5) says it will remove entries from\n> the\n> merge-set.  Shouldn't the server disallow the DELETE, someone somewhere\n> is in the\n> middle of a merge using this version, also there would be a race\n> condition if someone\n> deletes the version while the client is processing the DAV:merge-set of\n> a checked-out\n> resource.\n>\n> Regards,\n> Peter Raymond - MERANT\n\n\n\n", "id": "lists-006-12202927"}, {"subject": "Re: Versions being deleted during a MERGE..", "content": "Hi,\n\n\"Clemm, Geoff\" wrote:\n\n> A server is of course free to refuse the DELETE request,\n> and indicate as its reason that it didn't want to satisfy\n> the postcondition that would remove that version URL from\n> the DAV:merge-set.\n>\n\nI thought the servers (to be compliant) MUST enforce the postconditions.\nAre you saying a deltav compliant server needs not honour all the\npostconditions?  If servers do not honour the postconditions would it not\nlead to possible non-interoperability?\n\n>\n> Note thought that even if the server allows the deletion,\n> there is no race condition here, though,\n> just some dangling version URL's that will return 404's\n> when accessed.\n>\n\nThe condition I was thinking of was when client A issues the MERGE request\n(which checks-out the VCR) but after getting the HTTP response for the\nquery for\nthe checked-out resources DAV:merge-set client B deletes one of the\nversions\nreferenced in that set.  Client A then goes on to do a GET (for example) to\nretrieve\nthe content to be merged but it would fail (with a 404).....client B's\nDELETE got there\nfirst!\n\nI guess I would implement Tims idea and lock down all the resources before\nbeginning the interactive merge.\n\nAlso I just noticed that in section 11.2 we define merged-set, updated-set,\n\nand ignored-set but the example in section 11.2.1 has <D:update-set> etc\nnot <D:updated-set> etc.\n\n\nRegards,\nPeter Raymond - MERANT.\n\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n> Sent: Sunday, August 19, 2001 8:22 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Versions being deleted during a MERGE...\n>\n> Hi,\n>\n> I just noticed a potential problem with versions being used for a merge\n> operation\n> being deleted during the merge.\n>\n> Section 11 says a checked-out resource has a DAV:merge-set identifying\n> versions\n> to be merged.  DELETE (section 11.5) says it will remove entries from\n> the\n> merge-set.  Shouldn't the server disallow the DELETE, someone somewhere\n> is in the\n> middle of a merge using this version, also there would be a race\n> condition if someone\n> deletes the version while the client is processing the DAV:merge-set of\n> a checked-out\n> resource.\n>\n> Regards,\n> Peter Raymond - MERANT\n\n\n\n", "id": "lists-006-12212585"}, {"subject": "Re: Versions being deleted during a MERGE..", "content": "Peter Raymond wrote:\n\n> Hi,\n>\n> \"Clemm, Geoff\" wrote:\n>\n> > A server is of course free to refuse the DELETE request,\n> > and indicate as its reason that it didn't want to satisfy\n> > the postcondition that would remove that version URL from\n> > the DAV:merge-set.\n> >\n>\n> I thought the servers (to be compliant) MUST enforce the postconditions.\n> Are you saying a deltav compliant server needs not honour all the\n> postconditions?  If servers do not honour the postconditions would it not\n> lead to possible non-interoperability?\n>\n\nApologies...ignore that bit above....I just realized that since I want the\nDELETE to\nfail it is fine to fail one of the postconditions (and as Geoff says return the\nreason\nin the response).  It's only when the operation is successful that all the\npostconditions\nmust be honoured.\n\n>\n> >\n> > Note thought that even if the server allows the deletion,\n> > there is no race condition here, though,\n> > just some dangling version URL's that will return 404's\n> > when accessed.\n> >\n>\n> The condition I was thinking of was when client A issues the MERGE request\n> (which checks-out the VCR) but after getting the HTTP response for the\n> query for\n> the checked-out resources DAV:merge-set client B deletes one of the\n> versions\n> referenced in that set.  Client A then goes on to do a GET (for example) to\n> retrieve\n> the content to be merged but it would fail (with a 404).....client B's\n> DELETE got there\n> first!\n>\n> I guess I would implement Tims idea and lock down all the resources before\n> beginning the interactive merge.\n>\n> Also I just noticed that in section 11.2 we define merged-set, updated-set,\n>\n> and ignored-set but the example in section 11.2.1 has <D:update-set> etc\n> not <D:updated-set> etc.\n>\n> Regards,\n> Peter Raymond - MERANT.\n>\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n> > Sent: Sunday, August 19, 2001 8:22 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: Versions being deleted during a MERGE...\n> >\n> > Hi,\n> >\n> > I just noticed a potential problem with versions being used for a merge\n> > operation\n> > being deleted during the merge.\n> >\n> > Section 11 says a checked-out resource has a DAV:merge-set identifying\n> > versions\n> > to be merged.  DELETE (section 11.5) says it will remove entries from\n> > the\n> > merge-set.  Shouldn't the server disallow the DELETE, someone somewhere\n> > is in the\n> > middle of a merge using this version, also there would be a race\n> > condition if someone\n> > deletes the version while the client is processing the DAV:merge-set of\n> > a checked-out\n> > resource.\n> >\n> > Regards,\n> > Peter Raymond - MERANT\n\n\n\n", "id": "lists-006-12222996"}, {"subject": "RE: Versions being deleted during a MERGE..", "content": "I'll fix that.  Thanks!\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\nAlso I just noticed that in section 11.2 we define merged-set, updated-set,\n\nand ignored-set but the example in section 11.2.1 has <D:update-set> etc\nnot <D:updated-set> etc.\n\n\n\n", "id": "lists-006-12233777"}, {"subject": "Re: Re (2): Removing the DAV:activity and DAV:version-history and  DAV:baseline resource type value", "content": "On Wed, Jun 06, 2001 at 10:16:33AM +0100, Tim_Ellison@uk.ibm.com wrote:\n> Greg Stein <gstein@lyra.org> wrote:\n>...\n> > *) howthehell do I describe a Working Resource? I can't see that it has a\n> >    unique property.\n> \n> (You're going to like this :-)\n\n[ Greg puts on his safety harness... ]\n\n> A working resource has <DAV:checked-out/> and does not have\n> <DAV:auto-checkout/>\n> (appears and does not appear, respectively, in\n> DAV:supported-live-property-set)\n\nOh, bleck.\n\nI can't possibly imagine a client developer figuring stuff like that out.\nGeez...\n\n> > *) is DAV:checkout-set actually unique to a Version resource? Some of those\n> >    properties are reflected in VCRs. Which Version Resource properties *do*\n> >    get copied to a VCR, and which do not? The ones that don't will therefore\n> >    signal whether a resource is a Version resource or not.\n> \n> A version is identified by its support for the <DAV:version-name> property.\n\nBut also the absence of some other properties. VCRs have the version-name\nproperty on them, too.\n\nThis is why I'm leery of this approach. If I looked for a version-name\nproperty, then I'd be screwed because it would be on all my VCRs, too.\n\n> For the full list of defining properties, plus Geoff's corrections, see\n> http://lists.w3.org/Archives/Public/ietf-dav-versioning/2001AprJun/0115.html\n\nReading that, it would appear that creating a classification of the\nresources is order dependent. I better have my checks in the proper order.\n\nIf we aren't going to use resourcetype, then the contents of that post must\nbe reflected somewhere. Or people just aren't going to get it right. If it\ndoesn't go into the spec \"because it duplicates information\", then where are\nwe supposed to put it, such that people will find it?\n\nThe spec seems the appropriate place for algorithms like that.\n\nBut using a resourcetype can avoid algorithms in the first place :-)\n\n>...\n> > Oh: and Tim argued, \"well, for somebody to implement DeltaV, we're going to\n> > ask a lot more than simple Set computations.\" Oh. Great. Just because some\n> > part is difficult, that means we can make *everything* difficult? That's\n> > bogus.\n> >\n> > \"Hey, John. You can do DeltaV if you can jump over this 6 foot bar. Oh.\n> > Wait. The DeltaV designers said that if you can do that, then you can also\n> > jump over this 10 foot bar. Cool. Go, man! Jump!\"\n> >\n> > pthtpth. Non-starter.\n> \n> (I don't know what 'pthtpth' means, but you probably just swore at me in\n> acronym-speak:^)\n\nNah. Just a typed out \"raspberry\". :-)  (and you probably don't know that\nterm either, over there in the UK :-)\n\n> Flame on.\n> \n> Come on Greg -- you can't be serious.\n> [ ... Tim berating me ... ]\n\n:-) Okay. I probably deserved that.\n\nPartly serious. I disagree with the notion of saying that something has an\nacceptable difficulty just because something else is even more difficult.\nI'd prefer to see a simple \"this is <this> type\" in the resourcetype field.\n\n>...\n> (2) If we _do_ go for extending DAV:resourcetype the likely outcome is\n> something like a *Set* of orthogonal characteristics, such as\n> <version-controlled-resource>, <collection>, <checked-in> -- guess what,\n> you'll have to do that \"difficult\" Set thing again anyway.\n\nThis is probably the sticking point here. We'd probably end up with several\ntokens in there to avoid combinatorial explosion :-(\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-1223730"}, {"subject": "RE: Allow: header and supported method", "content": "No, you could do something like FTP does and have an HTTP\nmethod that tells the server a port to connect to in order\nto deliver invalidation responses, something like:\n\nREG_NOTIFY /foo.txt HTTP/1.1\nHost: www.oracle.com\n\n<respond-to>\n  <href>http://192.251.211.44:4234/notify</href>\n</respond-to>\n\nand the server would then post a list of HREFs to invalidate\nto that address.\n\nYou just require that the client also be able to function\nas a server.\n\nThe disadvantage of this approach is that is that it will\nhave problems with many firewalls.  The advantage is that\nthe server doesn't have to keep open a socket to the client\njust in case an invalidation would have to be done.  The\nserver could end up with a very large number of sockets in\nthis case.\n\n--Eric\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> Sent: Sunday, August 19, 2001 5:20 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: Allow: header and supported methods\n> \n> \n> We'd have to introduce push technology into HTTP.\n> \n> \n> \n> \n> \n> Peter Raymond <Peter.Raymond@merant.com>\n> 08/19/2001 08:15 AM\n> \n>  \n>         To:     Jim Amsden <jamsden@us.ibm.com>\n>         cc:     Eric.Sedlar@oracle.com\n>         Subject:        Re: Allow: header and supported methods\n> \n>  \n> \n> Hi Jim,\n> \n> Jim Amsden wrote:\n> \n> > Anyone interested in a new WebDAV working group to add event \n> notification?\n> > We could call it DAVE.\n> \n> Sounds like fun and certainly something I would be interested in.\n> \n> But, how would we do that over HTTP? Since the protocol is \n> request-response based the client\n> would\n> have to be polling at regular intervals asking if any events of interest \n> have occurred.\n> Would this perform well?\n> \n> Regards,\n> Peter Raymond - MERANT.\n> \n> \n> \n> \n> \n\n\n\n", "id": "lists-006-12241467"}, {"subject": "Re: Allow: header and supported method", "content": "Well, the client's listening port could also be the standard http port if it is not occupied by a\nrunning web server. This should reduce firewall problems\n\nAlternative ways to get the invalidation responses through could be:\n- consider the use of UDP packages\n- let clients know about each other to a certain degree and use them to spread out messages (maybe\nbtree like)\nI am not quite sure about the consequence of this approach but it could reduce the server's number\nof sockets considerably.\n\nMaybe polling could be offered as a fallback in case a firewall blocks all other communication.\nHowever, opening a listening port on client side will probably provide to less overall network\ntraffic and to least delay.\n\nEckhard\n\n\n-----Urspr?ngliche Nachricht-----\nVon: \"Eric Sedlar\" <Eric.Sedlar@oracle.com>\nAn: <ietf-dav-versioning@w3.org>\nGesendet: Dienstag, 21. August 2001 01:41\nBetreff: RE: Allow: header and supported methods\n\n\n> No, you could do something like FTP does and have an HTTP\n> method that tells the server a port to connect to in order\n> to deliver invalidation responses, something like:\n>\n> REG_NOTIFY /foo.txt HTTP/1.1\n> Host: www.oracle.com\n>\n> <respond-to>\n>   <href>http://192.251.211.44:4234/notify</href>\n> </respond-to>\n>\n> and the server would then post a list of HREFs to invalidate\n> to that address.\n>\n> You just require that the client also be able to function\n> as a server.\n>\n> The disadvantage of this approach is that is that it will\n> have problems with many firewalls.  The advantage is that\n> the server doesn't have to keep open a socket to the client\n> just in case an invalidation would have to be done.  The\n> server could end up with a very large number of sockets in\n> this case.\n>\n> --Eric\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> > Sent: Sunday, August 19, 2001 5:20 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: Re: Allow: header and supported methods\n> >\n> >\n> > We'd have to introduce push technology into HTTP.\n> >\n> >\n> >\n> >\n> >\n> > Peter Raymond <Peter.Raymond@merant.com>\n> > 08/19/2001 08:15 AM\n> >\n> >\n> >         To:     Jim Amsden <jamsden@us.ibm.com>\n> >         cc:     Eric.Sedlar@oracle.com\n> >         Subject:        Re: Allow: header and supported methods\n> >\n> >\n> >\n> > Hi Jim,\n> >\n> > Jim Amsden wrote:\n> >\n> > > Anyone interested in a new WebDAV working group to add event\n> > notification?\n> > > We could call it DAVE.\n> >\n> > Sounds like fun and certainly something I would be interested in.\n> >\n> > But, how would we do that over HTTP? Since the protocol is\n> > request-response based the client\n> > would\n> > have to be polling at regular intervals asking if any events of interest\n> > have occurred.\n> > Would this perform well?\n> >\n> > Regards,\n> > Peter Raymond - MERANT.\n> >\n> >\n> >\n> >\n> >\n\n\n\n", "id": "lists-006-12252553"}, {"subject": "Re: Versions being deleted during a MERGE..", "content": "Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n> I guess I would implement Tims idea and lock down all\n> the resources before beginning the interactive merge.\n\nMERGE has the potential to check out a great number of version-controlled\nresources on the server and leave them around for the client to combine\nmultiple source versions into each.  This requires multiple round trips to\nthe server before the version-controlled resources are checked in again.\nIt is likely that one would only want to target MERGE on a personal\nworkspace, so that other users are not interferring with the (potentially\nlong running) manual merge process.\n\nThe sources of the merge are versions, so, assuming the target _is_ a\npersonal workspace, conflicts will only arise when the source versions are\ndeleted (as you pointed out).  On the sub-set of servers that support\nversion deletion it will be necessary for the client to lock those versions\nto prevent them being deleted, or to 'skip' those resources that have\nsources missing (which would simply require an UNCHECKOUT of the\nversion-controlled resource), and then re-apply the MERGE to get the new\nset of sources.\n\nIf you choose to lock the versions you are ensuring that the results of the\nmerge reflect the state of the source and destination at the time the MERGE\nmethod completed (clearly, while you are manually merging clients may be\ncreating new versions that would have influenced the results of the merge).\nHowever, if you choose to 'skip' the resources that have missing versions\nin the merge set, and then re-apply the MERGE you may never complete the\nmerge (if someone is constantly deleting versions that caused conflicts in\nthe results of the merge).\n\nGiven that you cannot simultaneously lock all the versions (identified by\nthe DAV:merge-set property on all the checked-out version-controlled\nresources), and to reduce the requirements for a locking server, I'm more\ninclined to make a guess that deleting conflicting versions is infrequent,\nand simply retry the entire merge to get the latest server state.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12264730"}, {"subject": "RE: Versions being deleted during a MERGE..", "content": "   From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n\n   Given that you cannot simultaneously lock all the versions (identified by\n   the DAV:merge-set property on all the checked-out version-controlled\n   resources), and to reduce the requirements for a locking server, I'm more\n   inclined to make a guess that deleting conflicting versions is\ninfrequent,\n   and simply retry the entire merge to get the latest server state.\n\nI agree with Tim's suggestion here.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12274416"}, {"subject": "WebDAV Invalidation (Was Re: Allow: header and supported methods", "content": "Check out\nhttp://www.esi.org/invalidation_protocol_1-0.html for some work that looks\npretty similar\nto what we are talking about.\n\n--Eric\n\n\n\n", "id": "lists-006-12282034"}, {"subject": "MERGE &amp; UPDATE response", "content": "In an attempt to unify the responses from MERGE and UPDATE, and to address\nthe concerns some have expressed for parsing the responses of these methods,\nI propose that:\n(a) the DAV:ignore-set is dropped from the responses.  What would you do\nwith them anyway?  Speak up if you have a use-case that requires these; and,\n(b) the response marshalling should be in the Multi-Status format so that\nimplementations can reuse their existing code.  I think the responses will\nfit well in this format.\n\nNote that (a) will simplify the protocol, and (b) will simplify the\nimplementation without changing the semantics of the operations.  They are\nrelatively minor changes.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12290156"}, {"subject": "RE: MERGE &amp; UPDATE response", "content": "The concern about the complexity of the idiosyncratic\nresponse marshalling of MERGE and UPDATE responses has been raised\nin the past, and I agree with the approach that Tim\ndescribes below.  Does anyone object?\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim Ellison [mailto:tim@peir.com]\nSent: Tuesday, August 21, 2001 5:25 PM\nTo: DeltaV\nSubject: MERGE & UPDATE responses\n\n\nIn an attempt to unify the responses from MERGE and UPDATE, and to address\nthe concerns some have expressed for parsing the responses of these methods,\nI propose that:\n(a) the DAV:ignore-set is dropped from the responses.  What would you do\nwith them anyway?  Speak up if you have a use-case that requires these; and,\n(b) the response marshalling should be in the Multi-Status format so that\nimplementations can reuse their existing code.  I think the responses will\nfit well in this format.\n\nNote that (a) will simplify the protocol, and (b) will simplify the\nimplementation without changing the semantics of the operations.  They are\nrelatively minor changes.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12297843"}, {"subject": "Re: MERGE &amp; UPDATE response", "content": "Tim,\nGood suggestion. I agree.\n\n\n\n\n\n\"Tim Ellison\" <tim@peir.com>\nSent by: ietf-dav-versioning-request@w3.org\n08/21/2001 05:25 PM\n\n \n        To:     \"DeltaV\" <ietf-dav-versioning@w3.org>\n        cc: \n        Subject:        MERGE & UPDATE responses\n\n \n\nIn an attempt to unify the responses from MERGE and UPDATE, and to address\nthe concerns some have expressed for parsing the responses of these \nmethods,\nI propose that:\n(a) the DAV:ignore-set is dropped from the responses.  What would you do\nwith them anyway?  Speak up if you have a use-case that requires these; \nand,\n(b) the response marshalling should be in the Multi-Status format so that\nimplementations can reuse their existing code.  I think the responses will\nfit well in this format.\n\nNote that (a) will simplify the protocol, and (b) will simplify the\nimplementation without changing the semantics of the operations.  They are\nrelatively minor changes.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12306167"}, {"subject": "RE: Issues/questions regarding sections 3, 4 and 5..", "content": ">    Reading section 5.6 it took us quite a while to decide how to\n>    delete the last version from a version history.  I think the answer\n>    is \"you don't\" you must delete the version history itself in order\n>    to delete the last version.  Did we interpret this correctly?  Do\n>    you think we should clarify this in the spec?\n\n\nAs currently implemented, my server will allow you to delete the last\nversion.  That version goes away and the VCR reverts to the next to last\nversion.\n\nThat solution works because I don't fork.\n\nBut if the consensus is to prohibit this I can prohibit it (except as a\nside effect of UNCHECKOUT, though).\n\n\n\n", "id": "lists-006-12314739"}, {"subject": "RE: Issues/questions regarding sections 3, 4 and 5..", "content": "Ah, the wonderful ambiguities of English ... (:-).\n\nThis thread was about deleting the \"last\" version in the sense of\n\"the only version left in the version history\".  The result of this\nwould be a version history with no versions in it, which is not\nallowed by the spec.\n\nI believe you are referring to the \"last\" version in the sense\nof \"the one that was created most recently in a linear history\".\nThat is totally legal to delete (assuming it is not the only\nversion left in the history), and having the VCR revert to the\nimmediately preceding version is very reasonable (although not\nrequired by the protocol).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Wednesday, August 22, 2001 1:58 PM\nTo: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\nSubject: RE: Issues/questions regarding sections 3, 4 and 5...\n\n\n\n\n>    Reading section 5.6 it took us quite a while to decide how to\n>    delete the last version from a version history.  I think the answer\n>    is \"you don't\" you must delete the version history itself in order\n>    to delete the last version.  Did we interpret this correctly?  Do\n>    you think we should clarify this in the spec?\n\n\nAs currently implemented, my server will allow you to delete the last\nversion.  That version goes away and the VCR reverts to the next to last\nversion.\n\nThat solution works because I don't fork.\n\nBut if the consensus is to prohibit this I can prohibit it (except as a\nside effect of UNCHECKOUT, though).\n\n\n\n", "id": "lists-006-12322990"}, {"subject": "Re: WebDAV Invalidation (Was Re: Allow: header and supported methods", "content": "The protocol described in the ESI document allows to invalidate documents that have been downloaded\nto a local machine by applying a push technology. This could solve already several conflict\nsituations or even partly prevent problems.\n\nOn the other hand there seems to be an increasing need for more fine-grained notification services\nthat extend the traditional access control systems. Picture 1 in the following longer article tries\nto classify them:\n\n\"Beyond 'Yes or No' - Extending Access Control in Groupware with Negotiation and Awareness\"\n(http://www.informatik.uni-bonn.de/~os/Publications/COOP98a.ps)\n\nMaybe those needs are also worth discussing if they could be supported in the spec in order to allow\napplications to build up on them. The invalidation protocol seems to be a good basis also for this.\n\nEckhard\n\n\n-----Urspr?ngliche Nachricht-----\nVon: Eric Sedlar\nAn: ietf-dav-versioning@w3.org\nGesendet: Dienstag, 21. August 2001 19:00\nBetreff: WebDAV Invalidation (Was Re: Allow: header and supported methods)\n\n\nCheck out\nhttp://www.esi.org/invalidation_protocol_1-0.html for some work that looks pretty similar\nto what we are talking about.\n\n--Eric\n\n\n\n", "id": "lists-006-12332661"}, {"subject": "client workspaces, merging and forkin", "content": "I've been trying to understand how the working resource feature works\nwith merging and forking, and I've got a few questions:\n\n1. For merging & client workspaces, should the DAV:checked-out-for-merge\nmerge postcondition cover the case that the DAV:checkout element\nincluded a DAV:apply-to-version? In particular, should it say that a\nLocation: header must be in the response, and that this header contains\nthe URL of the working resource created by the checkout?\n\n2. A merge target is a version-controlled resource. Was it unnecessary\nto allow a merge target to be either a version-controlled resource or a\nchecked-out resource (e.g. a working resource)?\n\n3. How does the working resource feature work for a forking server? For\nexample, suppose that http://repo.webdav.org/wr/1 and\nhttp://repo.webdav.org/wr/2 identify two working resources that are\ncreated by requesting a checkout on a version controlled resource,\nhttp://repo.webdav.org/foo.html, and including a DAV:apply-to-version in\nthe request. The DAV:checked-in property of the vcr is\nhttp://repo.webdav.org/his/1/ver/V5. This is also the value of the\nDAV:checked-out property of each of the working resources. Each working\nresource has it's DAV:auto-update property set to the vcr URL. Now\nsuppose that the first working resource (http://repo.webdav.org/wr/1) is\nchecked in, creating version http://repo.webdav.org/his/1/ver/V6, and\nthat postcondition DAV:auto-update applies - the DAV:checked-in property\nof the vcr is now set to http://repo.webdav.org/his/1/ver/V6. Does this\nthen mean that it is impossible to ever check in the second working\nresource, http://repo.webdav.org/wr/2, as it's DAV:checked-out property\npoints to http://repo.webdav.org/his/1/ver/V5, and precondition\nDAV:no-overwrite-by-auto-update prevents the checkin? The\nDAV:auto-update property is protected, and so can't be changed by a\nclient PROPPATCH.\n\n4. Looks like there's a typo in draft 16, section 9.4 - the CHECKIN\n'forking' preconditions reference DAV:checkout-... conditions.\n\nThanks,\nAlison Macmillan\n\n--\n -------------------------------------------------------------\n The statements and opinions expressed here are my own\n and do not necessarily represent those of Oracle Corporation.\n -------------------------------------------------------------\n\n\n\n", "id": "lists-006-12342006"}, {"subject": "I-D ACTION:draft-ietf-deltav-versioning-17.tx", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Web Versioning and Configuration Management Working Group of the IETF.\n\nTitle: Versioning Extensions to WebDAV\nAuthor(s): G. Clemm, J. Amsden, T. Ellison, \n                          C. Kaler, J. Whitehead\nFilename: draft-ietf-deltav-versioning-17.txt\nPages: 107\nDate: 22-Aug-01\n\nThis document specifies a set of methods, headers, and resource types \nthat define the WebDAV Versioning extensions to the HTTP/1.1 protocol. \nWebDAV Versioning will minimize the complexity of clients that are\ncapable of interoperating with a variety of versioning repository\nmanagers, to facilitate widespread deployment of applications capable of\nutilizing the WebDAV Versioning services.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-17.txt\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-deltav-versioning-17.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-deltav-versioning-17.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n\n\n\nMessage/External-body attachment: stored\n\n\n\n\n", "id": "lists-006-12352476"}, {"subject": "Re: client workspaces, merging and forkin", "content": "Alison Macmillan wrote:\n\n> I've been trying to understand how the working resource feature works\n> with merging and forking, and I've got a few questions:\n>\n> 1. For merging & client workspaces, should the DAV:checked-out-for-merge\n> merge postcondition cover the case that the DAV:checkout element\n> included a DAV:apply-to-version? In particular, should it say that a\n> Location: header must be in the response, and that this header contains\n> the URL of the working resource created by the checkout?\n>\n\nSorry - please ignore this question. I guess the checked-out resource URL(s)\nare returned in the DAV:merged-set response element, (and it also covers the\ncase of merging more than one merge version + target).\n\n>\n> 2. A merge target is a version-controlled resource. Was it unnecessary\n> to allow a merge target to be either a version-controlled resource or a\n> checked-out resource (e.g. a working resource)?\n>\n> 3. How does the working resource feature work for a forking server? For\n> example, suppose that http://repo.webdav.org/wr/1 and\n> http://repo.webdav.org/wr/2 identify two working resources that are\n> created by requesting a checkout on a version controlled resource,\n> http://repo.webdav.org/foo.html, and including a DAV:apply-to-version in\n> the request. The DAV:checked-in property of the vcr is\n> http://repo.webdav.org/his/1/ver/V5. This is also the value of the\n> DAV:checked-out property of each of the working resources. Each working\n> resource has it's DAV:auto-update property set to the vcr URL. Now\n> suppose that the first working resource (http://repo.webdav.org/wr/1) is\n> checked in, creating version http://repo.webdav.org/his/1/ver/V6, and\n> that postcondition DAV:auto-update applies - the DAV:checked-in property\n> of the vcr is now set to http://repo.webdav.org/his/1/ver/V6. Does this\n> then mean that it is impossible to ever check in the second working\n> resource, http://repo.webdav.org/wr/2, as it's DAV:checked-out property\n> points to http://repo.webdav.org/his/1/ver/V5, and precondition\n> DAV:no-overwrite-by-auto-update prevents the checkin? The\n> DAV:auto-update property is protected, and so can't be changed by a\n> client PROPPATCH.\n>\n> 4. Looks like there's a typo in draft 16, section 9.4 - the CHECKIN\n> 'forking' preconditions reference DAV:checkout-... conditions.\n>\n> Thanks,\n> Alison Macmillan\n>\n> --\n>  -------------------------------------------------------------\n>  The statements and opinions expressed here are my own\n>  and do not necessarily represent those of Oracle Corporation.\n>  -------------------------------------------------------------\n\n--\n -------------------------------------------------------------\n The statements and opinions expressed here are my own\n and do not necessarily represent those of Oracle Corporation.\n -------------------------------------------------------------\n\n\n\n", "id": "lists-006-12361932"}, {"subject": "AW: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n> \n> Yes, that is what has been reported.\n> \n> Although if I am wrong about the lack of support for lock-null\n> resources, maybe I'm wrong about this too ... I hope not!\n> (I don't suppose two wrongs make a right in this case? :-)\n\nMS Webfolders display a folder icon for resources where the\nresourcetype is non-empty. Just tested.\n\n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n> Sent: Wednesday, June 06, 2001 5:57 PM\n> To: Clemm, Geoff; DeltaV (E-mail)\n> Subject: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:bas eline resource type values\n> \n> \n> could you expand a bit on what the bug is? Are they treating \n> anything with a\n> non-empty resourcetype as collection?\n> \n> \n\n\n\n", "id": "lists-006-1236235"}, {"subject": "RE: I-D ACTION:draft-ietf-deltav-versioning-17.tx", "content": "This draft is also available in word and html format on the deltav\nweb site, but if you could review the text document (to catch typos\ninduced by the Word-to-txt process), that would be best.\nNote that many of the section headings in the text version\nhave a space removed ... I will fix that in the final editing pass.\n\nThere will be a 2-week IETF wide last call issued sometime soon.\nPlease report any typo, no matter how small or trivial!\n\nThanks,\nGeoff\n\n-----Original Message-----\nFrom: Internet-Drafts@ietf.org [mailto:Internet-Drafts@ietf.org]\nSent: Friday, August 24, 2001 6:44 AM\nCc: ietf-dav-versioning@w3.org\nSubject: I-D ACTION:draft-ietf-deltav-versioning-17.txt\n\n\nA New Internet-Draft is available from the on-line Internet-Drafts\ndirectories.\nThis draft is a work item of the Web Versioning and Configuration Management\nWorking Group of the IETF.\n\nTitle: Versioning Extensions to WebDAV\nAuthor(s): G. Clemm, J. Amsden, T. Ellison, \n                          C. Kaler, J. Whitehead\nFilename: draft-ietf-deltav-versioning-17.txt\nPages: 107\nDate: 22-Aug-01\n\nThis document specifies a set of methods, headers, and resource types \nthat define the WebDAV Versioning extensions to the HTTP/1.1 protocol. \nWebDAV Versioning will minimize the complexity of clients that are\ncapable of interoperating with a variety of versioning repository\nmanagers, to facilitate widespread deployment of applications capable of\nutilizing the WebDAV Versioning services.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-17.txt\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-deltav-versioning-17.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-deltav-versioning-17.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n", "id": "lists-006-12372366"}, {"subject": "RE: client workspaces, merging and forkin", "content": "Alison Macmillan wrote:\n> A merge target is a version-controlled resource. Was it unnecessary\n> to allow a merge target to be either a version-controlled resource\n> or a checked-out resource (e.g. a working resource)?\n\nYes, it probably would be worth allowing the merge target to be\na working resource.  I'll put that on the \"fixes to draft 17\" list.\n\n> 3. How does the working resource feature work for a forking server? For\n> example, suppose that http://repo.webdav.org/wr/1 and\n> http://repo.webdav.org/wr/2 identify two working resources that are\n> created by requesting a checkout on a version controlled resource,\n> http://repo.webdav.org/foo.html, and including a DAV:apply-to-version in\n> the request. The DAV:checked-in property of the vcr is\n> http://repo.webdav.org/his/1/ver/V5. This is also the value of the\n> DAV:checked-out property of each of the working resources. Each working\n> resource has it's DAV:auto-update property set to the vcr URL. Now\n> suppose that the first working resource (http://repo.webdav.org/wr/1) is\n> checked in, creating version http://repo.webdav.org/his/1/ver/V6, and\n> that postcondition DAV:auto-update applies - the DAV:checked-in property\n> of the vcr is now set to http://repo.webdav.org/his/1/ver/V6. Does this\n> then mean that it is impossible to ever check in the second working\n> resource, http://repo.webdav.org/wr/2, as it's DAV:checked-out property\n> points to http://repo.webdav.org/his/1/ver/V5, and precondition\n> DAV:no-overwrite-by-auto-update prevents the checkin? The\n> DAV:auto-update property is protected, and so can't be changed by a\n> client PROPPATCH.\n\nYou have two choices:\n\n- Do what you would do on a non-forking server, i.e. checkout the new\nversion to get a new working resource, merge the contents of your old\nworking resource into that new working resource, delete the old\nworking resource, and then checkin the new working resource (and if\nsomeone else has checked in a new version since your checkout,\nrepeat the process).\n\n- Use UPDATE to change the DAV:checked-in version of the VCR to\nbe .../V5 and then checkin.\n\n> 4. Looks like there's a typo in draft 16, section 9.4 - the CHECKIN\n> 'forking' preconditions reference DAV:checkout-... conditions.\n\nYes, that is fixed in draft 17.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12383266"}, {"subject": "Re: client workspaces, merging and forkin", "content": "\"Clemm, Geoff\" wrote:\n\n> Alison Macmillan wrote:\n> > A merge target is a version-controlled resource. Was it unnecessary\n> > to allow a merge target to be either a version-controlled resource\n> > or a checked-out resource (e.g. a working resource)?\n>\n> Yes, it probably would be worth allowing the merge target to be\n> a working resource.  I'll put that on the \"fixes to draft 17\" list.\n>\n> > 3. How does the working resource feature work for a forking server? For\n> > example, suppose that http://repo.webdav.org/wr/1 and\n> > http://repo.webdav.org/wr/2 identify two working resources that are\n> > created by requesting a checkout on a version controlled resource,\n> > http://repo.webdav.org/foo.html, and including a DAV:apply-to-version in\n> > the request. The DAV:checked-in property of the vcr is\n> > http://repo.webdav.org/his/1/ver/V5. This is also the value of the\n> > DAV:checked-out property of each of the working resources. Each working\n> > resource has it's DAV:auto-update property set to the vcr URL. Now\n> > suppose that the first working resource (http://repo.webdav.org/wr/1) is\n> > checked in, creating version http://repo.webdav.org/his/1/ver/V6, and\n> > that postcondition DAV:auto-update applies - the DAV:checked-in property\n> > of the vcr is now set to http://repo.webdav.org/his/1/ver/V6. Does this\n> > then mean that it is impossible to ever check in the second working\n> > resource, http://repo.webdav.org/wr/2, as it's DAV:checked-out property\n> > points to http://repo.webdav.org/his/1/ver/V5, and precondition\n> > DAV:no-overwrite-by-auto-update prevents the checkin? The\n> > DAV:auto-update property is protected, and so can't be changed by a\n> > client PROPPATCH.\n>\n> You have two choices:\n>\n> - Do what you would do on a non-forking server, i.e. checkout the new\n> version to get a new working resource, merge the contents of your old\n> working resource into that new working resource, delete the old\n> working resource, and then checkin the new working resource (and if\n> someone else has checked in a new version since your checkout,\n> repeat the process).\n>\n\nOr, could you also just merge from the DAV:checked-in version of the VCR to\nthe working resource, and then check in the working resource? (Now that a\nworking resource can be a merge target).\n\nThanks,\nAlison.\n--\n -------------------------------------------------------------\n The statements and opinions expressed here are my own\n and do not necessarily represent those of Oracle Corporation.\n -------------------------------------------------------------\n\n\n\n", "id": "lists-006-12393384"}, {"subject": "RE: client workspaces, merging and forkin", "content": "   From: Alison Macmillan [mailto:alison.macmillan@oracle.com]\n   \n   > [to checkin a working resource whose DAV:checked-out version does not \n   > match the DAV:checked-in version of the DAV:auto-update VCR]\n   > Do what you would do on a non-forking server, i.e. checkout the new\n   > version to get a new working resource, merge the contents of your old\n   > working resource into that new working resource, delete the old\n   > working resource, and then checkin the new working resource (and if\n   > someone else has checked in a new version since your checkout,\n   > repeat the process).\n\n   Or, could you also just merge from the DAV:checked-in version of the VCR\nto\n   the working resource, and then check in the working resource? (Now that a\n   working resource can be a merge target).\n\nNot by the current protocol, since the DAV:no-overwrite-by-auto-update\npostcondition states:\n\n If the DAV:auto-update property for the checked-out resource\n identifies a version-controlled resource, the DAV:checked-out property\n of the checked-out resource MUST identify the same version as the\n DAV:checked-in property of that version-controlled resource.\n\nWe could relax that constraint to say:\n\n If the DAV:auto-update property for the checked-out resource\n identifies a version-controlled resource, at least one of the\n versions identified by the DAV:predecessor-set property of the\n checked-out resource MUST identify a version that is either the same\n as or a descendant of the version identified by the DAV:checked-in\n property of that version-controlled resource.\n\nIf there are no objections, I'll place this on the \"editorial fix\"\nlist for draft 17.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12403541"}, {"subject": "deltav changes-and-issue", "content": "During last call, I will be maintaining the \"changes and issues\"\ndocument in real time, i.e. every time a change is proposed for the\ndraft, I will add it to the changes-and-issues file on our web site, i.e.:\nhttp://www.webdav.org/deltav/protocol/changes-and-issues.htm\nIgnore the \"date\" listed on the web page for this resource ... I probably\nwon't bother updating the date field each time I update the\nchanges-and-issues document.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12412572"}, {"subject": "RE: Last Call: Versioning Extensions to WebDAV to Proposed Standar", "content": "Hey, the URL seems to be wrong in this email...\n\nIt points to draft 16 instead if draft 17!?!?\n\n--Dylan\n\n> -----Original Message-----\n> From: scoya@cnri.reston.va.us [mailto:scoya@cnri.reston.va.us]On Behalf\n> Of The IESG\n> Sent: Friday, August 24, 2001 2:17 PM\n> To: IETF-Announce:\n> Cc: ietf-dav-versioning@w3.org\n> Subject: Last Call: Versioning Extensions to WebDAV to Proposed Standard\n> \n> \n> \n> The IESG has received a request from the Web Versioning and\n> Configuration Management Working Group to consider Versioning\n> Extensions to WebDAV <draft-ietf-deltav-versioning-17.txt> as a\n> Proposed Standard.\n> \n> The IESG plans to make a decision in the next few weeks, and solicits\n> final comments on this action.  Please send any comments to the\n> iesg@ietf.org or ietf@ietf.org mailing lists by September 7, 2001.\n> \n> Files can be obtained via\n> http://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-16.txt\n\n\n\n", "id": "lists-006-12419607"}, {"subject": "RE: Last Call: Versioning Extensions to WebDAV to Proposed Standa r", "content": "Yes, Dylan is correct, the URL is: \nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-17.txt\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Dylan Barrell [mailto:dbarrell@opentext.com]\nSent: Friday, August 24, 2001 3:16 PM\nTo: iesg@ietf.org; IETF-Announce:@opentext.com\nCc: ietf-dav-versioning@w3.org\nSubject: RE: Last Call: Versioning Extensions to WebDAV to Proposed\nStandard\n\n\nHey, the URL seems to be wrong in this email...\n\nIt points to draft 16 instead if draft 17!?!?\n\n--Dylan\n\n> -----Original Message-----\n> From: scoya@cnri.reston.va.us [mailto:scoya@cnri.reston.va.us]On Behalf\n> Of The IESG\n> Sent: Friday, August 24, 2001 2:17 PM\n> To: IETF-Announce:\n> Cc: ietf-dav-versioning@w3.org\n> Subject: Last Call: Versioning Extensions to WebDAV to Proposed Standard\n> \n> \n> \n> The IESG has received a request from the Web Versioning and\n> Configuration Management Working Group to consider Versioning\n> Extensions to WebDAV <draft-ietf-deltav-versioning-17.txt> as a\n> Proposed Standard.\n> \n> The IESG plans to make a decision in the next few weeks, and solicits\n> final comments on this action.  Please send any comments to the\n> iesg@ietf.org or ietf@ietf.org mailing lists by September 7, 2001.\n> \n> Files can be obtained via\n> http://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-16.txt\n\n\n\n", "id": "lists-006-12429426"}, {"subject": "Changes to baseline section in draft 17..", "content": "Hi,\n\nI've had a quick look at the changes to the baseline section in the new\ndraft, seems OK, but spotted a couple of things:\n\nIn section 12.6.1 in the text above the diagram you refer to the\nproperty\nDAV:baselined-collection.  I think it should be DAV:baseline-collection.\n\nAlso I think it would help if we made it clearer that this example is\npopulating a collection based on a baseline (as opposed to creating a\nnew baseline based on a collection)...it sometimes seems odd to me that\nwe use BASELINE-CONTROL to do both these tasks.\n\nI would change the words to be something like:\n\n\"In this example, the collection /src is populated with members from an\nexisting baseline and is itself placed under baseline control.  A new\nversion-controlled configuration (/repo/vcc/128) is created and\nassociated with /src, and /src is initialized with version-controlled\nmembers whose DAV:checked-in versions are those selected by the\nDAV:baseline-collection (/repo/bc/15) of the specified baseline,\n/repo/blh/13/ver/8.  The following diagram illustrates the resulting\nstate on the server.\"\n\nRegards,\nPeter Raymond - MERANT.\n\n\n\n", "id": "lists-006-12440768"}, {"subject": "Definition of advanced versioning package", "content": "Draft 16 formally defined the \"Advanced-Server-Workspace\"\nand \"Advanced-Client-Workspace\" packages in Section 10.3.\nDraft 17 does not formally define such packages. Is this\nchange intentional?\n\nRoy\n\n\n\n", "id": "lists-006-12449121"}, {"subject": "RE: Definition of advanced versioning package", "content": "That was an editorial change made by Tim Ellision.\nThe intent of the \"advanced server workspace\" and\n\"advanced client workspace\" packages was a recommendation\nthat a server SHOULD implement all of the advanced\nfeatures if it implements any of the advanced features.\nIt was more direct to just make this statement directly,\nwhich is what now appears in second paragraph of section 10.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Roy Seto [mailto:Roy.Seto@oracle.com]\nSent: Monday, August 27, 2001 6:38 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Definition of advanced versioning packages\n\n\nDraft 16 formally defined the \"Advanced-Server-Workspace\"\nand \"Advanced-Client-Workspace\" packages in Section 10.3.\nDraft 17 does not formally define such packages. Is this\nchange intentional?\n\nRoy\n\n\n\n", "id": "lists-006-12456175"}, {"subject": "AW: Removing the DAV:activity and DAV:version-history and DAV:baseline resource type value", "content": "> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n> \n> If you believe there is a useful line drawn between \"resource state\"\n> and \"resource type\", then it is necessary to unambiguously define \"state\"\n> and\n> \"type\" (in particular, in a way that allows you to distinguish one\n> from the other).\n \nNice try. ;-)\n\nI'd be happy with a useful definition of what can appear inside \nresourcetype and how that matches to the different kind of resources \nmentioned in deltaV (and possibly other extensions).\n\nI see two ways to resolve this issue in the Spec:\n\n1) Top-Down: the spec defines types of resources and for each\n   type then defines what live properties it holds and what state\n   it can have.\n\n2) Bottum-Up: The current spec is enhanced by a chapter which\n   algorithmically defines how to detect the resource type from\n   the supported-xxx-set. Ideally this would also describe how\n   future extensions should add to this algorithm for their new\n   types. \n\nCould the creators of deltaV agree on a way to go forward? Please?\n\n//Stefan\n\nPS. As Tim wrote: the spec itself, the concepts etc. are all fine and\nthere is no argument about that. \n\n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: Lisa Dusseault [mailto:lisa@xythos.com]\n> Sent: Wednesday, June 06, 2001 12:00 PM\n> To: Clemm, Geoff; DeltaV (E-mail)\n> Subject: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:bas eline resource type values\n> \n> \n> If you believe that whether a resource is under version control \n> or not, is a\n> matter of state, then leave it OUT of resourcetype.  It's not called\n> \"resourcestate\".\n> \n> Version, version History, and others are still types.\n> \n> But draw a line somewhere.\n> \n> lisa\n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > Sent: Wednesday, June 06, 2001 8:07 AM\n> > To: DeltaV (E-mail)\n> > Subject: RE: Removing the DAV:activity and DAV:version-history and\n> > DAV:bas eline resource type values\n> >\n> >\n> > I think Tim's point was that if \"under version control\"\n> > (e.g. \"version-controlled-resource\") is part of\n> > the \"type\" of a resource, then \"checked-out\" and \"checked-in\"\n> > would equally usefully be considered as part of the type\n> > (since the significantly affect what methods can be\n> > applied to that resource).\n> >\n> > In each case, you have the same resource (i.e. when you\n> > put a resource under version control, it is the same resource\n> > but has some additional live properties and methods you can\n> > apply to it).\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n> > Sent: Wednesday, June 06, 2001 6:27 AM\n> > To: DeltaV (E-mail)\n> > Subject: AW: Removing the DAV:activity and DAV:version-history and DAV\n> > :baseline resource type values\n> >\n> >\n> >\n> >\n> > > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von\n> > > Tim_Ellison@uk.ibm.com\n> > > [...]\n> > >\n> > > My view of the world...\n> > >\n> > > Here's the list of elements that could appear in a\n> > DAV:resourcetype.  Some\n> > > of these can be combined to provide a really meaningful\n> > experience for the\n> > > client.  Obviously, some combinations are invalid.\n> > >      <DAV:checked-in/>\n> > >      <DAV:checked-out/>\n> > >      <DAV:collection/>\n> > >      <DAV:working-resource/>\n> > >      <DAV:version-controlled-resource/>\n> > >      <DAV:version/>\n> > >      <DAV:version-history/>\n> > >      <DAV:workspace/>\n> > >      <DAV:version-controlled-configuration/>\n> > >      <DAV:baseline/>\n> > >      <DAV:activity/>\n> > >\n> >\n> > What is your rationale for checked-in/out in the type? I think\n> > I have missed something in the spec, since it feels like a\n> > property to me.\n> >\n> > > So,\n> > > <DAV:resourcetype>\n> > >      <DAV:activity/>\n> > > </DAV:resourcetype\n> > >\n> > > would be good, that is, not surprisingly, an activity resource.\n> > >\n> > > <DAV:resourcetype>\n> > >      <DAV:checked-out/>\n> > >      <DAV:version-controlled-resource/>\n> > >      <DAV:collection/>\n> > >      <DAV:workspace/>\n> > > </DAV:resourcetype>\n> > >\n> > > would be good too, it is a checked-out, version-controlled\n> > resource for a\n> > > workspace collection.  And so on.\n> > >\n> > > Tim\n> > >\n> > >\n> \n> \n\n\n\n", "id": "lists-006-1246339"}, {"subject": "Re: WebDAV Invalidation (Was Re: Allow: header and supported methods", "content": "While Im nervous about trying to boil the ocean\nin the form of a 'general notifications protocol', Im\nwondering what people think about including the ability\nto subscribe to events on resources?\nBy this I mean, in short, being able to subscribe\nto a resource, such that when things happen to it,\nsuch as:\no  property change\no  update (last modified)\no  invalidate\no  lock expiration / lock override\no  deleted\n\na subscribed entity would receive a notification.\n\nThere's been some relevant work here in the form of\nan HTTP extension (SUBSCRIBE/NOTIFY methods) in the past\nto deal with some of these issues.  It was work that\nwas previously done in the context of using HTTP for IM\nand it quite similar to the SIP subscription extensions.\n\nDoes this sound at all like something the group\nwould be interested in taking a closer look at ?\n\nthanks,\n\n---\nJosh\n\n\n\n>From: \"Eckhard Kantz\" <deltav@wegalink.de>\n>To: <ietf-dav-versioning@w3.org>\n>Subject: Re: WebDAV Invalidation (Was Re: Allow: header and supported \n>methods)\n>Date: Wed, 22 Aug 2001 21:40:39 +0200\n>\n>The protocol described in the ESI document allows to invalidate documents \n>that have been downloaded\n>to a local machine by applying a push technology. This could solve already \n>several conflict\n>situations or even partly prevent problems.\n>\n>On the other hand there seems to be an increasing need for more \n>fine-grained notification services\n>that extend the traditional access control systems. Picture 1 in the \n>following longer article tries\n>to classify them:\n>\n>\"Beyond 'Yes or No' - Extending Access Control in Groupware with \n>Negotiation and Awareness\"\n>(http://www.informatik.uni-bonn.de/~os/Publications/COOP98a.ps)\n>\n>Maybe those needs are also worth discussing if they could be supported in \n>the spec in order to allow\n>applications to build up on them. The invalidation protocol seems to be a \n>good basis also for this.\n>\n>Eckhard\n>\n>\n>-----Urspr?ngliche Nachricht-----\n>Von: Eric Sedlar\n>An: ietf-dav-versioning@w3.org\n>Gesendet: Dienstag, 21. August 2001 19:00\n>Betreff: WebDAV Invalidation (Was Re: Allow: header and supported methods)\n>\n>\n>Check out\n>http://www.esi.org/invalidation_protocol_1-0.html for some work that looks \n>pretty similar\n>to what we are talking about.\n>\n>--Eric\n>\n\n\n_________________________________________________________________\nGet your FREE download of MSN Explorer at http://explorer.msn.com/intl.asp\n\n\n\n", "id": "lists-006-12464511"}, {"subject": "Re: WebDAV Invalidation (Was Re: Allow: header and supported methods", "content": "[J?sh Cohen wrote]\n> ...wondering what people think about including the ability\n> to subscribe to events on resources?\n\nA similar idea came to my mind, too. However, maintaining events on a resource basis may easily\nbecome too much work in a real-world scenario.Let's look at a non-technical example where event\nprocessing takes place and where some ideas may be derived from. An avarage day in an office may\nserve as such an example:\n\nIn the morning someone enters the rooms of the office where he is employed. From now on he will be\nexposed to event notifications in the office:\n- arrival/leaving of other team members\n- telephone calls from customers\n- someone starting/finishing some piece of work\n- Looking at the screen of somebody else will provide to very high frequent event notifications\nabout where the mouse is pointing to and which keys are pressed in what sequence by the co-worker\n- ...\nLeaving the office will normally prevent from receiving anymore events (given the mobile was\nswitched off :)\n\nIn a technical sense an equivalent of an office could play the role of an event distribution point.\nMany resources,e.g. all documents belonging to one project, could be asked somehow to deliver events\nto such a distribution point, e.g. a virtual office.\n\nA person being interested in receiving events from a certain project that is maintained by a virtual\noffice could then subscribe to it and would receive from then on events that are delivered to that\nvirtual office. Subscription to a virtual office would be the equivalent of entering an office in\nthe morning and to unsubcribe from a virtual office would be the equivalent of leaving the office in\nthe evening respectively.\n\nIt sounds easy but for sure it isn't. Since it is commonly known that _every_ system can be pulled\ndown by overloading it with events some precautions have to be build in. For example, if someone has\nto respond to multiple phone calls per hour it will be hard to focus on concentrated work at the\nsame time. In the opposite, someone in a call center will most likely not have any problems to deal\nwith a very high number of phone calls per hour. So it seems that the receipient of events should be\nable to maintain a filter that prevents from receiving unwanted and maybe too many events.\n\nActually, there would be at least two sets of filter rules to be maintained, one set of rules that\napply to the virtual office and which will decide upon what events will be send from resources to\nthe virtual office for distribution. A second set of filter rules would limit the number of\navailable events further in order to get only the desired ones to the receipient. There may be still\nother sets of rules that deal for example with security and authorization issues (not everyone maybe\nallowed to receive all events).\n\nDoes this approach sounds reasonable?\n\n> Does this sound at all like something the group\n> would be interested in taking a closer look at ?\n\nI can vote only for myself, however, at the moment I am looking for all kinds of ideas that could\nhelp to get closer to an event model that would work reasonably well in Internet scale. To give some\nmore background, the event model should work for huge document repositories as well as for automatic\nsystems that are connected over the internet. Particularly it should allow to connect radio\nastronomy stations that are located around the globe and to control them remotely. Those stations\nhave the need to get synchronized with regard to their pointing positions, receiver frequencies and\nother observation parameters as well as to deliver notifications dependent on the received signals\nto mention only some of the requirements.\n\nEckhard\n\n\n\n", "id": "lists-006-12476247"}, {"subject": "RE: Changes to baseline section in draft 17..", "content": "The rewording Peter suggests is fine with me.  I'll make that\nchange if nobody objects.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Saturday, August 25, 2001 4:53 AM\nTo: gclemm@Rational.Com\nCc: ietf-dav-versioning@w3.org\nSubject: Changes to baseline section in draft 17...\n\n\nHi,\n\nI've had a quick look at the changes to the baseline section in the new\ndraft, seems OK, but spotted a couple of things:\n\nIn section 12.6.1 in the text above the diagram you refer to the\nproperty\nDAV:baselined-collection.  I think it should be DAV:baseline-collection.\n\nAlso I think it would help if we made it clearer that this example is\npopulating a collection based on a baseline (as opposed to creating a\nnew baseline based on a collection)...it sometimes seems odd to me that\nwe use BASELINE-CONTROL to do both these tasks.\n\nI would change the words to be something like:\n\n\"In this example, the collection /src is populated with members from an\nexisting baseline and is itself placed under baseline control.  A new\nversion-controlled configuration (/repo/vcc/128) is created and\nassociated with /src, and /src is initialized with version-controlled\nmembers whose DAV:checked-in versions are those selected by the\nDAV:baseline-collection (/repo/bc/15) of the specified baseline,\n/repo/blh/13/ver/8.  The following diagram illustrates the resulting\nstate on the server.\"\n\nRegards,\nPeter Raymond - MERANT.\n\n\n\n", "id": "lists-006-12487460"}, {"subject": "RE: WebDAV Invalidation (Was Re: Allow: header and supported methods", "content": "The WebI WG in the IETF is also working on cache invalidation.  I've been\nfollowing this effort in order to ensure that it works for DAV permissions\nchanges as well as content changes.  As far as I can tell with their\nrequirements, it will work, because invalidation of caches due to\npermissions changes is simple:\n\n - the only documents with permissions that can be cached at all are those\nthat are publicly readable\n - the only permissions change that affects the cache is a reduction in read\npermissions, from publicly readable to not publicly readable\n - the only message that needs to be sent to the cache is \"invalidate your\ncache for this item\"  Possibly the only detail to add is whether a new\ndownload is recommended or not.\n\nYou specifically mention push, which could mean just sending a simple\nnotification, or it could mean pushing the body.  I don't like pushing the\nnew body to clients.  The only thing that should be pushed is a message, as\nsimple as possible, saying \"invalidate your cache for this item; a new\ndownload should be done\".   This leaves the client able to make the request\nwhen most appropriate, which is more likely to be \"just-in-time\" than\npre-fetch.\n\nIt's possible for web sites to push a new body to sophisticated caching\nservers that they have a special relationship with; that makes web sites\nthat update in the night able to vastly reduce traffic by using low-load\ntimes to get the new content out one hop.  However, that's very different\nthan pushing to all clients.  I'd point out that these caching servers are\ntrying to figure out how to charge the web sites to improve their\navailability and reduce load in this manner.  In other words, push is\nsomething web sites are likely to have to pay for, because most end-points\ndon't want to receive a costly push for free.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Eckhard Kantz\n> Sent: Wednesday, August 22, 2001 12:41 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: WebDAV Invalidation (Was Re: Allow: header and supported\n> methods)\n>\n>\n> The protocol described in the ESI document allows to invalidate\n> documents that have been downloaded\n> to a local machine by applying a push technology. This could\n> solve already several conflict\n> situations or even partly prevent problems.\n>\n> On the other hand there seems to be an increasing need for more\n> fine-grained notification services\n> that extend the traditional access control systems. Picture 1 in\n> the following longer article tries\n> to classify them:\n>\n> \"Beyond 'Yes or No' - Extending Access Control in Groupware with\n> Negotiation and Awareness\"\n> (http://www.informatik.uni-bonn.de/~os/Publications/COOP98a.ps)\n>\n> Maybe those needs are also worth discussing if they could be\n> supported in the spec in order to allow\n> applications to build up on them. The invalidation protocol seems\n> to be a good basis also for this.\n>\n> Eckhard\n>\n>\n> -----Urspr?ngliche Nachricht-----\n> Von: Eric Sedlar\n> An: ietf-dav-versioning@w3.org\n> Gesendet: Dienstag, 21. August 2001 19:00\n> Betreff: WebDAV Invalidation (Was Re: Allow: header and supported methods)\n>\n>\n> Check out\n> http://www.esi.org/invalidation_protocol_1-0.html for some work\n> that looks pretty similar\n> to what we are talking about.\n>\n> --Eric\n\n\n\n", "id": "lists-006-12496720"}, {"subject": "DeltaV and ACL supported on Sharematio", "content": "Xythos WFS 3.1 has DeltaV and ACL support, and we've upgraded Sharemation\nrecently to this latest version.  Test accounts are available free on\nwww.sharemation.com, where some Web tools are available to examine access\ncontrol and versioning information.  You can also test client WebDAV\napplications against Sharemation accounts.\n\nFrom the DeltaV spec we support\n - basic versioning features\n - version-control\n - checkout in-place\n - version-history\n - working-resource\nWFS does not support forking.\nWFS allows versions to be deleted.\n\nFrom the ACL spec:\n - principal URL space\n - various ACL-related properties on resources\n - the ACL method\nWFS supports a custom set of privileges that map to the canonical list.\n\nLisa Dusseault\nXythos\n\n\n\n", "id": "lists-006-12509382"}, {"subject": "RE: client workspaces, merging and forkin", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n>    From: Alison Macmillan [mailto:alison.macmillan@oracle.com]\n>\n>    > [to checkin a working resource whose DAV:checked-out version does\nnot\n>    > match the DAV:checked-in version of the DAV:auto-update VCR]\n>    > Do what you would do on a non-forking server, i.e. checkout the new\n>    > version to get a new working resource, merge the contents of your\nold\n>    > working resource into that new working resource, delete the old\n>    > working resource, and then checkin the new working resource (and if\n>    > someone else has checked in a new version since your checkout,\n>    > repeat the process).\n>\n>    Or, could you also just merge from the DAV:checked-in version of the\nVCR\n> to\n>    the working resource, and then check in the working resource? (Now\nthat a\n>    working resource can be a merge target).\n>\n> Not by the current protocol, since the DAV:no-overwrite-by-auto-update\n> postcondition states:\n>\n>  If the DAV:auto-update property for the checked-out resource\n>  identifies a version-controlled resource, the DAV:checked-out property\n>  of the checked-out resource MUST identify the same version as the\n>  DAV:checked-in property of that version-controlled resource.\n>\n> We could relax that constraint to say:\n>\n>  If the DAV:auto-update property for the checked-out resource\n>  identifies a version-controlled resource, at least one of the\n>  versions identified by the DAV:predecessor-set property of the\n>  checked-out resource MUST identify a version that is either the same\n>  as or a descendant of the version identified by the DAV:checked-in\n>  property of that version-controlled resource.\n>\n> If there are no objections, I'll place this on the \"editorial fix\"\n> list for draft 17.\n\nI object to this -- it is certainly not an editorial fix.\n\nThe purpose of this postcondition is to prevent the auto-update overwriting\nchanges made by other clients, by ensuring that the update is being applied\nto the same state of the resource that was checked-out.  With this proposed\nrewrite data can be lost unwittingly.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12516976"}, {"subject": "Re: client workspaces, merging and forkin", "content": "Tim Ellison wrote:\n\n> \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> >    From: Alison Macmillan [mailto:alison.macmillan@oracle.com]\n> >\n> >    > [to checkin a working resource whose DAV:checked-out version does\n> not\n> >    > match the DAV:checked-in version of the DAV:auto-update VCR]\n> >    > Do what you would do on a non-forking server, i.e. checkout the new\n> >    > version to get a new working resource, merge the contents of your\n> old\n> >    > working resource into that new working resource, delete the old\n> >    > working resource, and then checkin the new working resource (and if\n> >    > someone else has checked in a new version since your checkout,\n> >    > repeat the process).\n> >\n> >    Or, could you also just merge from the DAV:checked-in version of the\n> VCR\n> > to\n> >    the working resource, and then check in the working resource? (Now\n> that a\n> >    working resource can be a merge target).\n> >\n> > Not by the current protocol, since the DAV:no-overwrite-by-auto-update\n> > postcondition states:\n> >\n> >  If the DAV:auto-update property for the checked-out resource\n> >  identifies a version-controlled resource, the DAV:checked-out property\n> >  of the checked-out resource MUST identify the same version as the\n> >  DAV:checked-in property of that version-controlled resource.\n> >\n> > We could relax that constraint to say:\n> >\n> >  If the DAV:auto-update property for the checked-out resource\n> >  identifies a version-controlled resource, at least one of the\n> >  versions identified by the DAV:predecessor-set property of the\n> >  checked-out resource MUST identify a version that is either the same\n> >  as or a descendant of the version identified by the DAV:checked-in\n> >  property of that version-controlled resource.\n> >\n> > If there are no objections, I'll place this on the \"editorial fix\"\n> > list for draft 17.\n>\n> I object to this -- it is certainly not an editorial fix.\n>\n> The purpose of this postcondition is to prevent the auto-update overwriting\n> changes made by other clients, by ensuring that the update is being applied\n> to the same state of the resource that was checked-out.  With this proposed\n> rewrite data can be lost unwittingly.\n>\n\nHow are other client's changes overwritten? Doesn't the constraint on the value\nof DAV:predecessor-set indicate that the appropriate merge has happened?\n\nR'gds,\nAlison.\n\n--\n -------------------------------------------------------------\n The statements and opinions expressed here are my own\n and do not necessarily represent those of Oracle Corporation.\n -------------------------------------------------------------\n\n\n\n", "id": "lists-006-12527332"}, {"subject": "RE: client workspaces, merging and forkin", "content": "I agree with Alison.  If the DAV:checked-in version of the VCR is\nan ancestor of the checked-out resource, by definition the content\nof the VCR has been \"included\" in the content of the checked-out\nresource (that's the defined semantics of \"ancestor\").  This could\nhappen because:\n- the UPDATE method was used to set the DAV:checked-in version to\nbe a predecessor of the current DAV:checked-in version\n- the owner of the checked-out resource explicitly added the current\nDAV:checked-in version to the DAV:predecessor-set of the checked-out\nresource (assumedly, after merging the content of the DAV:checked-in\nversion into the content of the checked-out resource).\n\nIn either case, it should be legal for the checked-out resource to\nbe checked in, which is what the revised postcondition allows.  \n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Alison Macmillan [mailto:alison.macmillan@oracle.com]\nSent: Tuesday, September 04, 2001 8:13 AM\nTo: Tim Ellison\nCc: ietf-dav-versioning@w3.org\nSubject: Re: client workspaces, merging and forking\n\n\n\n\nTim Ellison wrote:\n\n> \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> >    From: Alison Macmillan [mailto:alison.macmillan@oracle.com]\n> >\n> >    > [to checkin a working resource whose DAV:checked-out version does\n> not\n> >    > match the DAV:checked-in version of the DAV:auto-update VCR]\n> >    > Do what you would do on a non-forking server, i.e. checkout the new\n> >    > version to get a new working resource, merge the contents of your\n> old\n> >    > working resource into that new working resource, delete the old\n> >    > working resource, and then checkin the new working resource (and if\n> >    > someone else has checked in a new version since your checkout,\n> >    > repeat the process).\n> >\n> >    Or, could you also just merge from the DAV:checked-in version of the\n> VCR\n> > to\n> >    the working resource, and then check in the working resource? (Now\n> that a\n> >    working resource can be a merge target).\n> >\n> > Not by the current protocol, since the DAV:no-overwrite-by-auto-update\n> > postcondition states:\n> >\n> >  If the DAV:auto-update property for the checked-out resource\n> >  identifies a version-controlled resource, the DAV:checked-out property\n> >  of the checked-out resource MUST identify the same version as the\n> >  DAV:checked-in property of that version-controlled resource.\n> >\n> > We could relax that constraint to say:\n> >\n> >  If the DAV:auto-update property for the checked-out resource\n> >  identifies a version-controlled resource, at least one of the\n> >  versions identified by the DAV:predecessor-set property of the\n> >  checked-out resource MUST identify a version that is either the same\n> >  as or a descendant of the version identified by the DAV:checked-in\n> >  property of that version-controlled resource.\n> >\n> > If there are no objections, I'll place this on the \"editorial fix\"\n> > list for draft 17.\n>\n> I object to this -- it is certainly not an editorial fix.\n>\n> The purpose of this postcondition is to prevent the auto-update\noverwriting\n> changes made by other clients, by ensuring that the update is being\napplied\n> to the same state of the resource that was checked-out.  With this\nproposed\n> rewrite data can be lost unwittingly.\n>\n\nHow are other client's changes overwritten? Doesn't the constraint on the\nvalue\nof DAV:predecessor-set indicate that the appropriate merge has happened?\n\nR'gds,\nAlison.\n\n--\n -------------------------------------------------------------\n The statements and opinions expressed here are my own\n and do not necessarily represent those of Oracle Corporation.\n -------------------------------------------------------------\n\n\n\n", "id": "lists-006-12538005"}, {"subject": "RE: Issues/questions regarding sections 3, 4 and 5..", "content": "Good.\n\nI already forbid deleting the only version, though I didn't know the\nspec actually said I had too.\n\nThat didn't prevent me from having someone try to delete the only\nversion and log a bug because they couldn't. :)\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> Sent: Wednesday, August 22, 2001 12:13 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Issues/questions regarding sections 3, 4 and 5...\n> \n> \n> Ah, the wonderful ambiguities of English ... (:-).\n> \n> This thread was about deleting the \"last\" version in the \n> sense of \"the only version left in the version history\".  The \n> result of this would be a version history with no versions in \n> it, which is not allowed by the spec.\n> \n> I believe you are referring to the \"last\" version in the \n> sense of \"the one that was created most recently in a linear \n> history\". That is totally legal to delete (assuming it is not \n> the only version left in the history), and having the VCR \n> revert to the immediately preceding version is very \n> reasonable (although not required by the protocol).\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net]\n> Sent: Wednesday, August 22, 2001 1:58 PM\n> To: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\n> Subject: RE: Issues/questions regarding sections 3, 4 and 5...\n> \n> \n> \n> \n> >    Reading section 5.6 it took us quite a while to decide how to\n> >    delete the last version from a version history.  I think \n> the answer\n> >    is \"you don't\" you must delete the version history \n> itself in order\n> >    to delete the last version.  Did we interpret this correctly?  Do\n> >    you think we should clarify this in the spec?\n> \n> \n> As currently implemented, my server will allow you to delete \n> the last version.  That version goes away and the VCR reverts \n> to the next to last version.\n> \n> That solution works because I don't fork.\n> \n> But if the consensus is to prohibit this I can prohibit it \n> (except as a side effect of UNCHECKOUT, though).\n> \n> \n\n\n\n", "id": "lists-006-12550183"}, {"subject": "No recommendation for how to make a resource unversione", "content": "Given the controversy and the problems with every method that's been\nsuggested to make a resource unversioned, I suggest that the DeltaV draft\nshould be silent on the question.  That means striking the non-normative\nnote on how clients might achieve this with COPY, DELETE, MOVE (a\nproblematic approach because COPY creates a new resource, and thus\ninitializes all sorts of new-resources stuff like default ACLs,\ncreationdate, owner, access history).\n\nI think we'll need to deal with this issue in the future, but it can wait.\n\nlisa\n\n\n\n", "id": "lists-006-12561220"}, {"subject": "RE: No recommendation for how to make a resource unversione", "content": "That sounds like a sensible suggestion to me.\nI'll make that change in the final editorial pass,\nif nobody objects.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Tuesday, September 04, 2001 2:39 PM\nTo: DeltaV\nSubject: No recommendation for how to make a resource unversioned\n\n\n\nGiven the controversy and the problems with every method that's been\nsuggested to make a resource unversioned, I suggest that the DeltaV draft\nshould be silent on the question.  That means striking the non-normative\nnote on how clients might achieve this with COPY, DELETE, MOVE (a\nproblematic approach because COPY creates a new resource, and thus\ninitializes all sorts of new-resources stuff like default ACLs,\ncreationdate, owner, access history).\n\nI think we'll need to deal with this issue in the future, but it can wait.\n\nlisa\n\n\n\n", "id": "lists-006-12569550"}, {"subject": "REPORT", "content": "I've been on vacation, but I've tried to keep up.\n\nIn version #17 the expand-property report has been moved from an\noptional report (Section 15 of version #16) to a SHOULD implement in\n3.8.\n\nI object to it being listed there, and I recall no discussion let alone\na consensus to moving it from section 15.  Outlook does not find\n'expand-property' listed in any discussion of this type in my folder\ndedicated to DeltaV messages.  As an optional report, I did not pay any\nattention to it.  The nesting feature (properties within properties)\nmakes this a very difficult and annoying feature to implement or use\nIMHO.\n\n====================\n\nThe version-tree report also seems to be defined differently (in 16 as\nwell as 17) than I thought.  I can implement it that way (fix my\nimplementation), but it seems more limited that it should be.\n\nFor example, I see no reason to redirect a version-tree report to the\nchecked-out version of a VCR.  It makes more sense to print the\nfollowing information, if the target is a VCR:\n\n1. A listing for the VCR (properties can be different than for a\nversion)\nFollowed by a listing for each version in the VCR (starting with the\nlatest version and continuing on down).\n\nAs currently defined, it takes 2 calls to get all the properties you\nwant on all the versions of a file.  One to pick up any properties on\nthe VCR including the location of the VHR and the other to pick up\nadditional properties on the file versions.\n\nAcutally, I'd far prefer the following definition for version 3.7:\n\nThe DAV:version-tree report describes the requested properties of all\nthe versions in the version history of a version.  If the report is\nrequested for a version-controlled resource, then the requested\nproperties of the version-controlled resource are supplied in addition\nto the requested properties for all the versions in the version history\nof the version.\n\nA server MAY support a depth value other than 0.  If so, the report may\ntarget a collection and the report is applied to each versioned\ncontrolled resource in the tree.\n\n\n\n", "id": "lists-006-12578198"}, {"subject": "RE: No recommendation for how to make a resource unversione", "content": "I agree.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: 04 September 2001 19:39\n> To: DeltaV\n> Subject: No recommendation for how to make a resource unversioned\n>\n>\n>\n> Given the controversy and the problems with every method that's been\n> suggested to make a resource unversioned, I suggest that the DeltaV draft\n> should be silent on the question.  That means striking the non-normative\n> note on how clients might achieve this with COPY, DELETE, MOVE (a\n> problematic approach because COPY creates a new resource, and thus\n> initializes all sorts of new-resources stuff like default ACLs,\n> creationdate, owner, access history).\n>\n> I think we'll need to deal with this issue in the future, but it can wait.\n>\n> lisa\n>\n\n\n\n", "id": "lists-006-12589033"}, {"subject": "RE: No recommendation for how to make a resource unversione", "content": "Me to.\n\n\n\n\n\"Tim Ellison\" <tim@peir.com>\nSent by: ietf-dav-versioning-request@w3.org\n09/04/2001 05:59 PM\n\n \n        To:     \"DeltaV\" <ietf-dav-versioning@w3.org>\n        cc: \n        Subject:        RE: No recommendation for how to make a resource unversioned\n\n \n\nI agree.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: 04 September 2001 19:39\n> To: DeltaV\n> Subject: No recommendation for how to make a resource unversioned\n>\n>\n>\n> Given the controversy and the problems with every method that's been\n> suggested to make a resource unversioned, I suggest that the DeltaV \ndraft\n> should be silent on the question.  That means striking the non-normative\n> note on how clients might achieve this with COPY, DELETE, MOVE (a\n> problematic approach because COPY creates a new resource, and thus\n> initializes all sorts of new-resources stuff like default ACLs,\n> creationdate, owner, access history).\n>\n> I think we'll need to deal with this issue in the future, but it can \nwait.\n>\n> lisa\n>\n\n\n\n", "id": "lists-006-12597763"}, {"subject": "extending method request/response bodie", "content": "Hi,\n\njust a check:\n\nis it ok to put \"arbitrary\" extension elements into deltaV request/response\nbodies, as long as they don't live in the DAV: namespace?\n\nJulian\n\n\n\n", "id": "lists-006-12608195"}, {"subject": "RE: extending method request/response bodie", "content": "Yes, as long as the extension elements can safely be ignored by servers\nand clients that don't understand them (this is a WebDAV requirement,\nnot a DeltaV requirement).\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\nSent: Tuesday, September 04, 2001 7:22 PM\nTo: ietf-dav-versioning@w3.org\nSubject: extending method request/response bodies\n\n\nHi,\n\njust a check:\n\nis it ok to put \"arbitrary\" extension elements into deltaV request/response\nbodies, as long as they don't live in the DAV: namespace?\n\nJulian\n\n\n\n", "id": "lists-006-12615971"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "OK,\n\nwhere's the best place to compile a list of known bug in Microsoft's\nwebfolders?\n\nJulian\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Stefan Eissing\n> Sent: Thursday, June 07, 2001 10:01 AM\n> To: DeltaV (E-mail)\n> Subject: AW: Removing the DAV:activity and DAV:version-history and\n> DAV:bas eline resource type values\n>\n>\n> > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n> >\n> > Yes, that is what has been reported.\n> >\n> > Although if I am wrong about the lack of support for lock-null\n> > resources, maybe I'm wrong about this too ... I hope not!\n> > (I don't suppose two wrongs make a right in this case? :-)\n>\n> MS Webfolders display a folder icon for resources where the\n> resourcetype is non-empty. Just tested.\n>\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n> > Sent: Wednesday, June 06, 2001 5:57 PM\n> > To: Clemm, Geoff; DeltaV (E-mail)\n> > Subject: RE: Removing the DAV:activity and DAV:version-history and\n> > DAV:bas eline resource type values\n> >\n> >\n> > could you expand a bit on what the bug is? Are they treating\n> > anything with a\n> > non-empty resourcetype as collection?\n> >\n> >\n>\n>\n>\n\n\n\n", "id": "lists-006-1261852"}, {"subject": "Re: No recommendation for how to make a resource unversione", "content": "On Tue, Sep 04, 2001 at 11:39:26AM -0700, Lisa Dusseault wrote:\n> \n> Given the controversy and the problems with every method that's been\n> suggested to make a resource unversioned, I suggest that the DeltaV draft\n> should be silent on the question.  That means striking the non-normative\n> note on how clients might achieve this with COPY, DELETE, MOVE (a\n> problematic approach because COPY creates a new resource, and thus\n> initializes all sorts of new-resources stuff like default ACLs,\n> creationdate, owner, access history).\n> \n> I think we'll need to deal with this issue in the future, but it can wait.\n\nI agree with Lisa.\n\nBen\n\n\n\n", "id": "lists-006-12624259"}, {"subject": "RE: client workspaces, merging and forkin", "content": "> In either case, it should be legal for the checked-\n> out resource to be checked in, which is what the\n> revised postcondition allows.\n\nOk, I agree -- I had to draw it out to convince myself<g>\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12631970"}, {"subject": "Re: REPORT", "content": "\"John Hall\" <johnhall@evergo.net> wrote:\n\n> I've been on vacation, but I've tried to keep up.\n>\n> In version #17 the expand-property report has been\n> moved from an optional report (Section 15 of\n> version #16) to a SHOULD implement in 3.8.\n>\n> I object to it being listed there, and I recall no\n> discussion let alone a consensus to moving it from\n> section 15.  Outlook does not find 'expand-property'\n> listed in any discussion of this type in my folder\n> dedicated to DeltaV messages.  As an optional report,\n> I did not pay any attention to it.  The nesting\n> feature (properties within properties) makes this a\n> very difficult and annoying feature to implement or\n> use IMHO.\n\nThis was discussed in the ondon IETF meeting and reported in the minutes\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JulSep/0193.html\n\n\nAs I recall, there was little objection in the room to this report as it\nwas considered a relatively simple recursion for the client and/or server\nto implement.\n\n> ====================\n>\n> The version-tree report also seems to be defined\n> differently (in 16 as well as 17) than I thought.  I\n> can implement it that way (fix my implementation), but\n> it seems more limited that it should be.\n>\n> For example, I see no reason to redirect a version-tree\n> report to the checked-out version of a VCR.  It makes\n> more sense to print the following information, if the target\n> is a VCR:\n>\n> 1. A listing for the VCR (properties can be different\n> than for a version)\n> Followed by a listing for each version in the VCR (starting\n> with the latest version and continuing on down).\n\nNot sure what you mean here.  The 'redirect' to the version is simply a\nconvenience.  What do you mean by \"each version in the VCR\"?  The report\nwill be applied to all versions in the version history of a version.\n\n> As currently defined, it takes 2 calls to get all the\n> properties you want on all the versions of a file.\n\nNo, the properties will be returned for all versions on a single REPORT\nrequest.\n\n> One to pick up any properties on the VCR including the\n> location of the VHR and the other to pick up additional\n> properties on the file versions.\n\nThe version tree report reports properties on versions.  You would simply\nuse PROPFIND to get the properties for a version-controlled resource.  Of\ncourse, you could use the expand property report to get properties for a\nversion-controlled resource and its checked-in/-out version and/or version\nhistory.\n\n> Acutally, I'd far prefer the following definition for\n> version 3.7:\n>\n> The DAV:version-tree report describes the requested\n> properties of all the versions in the version history\n> of a version.  If the report is requested for a\n> version-controlled resource, then the requested properties\n> of the version-controlled resource are supplied in addition\n> to the requested properties for all the versions in the\n> version history of the version.\n\nI have no strong objection to tis, but would like to see the `compelling\nuse case' that warrants a change.\n\n> A server MAY support a depth value other than 0.  If so,\n> the report may target a collection and the report is\n> applied to each versioned controlled resource in the tree.\n\nThis is already covered in the postcondition for REPORT, right?\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12639158"}, {"subject": "RE: REPORT", "content": "I agree with all of Tim's comments below.\nIn particular, having a \"version-tree\" report\nalso report on the properties of the version-controlled\nresource does not make sense to me, since the\nversion-controlled resource is not part of the\nversion tree.  And as Tim points out, this kind\nof \"batching\" is what the expand-property report\nis all about (in a non-special-cased manner).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\nSent: Wednesday, September 05, 2001 9:23 AM\nTo: 'DeltaV'\nSubject: Re: REPORTS\n\n\n\"John Hall\" <johnhall@evergo.net> wrote:\n\n> I've been on vacation, but I've tried to keep up.\n>\n> In version #17 the expand-property report has been\n> moved from an optional report (Section 15 of\n> version #16) to a SHOULD implement in 3.8.\n>\n> I object to it being listed there, and I recall no\n> discussion let alone a consensus to moving it from\n> section 15.  Outlook does not find 'expand-property'\n> listed in any discussion of this type in my folder\n> dedicated to DeltaV messages.  As an optional report,\n> I did not pay any attention to it.  The nesting\n> feature (properties within properties) makes this a\n> very difficult and annoying feature to implement or\n> use IMHO.\n\nThis was discussed in the ondon IETF meeting and reported in the minutes\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JulSep/0193.html\n\n\nAs I recall, there was little objection in the room to this report as it\nwas considered a relatively simple recursion for the client and/or server\nto implement.\n\n> ====================\n>\n> The version-tree report also seems to be defined\n> differently (in 16 as well as 17) than I thought.  I\n> can implement it that way (fix my implementation), but\n> it seems more limited that it should be.\n>\n> For example, I see no reason to redirect a version-tree\n> report to the checked-out version of a VCR.  It makes\n> more sense to print the following information, if the target\n> is a VCR:\n>\n> 1. A listing for the VCR (properties can be different\n> than for a version)\n> Followed by a listing for each version in the VCR (starting\n> with the latest version and continuing on down).\n\nNot sure what you mean here.  The 'redirect' to the version is simply a\nconvenience.  What do you mean by \"each version in the VCR\"?  The report\nwill be applied to all versions in the version history of a version.\n\n> As currently defined, it takes 2 calls to get all the\n> properties you want on all the versions of a file.\n\nNo, the properties will be returned for all versions on a single REPORT\nrequest.\n\n> One to pick up any properties on the VCR including the\n> location of the VHR and the other to pick up additional\n> properties on the file versions.\n\nThe version tree report reports properties on versions.  You would simply\nuse PROPFIND to get the properties for a version-controlled resource.  Of\ncourse, you could use the expand property report to get properties for a\nversion-controlled resource and its checked-in/-out version and/or version\nhistory.\n\n> Acutally, I'd far prefer the following definition for\n> version 3.7:\n>\n> The DAV:version-tree report describes the requested\n> properties of all the versions in the version history\n> of a version.  If the report is requested for a\n> version-controlled resource, then the requested properties\n> of the version-controlled resource are supplied in addition\n> to the requested properties for all the versions in the\n> version history of the version.\n\nI have no strong objection to tis, but would like to see the `compelling\nuse case' that warrants a change.\n\n> A server MAY support a depth value other than 0.  If so,\n> the report may target a collection and the report is\n> applied to each versioned controlled resource in the tree.\n\nThis is already covered in the postcondition for REPORT, right?\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12649756"}, {"subject": "RE: REPORT", "content": "> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net] \n> Sent: Wednesday, September 05, 2001 2:25 PM\n> To: 'Clemm, Geoff'; 'DeltaV'\n> Subject: RE: REPORTS\n> \n> \n> Tim, I have an email folder where I keep all the message \n> traffic.  I do not have that message.  I have a message where \n> you replied on 8/14/01, but I don't have the original.  I \n> don't know what could have happened to it.\n> \n> This is NOT a simple recursion, at least not on my server.\n> \n> Version-tree is just a propfind -- for client and server.  \n> Expand-property is a complete rewrite -- for client and \n> server.  I probably spent an hour or two on version-tree, and \n> a client would need less.  Expand-property is at least 2 \n> orders of magnitude more difficult (at least on my server). \n> \n> I do know you will find several refereneces to \n> expand-property by me -- all indicating that there was \n> absolutely no plans for implementation of that optional \n> report in my server.  I don't see how moving this can be \n> considered 'by consensus'.\n> \n> It was considered OPTIONAL before, it still should be.  At a \n> minimum, change the SHOULD to a MAY.\n> \n> ===============\n> \n> I do not agree that the VCR is not properly associated with \n> the list of previous versions.  They are intimately related \n> both on my server and, to the best of my ability to predict, \n> the minds of my users.  I have no PROBLEM crippling the \n> report (version-tree) to comply with the spec.  So I guess \n> I'll let that one rest.\n> \n> > \n> > This was discussed in the ondon IETF meeting and reported in\n> > the minutes \n> > \n> http://lists.w3.org/Archives/Public/ietf-dav-versioning/2001Ju\nlSep/0193.html\n> \n> \n> As I recall, there was little objection in the room to this\n> report as it was considered a relatively simple recursion for \n> the client and/or server to implement.\n\n\n\n", "id": "lists-006-12660870"}, {"subject": "RE: REPORT", "content": "> From: John Hall [mailto:johnhall@evergo.net] \n> \n>> This was discussed in the London IETF meeting and reported in\n>> the minutes \n>>\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JulSep/0193.html\n>> As I recall, there was little objection in the room to this\n>> report as it was considered a relatively simple recursion for \n>> the client and/or server to implement.\n\n> This is NOT a simple recursion, at least not on my server.\n> Version-tree is just a propfind -- for client and server.  \n> Expand-property is a complete rewrite -- for client and \n> server.  I probably spent an hour or two on version-tree, and \n> a client would need less.  Expand-property is at least 2 \n> orders of magnitude more difficult (at least on my server). \n\nThe expand-property report is precisely a recursive PROPFIND\n(i.e. when the server hits a specified property value that contains an\nhref, it recursively invoke PROPFIND on that href (just dumping the\nresults to the same output stream as nested XML). How is this not a\nsimple recursion?\n\nAnd note that no rewriting of your client is necessary ...  your\nclient does not have to invoke expand-property unless it choses to do\nso, since it is just a performance optimization (i.e. decreases the\nnumber of roundtrips).\n\n> I do know you will find several refereneces to \n> expand-property by me -- all indicating that there was \n> absolutely no plans for implementation of that optional \n> report in my server.  I don't see how moving this can be \n> considered 'by consensus'.\n\nNote that \"consensus\" does not mean \"unanimous\".  Note also that\n\"SHOULD\" (unlike \"MUST\") tells the client that it needs to be prepared\nfor servers that chose not to implement it, so a server is in\ncompliance even if it does not implement a SHOULD.\n\nPerhaps you could provide more explanation about why you can't just\ninvoke your PROPFIND code recursively on your server to produce the\nexpand-property report?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12670012"}, {"subject": "RE: REPORT", "content": "> Note that \"consensus\" does not mean \"unanimous\".\n\nHowever, the IETF is pretty clear that consensus obtained during a meeting\nis subject to review by the mailing list, and that's what's happening here.\n\nPerhaps a review of the need for expand-property report?  Do we have client\nimplementors on the list who need this report?\n\nlisa\n\n\n\n", "id": "lists-006-12679141"}, {"subject": "RE: REPORT", "content": "> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net] \n> Sent: Wednesday, September 05, 2001 4:48 PM\n> To: 'Clemm, Geoff'; 'DeltaV'\n> Subject: RE: REPORTS\n> \n> \n> \n> Perhaps you could provide more explanation about why you \n> can't just invoke your PROPFIND code recursively on your \n> server to produce the expand-property report?\n> \n> ======================================================\n> \n> Current code propfind:\n> Parse propfind.\n> Get a list of directory entries.\n> Print common top code for propfind.\n> Itterate through list of entries, printing property values \n> found. Producing output that looks identical to a propfind response.\n> \n> Current code version-history:\n> Parse essentially identical to propfind.\n> Cripple report to only deal with one item at a time, getting \n> one directory entry. Print common top code for propfind. For \n> entry, note flag that says \"print all versions for this \n> file\". Itterate through file versions, printing property \n> values found. Producing output that looks identical to a \n> propfind response.\n> \n> \n> Projected code\n> Rewrite parsing code entirely, trying to keep track of nested \n> conditional property lists. Get an initial list of directory \n> entries. Print common top code for propfind. Iterate through \n> list as before.\n> \n> OOPS -- they asked for an extra special property that just \n> happens to be a list of hrefs.  (Hard code knowledge of type \n> of property here, and the fact that it requires extra special \n> processing).  Hmmm.  Hit the database again I guess, trying \n> to keep track of a separate list of directory entries along \n> with a separate list of property elements applied to those \n> directory entries, producing a different form of output (due \n> to nesting) than before.  (Hard code searches, probably, for \n> each supported DeltaV property that contains an href and is \n> supported / generated -- since the type of processing \n> necessary depends radically on what type of 'href' it is.  \n> Rememeber to reset the property list of the object each and \n> every time you return from a call, since it could have changed.).  \n> \n> Potential additional complications due to organization of database.\n> \n> A bloody nightmare, actually.\n> \n> ================================================\n> \n> I don't regard this as a trivial change in the spec.  And I \n> thought we were in a period where we were making changes only \n> if no objection was raised in the interest of stabilizing the \n> draft and sending it out the door.\n> \n\n\n\n", "id": "lists-006-12686360"}, {"subject": "RE: REPORT", "content": "\"John Hall\" <johnhall@xythos.com> wrote:\n\n> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net]\n> Sent: Wednesday, September 05, 2001 2:25 PM\n> To: 'Clemm, Geoff'; 'DeltaV'\n> Subject: RE: REPORTS\n>\n>\n> Tim, I have an email folder where I keep all the message\n> traffic.  I do not have that message.  I have a message where\n> you replied on 8/14/01, but I don't have the original.  I\n> don't know what could have happened to it.\n\nSorry, can't help you there<g>\n\n> This is NOT a simple recursion, at least not on my server.\n\nI'm not implying that it is, but reporting my view of the opinion expressed\nin the meeting.\n\n> Version-tree is just a propfind -- for client and server.\n> Expand-property is a complete rewrite -- for client and\n> server.  I probably spent an hour or two on version-tree, and\n> a client would need less.  Expand-property is at least 2\n> orders of magnitude more difficult (at least on my server).\n\nOk, but with the greatest respect that is not a good enough reason to\nobject to the spec.  Clearly it is technically possible becuase a number of\nothers have either already implemented it without too much pain, or did not\nobject on the grounds of technical difficulty.\n\n> I do know you will find several refereneces to\n> expand-property by me -- all indicating that there was\n> absolutely no plans for implementation of that optional\n> report in my server.  I don't see how moving this can be\n> considered 'by consensus'.\n\nThere were no objections raised in the meeting or when the minutes were\npublished.  I'd consider that a consensus.\n\nFrom RFC2418 \"Working Group Guidelines\":\n\n'The core rule for operation is that acceptance or agreement is achieved\nvia working group \"rough consensus\".'\n\n'Note that 51% of the working group does not qualify as \"rough consensus\"\nand 99% is better than rough.'\n\n> It was considered OPTIONAL before, it still should be.  At a\n> minimum, change the SHOULD to a MAY.\n\nHow does this help?  They are both imply the functionality is optional.\n\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12696129"}, {"subject": "RE: REPORT", "content": "> Perhaps a review of the need for expand-property report?\n> Do we have client implementors on the list who need\n> this report?\n\nIts an important optimization in a number of scenarios.  Given a version\nhistory the expand-property report allows for a number of interesting\nqueries, such as all version-controlled resources referencing versions in\nthat version history (useful just before a DELETE).  For a\nbaseline-controlled collection it allows us to get the baseline collection\nin a single request (via the version-controlled configuration and\nbaseline).  Given a version it allows a client to determine all the\nversions in the same activity, and so on.  The list is extensive.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12705503"}, {"subject": "DAV:expand-property report (was RE: REPORTS", "content": "The most important point is the one Tim made, namely\nthat marking a feature as SHOULD rather than MAY does\nnot substantively affect what a server or client needs\nto code up, but just represents guidance to server writers\nas to the importance of an optional feature.  This is\nclearly something that will not be unanimous (since otherwise\nthe feature would either be removed or marked as a MUST).\n\nTo substantiate my claim that DAV:expand-property\nis straightforward to implement, I'll submit the\nfollowing pseudo-code (this assumes your implementation language\nsupports recursion).\n\nCheers,\nGeoff\n\nhandleDepthExpProp(httpRequest:String) {\n   r: Resource;\n   expPropArgs: ParsedXML;\n   depth: Integer;\n\n   r = lookupResource(getRequestURL(httpRequest));\n   expPropArgs = xmlParse(getBody(httpRequest));\n   depth = getDepth(httpRequest);\n   # depth is -1 if Depth:infinity is specified\n   addInitialMultistatusBoilerplateToResponse();\n   doDepthExpProp(r, expPropArgs, depth);\n   addFinalMultistatusBoilderplateToResponse(); }\n\n\ndoDepthExpProp(r:Resource, expPropArgs:ParsedXml, depth:Integer) {\n   i: Integer;\n   mem: Resource;\n\n   doExpProp(expPropArgs, r);\n   while (depth!=0) {\n      for (i=0; i<numInternalMembers(r); i++) {\n         mem=getInternalMember(r, i);\n         doDepthExpProp(mem, expPropArgs, depth-1); } } }\n\n\ndoExpProp(r:Resource, expPropArgs:ParsedXml) {\n   i: Integer;\n   expPropArg: ParsedXml;\n   value: String;\n   parsedValue: ParsedXml;\n\n   addInitialResponseBoilderplateToResponse(r);\n   for (i=0; i<numChild(expPropArgs); i++) {\n      expPropArg = getChild(expPropArgs, i);\n      value = getPropValue(r, getProp(expPropArg));\n      if (numChild(expPropArg) == 0) {\n         addPropValueToResponse(value)\n      }else{\n         parsedValue = xmlParse(value);\n         addExpandedPropValueToResponse(parsedValue, expPropArg); } }\n   addFinalResponseBoilderplateToResponse(); }\n\n\naddExpandedPropValueToResponse(parsedValue:ParsedXml, expPropArg:ParsedXml)\n{\n   r: Resource;\n   i: Integer;\n   subValue: ParsedXml;\n\n   if (isHref(parsedValue)) {\n      r = getHrefResource(parsedValue);\n      doExpProp(r, expPropArg);\n   }else if (isText(parsedValue)) {\n      addTextToResponse(parsedValue);\n   }else{\n      addBeginXmlNodeToResponse(xmlRoot(parsedValue));\n      for (i=0; i<numChild(parsedValue); i++) {\n         subValue = getChild(parsedValue, i);\n         addExpandedPropValueToResponse(subValue, expPropArg); };\n      addEndXmlNodeToResponse(xmlRoot(parsedValue)); }}}\n   \n   \nThe outer recursion handles the depth traversal.\nThe inner recursion handles the nested expand property.\nEach routine just has one if statement to stop the recursion,\nand one loop to iterate over the appropriate children.\nNot trivial perhaps, but pretty straightforward.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12713002"}, {"subject": "RE: REPORT", "content": "> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net] \n> Sent: Thursday, September 06, 2001 9:58 AM\n> To: 'Tim Ellison'; 'DeltaV'\n> Subject: RE: REPORTS\n> \n> \n> > \n> > There were no objections raised in the meeting or when the\n> > minutes were published.  I'd consider that a consensus.\n> \n> \n> It was the equivalent of slipping language in a bill at \n> reconciliation time, without debate, after midnight when \n> everyone else had gone home, then rushing the bill out for \n> signature before anyone noticed.\n> \n> MAY is more appropriate than SHOULD given the late date at \n> which the change was made, the manner of the change, and the \n> fact that a commercial implementation of the spec will not be \n> implementing this report and will recommend that clients who \n> wish to be interoperable avoid it as well.\n> \n> And if there is no difference between MAY and SHOULD, then \n> there should be no objection to making it MAY.\n> \n\n\n\n", "id": "lists-006-12722174"}, {"subject": "RE: MK* and lock-null (was: Re: Deleting versions", "content": "Greg wrote:\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Greg Stein\n> Sent: 07 June 2001 06:28\n> To: DeltaV\n> Cc: ejw@cse.ucsc.edu\n> Subject: MK* and lock-null (was: Re: Deleting versions)\n>\n>\n> On Wed, Jun 06, 2001 at 12:47:45PM -0400, Clemm, Geoff wrote:\n> >...\n> > So let's get some feedback from the working group:\n> > Who thinks that the ability to apply MKWORKSPACE or MKACTIVITY\n> > is a versioning/locking interaction that merits explicit\n> > mention in the versioning protocol?  (I think we can take it\n> > as given that Lisa thinks \"yes\" and I think \"no\").\n>\n> I think that we should explicitly specify that (contrary to RFC 2518), a\n> MKWORKSPACE or MKACTIVITY can be applied to a locknull resource.\n\nGiven that DeltaV will be streaking through the standards process faster\nthan 2518 can get a revision out (:-), I think unfortunately this is\nrequired.\n\n> Since allowing them to apply is contrary to 2518, then we need to\n> explicitly mention that fact. If we don't, then readers will\n> assume that you cannot use those methods on a lock-null.\n\nAgreed.\n\n> And yes: this should raise an issue for 2518 to loosen that language in\n> some way. (cc'ing Jim explicitly to ensure this is captured)\n\nThis is the real 'solution'.\n\nTim\n\n\n\n", "id": "lists-006-1272837"}, {"subject": "Cache-Control and the Vary header..", "content": "Hi,\n\nWhile reading section 8.3 of the draft I noticed that we explicitly specify\nthat the HTTP Vary header \nmust be sent on responses to methods that take Label headers.\n\nI assume this is because when a user does a caching operation and specifies\na Label he/she\ndoes not want the cached response to come back if they do the same method on\nthe same URL\nbut with a different Label header or without a Label header.\n\nBut thinking along the same lines why do we not include the Depth header in\nthe Vary field?\nA request on a URL can return different results depending on the presence or\nthe value of\nthe depth header.\n\nAlso the text in section 8.3 is wrong, it says that GET and PROPFIND are\ncacheable requests\nbut RFC2518 (section 8.1 for example) says that the methods MUST NOT be\ncached (eg\nCache-Control: no-cache).\nIf both GET and PROPFIND are not cacheable why have the reference to the\nVary header at all?\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (ADM)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-12730377"}, {"subject": "RE: Cache-Control and the Vary header..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   While reading section 8.3 of the draft I noticed that we explicitly\n   specify that the HTTP Vary header must be sent on responses to\n   methods that take Label headers.  I assume this is because when a\n   user does a caching operation and specifies a Label he/she does not\n   want the cached response to come back if they do the same method on\n   the same URL but with a different Label header or without a Label\n   header.\n\nYes.\n\n   But thinking along the same lines why do we not include the Depth\n   header in the Vary field?  A request on a URL can return different\n   results depending on the presence or the value of the depth header.\n\nThe Depth header does not affect GET and HEAD (which are the main\ncacheable requests).\n\n   Also the text in section 8.3 is wrong, it says that GET and\n   PROPFIND are cacheable requests but RFC2518 (section 8.1 for\n   example) says that the methods MUST NOT be cached (eg\n   Cache-Control: no-cache).\n\nGood catch!  PROPFIND is not cacheable (but GET is ... section 8.1\nof 2518 is just about PROPFIND).  I'll fix that by deleting the reference\nto PROPFIND.\n\n   If both GET and PROPFIND are not cacheable why have the reference\n   to the Vary header at all?\n\nThe Label header affects GET (unlike the Depth header), which is why\nthe Vary header is needed.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12738881"}, {"subject": "RE: REPORT", "content": "> From: John Hall [mailto:johnhall@evergo.net] \n> \n> MAY is more appropriate than SHOULD given the late date at \n> which the change was made, the manner of the change, and the \n> fact that a commercial implementation of the spec will not be \n> implementing this report and will recommend that clients who \n> wish to be interoperable avoid it as well.\n> And if there is no difference between MAY and SHOULD, then \n> there should be no objection to making it MAY.\n\nThere is no material difference to a client implementer,\nsince both MAY and SHOULD means that your client needs to\nprepared for it not being implemented.\n\nThe only difference is to a server implementer, and even\nthere, it is just a hint from the working group to the\nimplementor, not a requirement.\n\nThe consensus at the IETF meeting was that the expand-property\nreport was valuable enough (as demonstrated on the mailing list)\nfor it to be worth strengthening the MAY to a SHOULD.\nCurrently, we have only received objections from one vendor\nabout this, which does not in my opinion represent sufficient\nopposition to reflect a lack of consensus.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12747327"}, {"subject": "RE: REPORT", "content": "\"John Hall\" <johnhall@xythos.com> wrote:\n\n> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net]\n> Sent: Thursday, September 06, 2001 9:58 AM\n> To: 'Tim Ellison'; 'DeltaV'\n> Subject: RE: REPORTS\n>\n>\n> >\n> > There were no objections raised in the meeting or when the\n> > minutes were published.  I'd consider that a consensus.\n>\n>\n> It was the equivalent of slipping language in a bill at\n> reconciliation time, without debate, after midnight when\n> everyone else had gone home, then rushing the bill out for\n> signature before anyone noticed.\n\nHey, if you can run a country that way, I'm sure we can write a spec like\nthat<g>\n\n> MAY is more appropriate than SHOULD given the late date at\n> which the change was made, the manner of the change, and the\n> fact that a commercial implementation of the spec will not be\n> implementing this report and will recommend that clients who\n> wish to be interoperable avoid it as well.\n>\n> And if there is no difference between MAY and SHOULD, then\n> there should be no objection to making it MAY.\n\nLet's agree on what it _ought_ to say rather than on the process that got\nus to this point or what you will recommend.\n\nGiven that the report will be useful in a number of interesting scenarios I\nthink it is a useful optimization that servers SHOULD implement.  Note that\nclients are free not use use it, and servers are free not to implement it\nand both will be within the spec.  But servers should be encouraged to\nimplement it and clients should be encouraged to look for it and use it.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12755302"}, {"subject": "RE: WebDAV Invalidation (Was Re: Allow: header and supported methods", "content": "I'd definitely be interested in working on notifications.  We'd like clients\nto be able to know about events like the ones you suggest, plus:\n - new resource in collection I'm subscribed to\n - Access control change in resource I'm subscribed to\n - New version in VCR (similar to your update/last-modified event, perhaps\nequivalent)\n\nHow do we proceed?\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of J?sh Cohen\n> Sent: Wednesday, August 29, 2001 12:26 PM\n> To: deltav@wegalink.de; ietf-dav-versioning@w3.org\n> Subject: Re: WebDAV Invalidation (Was Re: Allow: header and supported\n> methods)\n>\n>\n> While Im nervous about trying to boil the ocean\n> in the form of a 'general notifications protocol', Im\n> wondering what people think about including the ability\n> to subscribe to events on resources?\n> By this I mean, in short, being able to subscribe\n> to a resource, such that when things happen to it,\n> such as:\n> o  property change\n> o  update (last modified)\n> o  invalidate\n> o  lock expiration / lock override\n> o  deleted\n>\n> a subscribed entity would receive a notification.\n>\n> There's been some relevant work here in the form of\n> an HTTP extension (SUBSCRIBE/NOTIFY methods) in the past\n> to deal with some of these issues.  It was work that\n> was previously done in the context of using HTTP for IM\n> and it quite similar to the SIP subscription extensions.\n>\n> Does this sound at all like something the group\n> would be interested in taking a closer look at ?\n>\n> thanks,\n>\n> ---\n> Josh\n>\n>\n>\n> >From: \"Eckhard Kantz\" <deltav@wegalink.de>\n> >To: <ietf-dav-versioning@w3.org>\n> >Subject: Re: WebDAV Invalidation (Was Re: Allow: header and supported\n> >methods)\n> >Date: Wed, 22 Aug 2001 21:40:39 +0200\n> >\n> >The protocol described in the ESI document allows to invalidate\n> documents\n> >that have been downloaded\n> >to a local machine by applying a push technology. This could\n> solve already\n> >several conflict\n> >situations or even partly prevent problems.\n> >\n> >On the other hand there seems to be an increasing need for more\n> >fine-grained notification services\n> >that extend the traditional access control systems. Picture 1 in the\n> >following longer article tries\n> >to classify them:\n> >\n> >\"Beyond 'Yes or No' - Extending Access Control in Groupware with\n> >Negotiation and Awareness\"\n> >(http://www.informatik.uni-bonn.de/~os/Publications/COOP98a.ps)\n> >\n> >Maybe those needs are also worth discussing if they could be\n> supported in\n> >the spec in order to allow\n> >applications to build up on them. The invalidation protocol\n> seems to be a\n> >good basis also for this.\n> >\n> >Eckhard\n> >\n> >\n> >-----Urspr?ngliche Nachricht-----\n> >Von: Eric Sedlar\n> >An: ietf-dav-versioning@w3.org\n> >Gesendet: Dienstag, 21. August 2001 19:00\n> >Betreff: WebDAV Invalidation (Was Re: Allow: header and\n> supported methods)\n> >\n> >\n> >Check out\n> >http://www.esi.org/invalidation_protocol_1-0.html for some work\n> that looks\n> >pretty similar\n> >to what we are talking about.\n> >\n> >--Eric\n> >\n>\n>\n> _________________________________________________________________\n> Get your FREE download of MSN Explorer at\nhttp://explorer.msn.com/intl.asp\n\n\n\n", "id": "lists-006-12764508"}, {"subject": "RE: WebDAV Invalidation (Was Re: Allow: header and supported methods", "content": "I'll schedule a BOF at the next IETF meeting. If there's enough interest, \nwe can create a proposed charter and petition the area directors for a new \nworking group.\n\n\n\n\n\n\n\"Lisa Dusseault\" <lisa@xythos.com>\nSent by: ietf-dav-versioning-request@w3.org\n09/06/2001 06:21 PM\n\n \n        To:     =?iso-8859-1?Q?J=F6sh_Cohen?= <joshrcohen@hotmail.com>, \n<deltav@wegalink.de>, <ietf-dav-versioning@w3.org>\n        cc:     \"Webdav WG\" <w3c-dist-auth@w3c.org>\n        Subject:        RE: WebDAV Invalidation (Was Re: Allow: header and supported methods)\n\n \n\nI'd definitely be interested in working on notifications.  We'd like \nclients\nto be able to know about events like the ones you suggest, plus:\n - new resource in collection I'm subscribed to\n - Access control change in resource I'm subscribed to\n - New version in VCR (similar to your update/last-modified event, perhaps\nequivalent)\n\nHow do we proceed?\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of J?sh Cohen\n> Sent: Wednesday, August 29, 2001 12:26 PM\n> To: deltav@wegalink.de; ietf-dav-versioning@w3.org\n> Subject: Re: WebDAV Invalidation (Was Re: Allow: header and supported\n> methods)\n>\n>\n> While Im nervous about trying to boil the ocean\n> in the form of a 'general notifications protocol', Im\n> wondering what people think about including the ability\n> to subscribe to events on resources?\n> By this I mean, in short, being able to subscribe\n> to a resource, such that when things happen to it,\n> such as:\n> o  property change\n> o  update (last modified)\n> o  invalidate\n> o  lock expiration / lock override\n> o  deleted\n>\n> a subscribed entity would receive a notification.\n>\n> There's been some relevant work here in the form of\n> an HTTP extension (SUBSCRIBE/NOTIFY methods) in the past\n> to deal with some of these issues.  It was work that\n> was previously done in the context of using HTTP for IM\n> and it quite similar to the SIP subscription extensions.\n>\n> Does this sound at all like something the group\n> would be interested in taking a closer look at ?\n>\n> thanks,\n>\n> ---\n> Josh\n>\n>\n>\n> >From: \"Eckhard Kantz\" <deltav@wegalink.de>\n> >To: <ietf-dav-versioning@w3.org>\n> >Subject: Re: WebDAV Invalidation (Was Re: Allow: header and supported\n> >methods)\n> >Date: Wed, 22 Aug 2001 21:40:39 +0200\n> >\n> >The protocol described in the ESI document allows to invalidate\n> documents\n> >that have been downloaded\n> >to a local machine by applying a push technology. This could\n> solve already\n> >several conflict\n> >situations or even partly prevent problems.\n> >\n> >On the other hand there seems to be an increasing need for more\n> >fine-grained notification services\n> >that extend the traditional access control systems. Picture 1 in the\n> >following longer article tries\n> >to classify them:\n> >\n> >\"Beyond 'Yes or No' - Extending Access Control in Groupware with\n> >Negotiation and Awareness\"\n> >(http://www.informatik.uni-bonn.de/~os/Publications/COOP98a.ps)\n> >\n> >Maybe those needs are also worth discussing if they could be\n> supported in\n> >the spec in order to allow\n> >applications to build up on them. The invalidation protocol\n> seems to be a\n> >good basis also for this.\n> >\n> >Eckhard\n> >\n> >\n> >-----Urspr?ngliche Nachricht-----\n> >Von: Eric Sedlar\n> >An: ietf-dav-versioning@w3.org\n> >Gesendet: Dienstag, 21. August 2001 19:00\n> >Betreff: WebDAV Invalidation (Was Re: Allow: header and\n> supported methods)\n> >\n> >\n> >Check out\n> >http://www.esi.org/invalidation_protocol_1-0.html for some work\n> that looks\n> >pretty similar\n> >to what we are talking about.\n> >\n> >--Eric\n> >\n>\n>\n> _________________________________________________________________\n> Get your FREE download of MSN Explorer at\nhttp://explorer.msn.com/intl.asp\n\n\n\n", "id": "lists-006-12778903"}, {"subject": "RE: REPORT", "content": "Hi,\n\nI believe that when the issue of moving the expand property report\nwas raised at the IETF meeting someone (Lisa I think) had a good use \ncase where the client had a need for this report.\nIt was that use case that drove us to decide that the report is\nactually very useful and that we should recommend that server\nvendors implement it.\n\nThat use case was not captured in the minutes, anyone remember\nwhat the scenario was?\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\nSent: 05 September 2001 14:23\nTo: 'DeltaV'\nSubject: Re: REPORTS\n\n\n\"John Hall\" <johnhall@evergo.net> wrote:\n\n> I've been on vacation, but I've tried to keep up.\n>\n> In version #17 the expand-property report has been\n> moved from an optional report (Section 15 of\n> version #16) to a SHOULD implement in 3.8.\n>\n> I object to it being listed there, and I recall no\n> discussion let alone a consensus to moving it from\n> section 15.  Outlook does not find 'expand-property'\n> listed in any discussion of this type in my folder\n> dedicated to DeltaV messages.  As an optional report,\n> I did not pay any attention to it.  The nesting\n> feature (properties within properties) makes this a\n> very difficult and annoying feature to implement or\n> use IMHO.\n\nThis was discussed in the ondon IETF meeting and reported in the minutes\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JulSep/0193.html\n\n\nAs I recall, there was little objection in the room to this report as it\nwas considered a relatively simple recursion for the client and/or server\nto implement.\n\n> ====================\n>\n> The version-tree report also seems to be defined\n> differently (in 16 as well as 17) than I thought.  I\n> can implement it that way (fix my implementation), but\n> it seems more limited that it should be.\n>\n> For example, I see no reason to redirect a version-tree\n> report to the checked-out version of a VCR.  It makes\n> more sense to print the following information, if the target\n> is a VCR:\n>\n> 1. A listing for the VCR (properties can be different\n> than for a version)\n> Followed by a listing for each version in the VCR (starting\n> with the latest version and continuing on down).\n\nNot sure what you mean here.  The 'redirect' to the version is simply a\nconvenience.  What do you mean by \"each version in the VCR\"?  The report\nwill be applied to all versions in the version history of a version.\n\n> As currently defined, it takes 2 calls to get all the\n> properties you want on all the versions of a file.\n\nNo, the properties will be returned for all versions on a single REPORT\nrequest.\n\n> One to pick up any properties on the VCR including the\n> location of the VHR and the other to pick up additional\n> properties on the file versions.\n\nThe version tree report reports properties on versions.  You would simply\nuse PROPFIND to get the properties for a version-controlled resource.  Of\ncourse, you could use the expand property report to get properties for a\nversion-controlled resource and its checked-in/-out version and/or version\nhistory.\n\n> Acutally, I'd far prefer the following definition for\n> version 3.7:\n>\n> The DAV:version-tree report describes the requested\n> properties of all the versions in the version history\n> of a version.  If the report is requested for a\n> version-controlled resource, then the requested properties\n> of the version-controlled resource are supplied in addition\n> to the requested properties for all the versions in the\n> version history of the version.\n\nI have no strong objection to tis, but would like to see the `compelling\nuse case' that warrants a change.\n\n> A server MAY support a depth value other than 0.  If so,\n> the report may target a collection and the report is\n> applied to each versioned controlled resource in the tree.\n\nThis is already covered in the postcondition for REPORT, right?\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12795364"}, {"subject": "The Depth header..", "content": "Hi,\n\nI have a few issues/questions surrounding the use of the depth header...\n\nAs Geoff pointed out in his reply to my message on the Vary header, GET \ndoes not take a Depth header.  This would have been really useful, this \ncame up in one of our deltav study groups here in MERANT...the scenario \nwas this:\n\nYou are a Working-Resource based client and are using labels to identify \nfiles to be used in a build (this is a common use of labels, the label \nselects which versions are to be included in a build).\n\nIf we could do a GET with a Depth header and supply the label in the label\nheader then in one operation we could retrieve all files needed for the\nbuild.\nSince the spec does not allow Depth on GET we would have to do a PROPFIND\nto get the DAV:label-name-set (or do a DASL query) and then issue multiple\nGET methods specifying the label header.\nWhy was depth not defined on the GET method? Seems like a really useful\nfeature.\n\nThe second issue I have with the depth header is they way it is defined \ninconsistently on each method that uses it....for example on the UPDATE \nmethod if depth is not specified then Depth: infinity is assumed...on the \nLABEL method if depth is not specified then Depth: 0 is assumed.  It would \nmake server implementation cleaner if we could always assume Depth: 0 in \nthe absence of a Depth header.  This also seems logical, if the client does \nnot ask for Depth then apply the operation only to the request resource.\nWhy not make the default behaviour of depth consistent?\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-12807555"}, {"subject": "Some more comments on the LABEL section..", "content": "Hi,\n\nI also have a couple more points/questions regarding section 8 (labels)....\n\nThe last paragraph of the introduction to the LABEL feature (section 8)\nseems \nout of place.  This text is non-normative and talks about distributed\nservers \nand synchronization which is not discussed elsewhere in the specification.  \nIt seems like the kinda text you would put in an implementers guide or a \nspecification regarding synchronization between deltav servers.  I am sure \nthat other aspects of deltav would cause synchronization problems in a \ndistributed server environment.  At the London IETF we talked about an \n\"implementers guide\" for deltav, if we have such a document I propose this \nsection is removed from the draft and placed in the implementers guide.\n\n\nAlso I am not sure I understand why UPDATE (section 8.9) can take two\nlabels, \none in the header and one in the DAV:label-name element.  It seems the \nDAV:label-name is used to ensure that the VCR identified by the request URL \nhas a certain label, it is only mentioned in a Precondition and so it does \nnot affect the UPDATE, it simply prevents UPDATE on a VCR which has no \nversions that have that label.  The Label header on this method will cause \nthe UPDATE to change the VCR to point at the version that has the specified \nlabel.  I guess my questions are:\n\nWhat's the use case for the DAV:label-name element? Why have it at all?\n\nWhy does the DAV:must-select-version-in-history precondition only affect the\n\nrequest URL, for example when you specify a depth should this precondition \nnot apply to all VCRs that match that depth?\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-12817304"}, {"subject": "Resource type (was RE: AW: Removing the DAV:activity and DAV:version-history and DAV:baseline resource type values", "content": "Lisa wrote:\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: 06 June 2001 17:00\n> To: Tim_Ellison@uk.ibm.com; DeltaV (E-mail)\n> Subject: RE: AW: Removing the DAV:activity and DAV:version-history and\n> DAV:baseline resource type values\n>\n>\n> Tim said:\n> > So, if we are to continue this use of DAV:resourcetype it would\n> > be to give clients a useful classification of a resource at a\n> > particular point in time that would give them a reasonable set\n> > of data for displaying an icon, greying menu items and so on.\n> > It should convey both versioning 'type' and 'state' that is\n> > within the mandate of WebDAV.  The specification has already\n> > called out a number of useful resource classifications and they\n> > are the ones that I proposed (DAV:checked-in _and_ DAV:checked-out\n> > may be redundant).\n>\n> In common usage, \"type\" is somewhere else along the range of persistence\n> from \"state\".  A couple thoughts on how you can tell the difference:\n>\n>  - When things can change state, it's because they're supposed to,\n> so we give a way to check out something that's checked in and vice\n> versa.  WebDAV does NOT give a way to turn a collection into a\n> regular resource -- clients have to _remove_ the resource --\n> completely taking away its existence -- and replace it with a\n> resource of a different type.\n\nI'm surprised that you say this.  WebDAV gives me PROPPATCH.\nSay I had a server that allowed clients to PROPPATCH the DAV:resourcetype\nproperty.  Why would that not be DAV compliant?\nImagine the client does a PUT to create a resource, sets some dead\nproperties and so on, maybe even LOCKs it.  Then they decide that they are\ngoing to restructure the resources, and convert that resource into a\ncollection.  The client simply PROPATCHes DAV:resourcetype, adding\n<DAV:collection/>, to flag it as a resource capable of storing a \"list of\ninternal member URIs\".  GET still works as before, PROPFIND still works as\nbefore, etc.  I don't recall seeing anything that said I have to delete the\nresource first.\n\nRFC2518 provides MKCOL for creating a resource as a collection.  This is\nfine and obviously very useful as a means to create a resource (with no\ncontent) and set a specific property (DAV:resourcetype) simultaneously.\nHowever, I hazard to guess that what most people would wish for is a method\nthat allows simultaneous atomic creation of content and numerous properties\nin the same method.  (Of course we'd debate such a beast for so long ...).\n\nDeltaV went through a phase of using MKRESOURCE to create all the different\nresources and ended up falling in line with MKCOL for numerous reasons.\n\nSo my question is, does WebDAV disallow <DAV:collection/> being a \"state\"\nthat I can change on a whim? (assuming no internal members are being left\norphaned)\n\n> The only sense in which that operation \"changes the type\" of a\n> collection is that it is an entity that shares the same name as\n> the previous entity -- but no other continuity.\n\nThat's one view of the world.  I don't hold that view and I think that\nRFC2518 permits both so that's cool.\n\n> DeltaV _does_ blur the line by adding a VERSION-CONTROL method\n> to turn a regular resource into a VCR, however, this method performs\n> drastic surgery, with the side effect of up to three resources\n> being created.\n\nBut if you step into my shoes for a moment, and think of the transformation\nsimply as a PROPPATCH with some set and remove elements the transformation\nmay not seem so drastic (obviously it is the server changing the properties\nof the resource so it isn't actually akin to a PROPPATCH).\n\nThe regular resource -> version-contolled resource transformation is, to me,\nsetting up the resource so that the server treats it differently with\nrespect to HTTP methods.  It is still the same resource (retains its dead\nproperties, locks are unaffected, binding refs to it remain intact etc.).\nHowever, if you think of the transformation as having to 'replace' the\nresource (i.e. by sequences of DELETE, LOCK, PUT/MKCOL, PROPATCH, BIND) then\nit does require lots of server effort to recreate a substantially equivalent\nresource state.  Isn't PROPPATCH simpler?\n\n> Many servers will only support version-controlled resources, and\n> thus not allow the transformation in either direction.\n\nAgreed.  And many servers will not support LOCKing for that matter :-)\n\n>  - States are used as adjectives.   A \"checked-out version-controlled\n> resource\" isn't a type, it's a type with a state modifier.  I think\n> intuitively we use the language correctly:  we abbreviate VCR, VR, and VHR\n> to define different types of resources, but we don't through the state\n> adjectives in to have COVCR and CIVCR.\n\nAbbreviations aside, the specification DOES refer to \"checked-out\nversion-controlled resources\" on many occasions since it is an important\nresource state, err type, err whatever.\n\n>  - State changes more frequently than type.  A typical VCR will have its\n> checked-in and checked-out state change MUCH more frequently than\n> its type.\n\nAgreed that this is typically the case.\n\n> I understand that this is one of many situations where there is\n> not a clear, fine line between two things.  You can certainly blur\n> the distinction if you choose by attacking any one of my arguments,\n> or all.\n\nHopefully you do not see this as attacking your arguments.  I understand\nyour position and that works too.  I offered an alternate view which you are\nfree to debunk.\n\n> That does not prove that we should clump them together.  Humans\n> are capable of fuzzy distinctions, and these are useful to us,\n> even if not to the software we write.\n\nIn the spec and in software we do need to be clear.\n\n> My argument is to apply common notions to decide what different\n> types need to be called out in resourcetype.  IMHO,\n> checked-in/checked-out is a state, not a type.\n\nWhether I agree with checked-in/checked-out being a state or type (I happen\nto think of it as a state too), I'm claiming that there is no reason why\nDAV:resourcetype cannot contain both (despite its name), and that the only\nrecognized value today <DAV:collection/> can be viewed as either a state or\ntype anyway.\n\nTim\n\n\n\n", "id": "lists-006-1282436"}, {"subject": "Re: The Depth header..", "content": "Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n> Hi,\n>\n> I have a few issues/questions surrounding the use of the depth header...\n>\n> As Geoff pointed out in his reply to my message on the Vary header, GET\n> does not take a Depth header.? This would have been really useful, this\n> came up in one of our deltav study groups here in MERANT...the scenario\n> was this:\n>\n> You are a Working-Resource based client and are using labels to identify\n> files to be used in a build (this is a common use of labels, the label\n> selects which versions are to be included in a build).\n>\n> If we could do a GET with a Depth header and supply the label in the\nlabel\n> header then in one operation we could retrieve all files needed for the\nbuild.\n> Since the spec does not allow Depth on GET we would have to do a PROPFIND\n> to get the DAV:label-name-set (or do a DASL query) and then issue\nmultiple\n> GET methods specifying the label header.\n> Why was depth not defined on the GET method? Seems like a really useful\n> feature.\n\nIn principle there is no problem doing a deep GET, however in practice it\nwould likey result is a huge response being sent by the server.  That\nresponse would have to be in multi-part MIME format to indicate the types\nof the resources that were being returned; and it would not lend itself to\nhitting caches maintained by all commonplace proxies.\n\nGiven that Depth: does not guarantee an atomic operation (i.e., the results\nmay be skewed over time) the only advantage is the reduction in GET\nrequests.  Since GET has no body and can be pipelined for multiple\ncollection members I don't think it is a huge overhead.\n\n> The second issue I have with the depth header is they way it is defined\n> inconsistently on each method that uses it....for example on the UPDATE\n> method if depth is not specified then Depth: infinity is assumed...\n\nI don't have the spec in front of me right now, but that doesn't sound\ngood?!\n\n> on the\n> LABEL method if depth is not specified then Depth: 0 is assumed.? It\nwould\n> make server implementation cleaner if we could always assume Depth: 0 in\n> the absence of a Depth header.? This also seems logical, if the client\ndoes\n> not ask for Depth then apply the operation only to the request resource.\n> Why not make the default behaviour of depth consistent?\n\nRather than be consistent I think we should look at each method and decide\nwhich makes the 'best sense' for that method.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12826747"}, {"subject": "Minor editorial change to section 9.2..", "content": "Hi,\n\nThis is a minor editorial issue...\n\nIn the properties for a working resource (section 9.2) we define\nDAV:checkout-fork and\nDAV:checkin-fork.  I propose we refer back to sections 4.2.1 and 4.2.2? By\ndefining them\nin section 9.2 it gives the impression that they have some other behaviour\nwhen defined \non a working resource rather than any other checked-out resource.\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-12836565"}, {"subject": "RE: The Depth header..", "content": "Hi,\n\n[Tim wrote:]\n\n>> Since the spec does not allow Depth on GET we would have to do a PROPFIND\n>> to get the DAV:label-name-set (or do a DASL query) and then issue\nmultiple\n>> GET methods specifying the label header.\n>> Why was depth not defined on the GET method? Seems like a really useful\n>> feature.\n\n>In principle there is no problem doing a deep GET, however in practice it\n>would likey result is a huge response being sent by the server.  That\n>response would have to be in multi-part MIME format to indicate the types\n>of the resources that were being returned; and it would not lend itself to\n>hitting caches maintained by all commonplace proxies.\n\nYes, I agree it would be large and would have to be multi-part MIME, I don't\n\nknow a lot about caching HTTP proxies, but would have thought they could \nhandle this.\n\n>Given that Depth: does not guarantee an atomic operation (i.e., the results\n>may be skewed over time) the only advantage is the reduction in GET\n>requests.  Since GET has no body and can be pipelined for multiple\n>collection members I don't think it is a huge overhead.\n\nOK, I think this makes sense, I hadn't read much about HTTP pipelining\nbut looking at RFC2616 it seems this would solve my performance concern\nabout multiple roundtrips etc.\n\n>> The second issue I have with the depth header is they way it is defined\n>> inconsistently on each method that uses it....for example on the UPDATE\n>> method if depth is not specified then Depth: infinity is assumed...\n\n>I don't have the spec in front of me right now, but that doesn't sound\n>good?!\n\nYes, section 7.1 seems to be saying that the default is to UPDATE\nthe whole configuration...it says:\n\n\"The request-URL identifies the set of possible update targets.  If \nDepth:0 is specified, the request-URL is the only possible update \ntarget; otherwise, any member of the configuration rooted at the \nrequest-URL is a possible update target.\"\n\n>> on the\n>> LABEL method if depth is not specified then Depth: 0 is assumed.? It\nwould\n>> make server implementation cleaner if we could always assume Depth: 0 in\n>> the absence of a Depth header.? This also seems logical, if the client\ndoes\n>> not ask for Depth then apply the operation only to the request resource.\n>> Why not make the default behaviour of depth consistent?\n\n>Rather than be consistent I think we should look at each method and decide\n>which makes the 'best sense' for that method.\n\nI disagree, this leads to implementations where you need different code\nfor each method (or a nasty set of if-statements) just to work out what\na default should be...eg...\n\nif (depth header not specified)\n{\n  if (method==UPDATE)\ndepth=infinity;\n  else if (method==LABEL)\ndepth=0;\n  else if....\n}\n\nAlso clients have to be aware what the default will be given the different\nmethods it is sending (or always be paranoid and specify depth).\nAlso helps keep the spec tidy so instead of specifying on each method what\nthe default depth is we can specify it in just one place at the top of the\nspec.\n\nI guess it's not a big issue for me, I just prefer a consistent definition\nof behaviour where possible.\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-12844585"}, {"subject": "Re: Some more comments on the LABEL section..", "content": "Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n> I also have a couple more points/questions regarding section 8\n(labels)....\n>\n> The last paragraph of the introduction to the LABEL feature (section 8)\nseems\n> out of place.? This text is non-normative and talks about distributed\nservers\n> and synchronization which is not discussed elsewhere in the\nspecification.\n> It seems like the kinda text you would put in an implementers guide or a\n> specification regarding synchronization between deltav servers.? I am\nsure\n> that other aspects of deltav would cause synchronization problems in a\n> distributed server environment.? At the London IETF we talked about an\n> \"implementers guide\" for deltav, if we have such a document I propose\nthis\n> section is removed from the draft and placed in the implementers guide.\n\nThat's fine by me (its there because someone asked for that justification\nto be added, but I'm equally happy for it to be moved out).\n\n> Also I am not sure I understand why UPDATE (section 8.9) can take two\nlabels,\n> one in the header and one in the DAV:label-name element.\n\nI think that is a bug.\n\nThe Label: header should not apply to an UPDATE request.  A label should\nonly appear in the body (in the DAV:label-name element) of the UPDATE\nrequest.  Then the Label: header simply means \"apply this method to the\nversion with the given label in the version history of the\nversion-controlled resource\".\n\n> It seems the\n> DAV:label-name is used to ensure that the VCR identified by the request\nURL\n> has a certain label, it is only mentioned in a Precondition and so it\ndoes\n> not affect the UPDATE, it simply prevents UPDATE on a VCR which has no\n> versions that have that label.? The Label header on this method will\ncause\n> the UPDATE to change the VCR to point at the version that has the\nspecified\n> label.? I guess my questions are:\n>\n> What's the use case for the DAV:label-name element? Why have it at all?\n\nI recommend we disallow/ignore the Label: header on an UPDATE request, and\nchange the postcondition to read:\n\n\"(DAV:apply-request-to-labeled-version): If the request includes a\nDAV:label-name element in the request body, the content and deep properties\nof the version-controlled resource are updated to be those of the version\nselected by that label.\"\n\n> Why does the DAV:must-select-version-in-history precondition only affect\nthe\n> request URL, for example when you specify a depth should this\nprecondition\n> not apply to all VCRs that match that depth?\n\nYou're right, for each version-controlled resource matching the depth\nheader, UPDATE should select the labeled version in the version history of\nthat version-controlled resource.\n\nGreat feedback ... keep it coming<g>!\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12855689"}, {"subject": "Re: The Depth header..", "content": " ...\n> > The second issue I have with the depth header is they way it is defined\n> > inconsistently on each method that uses it....for example on the UPDATE\n> > method if depth is not specified then Depth: infinity is assumed...\n>\n> I don't have the spec in front of me right now, but that doesn't sound\ngood?!\n...\n\nOk, so I got the spec out ...\n\nI think the default should be Depth:0.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12866095"}, {"subject": "Re: The Depth header..", "content": "Peter,\nDepth operations only apply to collections in WebDAV, or things that \n(effectively) derive from collections. GET on collections is \nunfortunately, for historical and current practice reasons, not defined by \nWebDAV on collections. Your server could choose to implement GET on a \ncollection to do whatever it wanted, but this would likely create an \ninteroperability problem. \n\nGET returning multiple resource would also require some sort of multi-part \nMIME protocol which is not currently defined for WebDAV. This would be \nrequired to separate the documents.\n\nThe default value for the Depth header is based on the default desirable \nbehavior, not consistency of value. I think clients should expect \noperations that take a Depth header to do something sensible when the \nheader is not included. Due to the various semantics involved, this will \nnot likely result in the same default value in all situations.\n\n\n\n\n\nPeter Raymond <Peter.Raymond@merant.com>\nSent by: ietf-dav-versioning-request@w3.org\n09/07/2001 05:00 AM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        The Depth header...\n\n \n\nHi, \nI have a few issues/questions surrounding the use of the depth header... \nAs Geoff pointed out in his reply to my message on the Vary header, GET \ndoes not take a Depth header.  This would have been really useful, this \ncame up in one of our deltav study groups here in MERANT...the scenario \nwas this: \nYou are a Working-Resource based client and are using labels to identify \nfiles to be used in a build (this is a common use of labels, the label \nselects which versions are to be included in a build). \nIf we could do a GET with a Depth header and supply the label in the label \nheader then in one operation we could retrieve all files needed for the \nbuild. \nSince the spec does not allow Depth on GET we would have to do a PROPFIND \nto get the DAV:label-name-set (or do a DASL query) and then issue multiple \nGET methods specifying the label header. \nWhy was depth not defined on the GET method? Seems like a really useful \nfeature. \nThe second issue I have with the depth header is they way it is defined \ninconsistently on each method that uses it....for example on the UPDATE \nmethod if depth is not specified then Depth: infinity is assumed...on the \nLABEL method if depth is not specified then Depth: 0 is assumed.  It would \n\nmake server implementation cleaner if we could always assume Depth: 0 in \nthe absence of a Depth header.  This also seems logical, if the client \ndoes \nnot ask for Depth then apply the operation only to the request resource. \nWhy not make the default behaviour of depth consistent? \nRegards, \n-- \nPeter Raymond - MERANT \nTechnical Architect (PVCS) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n\n\n\n", "id": "lists-006-12873488"}, {"subject": "RE: The Depth header..", "content": "Peter Raymond <Peter.Raymond@merant.com>\n\n> >In principle there is no problem doing a deep GET, however in practice\nit\n> >would likey result is a huge response being sent by the server.? That\n> >response would have to be in multi-part MIME format to indicate the\ntypes\n> >of the resources that were being returned; and it would not lend itself\nto\n> >hitting caches maintained by all commonplace proxies.\n>\n> Yes, I agree it would be large and would have to be multi-part MIME, I\ndon't\n> know a lot about caching HTTP proxies, but would have thought they could\n> handle this.\n\nI meant that if the deep GET included requests for numerous resources'\ncontent that were already in the proxy cache, the chances are that the\nproxy will not be able to satisy the request because it could not construct\na multistatus response (or whatever is used to marshal the response).\nSimilarly, when a large multistatus is returned the proxy will not know how\nto split it up and cache individual resource content for future GET\nrequests.\n\n(p.s. In retrospect, my comment on multi-part MIME may be wrong, but I\nmeant that the response would have to include info that is normally\nreturned in the GET response header, such as MIME-type & encoding).\n\n> ...\n>>> The second issue I have with the depth header is they way it is defined\n>>> inconsistently on each method that uses it....for example on the UPDATE\n>>> method if depth is not specified then Depth: infinity is assumed...\n>\n> >I don't have the spec in front of me right now, but that doesn't sound\n> >good?!\n>\n> Yes, section 7.1 seems to be saying that the default is to UPDATE\n> the whole configuration...it says:\n>\n> \"The request-URL identifies the set of possible update targets.? If\n> Depth:0 is specified, the request-URL is the only possible update\n> target; otherwise, any member of the configuration rooted at the\n> request-URL is a possible update target.\"\n\nThe deep operations only make sense when the request body includes a\nDAV:label-name element.\n\nI agree that the default should be depth zero.\n\n> ...\n> >Rather than be consistent I think we should look at each method and\ndecide\n> >which makes the 'best sense' for that method.\n>\n> I disagree, this leads to implementations where you need different code\n> for each method (or a nasty set of if-statements) just to work out what\n> a default should be...eg...\n>\n> if (depth header not specified)\n> {\n> ? if (method==UPDATE)\n> ??????? depth=infinity;\n> ? else if (method==LABEL)\n> ??????? depth=0;\n> ? else if....\n> }\n>\n> Also clients have to be aware what the default will be given the\ndifferent\n> methods it is sending (or always be paranoid and specify depth).\n> Also helps keep the spec tidy so instead of specifying on each method\nwhat\n> the default depth is we can specify it in just one place at the top of\nthe\n> spec.\n>\n> I guess it's not a big issue for me, I just prefer a consistent\ndefinition\n> of behaviour where possible.\n\nWe can debate whether the method has 'dispatch precedence' over the Depth:\nheader (i.e., causes a branch in the code logic) but I don't think that is\na useful discussion.\n\nI think we should aim for the default value to do the 'Natural Thing' for\neach method, and where it is a matter of debate be consistent.  I agree it\nis not a big deal, but just ask server implementers who have to support\nPROPFIND depth infinity as the default value and see how they like that<g>\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-12884247"}, {"subject": "RE: WebDAV Invalidation (Was Re: Allow: header and supported methods", "content": "I think thats a good idea to have a BOF.\nWhat Id like to see most importantly is a\nfocused, and narrow scope.  In my mind,\nthis is a mechanism for subscribing to\nand receiving specific change events on\nweb resources, within the existing web\ninfrastructure that integrates with DAV.\n\n\n---\nJosh\n\n\n\n>From: \"Jim Amsden\" <jamsden@us.ibm.com>\n>To: w3c-dist-auth@w3c.org, ietf-dav-versioning@w3.org\n>Subject: RE: WebDAV Invalidation (Was Re: Allow: header and supported \n>methods)\n>Date: Thu, 6 Sep 2001 20:40:25 -0400\n>\n>I'll schedule a BOF at the next IETF meeting. If there's enough interest,\n>we can create a proposed charter and petition the area directors for a new\n>working group.\n>\n>\n>\n>\n>\n>\n>\"Lisa Dusseault\" <lisa@xythos.com>\n>Sent by: ietf-dav-versioning-request@w3.org\n>09/06/2001 06:21 PM\n>\n>\n>         To:     =?iso-8859-1?Q?J=F6sh_Cohen?= <joshrcohen@hotmail.com>,\n><deltav@wegalink.de>, <ietf-dav-versioning@w3.org>\n>         cc:     \"Webdav WG\" <w3c-dist-auth@w3c.org>\n>         Subject:        RE: WebDAV Invalidation (Was Re: Allow: header and \n>supported methods)\n>\n>\n>\n>I'd definitely be interested in working on notifications.  We'd like\n>clients\n>to be able to know about events like the ones you suggest, plus:\n>  - new resource in collection I'm subscribed to\n>  - Access control change in resource I'm subscribed to\n>  - New version in VCR (similar to your update/last-modified event, perhaps\n>equivalent)\n>\n>How do we proceed?\n>\n>lisa\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of J?sh Cohen\n> > Sent: Wednesday, August 29, 2001 12:26 PM\n> > To: deltav@wegalink.de; ietf-dav-versioning@w3.org\n> > Subject: Re: WebDAV Invalidation (Was Re: Allow: header and supported\n> > methods)\n> >\n> >\n> > While Im nervous about trying to boil the ocean\n> > in the form of a 'general notifications protocol', Im\n> > wondering what people think about including the ability\n> > to subscribe to events on resources?\n> > By this I mean, in short, being able to subscribe\n> > to a resource, such that when things happen to it,\n> > such as:\n> > o  property change\n> > o  update (last modified)\n> > o  invalidate\n> > o  lock expiration / lock override\n> > o  deleted\n> >\n> > a subscribed entity would receive a notification.\n> >\n> > There's been some relevant work here in the form of\n> > an HTTP extension (SUBSCRIBE/NOTIFY methods) in the past\n> > to deal with some of these issues.  It was work that\n> > was previously done in the context of using HTTP for IM\n> > and it quite similar to the SIP subscription extensions.\n> >\n> > Does this sound at all like something the group\n> > would be interested in taking a closer look at ?\n> >\n> > thanks,\n> >\n> > ---\n> > Josh\n> >\n> >\n> >\n> > >From: \"Eckhard Kantz\" <deltav@wegalink.de>\n> > >To: <ietf-dav-versioning@w3.org>\n> > >Subject: Re: WebDAV Invalidation (Was Re: Allow: header and supported\n> > >methods)\n> > >Date: Wed, 22 Aug 2001 21:40:39 +0200\n> > >\n> > >The protocol described in the ESI document allows to invalidate\n> > documents\n> > >that have been downloaded\n> > >to a local machine by applying a push technology. This could\n> > solve already\n> > >several conflict\n> > >situations or even partly prevent problems.\n> > >\n> > >On the other hand there seems to be an increasing need for more\n> > >fine-grained notification services\n> > >that extend the traditional access control systems. Picture 1 in the\n> > >following longer article tries\n> > >to classify them:\n> > >\n> > >\"Beyond 'Yes or No' - Extending Access Control in Groupware with\n> > >Negotiation and Awareness\"\n> > >(http://www.informatik.uni-bonn.de/~os/Publications/COOP98a.ps)\n> > >\n> > >Maybe those needs are also worth discussing if they could be\n> > supported in\n> > >the spec in order to allow\n> > >applications to build up on them. The invalidation protocol\n> > seems to be a\n> > >good basis also for this.\n> > >\n> > >Eckhard\n> > >\n> > >\n> > >-----Urspr?ngliche Nachricht-----\n> > >Von: Eric Sedlar\n> > >An: ietf-dav-versioning@w3.org\n> > >Gesendet: Dienstag, 21. August 2001 19:00\n> > >Betreff: WebDAV Invalidation (Was Re: Allow: header and\n> > supported methods)\n> > >\n> > >\n> > >Check out\n> > >http://www.esi.org/invalidation_protocol_1-0.html for some work\n> > that looks\n> > >pretty similar\n> > >to what we are talking about.\n> > >\n> > >--Eric\n> > >\n> >\n> >\n> > _________________________________________________________________\n> > Get your FREE download of MSN Explorer at\n>http://explorer.msn.com/intl.asp\n>\n>\n>\n>\n\n\n_________________________________________________________________\nGet your FREE download of MSN Explorer at http://explorer.msn.com/intl.asp\n\n\n\n", "id": "lists-006-12895173"}, {"subject": "RE: The Depth header..", "content": "   From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n\n   Peter Raymond <Peter.Raymond@merant.com>\n\n   >>> The second issue I have with the depth header is they way it is\n   >>> defined inconsistently on each method that uses it....for\n   >>> example on the UPDATE method if depth is not specified then\n   >>> Depth: infinity is assumed...\n\n   > \"The request-URL identifies the set of possible update targets.? If\n   > Depth:0 is specified, the request-URL is the only possible update\n   > target; otherwise, any member of the configuration rooted at the\n   > request-URL is a possible update target.\"\n\n   The deep operations only make sense when the request body includes a\n   DAV:label-name element.\n\n   I agree that the default should be depth zero.\n\nI agree as well.  I'll make that change unless anyone objects.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-12913792"}, {"subject": "RE: WebDAV Invalidation (Was Re: Allow: header and supported methods", "content": "I agree that limiting the scope carefully is the best way to successfully\nnavigate the BOF process.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of J?sh Cohen\n> Sent: Friday, September 07, 2001 5:05 AM\n> To: jamsden@us.ibm.com; w3c-dist-auth@w3c.org;\n> ietf-dav-versioning@w3.org\n> Subject: RE: WebDAV Invalidation (Was Re: Allow: header and supported\n> methods)\n>\n>\n> I think thats a good idea to have a BOF.\n> What Id like to see most importantly is a\n> focused, and narrow scope.  In my mind,\n> this is a mechanism for subscribing to\n> and receiving specific change events on\n> web resources, within the existing web\n> infrastructure that integrates with DAV.\n>\n>\n> ---\n> Josh\n>\n>\n>\n> >From: \"Jim Amsden\" <jamsden@us.ibm.com>\n> >To: w3c-dist-auth@w3c.org, ietf-dav-versioning@w3.org\n> >Subject: RE: WebDAV Invalidation (Was Re: Allow: header and supported\n> >methods)\n> >Date: Thu, 6 Sep 2001 20:40:25 -0400\n> >\n> >I'll schedule a BOF at the next IETF meeting. If there's enough interest,\n> >we can create a proposed charter and petition the area directors\n> for a new\n> >working group.\n> >\n> >\n> >\n> >\n> >\n> >\n> >\"Lisa Dusseault\" <lisa@xythos.com>\n> >Sent by: ietf-dav-versioning-request@w3.org\n> >09/06/2001 06:21 PM\n> >\n> >\n> >         To:     =?iso-8859-1?Q?J=F6sh_Cohen?= <joshrcohen@hotmail.com>,\n> ><deltav@wegalink.de>, <ietf-dav-versioning@w3.org>\n> >         cc:     \"Webdav WG\" <w3c-dist-auth@w3c.org>\n> >         Subject:        RE: WebDAV Invalidation (Was Re: Allow:\n> header and\n> >supported methods)\n> >\n> >\n> >\n> >I'd definitely be interested in working on notifications.  We'd like\n> >clients\n> >to be able to know about events like the ones you suggest, plus:\n> >  - new resource in collection I'm subscribed to\n> >  - Access control change in resource I'm subscribed to\n> >  - New version in VCR (similar to your update/last-modified\n> event, perhaps\n> >equivalent)\n> >\n> >How do we proceed?\n> >\n> >lisa\n> >\n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of J?sh Cohen\n> > > Sent: Wednesday, August 29, 2001 12:26 PM\n> > > To: deltav@wegalink.de; ietf-dav-versioning@w3.org\n> > > Subject: Re: WebDAV Invalidation (Was Re: Allow: header and supported\n> > > methods)\n> > >\n> > >\n> > > While Im nervous about trying to boil the ocean\n> > > in the form of a 'general notifications protocol', Im\n> > > wondering what people think about including the ability\n> > > to subscribe to events on resources?\n> > > By this I mean, in short, being able to subscribe\n> > > to a resource, such that when things happen to it,\n> > > such as:\n> > > o  property change\n> > > o  update (last modified)\n> > > o  invalidate\n> > > o  lock expiration / lock override\n> > > o  deleted\n> > >\n> > > a subscribed entity would receive a notification.\n> > >\n> > > There's been some relevant work here in the form of\n> > > an HTTP extension (SUBSCRIBE/NOTIFY methods) in the past\n> > > to deal with some of these issues.  It was work that\n> > > was previously done in the context of using HTTP for IM\n> > > and it quite similar to the SIP subscription extensions.\n> > >\n> > > Does this sound at all like something the group\n> > > would be interested in taking a closer look at ?\n> > >\n> > > thanks,\n> > >\n> > > ---\n> > > Josh\n> > >\n> > >\n> > >\n> > > >From: \"Eckhard Kantz\" <deltav@wegalink.de>\n> > > >To: <ietf-dav-versioning@w3.org>\n> > > >Subject: Re: WebDAV Invalidation (Was Re: Allow: header and supported\n> > > >methods)\n> > > >Date: Wed, 22 Aug 2001 21:40:39 +0200\n> > > >\n> > > >The protocol described in the ESI document allows to invalidate\n> > > documents\n> > > >that have been downloaded\n> > > >to a local machine by applying a push technology. This could\n> > > solve already\n> > > >several conflict\n> > > >situations or even partly prevent problems.\n> > > >\n> > > >On the other hand there seems to be an increasing need for more\n> > > >fine-grained notification services\n> > > >that extend the traditional access control systems. Picture 1 in the\n> > > >following longer article tries\n> > > >to classify them:\n> > > >\n> > > >\"Beyond 'Yes or No' - Extending Access Control in Groupware with\n> > > >Negotiation and Awareness\"\n> > > >(http://www.informatik.uni-bonn.de/~os/Publications/COOP98a.ps)\n> > > >\n> > > >Maybe those needs are also worth discussing if they could be\n> > > supported in\n> > > >the spec in order to allow\n> > > >applications to build up on them. The invalidation protocol\n> > > seems to be a\n> > > >good basis also for this.\n> > > >\n> > > >Eckhard\n> > > >\n> > > >\n> > > >-----Urspr?ngliche Nachricht-----\n> > > >Von: Eric Sedlar\n> > > >An: ietf-dav-versioning@w3.org\n> > > >Gesendet: Dienstag, 21. August 2001 19:00\n> > > >Betreff: WebDAV Invalidation (Was Re: Allow: header and\n> > > supported methods)\n> > > >\n> > > >\n> > > >Check out\n> > > >http://www.esi.org/invalidation_protocol_1-0.html for some work\n> > > that looks\n> > > >pretty similar\n> > > >to what we are talking about.\n> > > >\n> > > >--Eric\n> > > >\n> > >\n> > >\n> > > _________________________________________________________________\n> > > Get your FREE download of MSN Explorer at\n> >http://explorer.msn.com/intl.asp\n> >\n> >\n> >\n> >\n>\n>\n> _________________________________________________________________\n> Get your FREE download of MSN Explorer at\n> http://explorer.msn.com/intl.asp\n\n\n\n", "id": "lists-006-12922426"}, {"subject": "Event Notification BOF (Was RE: WebDAV Invalidation", "content": "I am very interested in holding a BOF on Web/WebDAV event notifications as\nwell. I agree that the way to avoid the IMPP pit is to keep this effort\ntightly focused on Web notifications. Of course, if a General purpose Event\nNotification Architecture were to emerge from this effort, so much the\nbetter. However, this should not be the stated goal.\n\nA BOF on event notification was held at the Chicago IETF meeting in August,\n1998, the result of which was complete paralysis on this topic, due to many\nfactors. First, the effort was framed as a general-purpose EN facility, not\nlimited to just Web events. Next, since it was considered general purpose,\nthere was a lack of agreement on even where in the protocol stack this\neffort should sit. There was not universal agreement that it was an\napplication layer protocol. Finally, we made the mistake of having too many\npresentations, and not enough time for discussion, and I think that\nprevented the formation of any form of consensus on the topic.\n\nSome slides and notes from that period can be found at:\nhttp://www.ics.uci.edu/pub/ietf/notify/\n\nIn particular, the agenda should be viewed as an example of what not to do,\nsince there was not enough time for discussion (and all of the talks ran\nover their time slots).\n\nAs well, the program from the WISEN workshop (also held in 1998) has many\ninteresting EN slides.\nhttp://www.ics.uci.edu/IRUS/twist/wisen98/program.html\n\n- Jim\n\n\nJosh Cohen writes:\n> I think thats a good idea to have a BOF.\n> What Id like to see most importantly is a\n> focused, and narrow scope.  In my mind,\n> this is a mechanism for subscribing to\n> and receiving specific change events on\n> web resources, within the existing web\n> infrastructure that integrates with DAV.\n\n\nJim Amsden writes:\n> >I'll schedule a BOF at the next IETF meeting. If there's enough interest,\n> >we can create a proposed charter and petition the area directors\n> for a new working group.\n\n\n\n", "id": "lists-006-12944046"}, {"subject": "RE: The Depth header..", "content": "> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n>\n>    From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n>\n>    I agree that the default should be depth zero.\n>\n> I agree as well.  I'll make that change unless anyone objects.\n>\n\nMy objection is that if this is being done for consistency, then the spec\nshould be consistent with RFC 2518.\n\nFrom section 8.1: \"By default, the PROPFIND method without a Depth header\nMUST act as if a \"Depth: infinity\" header was included. \"\n\nSection 8.8.8: \"The Depth header is unnecessary as the default behavior of\nCOPY on a collection is to act as if a \"Depth: infinity\" header had been\nsubmitted. \"\n\nOn the other hand, from section 9.2: \"Methods which support the Depth header\nmay choose not to support all of the header's values and may define, on a\ncase by case basis, the behavior of the method if a Depth header is not\npresent.\"\n\nLisa\n\n\n\n", "id": "lists-006-12953456"}, {"subject": "RE: REPORT", "content": "What's the official way to see if expand-property is supported?  Just\nto try it?\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Tim Ellison\n> Sent: Thursday, September 06, 2001 1:03 PM\n> To: 'DeltaV'\n> Subject: RE: REPORTS\n> \n> \n> \"John Hall\" <johnhall@xythos.com> wrote:\n> \n> > -----Original Message-----\n> > From: John Hall [mailto:johnhall@evergo.net]\n> > Sent: Thursday, September 06, 2001 9:58 AM\n> > To: 'Tim Ellison'; 'DeltaV'\n> > Subject: RE: REPORTS\n> >\n> >\n> > >\n> > > There were no objections raised in the meeting or when the\n> > > minutes were published.  I'd consider that a consensus.\n> >\n> >\n> > It was the equivalent of slipping language in a bill at\n> > reconciliation time, without debate, after midnight when\n> > everyone else had gone home, then rushing the bill out for\n> > signature before anyone noticed.\n> \n> Hey, if you can run a country that way, I'm sure we can write a spec like\n> that<g>\n> \n> > MAY is more appropriate than SHOULD given the late date at\n> > which the change was made, the manner of the change, and the\n> > fact that a commercial implementation of the spec will not be\n> > implementing this report and will recommend that clients who\n> > wish to be interoperable avoid it as well.\n> >\n> > And if there is no difference between MAY and SHOULD, then\n> > there should be no objection to making it MAY.\n> \n> Let's agree on what it _ought_ to say rather than on the process that got\n> us to this point or what you will recommend.\n> \n> Given that the report will be useful in a number of interesting \n> scenarios I\n> think it is a useful optimization that servers SHOULD implement.  \n> Note that\n> clients are free not use use it, and servers are free not to implement it\n> and both will be within the spec.  But servers should be encouraged to\n> implement it and clients should be encouraged to look for it and use it.\n> \n> Regards,\n> Tim\n> \n> \n\n\n\n", "id": "lists-006-12962332"}, {"subject": "Re: REPORT", "content": "Hi,\n\nSection 3.1.5 defines the DAV:supported-report-set property, I believe you\nshould query this property (PROPFIND) and see if the expand property report\nis returned.\n\nRegards,\nPeter Raymond - MERANT.\n\nEric Sedlar wrote:\n\n> What's the official way to see if expand-property is supported?  Just\n> to try it?\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Tim Ellison\n> > Sent: Thursday, September 06, 2001 1:03 PM\n> > To: 'DeltaV'\n> > Subject: RE: REPORTS\n> >\n> >\n> > \"John Hall\" <johnhall@xythos.com> wrote:\n> >\n> > > -----Original Message-----\n> > > From: John Hall [mailto:johnhall@evergo.net]\n> > > Sent: Thursday, September 06, 2001 9:58 AM\n> > > To: 'Tim Ellison'; 'DeltaV'\n> > > Subject: RE: REPORTS\n> > >\n> > >\n> > > >\n> > > > There were no objections raised in the meeting or when the\n> > > > minutes were published.  I'd consider that a consensus.\n> > >\n> > >\n> > > It was the equivalent of slipping language in a bill at\n> > > reconciliation time, without debate, after midnight when\n> > > everyone else had gone home, then rushing the bill out for\n> > > signature before anyone noticed.\n> >\n> > Hey, if you can run a country that way, I'm sure we can write a spec like\n> > that<g>\n> >\n> > > MAY is more appropriate than SHOULD given the late date at\n> > > which the change was made, the manner of the change, and the\n> > > fact that a commercial implementation of the spec will not be\n> > > implementing this report and will recommend that clients who\n> > > wish to be interoperable avoid it as well.\n> > >\n> > > And if there is no difference between MAY and SHOULD, then\n> > > there should be no objection to making it MAY.\n> >\n> > Let's agree on what it _ought_ to say rather than on the process that got\n> > us to this point or what you will recommend.\n> >\n> > Given that the report will be useful in a number of interesting\n> > scenarios I\n> > think it is a useful optimization that servers SHOULD implement.\n> > Note that\n> > clients are free not use use it, and servers are free not to implement it\n> > and both will be within the spec.  But servers should be encouraged to\n> > implement it and clients should be encouraged to look for it and use it.\n> >\n> > Regards,\n> > Tim\n> >\n> >\n\n\n\n", "id": "lists-006-12972430"}, {"subject": "RE: Re (2): Removing the DAV:activity and DAV:version-history and  DAV:baseline resource type value", "content": "Greg wrote:\n\n> > A version is identified by its support for the\n> > <DAV:version-name> property.\n>\n> But also the absence of some other properties. VCRs have the version-name\n> property on them, too.\n\nNope.  A version-controlled resource does not have a DAV:version-name\nproperty.\n\n> Reading that, it would appear that creating a classification\n> of the resources is order dependent. I better have my checks\n> in the proper order.\n\nNope again, the checks can be performed in any order.\n\n> If we aren't going to use resourcetype, then the contents of\n> that post must be reflected somewhere. Or people just aren't\n> going to get it right. If it doesn't go into the spec \"because\n> it duplicates information\", then where are we supposed to put\n> it, such that people will find it?\n>\n> The spec seems the appropriate place for algorithms like that.\n\nI hereby volunteer to write an appendix describing that if people consider\nit a good thing.\n\n> But using a resourcetype can avoid algorithms in the first place :-)\n\n> > (I don't know what 'pthtpth' means, but you probably just swore at me in\n> > acronym-speak:^)\n>\n> Nah. Just a typed out \"raspberry\". :-)  (and you probably don't\n> know that term either, over there in the UK :-)\n\nOh yes, I'm please to say that some parts of our `culture` are compatible\n:-)\n\n> ...\n> >...\n> > (2) If we _do_ go for extending DAV:resourcetype the likely outcome is\n> > something like a *Set* of orthogonal characteristics, such as\n> > <version-controlled-resource>, <collection>, <checked-in> -- guess what,\n> > you'll have to do that \"difficult\" Set thing again anyway.\n>\n> This is probably the sticking point here. We'd probably end up with\nseveral\n> tokens in there to avoid combinatorial explosion :-(\n\nAbsolutely.\n\nTim\n\n\n\n", "id": "lists-006-1298181"}, {"subject": "RE: REPORT", "content": "Yes, looking at DAV:supported-report-set is the correct way \nto determine if a report is supported by a particular resource.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Friday, September 07, 2001 1:27 PM\nTo: Eric Sedlar\nCc: 'DeltaV'\nSubject: Re: REPORTS\n\n\nHi,\n\nSection 3.1.5 defines the DAV:supported-report-set property, I believe you\nshould query this property (PROPFIND) and see if the expand property report\nis returned.\n\nRegards,\nPeter Raymond - MERANT.\n\nEric Sedlar wrote:\n\n> What's the official way to see if expand-property is supported?  Just\n> to try it?\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Tim Ellison\n> > Sent: Thursday, September 06, 2001 1:03 PM\n> > To: 'DeltaV'\n> > Subject: RE: REPORTS\n> >\n> >\n> > \"John Hall\" <johnhall@xythos.com> wrote:\n> >\n> > > -----Original Message-----\n> > > From: John Hall [mailto:johnhall@evergo.net]\n> > > Sent: Thursday, September 06, 2001 9:58 AM\n> > > To: 'Tim Ellison'; 'DeltaV'\n> > > Subject: RE: REPORTS\n> > >\n> > >\n> > > >\n> > > > There were no objections raised in the meeting or when the\n> > > > minutes were published.  I'd consider that a consensus.\n> > >\n> > >\n> > > It was the equivalent of slipping language in a bill at\n> > > reconciliation time, without debate, after midnight when\n> > > everyone else had gone home, then rushing the bill out for\n> > > signature before anyone noticed.\n> >\n> > Hey, if you can run a country that way, I'm sure we can write a spec\nlike\n> > that<g>\n> >\n> > > MAY is more appropriate than SHOULD given the late date at\n> > > which the change was made, the manner of the change, and the\n> > > fact that a commercial implementation of the spec will not be\n> > > implementing this report and will recommend that clients who\n> > > wish to be interoperable avoid it as well.\n> > >\n> > > And if there is no difference between MAY and SHOULD, then\n> > > there should be no objection to making it MAY.\n> >\n> > Let's agree on what it _ought_ to say rather than on the process that\ngot\n> > us to this point or what you will recommend.\n> >\n> > Given that the report will be useful in a number of interesting\n> > scenarios I\n> > think it is a useful optimization that servers SHOULD implement.\n> > Note that\n> > clients are free not use use it, and servers are free not to implement\nit\n> > and both will be within the spec.  But servers should be encouraged to\n> > implement it and clients should be encouraged to look for it and use it.\n> >\n> > Regards,\n> > Tim\n> >\n> >\n\n\n\n", "id": "lists-006-12982650"}, {"subject": "Re: Feature request for CHECKIN/OUT extensio", "content": "Hi,\n\nI have updated my proposal. The main changes are:\n\n1) I am now using the defined element names for the response bodies\n(checkin-response, checkout-response) [Geoff, thanks for adding this to\ndraft 17]\n\n2) FORBIDDEN is 403, not 409.\n\nJulian\n\n--\n\nFeature request for CHECKIN/OUT extension\n\nIn many cases, a versioning-aware client might want to display/include the\nURI of the version it's editing *while* it's edited. For instance, a\nversioning\naware editor might include this as meta-information, or the author of a\ndocument might want to know the URI of the version *before* it's checked in.\nA well-known example is the W3C way of referring to document versions in\nrecommendations: it contains HREFs to \"the current version\", to \"this\nversion\"\nand to the \"previous version\". Something like this is currently impossible\nwith deltaV, as the version URI is determined at the time of CHECKIN.\n\nProposal:\n\n1) Extend CHECKOUT to optionally return an \"expected CHECKIN URI\".\n2) Extend CHECKIN to optionally use the \"expected CHECKIN URI\", failing the\nrequest if it's not possible to checkin the resource with the desired\nversion URI (in which case a new \"expected CHECKIN URI\" is returned).\n\n\nI propose to pass the information in the request/response bodies of\nCHECKIN / CHECKOUT, such as:\n\nCHECKOUT method:\n\n>>REQUEST\n\n  CHECKOUT /foo.html HTTP/1.1\n  Host: www.webdav.org\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkout xmlns:D=\"DAV:\">\n    <D:compute-expected-version-URI />\n  </D:checkout>\n\n\n>>RESPONSE\n\n  HTTP/1.1 200 OK\n  Cache-Control: no-cache\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkout-response xmlns:D=\"DAV:\">\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:expected-ver\nsion-URI>\n  </D:checkout-response>\n\n(Note: if the expected-version-URI cannot be computed, the server will\nsimply not\ninclude it in it's answer).\n\n\nCHECKIN method:\n\n\n>>REQUEST\n\n  CHECKIN /foo.html HTTP/1.1\n  Host: www.webdav.org\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkin xmlns:D=\"DAV:\">\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:expected-ver\nsion-URI>\n  </D:checkin>\n\n>>RESPONSE\n\n  HTTP/1.1 201 Created\n  Location: http://repo.webdav.org/his/23/ver/32\n  Cache-Control: no-cache\n\n  or\n\n>>RESPONSE\n\n  HTTP/1.1 403 Forbidden\n  Cache-Control: no-cache\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkin-response xmlns:D=\"DAV:\">\n    <D:cannot-assign-expected-version-URI />\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/33</D:expected-ver\nsion-URI>\n  </D:checkin-response>\n\n\n\n", "id": "lists-006-12993587"}, {"subject": "RE: Feature request for CHECKIN/OUT extensio", "content": "We should add a \"proposed new feature\" section to the FAQ,\nso that folks can see the list of what is being proposed\n(those that become widely adopted would be likely candidates for \ninclusion when we go to the next RFC level).\n\nThe FAQ is still off-line, but I sent a note to Greg asking\nif he would be able to bring it back on-line.\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\nSent: Friday, September 07, 2001 3:23 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: Feature request for CHECKIN/OUT extension\n\n\nHi,\n\nI have updated my proposal. The main changes are:\n\n1) I am now using the defined element names for the response bodies\n(checkin-response, checkout-response) [Geoff, thanks for adding this to\ndraft 17]\n\n2) FORBIDDEN is 403, not 409.\n\nJulian\n\n--\n\nFeature request for CHECKIN/OUT extension\n\nIn many cases, a versioning-aware client might want to display/include the\nURI of the version it's editing *while* it's edited. For instance, a\nversioning\naware editor might include this as meta-information, or the author of a\ndocument might want to know the URI of the version *before* it's checked in.\nA well-known example is the W3C way of referring to document versions in\nrecommendations: it contains HREFs to \"the current version\", to \"this\nversion\"\nand to the \"previous version\". Something like this is currently impossible\nwith deltaV, as the version URI is determined at the time of CHECKIN.\n\nProposal:\n\n1) Extend CHECKOUT to optionally return an \"expected CHECKIN URI\".\n2) Extend CHECKIN to optionally use the \"expected CHECKIN URI\", failing the\nrequest if it's not possible to checkin the resource with the desired\nversion URI (in which case a new \"expected CHECKIN URI\" is returned).\n\n\nI propose to pass the information in the request/response bodies of\nCHECKIN / CHECKOUT, such as:\n\nCHECKOUT method:\n\n>>REQUEST\n\n  CHECKOUT /foo.html HTTP/1.1\n  Host: www.webdav.org\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkout xmlns:D=\"DAV:\">\n    <D:compute-expected-version-URI />\n  </D:checkout>\n\n\n>>RESPONSE\n\n  HTTP/1.1 200 OK\n  Cache-Control: no-cache\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkout-response xmlns:D=\"DAV:\">\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:expected-ver\nsion-URI>\n  </D:checkout-response>\n\n(Note: if the expected-version-URI cannot be computed, the server will\nsimply not\ninclude it in it's answer).\n\n\nCHECKIN method:\n\n\n>>REQUEST\n\n  CHECKIN /foo.html HTTP/1.1\n  Host: www.webdav.org\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkin xmlns:D=\"DAV:\">\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:expected-ver\nsion-URI>\n  </D:checkin>\n\n>>RESPONSE\n\n  HTTP/1.1 201 Created\n  Location: http://repo.webdav.org/his/23/ver/32\n  Cache-Control: no-cache\n\n  or\n\n>>RESPONSE\n\n  HTTP/1.1 403 Forbidden\n  Cache-Control: no-cache\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <D:checkin-response xmlns:D=\"DAV:\">\n    <D:cannot-assign-expected-version-URI />\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/33</D:expected-ver\nsion-URI>\n  </D:checkin-response>\n\n\n\n", "id": "lists-006-13004278"}, {"subject": "RE: Minor editorial change to section 9.2..", "content": "That change is fine with me.  I'll make it if there are no objections.\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\nThis is a minor editorial issue... \nIn the properties for a working resource (section 9.2) we define\nDAV:checkout-fork and \nDAV:checkin-fork.  I propose we refer back to sections 4.2.1 and 4.2.2? By\ndefining them \nin section 9.2 it gives the impression that they have some other behaviour\nwhen defined \non a working resource rather than any other checked-out resource. \n\n\n\n", "id": "lists-006-13015531"}, {"subject": "RE: Feature request for CHECKIN/OUT extensio", "content": "Attached is an ID-formatted version of my proposal (below in text format,\nattached as RFC2629-XML).\n\n--\n\n\nNetwork Working Group                                         J. Reschke\nInternet-Draft                                                greenbytes\nExpires: March 10, 2002                                September 9, 2001\n\n\n             Computing the CHECKIN URI in WebDAV versioning\n               draft-reschke-deltav-computecheckinuri-00\n\nStatus of this Memo\n\n   This document is an Internet-Draft and is in full conformance with\n   all provisions of Section 10 of RFC2026.\n\n   Internet-Drafts are working documents of the Internet Engineering\n   Task Force (IETF), its areas, and its working groups.  Note that\n   other groups may also distribute working documents as Internet-\n   Drafts.\n\n   Internet-Drafts are draft documents valid for a maximum of six months\n   and may be updated, replaced, or obsoleted by other documents at any\n   time.  It is inappropriate to use Internet-Drafts as reference\n   material or to cite them other than as \"work in progress.\"\n\n   The list of current Internet-Drafts can be accessed at\n   http://www.ietf.org/ietf/1id-abstracts.txt.\n\n   The list of Internet-Draft Shadow Directories can be accessed at\n   http://www.ietf.org/shadow.html.\n\n   This Internet-Draft will expire on March 10, 2002.\n\nCopyright Notice\n\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n\nAbstract\n\n   In many cases, a versioning-aware client might want to\n   display/include the URI of the version it's editing while it's being\n   edited.  For instance, an editor might include this as meta\n   information, or the author of a document might want to know the URI\n   of the version before it's checked in.  A well-known example is the\n   W3C way of referring to document versions in recommendations: it\n   contains references to \"the current version\", to \"this version\" and\n   to the \"previous version\".  Something like this is currently\n   impossible with the current draft version of WebDAV deltaV [deltaV],\n   as the version URI is determined at the time of CHECKIN.\n\n   Distribution of this document is unlimited.  Please send comments to\n\n\n\nReschke                  Expires March 10, 2002                 [Page 1]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\n   the WebDAV versioning (delta-V) working group at ietf-dav-\n   versioning@w3.org[1], which may be joined by sending a message with\n   subject \"subscribe\" to ietf-dav-versioning-request@w3.org[2].\n\n   Discussions of the delta-V working group are archived at URL:\n   http://lists.w3.org/Archives/Public/ietf-dav-versioning/.\n\nTable of Contents\n\n   1.  Notational Conventions . . . . . . . . . . . . . . . . . . . .  3\n   2.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n   3.  Changes for CHECKOUT method (when applied to a\n       version-controlled resource) . . . . . . . . . . . . . . . . .  5\n   3.1 Example for successful CHECKOUT with computed-checkin-URI  . .  5\n   3.2 Example for successful CHECKOUT without computed-checkin-URI .  6\n   4.  Changes for CHECKIN method (when applied to a\n       version-controlled resource) . . . . . . . . . . . . . . . . .  7\n   4.1 Example for successful CHECKIN with computed-checkin-URI . . .  7\n   4.2 Example for failed CHECKIN with computed-checkin-URI . . . . .  8\n   5.  Compatibility Considerations . . . . . . . . . . . . . . . . .  9\n   6.  Internationalization Considerations  . . . . . . . . . . . . . 10\n   7.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 11\n   8.  Copyright  . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n   9.  Intellectual Property  . . . . . . . . . . . . . . . . . . . . 13\n       References . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n       Author's Address . . . . . . . . . . . . . . . . . . . . . . . 14\n       Full Copyright Statement . . . . . . . . . . . . . . . . . . . 15\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                 [Page 2]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\n1. Notational Conventions\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                 [Page 3]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\n2. Introduction\n\n   In many cases, a versioning-aware client might want to\n   display/include the URI of the version it's editing while it's being\n   edited.  For instance, an editor might include this as meta\n   information, or the author of a document might want to know the URI\n   of the version before it's checked in.  A well-known example is the\n   W3C way of referring to document versions in recommendations: it\n   contains references to \"the current version\", to \"this version\" and\n   to the \"previous version\".  Something like this is currently\n   impossible with the current draft version of WebDAV deltaV [deltaV],\n   as the version URI is determined at the time of CHECKIN.\n\n   This specification builds on the infrastructure provided by the\n   WebDAV Versioning Protocol, adding support for servers willing to\n   compute an \"expected CHECKIN URI\" upon CHECKOUT, and using this URI\n   at time of CHECKIN.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                 [Page 4]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\n3. Changes for CHECKOUT method (when applied to a version-controlled\n   resource)\n\n   A client may ask for an \"expected CHECKIN URI\" upon CHECKOUT.  This\n   is done by placing DAV:compute-expected-checkin-URI as top-level\n   element into the request body.  The server is free to either ignore\n   the request, or to return it's best guess about what the URI for a\n   version resource created upon CHECKIN would be.\n\n   The client can detect the \"expected CHECKIN URI\" by parsing the\n   response body for a top-level element called DAV:expected-checkin-\n   URI.\n\n3.1 Example for successful CHECKOUT with computed-checkin-URI\n\n    >>Request\n\n      CHECKOUT /foo.html HTTP/1.1\n      Host: www.webdav.org\n      Content-Type: text/xml; charset=\"utf-8\"\n      Content-Length: xxxx\n\n      <D:checkout xmlns:D=\"DAV:\">\n        <D:compute-expected-version-URI />\n      </D:checkout>\n\n    >>Response\n\n      HTTP/1.1 200 OK\n      Cache-Control: no-cache\n      Content-Type: text/xml; charset=\"utf-8\"\n      Content-Length: xxxx\n\n      <D:checkout-response xmlns:D=\"DAV:\">\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:expected-ver\nsion-URI>\n      </D:checkout-response>\n\n   In this example, the server was able to compute the \"expected CHECKIN\n   URI\" and returned it in the DAV:expected-version-URI element.\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                 [Page 5]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\n3.2 Example for successful CHECKOUT without computed-checkin-URI\n\n    >>Request\n\n      CHECKOUT /foo.html HTTP/1.1\n      Host: www.webdav.org\n      Content-Type: text/xml; charset=\"utf-8\"\n      Content-Length: xxxx\n\n      <D:checkout xmlns:D=\"DAV:\">\n        <D:compute-expected-version-URI />\n      </D:checkout>\n\n    >>Response\n\n      HTTP/1.1 200 OK\n      Cache-Control: no-cache\n\n   In this case, no response body was returned, and thus no \"expected\n   CHECKIN URI\" is available.  Simarily, the server may also return\n\n    >>Response\n\n      HTTP/1.1 200 OK\n      Cache-Control: no-cache\n      Content-Type: text/xml; charset=\"utf-8\"\n      Content-Length: xxxx\n\n      <D:checkout-response xmlns:D=\"DAV:\">\n          ...other content...\n      </D:checkout-response>\n\n   where a response body is available, but it doesn't contain the\n   DAV:expected-checkin-URI element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                 [Page 6]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\n4. Changes for CHECKIN method (when applied to a version-controlled\n   resource)\n\n   A client may submit the \"expected CHECKIN URI\" (obtained during\n   CHECKOUT) upon a CHECKIN by placing it into a top-level DAV:expected-\n   checkin-URI element in the request body.  A server may\n\n   o  simply ignore the presence of this information or\n\n   o  use the information and try to checkin the resource using the\n      \"expected checkin URI\" as location for the version resource.  A\n      failure to create a version resource at the \"expected checkin URI\"\n      MUST cause the operation to fail with a status code of 403\n      (forbidden) and a response body containing the top-level element\n      DAV:cannot-assign-expected-version-URI.  In addition, a server MAY\n      return a new \"expected checkin URI\" in it's response body.\n\n\n4.1 Example for successful CHECKIN with computed-checkin-URI\n\n   >>Request\n\n     CHECKIN /foo.html HTTP/1.1\n     Host: www.webdav.org\n     Content-Type: text/xml; charset=\"utf-8\"\n     Content-Length: xxxx\n\n     <D:checkin xmlns:D=\"DAV:\">\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:expected-ver\nsion-URI>\n     </D:checkin>\n\n    >>Response\n\n     HTTP/1.1 201 Created\n     Location: http://repo.webdav.org/his/23/ver/32\n     Cache-Control: no-cache\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                 [Page 7]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\n4.2 Example for failed CHECKIN with computed-checkin-URI\n\n    >>Request\n\n     CHECKIN /foo.html HTTP/1.1\n     Host: www.webdav.org\n     Content-Type: text/xml; charset=\"utf-8\"\n     Content-Length: xxxx\n\n     <D:checkin xmlns:D=\"DAV:\">\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:expected-ver\nsion-URI>\n     </D:checkin>\n\n    >>Response\n\n     HTTP/1.1 403 Forbidden\n     Cache-Control: no-cache\n     Content-Type: text/xml; charset=\"utf-8\"\n     Content-Length: xxxx\n\n     <D:checkin-response xmlns:D=\"DAV:\">\n       <D:cannot-assign-expected-version-URI />\n\n<D:expected-version-URI>http://repo.webdav.org/his/23/ver/33</D:expected-ver\nsion-URI>\n     </D:checkin-response>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                 [Page 8]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\n5. Compatibility Considerations\n\n   This specification does introduce new protocol elements for the\n   request and response bodies for CHECKIN and CHECKOUT.\n\n   Clients not aware of this specification will never submit the new\n   protocol elements in a request and therefore never will see the new\n   response elements.\n\n   Servers not aware of this specification will ignore the additional\n   two request body elements which is legal behaviour according to this\n   protocol (indicating that the protocol extension is not available).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                 [Page 9]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\n6. Internationalization Considerations\n\n   This proposal builds on [deltaV], and inherits its\n   internationalizability.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                [Page 10]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\n7. IANA Considerations\n\n   This proposal does not introduce any new IANA considerations, since\n   it does not specify any new namespaces (in the general sense), but\n   merely uses existing ones.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                [Page 11]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\n8. Copyright\n\n   To be supplied by the RFC Editor.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                [Page 12]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\n9. Intellectual Property\n\n   To be supplied by the RFC Editor.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                [Page 13]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\nReferences\n\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\n   [RFC2518]  Goland, Y., Whitehead, E., Faizi, A., Carter, S. and D.\n              Jensen, \"HTTP Extensions for Distributed Authoring --\n              WEBDAV\", RFC 2518, February 1999.\n\n   [deltaV]   Clemm, G., Amsden, J., Ellison, T., Kaler, C. and J.\n              Whitehead, \"Versioning Extensions to WebDAV\", ID draft-\n              ietf-deltav-versioning-17, August 2001,\n              <http://www.webdav.org/deltav/protocol/draft-ietf-deltav-\n              versioning-17.htm>.\n\n   [1]  <mailto:ietf-dav-versioning@w3.org>\n\n   [2]  <mailto:ietf-dav-versioning-request@w3.org?subject=subscribe>\n\n\nAuthor's Address\n\n   Julian F. Reschke\n   greenbytes GmbH\n   Salzmannstrasse 152\n   Muenster, NW  48159\n   Germany\n\n   EMail: julian.reschke@greenbytes.de\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                [Page 14]\n\nInternet-Draft      CHECKIN URI in WebDAV versioning      September 2001\n\n\nFull Copyright Statement\n\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n\n   This document and translations of it may be copied and furnished to\n   others, and derivative works that comment on or otherwise explain it\n   or assist in its implementation may be prepared, copied, published\n   and distributed, in whole or in part, without restriction of any\n   kind, provided that the above copyright notice and this paragraph are\n   included on all such copies and derivative works.  However, this\n   document itself may not be modified in any way, such as by removing\n   the copyright notice or references to the Internet Society or other\n   Internet organizations, except as needed for the purpose of\n   developing Internet standards in which case the procedures for\n   copyrights defined in the Internet Standards process must be\n   followed, or as required to translate it into languages other than\n   English.\n\n   The limited permissions granted above are perpetual and will not be\n   revoked by the Internet Society or its successors or assigns.\n\n   This document and the information contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n\nAcknowledgement\n\n   Funding for the RFC Editor function is currently provided by the\n   Internet Society.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReschke                  Expires March 10, 2002                [Page 15]\n\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Julian F.\n> Reschke\n> Sent: Friday, September 07, 2001 9:23 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: Feature request for CHECKIN/OUT extension\n>\n>\n> Hi,\n>\n> I have updated my proposal. The main changes are:\n>\n> 1) I am now using the defined element names for the response bodies\n> (checkin-response, checkout-response) [Geoff, thanks for adding this to\n> draft 17]\n>\n> 2) FORBIDDEN is 403, not 409.\n>\n> Julian\n>\n> --\n>\n> Feature request for CHECKIN/OUT extension\n>\n> In many cases, a versioning-aware client might want to display/include the\n> URI of the version it's editing *while* it's edited. For instance, a\n> versioning\n> aware editor might include this as meta-information, or the author of a\n> document might want to know the URI of the version *before* it's\n> checked in.\n> A well-known example is the W3C way of referring to document versions in\n> recommendations: it contains HREFs to \"the current version\", to \"this\n> version\"\n> and to the \"previous version\". Something like this is currently impossible\n> with deltaV, as the version URI is determined at the time of CHECKIN.\n>\n> Proposal:\n>\n> 1) Extend CHECKOUT to optionally return an \"expected CHECKIN URI\".\n> 2) Extend CHECKIN to optionally use the \"expected CHECKIN URI\",\n> failing the\n> request if it's not possible to checkin the resource with the desired\n> version URI (in which case a new \"expected CHECKIN URI\" is returned).\n>\n>\n> I propose to pass the information in the request/response bodies of\n> CHECKIN / CHECKOUT, such as:\n>\n> CHECKOUT method:\n>\n> >>REQUEST\n>\n>   CHECKOUT /foo.html HTTP/1.1\n>   Host: www.webdav.org\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx\n>\n>   <D:checkout xmlns:D=\"DAV:\">\n>     <D:compute-expected-version-URI />\n>   </D:checkout>\n>\n>\n> >>RESPONSE\n>\n>   HTTP/1.1 200 OK\n>   Cache-Control: no-cache\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx\n>\n>   <D:checkout-response xmlns:D=\"DAV:\">\n>\n> <D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:ex\n> pected-ver\n> sion-URI>\n>   </D:checkout-response>\n>\n> (Note: if the expected-version-URI cannot be computed, the server will\n> simply not\n> include it in it's answer).\n>\n>\n> CHECKIN method:\n>\n>\n> >>REQUEST\n>\n>   CHECKIN /foo.html HTTP/1.1\n>   Host: www.webdav.org\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx\n>\n>   <D:checkin xmlns:D=\"DAV:\">\n>\n> <D:expected-version-URI>http://repo.webdav.org/his/23/ver/32</D:ex\n> pected-ver\n> sion-URI>\n>   </D:checkin>\n>\n> >>RESPONSE\n>\n>   HTTP/1.1 201 Created\n>   Location: http://repo.webdav.org/his/23/ver/32\n>   Cache-Control: no-cache\n>\n>   or\n>\n> >>RESPONSE\n>\n>   HTTP/1.1 403 Forbidden\n>   Cache-Control: no-cache\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx\n>\n>   <D:checkin-response xmlns:D=\"DAV:\">\n>     <D:cannot-assign-expected-version-URI />\n>\n> <D:expected-version-URI>http://repo.webdav.org/his/23/ver/33</D:ex\n> pected-ver\n> sion-URI>\n>   </D:checkin-response>\n>\n>\n\n\n\n\n\ntext/xml attachment: draft-reschke-deltav-computecheckinuri.xml\n\n\n\n\n", "id": "lists-006-13023295"}, {"subject": "RE: Some more comments on the LABEL section..", "content": "   From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n\n   Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n   > The last paragraph of the introduction to the LABEL feature\n   > (section 8) seems out of place.? This text is non-normative and\n   > talks about distributed servers and synchronization which is not\n   > discussed elsewhere in the specification.  It seems like the\n   > kinda text you would put in an implementers guide or a\n   > specification regarding synchronization between deltav servers.?\n   > I am sure that other aspects of deltav would cause\n   > synchronization problems in a distributed server environment.? At\n   > the London IETF we talked about an \"implementers guide\" for\n   > deltav, if we have such a document I propose this section is\n   > removed from the draft and placed in the implementers guide.\n\n   That's fine by me (its there because someone asked for that\n   justification to be added, but I'm equally happy for it to be moved\n   out).\n\nFine by me as well.  Unless somebody objects, I'll delete this and\nwe can add it to an implementers guide.\n\n   > Also I am not sure I understand why UPDATE (section 8.9) can take\n   > two labels, one in the header and one in the DAV:label-name\n   > element.\n\n   I think that is a bug.\n\nYes, definitely a bug ... thanks for catching that, Peter!\n\n   The Label: header should not apply to an UPDATE request.  A label should\n   only appear in the body (in the DAV:label-name element) of the UPDATE\n   request.  Then the Label: header simply means \"apply this method to the\n   version with the given label in the version history of the\n   version-controlled resource\".\n\nYes.  This was left over from the days when semantics of UPDATE were\nthe other direction (i.e. the resource to be updated was in the body,\nand the versions to use for the update were specified by the request URL).\n\n   I recommend we disallow/ignore the Label: header on an UPDATE request,\nand\n   change the postcondition to read:\n\n   \"(DAV:apply-request-to-labeled-version): If the request includes a\n   DAV:label-name element in the request body, the content and deep\nproperties\n   of the version-controlled resource are updated to be those of the version\n   selected by that label.\"\n\nYes, that was the intent.  I'll make this fix.\n\n   > Why does the DAV:must-select-version-in-history precondition only\n   > affect the request URL, for example when you specify a depth\n   > should this precondition not apply to all VCRs that match that\n   > depth?\n\n   You're right, for each version-controlled resource matching the\n   depth header, UPDATE should select the labeled version in the\n   version history of that version-controlled resource.\n\nWhen \"the request is applied to all members\", the request is\neffectively reapplied for each member, which means the \"request-URI\"\nis effectively reset to be the URI for the member to which the request\nis currently being applied.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13053988"}, {"subject": "RE: The Depth header..", "content": "My impression is that there is more support for having the\ndefault value of the Depth header for a given method to\nbe the \"natural\" value for that method, not some global\ndefault (and as you point out below, section 9.2 of 2518\nsupports that position).  \n\nFor the UPDATE method, Tim pointed out that\nDepth:0 is the more natural default for the Depth\nheader since Depth:infinity only makes sense when the label\nfeature is supported and DAV:label-name is specified in the\nrequest body.  That argument makes sense to me.\n\n(And just for the record, I believe that\nmaking the default Depth value for PROPFIND be Depth:infinity\nwas a mistake, and that it should be changed to Depth:0\nin the next rev of 2518, but that's a thread for a different\nmailing list :-).\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Friday, September 07, 2001 12:56 PM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: RE: The Depth header...\n\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n>\n>    From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n>\n>    I agree that the default should be depth zero.\n>\n> I agree as well.  I'll make that change unless anyone objects.\n>\n\nMy objection is that if this is being done for consistency, then the spec\nshould be consistent with RFC 2518.\n\nFrom section 8.1: \"By default, the PROPFIND method without a Depth header\nMUST act as if a \"Depth: infinity\" header was included. \"\n\nSection 8.8.8: \"The Depth header is unnecessary as the default behavior of\nCOPY on a collection is to act as if a \"Depth: infinity\" header had been\nsubmitted. \"\n\nOn the other hand, from section 9.2: \"Methods which support the Depth header\nmay choose not to support all of the header's values and may define, on a\ncase by case basis, the behavior of the method if a Depth header is not\npresent.\"\n\nLisa\n\n\n\n", "id": "lists-006-13064517"}, {"subject": "Working Collection", "content": "What happened to the DAV:version-controlled-binding-set Working\nCollection property, in draft 17? Section 14.3 ends a bit abruptly, and\nWorking Collection is no longer in the Resource Classification appendix.\n\nThanks,\nAlison.\n--\n -------------------------------------------------------------\n The statements and opinions expressed here are my own\n and do not necessarily represent those of Oracle Corporation.\n -------------------------------------------------------------\n\n\n\n", "id": "lists-006-13074443"}, {"subject": "Property-o-ram", "content": "Prompted by the recent discussions, I thought I'd share this list of\nproperties derived from DeltaV and WebDAV specs.\n\nAs usual, I have a cryptic layout and nomenclature (free decoding ring not\nincluded).\n\nProtected and computed properties are flagged as such.\nThe defining feature is noted in square brackets (so if your server \"doesn't\ndo activities\" then you don't get to play with any [activity] properties).\n\n------------------\nDelta-V Properties versioning-15\n\n*Any* DeltaV Resource\n\nDAV:creationdate [webdav]\nDAV:displayname [webdav]\nDAV:getcontentlanguage [webdav]\nDAV:getcontentlength [webdav]\nDAV:getcontenttype [webdav]\nDAV:getetag [webdav]\nDAV:getlastmodified [webdav]\nDAV:lockdiscovery [webdav]\nDAV:resourcetype [webdav]\nDAV:source [webdav]\nDAV:supportedlock [webdav]\nDAV:comment [version-control]\nDAV:creator-displayname [version-control]\nDAV:supported-method-set (protected) [version-control]\nDAV:supported-live-property-set (protected) [version-control]\nDAV:supported-report-set (protected) [version-control]\nDAV:workspace (protected) [workspace]\nDAV:version-controlled-configuration (computed) [baseline]\n\n\n*Any* Checked-out Resource\n\nDAV:checked-out (protected) [version-control]\nDAV:predecessor-set [version-control]\nDAV:precursor-set [version-control]\nDAV:merge-set [merge]\nDAV:auto-merge-set [merge]\nDAV:unreserved [activity]\nDAV:activity-set [activity]\n\n\nVersion-Controlled Resource\n\nDAV:checked-in (protected) [version-control] *only if checked-in*\nDAV:auto-checkout [version-control]\nDAV:auto-checkin [version-control]\nDAV:version-history (computed) [version history]\n+ all deltav resource properties.\n+ all checked-out resource properties if it is checked out.\n\n\nVersion-controlled configuration\n\nDAV:baseline-controlled-collection (protected) [baseline]\nDAV:subbaseline-set [baseline] * only if checked-out *\nDAV:version-controlled-configuration (computed) [baseline]\n+ all version-controlled resource properties.\n\n\nVersion\n\nDAV:predecessor-set (protected) [version-control]\nDAV:successor-set (computed) [version-control]\nDAV:checkout-set (computed) [version-control]\nDAV:version-name (protected) [version-control]\nDAV:precursor-set (protected) [version-control]\nDAV:checkout-fork [checkout]\nDAV:checkin-fork [checkout]\nDAV:version-history (computed) [version history]\nDAV:label-name-set (protected) [label]\nDAV:activity-set [activity]\nDAV:version-controlled-binding-set [version-controlled collection] * only if\ncollection *\n+ all deltav resource properties\n\n\nWorking Resource\n\nDAV:version-controlled-binding-set [version-controlled collection] * only if\ncollection *\n+ all deltav resource properties\n+ all checked-out resource properties\n\n\nBaseline\n\nDAV:baseline-collection (protected) [baseline]\nDAV:subbaseline-set (protected) [baseline]\n+ all version properties\n\n\nVersion History Resource\n\nDAV:version-set (protected) [version history]\nDAV:root-version (computed) [version history]\n+ all deltav resource properties\n\n\nWorkspace Resource\n\nDAV:workspace-checkout-set (computed) [workspace]\nDAV:baseline-controlled-collection-set (computed) [baseline]\nDAV:current-activity-set [activity]\n+ all deltav resource properties\n\n\nActivity Resource\n\nDAV:activity-version-set (computed) [activity]\nDAV:activity-checkout-set (computed) [activity]\nDAV:subactivity-set [activity]\nDAV:current-workspace-set (computed) [activity]\n+ all deltav resource properties\n\n\nVersion-Controlled Collection Resource\n\nDAV:eclipsed-set (computed) [version-controlled collection]\n+ all version-controlled resource properties\n\n-----------------\n\nTrivia: If a server implements all the deltav features, a baseline would\nhave 31 live properties.  Allprop? No thanks.\n\n\nTim\n\n\n\n", "id": "lists-006-1308088"}, {"subject": "RE: Working Collection", "content": "Unlike a collection version (whose member state is defined in its\nDAV:version-controlled-binding-set), the member state of a working\ncollection is defined by its actual bindings (i.e. internal members).\nThis allows a client to atomically add new members\n(i.e. members added to the working collection by PUT and MKCOL), delete\nold members, or rename members, in a single atomic operation (i.e. the\nCHECKIN of the working collection).\n\nThere was a draft that incorrectly associated\nDAV:version-controlled-binding-set\nwith working collections, but that was fixed in draft 17.\n\nThe working collection is no longer in the Resource Classification appendix\nbecause it is just a working resource that happens to be a collection.\nSo we could say that a working collection has the properties/methods\nof both a working resource and a collection, but this was felt to be\nobvious enough to not require a section in the appendix.\nWe could add it back in if this is not in fact as obvious as was originally\nthought.\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Alison Macmillan [mailto:alison.macmillan@oracle.com]\nSent: Monday, September 10, 2001 11:50 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Working Collections\n\n\n\nWhat happened to the DAV:version-controlled-binding-set Working\nCollection property, in draft 17? Section 14.3 ends a bit abruptly, and\nWorking Collection is no longer in the Resource Classification appendix.\n\nThanks,\nAlison.\n--\n -------------------------------------------------------------\n The statements and opinions expressed here are my own\n and do not necessarily represent those of Oracle Corporation.\n -------------------------------------------------------------\n\n\n\n", "id": "lists-006-13081608"}, {"subject": "Re (2): The Depth header..", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> My impression is that there is more support for having the\n> default value of the Depth header for a given method to\n> be the \"natural\" value for that method\nFine with me, if there is such a beast :-)\n\n> For the UPDATE method, Tim pointed out that\n> Depth:0 is the more natural default for the Depth\n> header since Depth:infinity only makes sense when the label\n> feature is supported and DAV:label-name is specified in the\n> request body.  That argument makes sense to me.\nSo what's the natural default for a baseline ? My impression\nwas that this would be sort of infinity (In the end limited by the members\nof the configuration).\n\nCheers, Edgar\n\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-13090774"}, {"subject": "RE: Re (2): The Depth header..", "content": "The protocol for updating a baseline-controlled collection with a\nnew baseline is to apply the UPDATE request to the version-controlled\nconfiguration, which is a non-collection resource and therefore Depth:0\nis sufficient and appropriate.  As a side effect, an arbitrarily large\nnumber of version-controlled members of the baseline-controlled collection\nwill also be updated (and these will be enumerated in the response to\nthe UPDATE request, but not because of a Depth header).\n\nSo the only UPDATE request for which a Depth:infinity header is appropriate\nwould be one that is updating all members of a collection with a specifid\nlabel (i.e. with DAV:label-name in the request body).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n\n> For the UPDATE method, Tim pointed out that\n> Depth:0 is the more natural default for the Depth\n> header since Depth:infinity only makes sense when the label\n> feature is supported and DAV:label-name is specified in the\n> request body.  That argument makes sense to me.\n\nSo what's the natural default for a baseline ? My impression\nwas that this would be sort of infinity (In the end limited by the members\nof the configuration).\n\n\n\n", "id": "lists-006-13098863"}, {"subject": "Re: Working Collection", "content": "\"Clemm, Geoff\" wrote:\n\n> Unlike a collection version (whose member state is defined in its\n> DAV:version-controlled-binding-set), the member state of a working\n> collection is defined by its actual bindings (i.e. internal members).\n> This allows a client to atomically add new members\n> (i.e. members added to the working collection by PUT and MKCOL), delete\n> old members, or rename members, in a single atomic operation (i.e. the\n> CHECKIN of the working collection).\n>\n> There was a draft that incorrectly associated\n> DAV:version-controlled-binding-set\n> with working collections, but that was fixed in draft 17.\n>\n\nAlthough the property definition has been removed from 14.3, the last paragraph\nof 14.3 still ends with:\n\"A working collection has all the properties of a working resource.\n       In addition, the version-controlled-collection feature introduces\n       the following REQUIRED property for a working collection. \"\n\n>\n> The working collection is no longer in the Resource Classification appendix\n> because it is just a working resource that happens to be a collection.\n> So we could say that a working collection has the properties/methods\n> of both a working resource and a collection, but this was felt to be\n> obvious enough to not require a section in the appendix.\n> We could add it back in if this is not in fact as obvious as was originally\n> thought.\n>\n\nNo need to add it back in, as far as I'm concerned.\n\nThanks,\nAlison.\n\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Alison Macmillan [mailto:alison.macmillan@oracle.com]\n> Sent: Monday, September 10, 2001 11:50 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Working Collections\n>\n> What happened to the DAV:version-controlled-binding-set Working\n> Collection property, in draft 17? Section 14.3 ends a bit abruptly, and\n> Working Collection is no longer in the Resource Classification appendix.\n>\n> Thanks,\n> Alison.\n> --\n>  -------------------------------------------------------------\n>  The statements and opinions expressed here are my own\n>  and do not necessarily represent those of Oracle Corporation.\n>  -------------------------------------------------------------\n\n--\n -------------------------------------------------------------\n The statements and opinions expressed here are my own\n and do not necessarily represent those of Oracle Corporation.\n -------------------------------------------------------------\n\n\n\n", "id": "lists-006-13107259"}, {"subject": "RE: Working Collection", "content": "   From: Alison Macmillan [mailto:alison.macmillan@oracle.com]\n\n   \"Clemm, Geoff\" wrote:\n   > There was a draft that incorrectly associated\n   > DAV:version-controlled-binding-set\n   > with working collections, but that was fixed in draft 17.\n\n   Although the property definition has been removed from 14.3, the\n   last paragraph of 14.3 still ends with:\n\n   \"A working collection has all the properties of a working resource.\n   In addition, the version-controlled-collection feature introduces\n   the following REQUIRED property for a working collection. \"\n\nOK, now I get it.  Thanks for noticing that!  Since working collections\ndo not have any special properties, they need to be described in the\nsection 14, not in a \"working collection properties\" section.  I'll\nmake that fix.\n\nMany thanks to Alison and Peter for catching these editorial errors so\nthat they can be fixed before they are memorialized in the RFC!\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13117200"}, {"subject": "Call for Experts: JSR-147 (Workspace Versioning and Configuration  Management", "content": "The Executive Commitee of the Java Community Process (www.jcp.org)\nhas recently approved the Java Specification Request,\nJSR-147: \"Workspace Versioning and Configuration Management\".\nThe purpose of this specification is to provide a client-side\nJava library for using DeltaV/WebDAV to communicate with a\nversioning server.\n\nThe full text of this JSR, as well as instructions for volunteering\nfor the Expert Group for this JSR, can be found at \n<http://www.jcp.org/jsr/detail/147.jsp>.\n\nThe \"expert group\" is similar in function to an IETF design team.\nNote that you must be a member of the JCP in order to serve as an\nexpert, which basically requires you to send in annual dues and sign\nan agreement about public usage of your submissions to the JCP\n(details at http://www.jcp.org).\n\nI encourage anyone with expertise in DeltaV or Java (preferably both)\nto volunteer for this effort.  The expert team will be selected by the\nend of September (9/30/01).\n\nI've appended a description of JSR-147 to this message.\n\nCheers,\nGeoff\n\n--------------------------------------------------------------------\n\nJSR-147: Workspace Versioning and Configuration Management\n\nCollaborative authoring tools, including tools targeted for software\ndevelopment, document management, and web content management, need\naccess to a variety of services for versioning and configuration\nmanagement of the files and web resources being created and\nmodified. The DeltaV protocol (which is an extension to the WebDAV\nprotocol, which itself is an extension of the HTTP/1.1 protocol)\nprovides a standard protocol for versioning and configuration\nmanagement of web resources. The DeltaV protocol is the result of a\nthree-year collaborative effort by a wide range of participants from\nthe open source community, academics, and industry (e.g. IBM, Oracle,\nMerant, Microsoft, Rational). But this protocol has the following\nproblems when used by a client:\n\n- The client often needs to maintain copies of the web resources in\n  the client file system (e.g. for disconnected use and performance\n  improvement). Unless clients agree on how that local file system\n  state is maintained, it is impossible for multiple clients to\n  maintain correct local file system state.\n\n- DeltaV (since it is a client-server protocol) provides no standard\n  mechanism for requesting information from the user to complete a\n  requested operation.\n\n- There is a large amount of boilerplate coding required to generate\n  and receive HTTP messages. It is far simpler and less error prone\n  for a client application to simply invoke Java routines.\n\n- There are two significantly different variants of the DeltaV\n  protocol: the client-workspace package and the server-workspace\n  package.  From a client's perspective, these two packages provide the\n  same functionality, and only differ by whether or not persistent state\n  is maintained on the client.\n\nThis specification will address these problems by defining a client\nside library that will expose the full DeltaV functionality and will\nuse the DeltaV protocol to communicate with a server, but will:\n\n- automatically provide client-side file maintenance required by any\n  DeltaV operation\n\n- define GUI callbacks for requesting from the user any information\n  required to complete an operation\n\n- generate the DeltaV messages and parse the DeltaV responses\n\n- hide the distinction between a client workspace and a server\n  workspace in the client side library implementation, so that a user of\n  the library is presented with a single uniform workspace interface.\n\n\n\n", "id": "lists-006-13125433"}, {"subject": "Lockin", "content": "In Xythos first generation server, locking a VCR locks the VHR and all\nVERSIONS.\n\nDeltaV defines these as completely different resources, and it has been\npreviously mentioned that they should be locked independently.\n\nBut it looks like things are more complex than they first appear.\n\nA VHR is not appropriately a target of a PUT or a PROPPATCH on my\nsystem.  What meaning could they have?  Note that we have been told that\nin order to support global properties we should have people do a\nPROPPATCH on the VHR.  \n\nIn my model of how that would work, the real resource being modified is\nthe VCR and all versions of the file -- not the VHR -- and a PROPFIND on\nthe VCR should see the global properties.  If the VCR is locked, a\nPROPPATCH that modifies its state should fail.\n\nIt has been pointed out to me that this was probably not what the list\nmeant.  If such properties (set on the VHR) were not visible on the VCR\nand you had to access the VHR to get them then someone implementing that\nshould allow a lock on the VHR.  However, in that case I wouldn't see\n'setting VHR properties' as being a way to implement global properites.\nI'd drop my plans to support PROPPATCH on the VHR, hence the reason to\nlock the VHR.\n\nTherefore, I see no reason why a VHR should be locked independently of a\nVCR.  Either the operation is moot, or (in the case of guidance we have\nreceived on global properties) the proper lock is on the VCR not the\nVHR.\n\nNext, we have past versions.  Past versions are not mutable (there goes\nPUT and PROPPATCH).  A non-forking server such as mine does not allow\npast versions to be checked out.  LABEL isn't supported, but is LABEL\nsupposed to honor a write lock?  I'm not so sure.  So I see no reason to\nsupport a LOCK on a past version.\n\nA CHECKOUT creates a 'state that can be modified'.  \n\nIn the case of Checkout-In-Place, that is logically the VCR.  I'm told\nthat there shouldn't be a real version in this case that can be accessed\nindependently of the VCR.  Again, only a VCR lock makes sense.\n\nYes, I note that I must provide for a lock on a working resource.\n\nI'm just trying to find a reason whey I should allow it anywhere else.\nI'm not seeing one.\n\n\n\n", "id": "lists-006-13135786"}, {"subject": "RE: Lockin", "content": "   From: John Hall [mailto:johnhall@xythos.com]\n\n   In Xythos first generation server, locking a VCR locks the VHR and all\n   VERSIONS.\n\n   DeltaV defines these as completely different resources, and it has been\n   previously mentioned that they should be locked independently.\n\nYes, it is fine for your client to present a model to the user that a\nlock on a VCR also locks the VHR, but to be compatible with the\nprotocol, that should be marshalled as two LOCK requests, one to the\nVCR and another to the VHR.\n\n   A VHR is not appropriately a target of a PUT or a PROPPATCH on my\n   system.  What meaning could they have?\n\nA PUT is undefined on a VHR (just as PUT is undefined on a collection\nand an activity).  PROPPATCH is meaningful ... it gives the VHR a\nproperty (DAV:displayname, or some custom property).\n\n   Note that we have been told that\n   in order to support global properties we should have people do a\n   PROPPATCH on the VHR.  \n\nThe way this would work is that your GUI would display both the\nproperties of a VCR as well as the properties of the VHR, thus\neffectively displaying the VCR as \"inheriting\" the properties of its\nVHR.  You would have to make some decision about what to do in the\ncase of conflicts (i.e. when both the VCR and VHR have the same\nproperty with different values).  A client would be responsible for\ndeciding whether a the property is a \"global\" (on the VHR) or \"local\"\n(on the VCR) property (assumedly based on some GUI gesture from the\nuser).\n\n   In my model of how that would work, the real resource being modified is\n   the VCR and all versions of the file -- not the VHR -- and a PROPFIND on\n   the VCR should see the global properties.   If the VCR is locked, a\n   PROPPATCH that modifies its state should fail.\n\nYour client can present any model that it wants, but to interoperate\nwith multiple servers, it needs to adhere to the DeltaV semantics,\nin which the VCR and VHR are separate resources with their own locks.\nSimilarly, your client can do whatever it wants in terms of displaying\na global property model, but to provide an interoperable form, it\nmust use DeltaV/WebDAV compatible requests (such as modeling global\nproperties as properties of the shared VHR).\n\n   It has been pointed out to me that this was probably not what the list\n   meant.  If such properties (set on the VHR) were not visible on the VCR\n   and you had to access the VHR to get them then someone implementing that\n   should allow a lock on the VHR.  However, in that case I wouldn't see\n   'setting VHR properties' as being a way to implement global properites.\n   I'd drop my plans to support PROPPATCH on the VHR, hence the reason to\n   lock the VHR.\n\n   Therefore, I see no reason why a VHR should be locked independently of a\n   VCR.  Either the operation is moot, or (in the case of guidance we have\n   received on global properties) the proper lock is on the VCR not the\n   VHR.\n\nI agree that being able to lock a VHR is of neglibible value.\nSomeone might decide to implement global properties by placing\nthem on the VHR, in which case being able to lock a VHR would\nbe of value to that client, but not a very compelling use case\nfor me.\n\n   Next, we have past versions.  Past versions are not mutable (there goes\n   PUT and PROPPATCH).  A non-forking server such as mine does not allow\n   past versions to be checked out.  LABEL isn't supported, but is LABEL\n   supposed to honor a write lock?  I'm not so sure.\n\nSee section 1.8, Versioning Methods and Write Locks:\n If a write-locked resource has a non-computed property defined by this\n document, the property value MUST NOT be changed by a request unless\n the appropriate lock token is included in the request.  Since every\n method introduced in this document other than REPORT modifies at least\n one property defined by this document, every versioning method other\n than REPORT is affected by a write lock\n\nSo yes, labels are controlled by write locks, but since the LABEL\nmethod gives you incremental add/delete capability, there is little\nor no reason to \"lock\" the version for a LABEL request.\n\n   So I see no reason to support a LOCK on a past version.\n\nI agree.  Locking a version is even less likely/important than locking a\nVHR.\n\n   A CHECKOUT creates a 'state that can be modified'.  \n\n   In the case of Checkout-In-Place, that is logically the VCR.  I'm told\n   that there shouldn't be a real version in this case that can be accessed\n   independently of the VCR.  Again, only a VCR lock makes sense.\n\nI agree.  Locking a VCR is the prime locking use case.\n\n   Yes, I note that I must provide for a lock on a working resource.\n\nYes, although since a working resource has an obscure URL, it is\nunlikely that anyone will try to use your working resource, so\nlocking is probably not all that important for working resources.\n\n   I'm just trying to find a reason whey I should allow it anywhere else.\n   I'm not seeing one.\n\nIf you only handle locking of a VCR, I believe you will handle 98%\nof the important use cases.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13144902"}, {"subject": "Global Propertie", "content": "> Your client can present any model that it wants, but to \n> interoperate with multiple servers, it needs to adhere to the \n> DeltaV semantics, in which the VCR and VHR are separate \n> resources with their own locks. Similarly, your client can do \n> whatever it wants in terms of displaying a global property \n> model, but to provide an interoperable form, it must use \n> DeltaV/WebDAV compatible requests (such as modeling global \n> properties as properties of the shared VHR).\n\n\n'Modeling' global properties as properties of the VHR in such a system\nis necessarily a proprietary design.  It is simpler to just say that\nDeltaV does not provide global properties, period.\n\nFor properties to be global, I have to be able to get them by doing a\npropfind on the VCR or any particular VERSION.  If I have to go to two\ncompletely different places with two completely different requests, then\nthey are not behaving as global properties.  Pretending that they are\nwould only confuse people.\n\n=====================\n\nGlobal Properties are still useful, though.  But the only real way I can\nsee them being implemented is adding something like a scope attribute to\nthe prop element like:\n\n<property-update>\n  <prop scope=global>\n     <globalprop1>foo</globalprop1>\n  </prop>\n</property-update>\n\n============================\n\nI assume that servers that don't support global properties would just\nignore the scope attribute.\n\n\n\n", "id": "lists-006-13157034"}, {"subject": "Any DeltaV clients out there", "content": "I have been bogged down in things a bit here so am trying to get on top\nof things again. We are going to support a DeltaV friendly versioning\nmodel etc, but were debating whether it was worth our effort at this\nstage supporting the DeltaV protocol. We were unsure of what\nclients existed that we could (1) try locally to test things (2) tell\ncustomers that they could purchase.\n\nWe are developing a server product, not standalone client applications.\nWe do not want to develop a DeltaV client (and do not need to for what\nwe are doing). We are making things compatible for the future when clients\nare available, but I cannot see (at this stage) there is much benefit\nto *us* implementing the DeltaV protocol at this stage. Are there clients\naround now I could get a copy of to try things out internally/recommend\nto customers? If not know, any rough indications of timelines when the\nwould be available?\n\nThanks,\n\nAlan\n\n\n\n", "id": "lists-006-13165433"}, {"subject": "RE: Any DeltaV clients out there", "content": "I believe the main benefit of early support for the DeltaV protocol is\nthat you can provide WebDAV access (and therefore all of the current WebDAV\nclients such as Word 2000 and the Windows Explorer can run against your\nserver),\nand that a simple \"DeltaV helper\" client can let you do explicit\ncheckout/checkin\nif it is needed.  As more clients support the DeltaV operations, the DeltaV\nhelper client can eventually be phased out.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Alan Kent [mailto:ajk@mds.rmit.edu.au]\nSent: Wednesday, September 12, 2001 10:09 PM\nTo: DeltaV\nSubject: Any DeltaV clients out there?\n\n\nI have been bogged down in things a bit here so am trying to get on top\nof things again. We are going to support a DeltaV friendly versioning\nmodel etc, but were debating whether it was worth our effort at this\nstage supporting the DeltaV protocol. We were unsure of what\nclients existed that we could (1) try locally to test things (2) tell\ncustomers that they could purchase.\n\nWe are developing a server product, not standalone client applications.\nWe do not want to develop a DeltaV client (and do not need to for what\nwe are doing). We are making things compatible for the future when clients\nare available, but I cannot see (at this stage) there is much benefit\nto *us* implementing the DeltaV protocol at this stage. Are there clients\naround now I could get a copy of to try things out internally/recommend\nto customers? If not know, any rough indications of timelines when the\nwould be available?\n\nThanks,\n\nAlan\n\n\n\n", "id": "lists-006-13173263"}, {"subject": "RE: Global Propertie", "content": "The concept of global properties is not defined in the protocol,\nso either your clients or your servers (or both) will need to \nadopt some non-standard convention to support the concept.\n\nAn advantage of the \"VHR property\" approach is that only the clients\nneed to understand the convention (you can use standard DeltaV servers).\nAn advantage of the attribute approach you describe below is that\nany client can see the global properties (but only special servers\ncan be used).  So either approach has its advantages and disadvantages.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@xythos.com]\nSent: Wednesday, September 12, 2001 6:28 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Global Properties\n\n\n\n\n> Your client can present any model that it wants, but to \n> interoperate with multiple servers, it needs to adhere to the \n> DeltaV semantics, in which the VCR and VHR are separate \n> resources with their own locks. Similarly, your client can do \n> whatever it wants in terms of displaying a global property \n> model, but to provide an interoperable form, it must use \n> DeltaV/WebDAV compatible requests (such as modeling global \n> properties as properties of the shared VHR).\n\n\n'Modeling' global properties as properties of the VHR in such a system\nis necessarily a proprietary design.  It is simpler to just say that\nDeltaV does not provide global properties, period.\n\nFor properties to be global, I have to be able to get them by doing a\npropfind on the VCR or any particular VERSION.  If I have to go to two\ncompletely different places with two completely different requests, then\nthey are not behaving as global properties.  Pretending that they are\nwould only confuse people.\n\n=====================\n\nGlobal Properties are still useful, though.  But the only real way I can\nsee them being implemented is adding something like a scope attribute to\nthe prop element like:\n\n<property-update>\n  <prop scope=global>\n     <globalprop1>foo</globalprop1>\n  </prop>\n</property-update>\n\n============================\n\nI assume that servers that don't support global properties would just\nignore the scope attribute.\n\n\n\n", "id": "lists-006-13181964"}, {"subject": "RE: Property-o-ram", "content": "Very nice, Tim!\n\nI propose that we add this text as an appendix to the protocol.\nI'd appreciate any comments as to the format (I actually like\nit just the way Tim formatted it).  The only change I'd suggest\nmaking is adding the list of methods that apply as well.\n\nCheers,\nGeoff\n  \n\n-----Original Message-----\nFrom: Tim Ellison [mailto:tim@peir.com]\nSent: Thursday, June 07, 2001 8:06 AM\nTo: DeltaV\nSubject: Property-o-rama\n\n\nPrompted by the recent discussions, I thought I'd share this list of\nproperties derived from DeltaV and WebDAV specs.\n\nAs usual, I have a cryptic layout and nomenclature (free decoding ring not\nincluded).\n\nProtected and computed properties are flagged as such.\nThe defining feature is noted in square brackets (so if your server \"doesn't\ndo activities\" then you don't get to play with any [activity] properties).\n\n------------------\nDelta-V Properties versioning-15\n\n*Any* DeltaV Resource\n\nDAV:creationdate [webdav]\nDAV:displayname [webdav]\nDAV:getcontentlanguage [webdav]\nDAV:getcontentlength [webdav]\nDAV:getcontenttype [webdav]\nDAV:getetag [webdav]\nDAV:getlastmodified [webdav]\nDAV:lockdiscovery [webdav]\nDAV:resourcetype [webdav]\nDAV:source [webdav]\nDAV:supportedlock [webdav]\nDAV:comment [version-control]\nDAV:creator-displayname [version-control]\nDAV:supported-method-set (protected) [version-control]\nDAV:supported-live-property-set (protected) [version-control]\nDAV:supported-report-set (protected) [version-control]\nDAV:workspace (protected) [workspace]\nDAV:version-controlled-configuration (computed) [baseline]\n\n\n*Any* Checked-out Resource\n\nDAV:checked-out (protected) [version-control]\nDAV:predecessor-set [version-control]\nDAV:precursor-set [version-control]\nDAV:merge-set [merge]\nDAV:auto-merge-set [merge]\nDAV:unreserved [activity]\nDAV:activity-set [activity]\n\n\nVersion-Controlled Resource\n\nDAV:checked-in (protected) [version-control] *only if checked-in*\nDAV:auto-checkout [version-control]\nDAV:auto-checkin [version-control]\nDAV:version-history (computed) [version history]\n+ all deltav resource properties.\n+ all checked-out resource properties if it is checked out.\n\n\nVersion-controlled configuration\n\nDAV:baseline-controlled-collection (protected) [baseline]\nDAV:subbaseline-set [baseline] * only if checked-out *\nDAV:version-controlled-configuration (computed) [baseline]\n+ all version-controlled resource properties.\n\n\nVersion\n\nDAV:predecessor-set (protected) [version-control]\nDAV:successor-set (computed) [version-control]\nDAV:checkout-set (computed) [version-control]\nDAV:version-name (protected) [version-control]\nDAV:precursor-set (protected) [version-control]\nDAV:checkout-fork [checkout]\nDAV:checkin-fork [checkout]\nDAV:version-history (computed) [version history]\nDAV:label-name-set (protected) [label]\nDAV:activity-set [activity]\nDAV:version-controlled-binding-set [version-controlled collection] * only if\ncollection *\n+ all deltav resource properties\n\n\nWorking Resource\n\nDAV:version-controlled-binding-set [version-controlled collection] * only if\ncollection *\n+ all deltav resource properties\n+ all checked-out resource properties\n\n\nBaseline\n\nDAV:baseline-collection (protected) [baseline]\nDAV:subbaseline-set (protected) [baseline]\n+ all version properties\n\n\nVersion History Resource\n\nDAV:version-set (protected) [version history]\nDAV:root-version (computed) [version history]\n+ all deltav resource properties\n\n\nWorkspace Resource\n\nDAV:workspace-checkout-set (computed) [workspace]\nDAV:baseline-controlled-collection-set (computed) [baseline]\nDAV:current-activity-set [activity]\n+ all deltav resource properties\n\n\nActivity Resource\n\nDAV:activity-version-set (computed) [activity]\nDAV:activity-checkout-set (computed) [activity]\nDAV:subactivity-set [activity]\nDAV:current-workspace-set (computed) [activity]\n+ all deltav resource properties\n\n\nVersion-Controlled Collection Resource\n\nDAV:eclipsed-set (computed) [version-controlled collection]\n+ all version-controlled resource properties\n\n-----------------\n\nTrivia: If a server implements all the deltav features, a baseline would\nhave 31 live properties.  Allprop? No thanks.\n\n\nTim\n\n\n\n", "id": "lists-006-1318593"}, {"subject": "Re: WebDAV Invalidation (Was Re: Allow: header and supported meth ods", "content": "collaboration, groups, awareness, focus, dynamics of previous items - workflow/lifecycle looks to me\nlike only one area that would benefit from Internet Event Notifications, however, it may be the most\nimportant one.\n\nEckhard\n\n-----Urspr?ngliche Nachricht-----\nVon: \"Dyer, Kevin\" <kevin.dyer@matrixone.com>\nAn: \"'Lisa Dusseault'\" <lisa@xythos.com>; \"J?sh Cohen\" <joshrcohen@hotmail.com>;\n<jamsden@us.ibm.com>; <w3c-dist-auth@w3c.org>; <ietf-dav-versioning@w3.org>\nGesendet: Mittwoch, 12. September 2001 16:12\nBetreff: RE: WebDAV Invalidation (Was Re: Allow: header and supported meth ods)\n\n\n> All on this thread,\n>\n> Let me boil this down to what I consider the essence of this thread.\n> This entire discussion on publish-Subscribe to notification of events,\n> or the automatic enrollment in a notification event because of the user,\n> e.g. owner, is the genesis of a workflow/lifecycle module within the\n> WebDAV server.\n>\n> Am I off base here? When you peel enough layers off of this discussion,\n> isn't workflow/lifecycle at the heart of it? Except for the simple case\n> where a single item is modified, but even that needs to have exceptions.\n>\n> Kevin\n>\n> > -----Original Message-----\n> > From: Lisa Dusseault [mailto:lisa@xythos.com]\n> > Sent: Friday, September 07, 2001 12:46 PM\n> > To: J?sh Cohen; jamsden@us.ibm.com; w3c-dist-auth@w3c.org;\n> > ietf-dav-versioning@w3.org\n> > Subject: RE: WebDAV Invalidation (Was Re: Allow: header and supported\n> > methods)\n> >\n> >\n> > I agree that limiting the scope carefully is the best way to\n> > successfully\n> > navigate the BOF process.\n> >\n> > lisa\n> >\n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of J?sh Cohen\n> > > Sent: Friday, September 07, 2001 5:05 AM\n> > > To: jamsden@us.ibm.com; w3c-dist-auth@w3c.org;\n> > > ietf-dav-versioning@w3.org\n> > > Subject: RE: WebDAV Invalidation (Was Re: Allow: header and\n> > supported\n> > > methods)\n> > >\n> > >\n> > > I think thats a good idea to have a BOF.\n> > > What Id like to see most importantly is a\n> > > focused, and narrow scope.  In my mind,\n> > > this is a mechanism for subscribing to\n> > > and receiving specific change events on\n> > > web resources, within the existing web\n> > > infrastructure that integrates with DAV.\n> > >\n> > >\n> > > ---\n> > > Josh\n> > >\n> > >\n> > >\n> > > >From: \"Jim Amsden\" <jamsden@us.ibm.com>\n> > > >To: w3c-dist-auth@w3c.org, ietf-dav-versioning@w3.org\n> > > >Subject: RE: WebDAV Invalidation (Was Re: Allow: header\n> > and supported\n> > > >methods)\n> > > >Date: Thu, 6 Sep 2001 20:40:25 -0400\n> > > >\n> > > >I'll schedule a BOF at the next IETF meeting. If there's\n> > enough interest,\n> > > >we can create a proposed charter and petition the area directors\n> > > for a new\n> > > >working group.\n> > > >\n> > > >\n> > > >\n> > > >\n> > > >\n> > > >\n> > > >\"Lisa Dusseault\" <lisa@xythos.com>\n> > > >Sent by: ietf-dav-versioning-request@w3.org\n> > > >09/06/2001 06:21 PM\n> > > >\n> > > >\n> > > >         To:     =?iso-8859-1?Q?J=F6sh_Cohen?=\n> > <joshrcohen@hotmail.com>,\n> > > ><deltav@wegalink.de>, <ietf-dav-versioning@w3.org>\n> > > >         cc:     \"Webdav WG\" <w3c-dist-auth@w3c.org>\n> > > >         Subject:        RE: WebDAV Invalidation (Was Re: Allow:\n> > > header and\n> > > >supported methods)\n> > > >\n> > > >\n> > > >\n> > > >I'd definitely be interested in working on notifications.\n> > We'd like\n> > > >clients\n> > > >to be able to know about events like the ones you suggest, plus:\n> > > >  - new resource in collection I'm subscribed to\n> > > >  - Access control change in resource I'm subscribed to\n> > > >  - New version in VCR (similar to your update/last-modified\n> > > event, perhaps\n> > > >equivalent)\n> > > >\n> > > >How do we proceed?\n> > > >\n> > > >lisa\n> > > >\n> > > > > -----Original Message-----\n> > > > > From: ietf-dav-versioning-request@w3.org\n> > > > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> > J?sh Cohen\n> > > > > Sent: Wednesday, August 29, 2001 12:26 PM\n> > > > > To: deltav@wegalink.de; ietf-dav-versioning@w3.org\n> > > > > Subject: Re: WebDAV Invalidation (Was Re: Allow: header\n> > and supported\n> > > > > methods)\n> > > > >\n> > > > >\n> > > > > While Im nervous about trying to boil the ocean\n> > > > > in the form of a 'general notifications protocol', Im\n> > > > > wondering what people think about including the ability\n> > > > > to subscribe to events on resources?\n> > > > > By this I mean, in short, being able to subscribe\n> > > > > to a resource, such that when things happen to it,\n> > > > > such as:\n> > > > > o  property change\n> > > > > o  update (last modified)\n> > > > > o  invalidate\n> > > > > o  lock expiration / lock override\n> > > > > o  deleted\n> > > > >\n> > > > > a subscribed entity would receive a notification.\n> > > > >\n> > > > > There's been some relevant work here in the form of\n> > > > > an HTTP extension (SUBSCRIBE/NOTIFY methods) in the past\n> > > > > to deal with some of these issues.  It was work that\n> > > > > was previously done in the context of using HTTP for IM\n> > > > > and it quite similar to the SIP subscription extensions.\n> > > > >\n> > > > > Does this sound at all like something the group\n> > > > > would be interested in taking a closer look at ?\n> > > > >\n> > > > > thanks,\n> > > > >\n> > > > > ---\n> > > > > Josh\n> > > > >\n> > > > >\n> > > > >\n> > > > > >From: \"Eckhard Kantz\" <deltav@wegalink.de>\n> > > > > >To: <ietf-dav-versioning@w3.org>\n> > > > > >Subject: Re: WebDAV Invalidation (Was Re: Allow:\n> > header and supported\n> > > > > >methods)\n> > > > > >Date: Wed, 22 Aug 2001 21:40:39 +0200\n> > > > > >\n> > > > > >The protocol described in the ESI document allows to invalidate\n> > > > > documents\n> > > > > >that have been downloaded\n> > > > > >to a local machine by applying a push technology. This could\n> > > > > solve already\n> > > > > >several conflict\n> > > > > >situations or even partly prevent problems.\n> > > > > >\n> > > > > >On the other hand there seems to be an increasing need for more\n> > > > > >fine-grained notification services\n> > > > > >that extend the traditional access control systems.\n> > Picture 1 in the\n> > > > > >following longer article tries\n> > > > > >to classify them:\n> > > > > >\n> > > > > >\"Beyond 'Yes or No' - Extending Access Control in\n> > Groupware with\n> > > > > >Negotiation and Awareness\"\n> > > > > >(http://www.informatik.uni-bonn.de/~os/Publications/COOP98a.ps)\n> > > > > >\n> > > > > >Maybe those needs are also worth discussing if they could be\n> > > > > supported in\n> > > > > >the spec in order to allow\n> > > > > >applications to build up on them. The invalidation protocol\n> > > > > seems to be a\n> > > > > >good basis also for this.\n> > > > > >\n> > > > > >Eckhard\n> > > > > >\n> > > > > >\n> > > > > >-----Urspr?ngliche Nachricht-----\n> > > > > >Von: Eric Sedlar\n> > > > > >An: ietf-dav-versioning@w3.org\n> > > > > >Gesendet: Dienstag, 21. August 2001 19:00\n> > > > > >Betreff: WebDAV Invalidation (Was Re: Allow: header and\n> > > > > supported methods)\n> > > > > >\n> > > > > >\n> > > > > >Check out\n> > > > > >http://www.esi.org/invalidation_protocol_1-0.html for some work\n> > > > > that looks\n> > > > > >pretty similar\n> > > > > >to what we are talking about.\n> > > > > >\n> > > > > >--Eric\n> > > > > >\n> > > > >\n> > > > >\n> > > > >\n> > _________________________________________________________________\n> > > > > Get your FREE download of MSN Explorer at\n> > > >http://explorer.msn.com/intl.asp\n> > > >\n> > > >\n> > > >\n> > > >\n> > >\n> > >\n> > > _________________________________________________________________\n> > > Get your FREE download of MSN Explorer at\n> > > http://explorer.msn.com/intl.asp\n> >\n\n\n\n", "id": "lists-006-13191458"}, {"subject": "RE: Lockin", "content": "> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: 12 September 2001 21:43\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Locking\n>\n>\n>    From: John Hall [mailto:johnhall@xythos.com]\n>\n> ...\n>    Therefore, I see no reason why a VHR should be locked\n> independently of a\n>    VCR.  Either the operation is moot, or (in the case of guidance we have\n>    received on global properties) the proper lock is on the VCR not the\n>    VHR.\n>\n> I agree that being able to lock a VHR is of neglibible value.\n> Someone might decide to implement global properties by placing\n> them on the VHR, in which case being able to lock a VHR would\n> be of value to that client, but not a very compelling use case\n> for me.\n\nLocking a version history resource will prevent all clients from creating a\nnew version in that history (e.g., by checking in a version-controlled\nresource or working resource, or using the VERSION-CONTROL method).  When\nlocked the history's DAV:version-set cannot be modified thus preventing\nthese operations.\n\nNot sure when that would be useful though<g>\n\nTim\n\n\n\n", "id": "lists-006-13218289"}, {"subject": "I-D ACTION:draft-ietf-deltav-versioning-18.tx", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Web Versioning and Configuration Management Working Group of the IETF.\n\nTitle: Versioning Extensions to WebDAV\nAuthor(s): G. Clemm, J. Amsden, T. Ellison, \n                          C. Kaler, J. Whitehead\nFilename: draft-ietf-deltav-versioning-18.txt\nPages: 106\nDate: 12-Sep-01\n\nThis document specifies a set of methods, headers, and resource types \nthat define the WebDAV Versioning extensions to the HTTP/1.1 protocol. \nWebDAV Versioning will minimize the complexity of clients that are\ncapable of interoperating with a variety of versioning repository\nmanagers, to facilitate widespread deployment of applications capable of\nutilizing the WebDAV Versioning services.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-18.txt\n\nTo remove yourself from the IETF Announcement list, send a message to \nietf-announce-request with the word unsubscribe in the body of the message.\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-deltav-versioning-18.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-deltav-versioning-18.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n\n\n\nMessage/External-body attachment: stored\n\n\n\n\n", "id": "lists-006-13226935"}, {"subject": "RE: I-D ACTION:draft-ietf-deltav-versioning-18.tx", "content": "This is the final version of the deltav draft, which\nhas been submitted to the IESG for approval and \"nroff'ification\".\n\nAll issues raised during the IESG last call (which ended\non September 7) have been addressed.\nThe changes from draft 17 to draft 18 are described in\nthe \"changes and issues\" document\n<http://www.webdav.org/deltav/protocol/changes-and-issues.htm>.\n\nI'd like all of my co-authors to carefully review the text\nversion of draft-18 (I have hand edited this version, to fix all\nof the various Word-generation anomalies).  If any other member\nof the deltav working group has some time to review the text\nversion, that would be greatly appreciated!\n\nThanks to everyone in the DeltaV working group for all the hard\nwork over the last three years!  Now we can all focus on\nfinishing up our implementations (:-).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Internet-Drafts@ietf.org [mailto:Internet-Drafts@ietf.org]\nSent: Thursday, September 13, 2001 6:54 AM\nCc: ietf-dav-versioning@w3.org\nSubject: I-D ACTION:draft-ietf-deltav-versioning-18.txt\n\n\nA New Internet-Draft is available from the on-line Internet-Drafts\ndirectories.\nThis draft is a work item of the Web Versioning and Configuration Management\nWorking Group of the IETF.\n\nTitle: Versioning Extensions to WebDAV\nAuthor(s): G. Clemm, J. Amsden, T. Ellison, \n                          C. Kaler, J. Whitehead\nFilename: draft-ietf-deltav-versioning-18.txt\nPages: 106\nDate: 12-Sep-01\n\nThis document specifies a set of methods, headers, and resource types \nthat define the WebDAV Versioning extensions to the HTTP/1.1 protocol. \nWebDAV Versioning will minimize the complexity of clients that are\ncapable of interoperating with a variety of versioning repository\nmanagers, to facilitate widespread deployment of applications capable of\nutilizing the WebDAV Versioning services.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-18.txt\n\nTo remove yourself from the IETF Announcement list, send a message to \nietf-announce-request with the word unsubscribe in the body of the message.\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-deltav-versioning-18.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-deltav-versioning-18.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n", "id": "lists-006-13235945"}, {"subject": "I-D ACTION:draft-ietf-deltav-versioning-18.tx", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Web Versioning and Configuration Management Working Group of the IETF.\n\nTitle: Versioning Extensions to WebDAV\nAuthor(s): G. Clemm, J. Amsden, T. Ellison, \n                          C. Kaler, J. Whitehead\nFilename: draft-ietf-deltav-versioning-18.txt\nPages: 106\nDate: 12-Sep-01\n\nThis document specifies a set of methods, headers, and resource types \nthat define the WebDAV Versioning extensions to the HTTP/1.1 protocol. \nWebDAV Versioning will minimize the complexity of clients that are\ncapable of interoperating with a variety of versioning repository\nmanagers, to facilitate widespread deployment of applications capable of\nutilizing the WebDAV Versioning services.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-18.txt\n\nTo remove yourself from the IETF Announcement list, send a message to \nietf-announce-request with the word unsubscribe in the body of the message.\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-deltav-versioning-18.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-deltav-versioning-18.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n\n\n\nMessage/External-body attachment: stored\n\n\n\n\n", "id": "lists-006-13247844"}, {"subject": "I-D ACTION:draft-ietf-deltav-versioning-18.tx", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Web Versioning and Configuration Management Working Group of the IETF.\n\nTitle: Versioning Extensions to WebDAV\nAuthor(s): G. Clemm, J. Amsden, T. Ellison,\n                          C. Kaler, J. Whitehead\nFilename: draft-ietf-deltav-versioning-18.txt\nPages: 106\nDate: 12-Sep-01\n\nThis document specifies a set of methods, headers, and resource types \nthat define the WebDAV Versioning extensions to the HTTP/1.1 protocol. \nWebDAV Versioning will minimize the complexity of clients that are\ncapable of interoperating with a variety of versioning repository\nmanagers, to facilitate widespread deployment of applications capable of\nutilizing the WebDAV Versioning services.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-18.txt\n\nTo remove yourself from the IETF Announcement list, send a message to \nietf-announce-request with the word unsubscribe in the body of the message.\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-deltav-versioning-18.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-deltav-versioning-18.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n\n\n\nMessage/External-body attachment: stored\n\n\n\n\n", "id": "lists-006-13256950"}, {"subject": "Various comments..", "content": "Hi,\n\nI am not sure what scope we have for change to the specification (now that\nit's completed last call),\nbut here are various issues/observations on draft 18:\n\nSection 11.2, the MERGE method does not have pre or post conditions that\ndefine what should\nhappen if the DAV:source and the target URL point to the same version of a\nresource.  I am \nassuming that the MERGE would return a success but basically be a no-op.\n\nSection 11.2 the DAV:descendent-version postcondition is missing a full stop\n(period) at the end\nof the sentence.\n\nSection 11.3 should the DAV:ignored-preview set include resources that are\nthe same in both\nthe target and source (do not require merging) as well as resources that are\nnot present in\nthe target.  It seems like identifying resources which are ignored because\nthey are identical\nwould be a useful thing for this report to return.\n\nSection 11.3.1 in this example it would be good to show a example\nDAV:ignored-preview element\nand to show a element which has multiple resources, eg multiple\nconflict-previews (more than one\nresource in the two workspaces that conflicts).  The current example is very\nsimple and MERGE\nis quite complex.\n\nReading section 11 it implies that when DAV:source is a workspace (or\ncollection) and the\ntarget URL is also a workspace (or collection) if a VCR is found in the\nsource collection\nbut not in the target it is ignored and not added, this seems odd.  Why is\nthis? Surely the \nfile should be added to the target collection.\n\nThe VERSION-CONTROL method can be used to create multiple VCRs pointing to\nthe same\nversion history (provided they are not in a workspace).  How would this\naffect MERGE?\nImagine a collection containing multiple VCRs (which DAV:checked-in pointing\nto potentially \ndifferent versions) of the same VHR.  What would happen when a MERGE request\nwas carried\nout on the collection? Which VCR would be the target?\n\nFinally, section 10.2 defines a \"Collection Version Resource\" and this says\nthat a collection\nversion captures bindings to VCRs.  But later in section 14 a version\ncontrolled collection\nis defined as having bindings to version histories (VHRs).  I think section\n10 is misleading\nand section 14 is correct.\n\nSome of the issues regarding merging I had to explain to a group of MERANT\nstaff so\nI drew some Powerpoint slides to help.  Find these slides attached to the\ne-mail, they\nmay help explain the scenarios I am talking about.\n\n <<merge.ppt>> \nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n\n\n\n\napplication/vnd.ms-powerpoint attachment: merge.ppt\n\n\n\n\n", "id": "lists-006-13266708"}, {"subject": "Editorial: DAV:ignore-preview or DAV:ignored-preview", "content": "Section 11.3 of both draft-18 and draft-17 include the\nDAV:ignore-preview XML element in the DTD of\nDAV:merge-preview-response, but go on to define the\nDAV:ignored-preview element. Is this an editorial mistake?\n\nRoy\n\n\n\n", "id": "lists-006-13277525"}, {"subject": "RE: Various comments..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   I am not sure what scope we have for change to the specification\n   (now that it's completed last call), but here are various\n   issues/observations on draft 18:\n\nI will get one last swipe at the document when I get it back from\nthe IETF editor (i.e. in the nroff format), so please keep sending\nme any errors/typos that you find in the document, and I'll fold\nthem into that final editing pass.\n\n   Section 11.2, the MERGE method does not have pre or post conditions\n   that define what should happen if the DAV:source and the target URL\n   point to the same version of a resource.  I am assuming that the\n   MERGE would return a success but basically be a no-op.\n\nI'll squeeze an \"or is the same as\" into the DAV:ancestor-version\npostcondition.\n\n   Section 11.2 the DAV:descendent-version postcondition is missing a\n   full stop (period) at the end of the sentence.\n\nThanks for noticing!  Will fix.\n\n   Section 11.3 should the DAV:ignored-preview set include resources\n   that are the same in both the target and source (do not require\n   merging) as well as resources that are not present in the target.\n   It seems like identifying resources which are ignored because they\n   are identical would be a useful thing for this report to return.\n\nA client can determine this information by subyracting the various\nDAV:xxx-preview sets from the original source set.\n\n   Section 11.3.1 in this example it would be good to show a example\n   DAV:ignored-preview element and to show a element which has\n   multiple resources, eg multiple conflict-previews (more than one\n   resource in the two workspaces that conflicts).  The current\n   example is very simple and MERGE is quite complex.\n\nWe are planning on creating a \"scenarios\" document\nwhich will have more realistic examples of all the methods, and\nthis would be a good place for this information.\n\n   Reading section 11 it implies that when DAV:source is a workspace\n   (or collection) and the target URL is also a workspace (or\n   collection) if a VCR is found in the source collection but not in\n   the target it is ignored and not added, this seems odd.  Why is\n   this? Surely the file should be added to the target collection.\n\nIt could be, but if the owner of the target workspace has just\nexplicitly deleted the VCR that referenced the VHR of the version,\nto recreate that VCR as a result of the merge would be wrong.\nSimilarly, if all of those VHR's were moved into a different\nbaselined collection (not visible in the target workspace), to\nrecreate them in the collection they were just moved from would\nbe wrong.\n\n   The VERSION-CONTROL method can be used to create multiple VCRs\n   pointing to the same version history (provided they are not in a\n   workspace).  How would this affect MERGE?  Imagine a collection\n   containing multiple VCRs (which DAV:checked-in pointing to\n   potentially different versions) of the same VHR.  What would happen\n   when a MERGE request was carried out on the collection? Which VCR\n   would be the target?\n\nIt would be ambiguous, and the result would be server defined.\nThere is no \"right\" thing to do here (sometimes you might want\njust one, sometimes both, and sometimes just an error message).\n\n   Finally, section 10.2 defines a \"Collection Version Resource\" and\n   this says that a collection version captures bindings to VCRs.  But\n   later in section 14 a version controlled collection is defined as\n   having bindings to version histories (VHRs).  I think section 10 is\n   misleading and section 14 is correct.\n\nWhere in section 14 does it say that a version-controlled \ncollection has bindings to version histories?  A working collection\nhas bindings to version histories, but a version-controlled collection\nhas bindings to version-controlled resources, not version histories.\n\nNote that a collection version is very different from a version-controlled\ncollection (just as a version is very different from a version-controlled\nresource).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13284602"}, {"subject": "RE: Various comments..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   Reading section 11 it implies that when DAV:source is a workspace\n   (or collection) and the target URL is also a workspace (or\n   collection) if a VCR is found in the source collection but not in\n   the target it is ignored and not added, this seems odd.  Why is\n   this? Surely the file should be added to the target collection.\n\n   From: Geoff Clemm\n\n   It could be, but if the owner of the target workspace has just\n   explicitly deleted the VCR that referenced the VHR of the version,\n   to recreate that VCR as a result of the merge would be wrong.\n   Similarly, if all of those VHR's were moved into a different\n   baselined collection (not visible in the target workspace), to\n   recreate them in the collection they were just moved from would\n   be wrong.\n\nI should have added that if the inverse were true, i.e. the files\nwere added in source workspace, it would be wrong *not* to add the\nfiles into the destination workspace.  So it is ambiguous.\n\nNote that there is no problem when the server supports versioned\ncollections, because the collection version would be merged first,\nand it would add the VCR to the destination that would then be the\ntarget of the merge for the new version.  If the server does not\nsupport versioned collections, then the client should do a merge-preview\nfirst, and ask the user what should be done about \"ignored\" versions.\nIf the user says \"ignore\", then just invoke MERGE.  If the user says\n\"add them\", then the client would first add the appropriate VCR's\nto the destination, and then invoke merge.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13295799"}, {"subject": "RE: MK* and lock-null (was: Re: Deleting versions", "content": "OK, that's enough of a consensus for me (:-).\n\nUnless anyone objects, I will add a sentence to\nsection 1.8 (Versioning Methods and Locks) explicitly\nidentifying MKRESOURCE and MKACTIVITY as additional\nmethods that can be applied to a lock null resource.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim Ellison [mailto:tim@peir.com]\nSent: Thursday, June 07, 2001 7:02 AM\nTo: DeltaV\nSubject: RE: MK* and lock-null (was: Re: Deleting versions)\n\n\nGreg wrote:\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Greg Stein\n> Sent: 07 June 2001 06:28\n> To: DeltaV\n> Cc: ejw@cse.ucsc.edu\n> Subject: MK* and lock-null (was: Re: Deleting versions)\n>\n>\n> On Wed, Jun 06, 2001 at 12:47:45PM -0400, Clemm, Geoff wrote:\n> >...\n> > So let's get some feedback from the working group:\n> > Who thinks that the ability to apply MKWORKSPACE or MKACTIVITY\n> > is a versioning/locking interaction that merits explicit\n> > mention in the versioning protocol?  (I think we can take it\n> > as given that Lisa thinks \"yes\" and I think \"no\").\n>\n> I think that we should explicitly specify that (contrary to RFC 2518), a\n> MKWORKSPACE or MKACTIVITY can be applied to a locknull resource.\n\nGiven that DeltaV will be streaking through the standards process faster\nthan 2518 can get a revision out (:-), I think unfortunately this is\nrequired.\n\n> Since allowing them to apply is contrary to 2518, then we need to\n> explicitly mention that fact. If we don't, then readers will\n> assume that you cannot use those methods on a lock-null.\n\nAgreed.\n\n> And yes: this should raise an issue for 2518 to loosen that language in\n> some way. (cc'ing Jim explicitly to ensure this is captured)\n\nThis is the real 'solution'.\n\nTim\n\n\n\n", "id": "lists-006-1329921"}, {"subject": "RE: Editorial: DAV:ignore-preview or DAV:ignored-preview", "content": "Yes, it should be \"DAV:ignore-preview\" in both cases.\nThanks for noticing that, Roy!\nI'll add that to the two items that Peter reported.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Roy Seto [mailto:Roy.Seto@oracle.com]\nSent: Thursday, September 13, 2001 3:46 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Editorial: DAV:ignore-preview or DAV:ignored-preview?\n\n\nSection 11.3 of both draft-18 and draft-17 include the\nDAV:ignore-preview XML element in the DTD of\nDAV:merge-preview-response, but go on to define the\nDAV:ignored-preview element. Is this an editorial mistake?\n\nRoy\n\n\n\n", "id": "lists-006-13304604"}, {"subject": "RE: Various comments..", "content": "Hi,\n\n[Peter Wrote:]\n\n>>   Finally, section 10.2 defines a \"Collection Version Resource\" and\n>>   this says that a collection version captures bindings to VCRs.  But\n>>   later in section 14 a version controlled collection is defined as\n>>   having bindings to version histories (VHRs).  I think section 10 is\n>>   misleading and section 14 is correct.\n\n[Geoff Responded:]\n\n>Where in section 14 does it say that a version-controlled \n>collection has bindings to version histories?  A working collection\n>has bindings to version histories, but a version-controlled collection\n>has bindings to version-controlled resources, not version histories.\n>\n>Note that a collection version is very different from a version-controlled\n>collection (just as a version is very different from a version-controlled\n>resource).\n\nYes, what you said matches how I thought Version Controlled Collections\nwork, but does not match the specification.\n\nA Version Controlled Collection DOES have bindings to Version Controlled\nResources\nand this is fine, I understand this and it makes sense.\n\nA Collection Version (for example the DAV:checked-in version of the Version\nControlled Collection) has bindings to Version Histories.\n\nBut the issue I was reporting was that section 10.2 defines the bindings of\na COLLECTION VERSION to be bindings to Version Controlled Resources.  This\nis incorrect and does not match what you said in your reply.\n\nI propose we make two changes:\n\n1.\n\nIt takes some time to understand section 14, it would have helped if the\ndiagram \nwas complete and showed that /x is a Version Controlled Collection, and that\nV2 \nof VH14 is a Collection Version.\n\n\n2.\n\nThe current text of 10.2 says:\n\nCollection Version Resource\n\n       A \"collection version resource\", or simply \"collection version\",\n       captures the content, dead properties, and version-controlled\n       bindings of a version-controlled collection (see Section 14).  A\n       version-controlled binding is a binding to a version-controlled\n       resource.....\n\nI propose we make this clearer and say:\n\nCollection Version Resource\n\n A \"collection version resource\", or simply \"collection version\",\n       captures the content, dead properties, and bindings to the \n       Version History Resources identified in the the version-controlled\n       bindings of a version-controlled collection (see Section 14).  A\n       version-controlled binding is a binding to a version-controlled\n       resource. A binding of a collection version is a binding to a\n       version history resource.\n\nRegards,\nPeter Raymond - MERANT.\n\n\n\n", "id": "lists-006-13312717"}, {"subject": "Powerpoint slides of Version Controlled Collections...", "content": "Hi,\n\nHere are two slides representing Version Controlled Collections in\npowerpoint...\nIs my understanding of VCCs (as shown in these slides) correct?\nIs this useful stuff to put on www.webdav.org/deltav?\n\n <<Version Controlled Collections.ppt>> \nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n\n\n\n\napplication/vnd.ms-powerpoint attachment: Version_Controlled_Collections.ppt\n\n\n\n\n", "id": "lists-006-13322820"}, {"subject": "Re: Powerpoint slides of Version Controlled Collections...", "content": "Peter,\nI found this quite helpful. Greg, how could we host this on \nwebdav.org/deltav? Just save as HTML and provide a link off an notes page?\n\n\n\n\n\nPeter Raymond <Peter.Raymond@merant.com>\nSent by: ietf-dav-versioning-request@w3.org\n09/14/2001 05:21 AM\n\n \n        To:     gclemm@rational.com\n        cc:     ietf-dav-versioning@w3.org\n        Subject:        Powerpoint slides of Version Controlled Collections....\n\n \n\n\n\n\nHi, \n\nHere are two slides representing Version Controlled Collections in \npowerpoint... \nIs my understanding of VCCs (as shown in these slides) correct? \nIs this useful stuff to put on www.webdav.org/deltav? \n\n <<Version Controlled Collections.ppt>> \nRegards, \n-- \nPeter Raymond - MERANT \nTechnical Architect (PVCS) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n\n\n\n\n#### Version Controlled Collections.ppt has been removed from this note on \nSeptember 14 2001 by Jim Amsden\n\n\n\n", "id": "lists-006-13331926"}, {"subject": "RE: Powerpoint slides of Version Controlled Collections...", "content": "Looks fine to me.  Do you have a web site you could post this on,\nthat I could link to from the deltav site?  That was how most of the\ndocument references are currently handled.\nOtherwise, we could also just put the source of these slides\ndirectly on the deltav site.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Friday, September 14, 2001 5:21 AM\nTo: gclemm@Rational.Com\nCc: ietf-dav-versioning@w3.org\nSubject: Powerpoint slides of Version Controlled Collections....\n\n\nHi, \nHere are two slides representing Version Controlled Collections in\npowerpoint... \nIs my understanding of VCCs (as shown in these slides) correct? \nIs this useful stuff to put on www.webdav.org/deltav? \n<<Version Controlled Collections.ppt>> \nRegards, \n-- \nPeter Raymond - MERANT \nTechnical Architect (PVCS) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n\n\n\n", "id": "lists-006-13341919"}, {"subject": "RE: Various comments..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   It takes some time to understand section 14, it would have helped\n   if the diagram was complete and showed that /x is a Version\n   Controlled Collection, and that V2 of VH14 is a Collection Version.\n\nThat is probably something that would be hard to do in the final\neditorial pass (the pagination would have to be changed since there\nis no good place to squeeze that info into the existing diagram).\nSince this is explicitly stated in the text describing the \ndiagram, I think I'd prefer leaving it the way it is (ASCII art\nonly lets you do so much before it overloads).\n\n   The current text of 10.2 says: \n\n   Collection Version Resource \n\n   A \"collection version resource\", or simply \"collection version\", \n   captures the content, dead properties, and version-controlled \n   bindings of a version-controlled collection (see Section 14).  A \n   version-controlled binding is a binding to a version-controlled \n   resource..... \n\n   I propose we make this clearer and say: \n\n   Collection Version Resource \n\n     A \"collection version resource\", or simply \"collection version\", \n   captures the content, dead properties, and bindings to the \n   Version History Resources identified in the the version-controlled \n   bindings of a version-controlled collection (see Section 14).  A \n   version-controlled binding is a binding to a version-controlled \n   resource. A binding of a collection version is a binding to a \n   version history resource. \n\nThe word \"captures\" was intended to be the flag that this was a \"fuzzy\"\ndefinition, that will be firmed up in the referenced section (section 14).\nBut I agree we could make this clearer.  How about:\n\n   A \"collection version resource\", or simply \"collection version\", \n   captures the content, dead properties, and version-controlled \n   bindings of a version-controlled collection (see Section 14).  A \n   version-controlled binding is a binding to the version history\n   of a version-controlled resource..... \n\nThere is one sentence in section 14 I will also have to adjust, but\nI think defining a \"version-controlled binding\" as a binding to a\nversion history would then make things clearer.  What do you think?\n(Also, this has the benefit of not requiring repagination :-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13351482"}, {"subject": "RE: Various comments..", "content": "Hi,\n\nOne of the problems is that Section 10 does not define the term\n\"Version-Controlled Collection\".\n\nHow about in section 10 defining the term \"Version-Controlled Collection\" \nthen we can explicitly say that a VCC has bindings to VCRs and a Collection \nVersion has version-controlled bindings to VHRs (using the text you\nsuggested).\n\nWould this also cause re-pagination?\n\nI am worried that if we define the term version-controlled binding to be\nbindings to VHRs then it will become unclear if the VCC itself has bindings\nto VHRs or VCRs.\n\nEither way, the changes you have suggested are definitely an improvement.\n\nP.S.  I will see what I can do about getting the powerpoint slides on a \npublic web server and let you know the URL.\n\nRegards,\n--\nPeter Raymond - MERANT\nTechnical Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: 14 September 2001 14:56\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Various comments...\n\n\n   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   It takes some time to understand section 14, it would have helped\n   if the diagram was complete and showed that /x is a Version\n   Controlled Collection, and that V2 of VH14 is a Collection Version.\n\nThat is probably something that would be hard to do in the final\neditorial pass (the pagination would have to be changed since there\nis no good place to squeeze that info into the existing diagram).\nSince this is explicitly stated in the text describing the \ndiagram, I think I'd prefer leaving it the way it is (ASCII art\nonly lets you do so much before it overloads).\n\n   The current text of 10.2 says: \n\n   Collection Version Resource \n\n   A \"collection version resource\", or simply \"collection version\", \n   captures the content, dead properties, and version-controlled \n   bindings of a version-controlled collection (see Section 14).  A \n   version-controlled binding is a binding to a version-controlled \n   resource..... \n\n   I propose we make this clearer and say: \n\n   Collection Version Resource \n\n     A \"collection version resource\", or simply \"collection version\", \n   captures the content, dead properties, and bindings to the \n   Version History Resources identified in the the version-controlled \n   bindings of a version-controlled collection (see Section 14).  A \n   version-controlled binding is a binding to a version-controlled \n   resource. A binding of a collection version is a binding to a \n   version history resource. \n\nThe word \"captures\" was intended to be the flag that this was a \"fuzzy\"\ndefinition, that will be firmed up in the referenced section (section 14).\nBut I agree we could make this clearer.  How about:\n\n   A \"collection version resource\", or simply \"collection version\", \n   captures the content, dead properties, and version-controlled \n   bindings of a version-controlled collection (see Section 14).  A \n   version-controlled binding is a binding to the version history\n   of a version-controlled resource..... \n\nThere is one sentence in section 14 I will also have to adjust, but\nI think defining a \"version-controlled binding\" as a binding to a\nversion history would then make things clearer.  What do you think?\n(Also, this has the benefit of not requiring repagination :-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13361033"}, {"subject": "RE: Various comments..", "content": "Adding a word or two here or there is fine.  Deleting stuff is fine.\nAdding a whole new term or sentence is harder.  Errors will be corrected\nno matter how much rework is required, but at the moment I'm\nresisting any purely editorial changes that would cause pagination\nspillover.  If we redefine VCB's to be bindings to version histories,\nit would no longer be the case that the bindings in VCR's are VCB's,\nbut rather that they define VCB's.  There's just one place in section\n14 that would need to be adjusted because of this (since we don't use\nthe term VCB much), so that should be OK.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Friday, September 14, 2001 10:34 AM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: RE: Various comments...\n\n\nHi, \nOne of the problems is that Section 10 does not define the term \n\"Version-Controlled Collection\". \nHow about in section 10 defining the term \"Version-Controlled Collection\" \nthen we can explicitly say that a VCC has bindings to VCRs and a Collection \nVersion has version-controlled bindings to VHRs (using the text you\nsuggested). \nWould this also cause re-pagination? \nI am worried that if we define the term version-controlled binding to be \nbindings to VHRs then it will become unclear if the VCC itself has bindings \nto VHRs or VCRs. \nEither way, the changes you have suggested are definitely an improvement. \nP.S.  I will see what I can do about getting the powerpoint slides on a \npublic web server and let you know the URL. \n\n\n-----Original Message----- \nFrom: Clemm, Geoff [mailto:gclemm@rational.com] \n\nHow about: \n   A \"collection version resource\", or simply \"collection version\", \n   captures the content, dead properties, and version-controlled \n   bindings of a version-controlled collection (see Section 14).  A \n   version-controlled binding is a binding to the version history \n   of a version-controlled resource..... \nThere is one sentence in section 14 I will also have to adjust, but \nI think defining a \"version-controlled binding\" as a binding to a \nversion history would then make things clearer.  What do you think? \n(Also, this has the benefit of not requiring repagination :-). \nCheers, \nGeoff \n\n\n\n", "id": "lists-006-13373133"}, {"subject": "Re: Powerpoint slides of Version Controlled Collections...", "content": "Peter wrote:\n> Here are two slides representing Version Controlled Collections\n> in powerpoint...\n> Is my understanding of VCCs (as shown in these slides) correct?\n> Is this useful stuff to put on www.webdav.org/deltav?\n\nI found this confusing since it implies/states that the collection version\nhas bindings to the version history resources, whereas in practice a\ncollection version has no bindings (but it does have a property that\n'captures' the version-controlled bindings of a version-controlled\ncollection.)\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-13382818"}, {"subject": "RE: Various comments..", "content": "Peter Raymond writes:\n> P.S.  I will see what I can do about getting the powerpoint slides on a \n> public web server and let you know the URL.  \n\nI have posted these slides on the webdav.org site, at:\n\nhttp://www.webdav.org/deltav/presentations/vcc.pdf\nhttp://www.webdav.org/deltav/presentations/vcc.ppt\n\nUsing WebDAV, it was pretty easy to do this...\n\n- Jim\n\n\n\n", "id": "lists-006-13390469"}, {"subject": "Clarification of DAV:update-merge-set when rerunning MERG", "content": "I'm looking at the behavior of the MERGE method when it is\nrerun. I'd like clarification of the DAV:update-merge-set\npostcondition in Section 11.2 for this scenario. \n\nSpecifically, if a merge target was already checked out\nbefore the second or later MERGE, and its DAV:merge-set or\nDAV:auto-merge-set already includes the merge source, does\nthe merge target appear in a DAV:response XML element in the\nresponse body? \n\nI feel this is ambiguous in draft-18. The\nDAV:update-merge-set postcondition does apply to this merge\ntarget, because it was already checked out before the MERGE,\nand its DAV:checked-out version is not a descendant of the\nmerge source (assuming a client has not moved the merge\nsource from DAV:merge-set to DAV:predecessor-set between the\nMERGE requests). However, the state of the merge target does\nnot actually change in the second MERGE request, since\nadding a source to a DAV:merge-set which already contains it\ndoesn't change the DAV:merge-set property.\n\nI prefer that the DAV:update-merge-set postcondition require\nthe response body to include the merge target in this case.\nI think that makes it easier to implement clients that cache\nminimal state and support users who wish to restart the\noverall merge process where they left off.  Here is a use\ncase:\n\n1. A user's client issues a MERGE request, including\n   the DAV:merge-set and DAV:auto-merge-set \n   properties in the DAV:prop element of the request \n   body. The client remembers the resources listed\n   in the response body which have nonempty \n   DAV:merge-set or DAV:auto-merge-set properties.\n\n2. The user iterates through the conflict targets \n   identified in step 1, performing a logical merge of \n   their content and dead properties and moving merge \n   sources from DAV:merge-set or DAV:auto-merge-set to \n   DAV:predecessor-set as he or she modifies each \n   checked-out target resource.\n\n3. Before the user is done with step 2, the client \n   crashes and its state is lost, or the user wishes\n   to finish step 2 from a different client instance\n   in a different physical location. At this point,\n   the new client instance does not know the set of \n   targets which still have nonempty DAV:merge-set\n   or DAV:auto-merge-set properties. If the client\n   can rerun MERGE with the same request-URI and\n   source, and be guaranteed to be given the set of \n   targets with nonempty DAV:merge-set or \n   DAV:auto-merge-set properties, this would be an \n   attractive way to let the user continue where\n   he or she left off.\n\nAlternative options I considered for supporting restart:\n\n - The client could do a PROPFIND Depth:infinity\n   and look for resources which have nonempty \n   DAV:merge-set or DAV:auto-merge-set properties,\n   but it seems difficult to make this efficient.\n   It also requires the client to detect the restart\n   case and implement it with a different code path.\n\n - The client could do a DASL query to optimize\n   the PROPFIND above if DASL were standardized.\n\n--\n\nI have a similar question about the behavior of the\nDAV:merge-preview REPORT after the corresponding MERGE has\nalready been done. If a merge target requires a merge, and\nits DAV:merge-set or DAV:auto-merge-set already includes the\nmerge source, does the response body include it in a\nDAV:conflict-preview element? (For reasons similar to the\nDAV:update-merge-set case, I prefer that it must.)\n\n\nThanks,\nRoy\n\n\n\n", "id": "lists-006-13397906"}, {"subject": "VCR properties (was: Removing the DAV:activity ...", "content": "On Thu, Jun 07, 2001 at 12:02:09PM +0100, Tim Ellison wrote:\n> Greg wrote:\n> \n> > > A version is identified by its support for the\n> > > <DAV:version-name> property.\n> >\n> > But also the absence of some other properties. VCRs have the version-name\n> > property on them, too.\n> \n> Nope.  A version-controlled resource does not have a DAV:version-name\n> property.\n\nWoah. Reading the spec on this part closely... it would appear that we\ndropped the whole thing about a VCR copying all the props of the version?\n\nWhat happened here when I wasn't looking? :-)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-1340026"}, {"subject": "RE: Clarification of DAV:update-merge-set when rerunning MERG", "content": "   From: Roy Seto [mailto:Roy.Seto@oracle.com]\n\n   I'm looking at the behavior of the MERGE method when it is\n   rerun. I'd like clarification of the DAV:update-merge-set\n   postcondition in Section 11.2 for this scenario. \n\n   Specifically, if a merge target was already checked out\n   before the second or later MERGE, and its DAV:merge-set or\n   DAV:auto-merge-set already includes the merge source, does\n   the merge target appear in a DAV:response XML element in the\n   response body? \n\nYes, this is required by the last sentence of the DAV:update-merge-set\npostcondition.\n\n   I feel this is ambiguous in draft-18. The\n   DAV:update-merge-set postcondition does apply to this merge\n   target, because it was already checked out before the MERGE,\n   and its DAV:checked-out version is not a descendant of the\n   merge source (assuming a client has not moved the merge\n   source from DAV:merge-set to DAV:predecessor-set between the\n   MERGE requests). However, the state of the merge target does\n   not actually change in the second MERGE request, since\n   adding a source to a DAV:merge-set which already contains it\n   doesn't change the DAV:merge-set property.\n\nThe last sentence of DAV:update-merge-set applies to any\ntarget that matches this postcondition, i.e.:\n\n If the merge target was checked out by the MERGE (or was already\n checked out before the MERGE), and if the DAV:checked-out version of\n the merge target is not a descendant of the merge source ...\n\nThere is no dependency on whether or not the the merge source\nis already in the DAV:merge-set or DAV:auto-merge-set.\nIf this is not clear, I could move the \"must be in a DAV:response\"\nsentence up into the first sentence of this precondition, if you\nthink that would be clearer.\n\n[restart example omitted]\n\n   Alternative options I considered for supporting restart:\n\n    - The client could do a PROPFIND Depth:infinity\n      and look for resources which have nonempty \n      DAV:merge-set or DAV:auto-merge-set properties,\n      but it seems difficult to make this efficient.\n      It also requires the client to detect the restart\n      case and implement it with a different code path.\n\nWell, a client has to do this anyway, if the user doesn't\nremember what MERGE they performed.  But I agree that this\nwould be a challenge to make efficient.  One approach is\nto play a little fast'n'loose with the PROPFIND semantics,\nand only have the PROPFIND return results with non-empty\nDAV:(auto-)merge-set properties, and just use an index\non those properties to optimize the speed of the PROPFIND.\n\n    - The client could do a DASL query to optimize\n      the PROPFIND above if DASL were standardized.\n\nYeah, that would be nice (:-).\n\nAnd of course, option 3 is to just use the DAV:merge-preview\nreport to get the info you need.\n\n   --\n\n   I have a similar question about the behavior of the\n   DAV:merge-preview REPORT after the corresponding MERGE has\n   already been done. If a merge target requires a merge, and\n   its DAV:merge-set or DAV:auto-merge-set already includes the\n   merge source, does the response body include it in a\n   DAV:conflict-preview element? (For reasons similar to the\n   DAV:update-merge-set case, I prefer that it must.)\n\nThe merge-preview element contains all resources that \"need\nto be merged\".  Whether or not something needs to be merged\nis not changed by that version already being in the\nDAV:merge-set.  So DAV:merge-preview definitely works the\nway you want (and was intended to do so).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13408496"}, {"subject": "Re: Clarification of DAV:update-merge-set when rerunning MERG", "content": "Geoff,\n\nThanks for the clarification. What about making the following two edits?\n\n1. I agree that moving the \"must be in a DAV:response\" sentence up into\nthe first or second sentence of the DAV:update-merge-set postcondition\nwould make the intent clearer.\n\n2. I think I was confused by the text in the opening of Section 11.2, \"The\nresponse to a MERGE request identifies the resources modified by the\nrequest, so that a client can efficiently update any cached state it is\nmaintaining.\" I got confused because DAV:update-merge-set doesn't actually\nchange the target's state when MERGE is rerun. After reading your\nclarification, I understand this text is non-normative and the\nDAV:update-merge-set postcondition is normative, but other readers might\nmake the same mistake I did.\n\nWould it be possible to modify the introductory text above to something\nlike \"The response to a MERGE identifies resources which a client must\nmodify to complete the merge. It also identifies resources modified by the\nrequest, so that a client can efficiently update any cached state it is\nmaintaining.\"\n\nThanks,\nRoy\n\n\"Clemm, Geoff\" wrote:\n\n>    From: Roy Seto [mailto:Roy.Seto@oracle.com]\n>\n>    I'm looking at the behavior of the MERGE method when it is\n>    rerun. I'd like clarification of the DAV:update-merge-set\n>    postcondition in Section 11.2 for this scenario.\n>\n>    Specifically, if a merge target was already checked out\n>    before the second or later MERGE, and its DAV:merge-set or\n>    DAV:auto-merge-set already includes the merge source, does\n>    the merge target appear in a DAV:response XML element in the\n>    response body?\n>\n> Yes, this is required by the last sentence of the DAV:update-merge-set\n> postcondition.\n>\n>    I feel this is ambiguous in draft-18. The\n>    DAV:update-merge-set postcondition does apply to this merge\n>    target, because it was already checked out before the MERGE,\n>    and its DAV:checked-out version is not a descendant of the\n>    merge source (assuming a client has not moved the merge\n>    source from DAV:merge-set to DAV:predecessor-set between the\n>    MERGE requests). However, the state of the merge target does\n>    not actually change in the second MERGE request, since\n>    adding a source to a DAV:merge-set which already contains it\n>    doesn't change the DAV:merge-set property.\n>\n> The last sentence of DAV:update-merge-set applies to any\n> target that matches this postcondition, i.e.:\n>\n>  If the merge target was checked out by the MERGE (or was already\n>  checked out before the MERGE), and if the DAV:checked-out version of\n>  the merge target is not a descendant of the merge source ...\n>\n> There is no dependency on whether or not the the merge source\n> is already in the DAV:merge-set or DAV:auto-merge-set.\n> If this is not clear, I could move the \"must be in a DAV:response\"\n> sentence up into the first sentence of this precondition, if you\n> think that would be clearer.\n>\n> [restart example omitted]\n>\n>    Alternative options I considered for supporting restart:\n>\n>     - The client could do a PROPFIND Depth:infinity\n>       and look for resources which have nonempty\n>       DAV:merge-set or DAV:auto-merge-set properties,\n>       but it seems difficult to make this efficient.\n>       It also requires the client to detect the restart\n>       case and implement it with a different code path.\n>\n> Well, a client has to do this anyway, if the user doesn't\n> remember what MERGE they performed.  But I agree that this\n> would be a challenge to make efficient.  One approach is\n> to play a little fast'n'loose with the PROPFIND semantics,\n> and only have the PROPFIND return results with non-empty\n> DAV:(auto-)merge-set properties, and just use an index\n> on those properties to optimize the speed of the PROPFIND.\n>\n>     - The client could do a DASL query to optimize\n>       the PROPFIND above if DASL were standardized.\n>\n> Yeah, that would be nice (:-).\n>\n> And of course, option 3 is to just use the DAV:merge-preview\n> report to get the info you need.\n>\n>    --\n>\n>    I have a similar question about the behavior of the\n>    DAV:merge-preview REPORT after the corresponding MERGE has\n>    already been done. If a merge target requires a merge, and\n>    its DAV:merge-set or DAV:auto-merge-set already includes the\n>    merge source, does the response body include it in a\n>    DAV:conflict-preview element? (For reasons similar to the\n>    DAV:update-merge-set case, I prefer that it must.)\n>\n> The merge-preview element contains all resources that \"need\n> to be merged\".  Whether or not something needs to be merged\n> is not changed by that version already being in the\n> DAV:merge-set.  So DAV:merge-preview definitely works the\n> way you want (and was intended to do so).\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-13420032"}, {"subject": "HELP &ndash;&ndash; DeltaV Rose mode", "content": "Hi,\n\nI am trying to implement DeltaV and I could find the HTML Rose model.\nCan someone send me the source model?\n\nThanks in advance,\n-Sreekanth.\n\n\n\n", "id": "lists-006-13432549"}, {"subject": "RE: HELP &ndash;&ndash; DeltaV Rose mode", "content": "I added the .mdl source for this model to the web site, and added a link\nin the deltav home page.\n\nNote that this model is somewhat out-of-date.  I am currently working on \nproducing a version that accurately reflects the final draft (18).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Sreekanth Chintala [mailto:schintala@skyva.com]\nSent: Tuesday, September 25, 2001 11:04 AM\nTo: ietf-dav-versioning@w3.org\nSubject: HELP -- DeltaV Rose model\n\n\nHi,\n\nI am trying to implement DeltaV and I could find the HTML Rose model.\nCan someone send me the source model?\n\nThanks in advance,\n-Sreekanth.\n\n\n\n", "id": "lists-006-13439737"}, {"subject": "Missing version number in diagram..", "content": "Hi,\n\nA very minor editorial point but the diagram of activities in section 13 is\nmissing a \nversion name.  In the diagram foo.html has a version pointed to by Activity\nAct-1 \nbut this has no version name.  I think it should be V3.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-13447601"}, {"subject": "RE: I-D ACTION:draft-ietf-deltav-versioning-18.tx", "content": "Since \"nroffification\" does not appear to have been started,\nI decided to submit a new draft (draft 19) which fixes the\ntypos detected in draft 18, by directly patching the ascii form\n(to avoid mechanical transformation errors).  Many thanks to \nJohn Vasta, Roy Seto, and Peter Raymond for their hard work in\nfinding these typos!\n\nUnfortunately, I submitted draft 18 before getting Peter's most\nrecent message (adding \"V3\" to the activity diagram), but I'll\nmake sure to get that changed in the nroffified version.\nThere's still time to get typos fixed, so all reviews continue\nto be greatly appreciated!\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@Rational.Com]\nSent: Thursday, September 13, 2001 8:27 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: I-D ACTION:draft-ietf-deltav-versioning-18.txt\n\n\nThis is the final version of the deltav draft, which\nhas been submitted to the IESG for approval and \"nroff'ification\".\n\nAll issues raised during the IESG last call (which ended\non September 7) have been addressed.\nThe changes from draft 17 to draft 18 are described in\nthe \"changes and issues\" document\n<http://www.webdav.org/deltav/protocol/changes-and-issues.htm>.\n\nI'd like all of my co-authors to carefully review the text\nversion of draft-18 (I have hand edited this version, to fix all\nof the various Word-generation anomalies).  If any other member\nof the deltav working group has some time to review the text\nversion, that would be greatly appreciated!\n\nThanks to everyone in the DeltaV working group for all the hard\nwork over the last three years!  Now we can all focus on\nfinishing up our implementations (:-).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Internet-Drafts@ietf.org [mailto:Internet-Drafts@ietf.org]\nSent: Thursday, September 13, 2001 6:54 AM\nCc: ietf-dav-versioning@w3.org\nSubject: I-D ACTION:draft-ietf-deltav-versioning-18.txt\n\n\nA New Internet-Draft is available from the on-line Internet-Drafts\ndirectories.\nThis draft is a work item of the Web Versioning and Configuration Management\nWorking Group of the IETF.\n\nTitle: Versioning Extensions to WebDAV\nAuthor(s): G. Clemm, J. Amsden, T. Ellison, \n                          C. Kaler, J. Whitehead\nFilename: draft-ietf-deltav-versioning-18.txt\nPages: 106\nDate: 12-Sep-01\n\nThis document specifies a set of methods, headers, and resource types \nthat define the WebDAV Versioning extensions to the HTTP/1.1 protocol. \nWebDAV Versioning will minimize the complexity of clients that are\ncapable of interoperating with a variety of versioning repository\nmanagers, to facilitate widespread deployment of applications capable of\nutilizing the WebDAV Versioning services.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-18.txt\n\nTo remove yourself from the IETF Announcement list, send a message to \nietf-announce-request with the word unsubscribe in the body of the message.\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-deltav-versioning-18.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-deltav-versioning-18.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n", "id": "lists-006-13455491"}, {"subject": "RE: Missing version number in diagram..", "content": "Yes, it should have been marked \"V3\".  I'll get\nthat fixed.  Thanks for finding that typo!\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Wednesday, September 26, 2001 8:43 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Missing version number in diagram...\n\n\nHi, \nA very minor editorial point but the diagram of \nactivities in section 13 is missing a \nversion name.  In the diagram foo.html has a version\npointed to by Activity Act-1 \nbut this has no version name.  I think it should be V3. \n\n\n\n", "id": "lists-006-13468407"}, {"subject": "RE: Any DeltaV clients out there", "content": "Alan Kent writes:\n> We were unsure of what\n> clients existed that we could (1) try locally to test things (2) tell\n> customers that they could purchase.\n\nThere is also the Subversion client -- Subversion uses the DeltaV protocol,\nand provides both client and server pieces.\n\nhttp://subversion.tigris.org/\n\n- Jim\n\n\n\n", "id": "lists-006-13476380"}, {"subject": "RE: Property-o-ram", "content": "> I propose that we add this text as an appendix to the protocol.\n\nI heartily agree.\n\n> I'd appreciate any comments as to the format (I actually like\n> it just the way Tim formatted it).  The only change I'd suggest\n> making is adding the list of methods that apply as well.\n\nWell, I have one small comment. I found the *any* DeltaV resource to be a\nlittle confusing below, since it's really \"any resource that supports the\noption listed next to the property\", not \"any resource at all\".\n\n>\n> ------------------\n> Delta-V Properties versioning-15\n>\n> *Any* DeltaV Resource\n>\n> DAV:creationdate [webdav]\n> DAV:displayname [webdav]\n> DAV:getcontentlanguage [webdav]\n> DAV:getcontentlength [webdav]\n> DAV:getcontenttype [webdav]\n> DAV:getetag [webdav]\n> DAV:getlastmodified [webdav]\n> DAV:lockdiscovery [webdav]\n> DAV:resourcetype [webdav]\n> DAV:source [webdav]\n> DAV:supportedlock [webdav]\n> DAV:comment [version-control]\n> DAV:creator-displayname [version-control]\n> DAV:supported-method-set (protected) [version-control]\n> DAV:supported-live-property-set (protected) [version-control]\n> DAV:supported-report-set (protected) [version-control]\n> DAV:workspace (protected) [workspace]\n> DAV:version-controlled-configuration (computed) [baseline]\n\n- Jim\n\n\n\n", "id": "lists-006-1348083"}, {"subject": "Clarification on definition of a configuration...", "content": "Hi,\n\nI just wanted to check that my understanding of Configurations and\nComponents\nis correct....if the group agrees I could add this to the deltaV FAQ because\nI think the text in the specification can be easily misunderstood.\n\n\n\nThe statement in section 12 says:\n\n       \"A configuration is a set of resources that consists of a root\n       collection and all members of that root collection that are not\n       members of another configuration.\"\n\nSo given the collection structure:\n\n        build\n          |\n          |\n          +----- include\n          |\n          |\n          +----- src\n                  |\n                  +----- gui\n\nYou cannot have a configuration rooted at build and another configuration\nrooted at build/src.\n\nBut later in section 12 it says:\n\n       \"the root collection of a configuration can have a member that \n        is the root collection of one of its components\" \n\nSo you can have a configuration rooted at build and a component rooted at\nbuild/src.\n\nIs my understanding of this correct?\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-13483794"}, {"subject": "Legal operations on members of a Baseline Collection..", "content": "Hi,\n\nThe Baseline Collection captures the state of resources that were in the \nBaseline-Controlled Collection when the Baseline was created or when the \nVersion-Controlled Configuration checked-in.\nIn my opinion the resources in the Baseline Collection should be frozen \n(since they just capture state), but, the specification only seems to\ndisallow CHECKOUT of a member of this collection.\n\nSection 12.11 defines (in precondition\nDAV:must-not-update-baseline-collection) \nthat CHECKOUT cannot be done on a member of a Baseline Collection.\nShouldn't \nother operations, eg COPY, MOVE, PUT, DELETE, PROPPATCH also be prevented on\n\nmembers of a baseline collection? \n\nIf these methods can be done on members of the baseline collection then\nthe baseline is not stable and can be changed without checking out the\nVersion-Controlled Configuration...this seems odd....\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-13493047"}, {"subject": "Clarification on what exactly is captured in the Baseline Collect ion..", "content": "Hi,\n\nI thought I understood what was captured in the Baseline Collection (the \ncollection which captures the state of the Baseline-Controlled Collection), \nbut reading the spec in more detail with others in MERANT some seeds of \ndoubt have been sown.\n\nBelow is a detailed explanation, but I guess the basic question is, given:\n\nbuild\n  |\n  + include ---- globals.h\n\nWhere build and include are collections and globals.h is a VCR.\n\nDoes the Baseline Collection contain either:\n\n1) A binding to a collection where that collection contains a binding to a \n   VCR for globals.h.\n\nor\n\n2) One binding called \"include/globals.h\" which points to the VCR for\nglobals.h.\n\nIs the Baseline Collection \"deep\" (containing collections and their members)\nor \"shallow\"\ndoes it only contain VCRs and have \"multi-segment\" bindings to indicate the\npresence\nof collections?\n  \n\n\nHere is my analysis of the specification which shows this is ambiguous......\n\n\nSection 12 says:\n\n       \"In order to allow efficient baseline implementation, the state of a \n        baseline of a collection is limited to be a set of versions and\ntheir \n        names relative to the collection\"\n\nIs it a set of versions or a set of VCRs pointing to versions?  I thought it\nwas the \nlatter.  Section 12.3.1 describes the members of the Baseline Collection to\nbe VCRs\nnot versions.  \n\nIn the postcondition DAV:select-existing-baseline it also talks about VCRs\nbeing \ncreated for each \"version in the baseline\", this gives the impression that\nversions\n(not VCRs) are captured by the baseline collection.\n\nAre the bindings to the VCRs in the Baseline Collection \"multi-segment\", eg \nbuild/src/gui/main.c or does the Baseline Collection capture the collections\nthat \nwere members of the original collection?\n\nWe talk about the baseline capturing the state of the version-controlled\nmembers\nof a collection, but does it actually also capture the state of the\ncollections\nthat are in the configuration rooted at the baseline-controlled collection?\n\nI think the bindings are \"multi-segment\" and the Baseline Collection is\n\"flat\",\nthe only hint to this is in the DAV:select-existing-baseline postcondition\nwhere it says that \"Any nested collections that are needed to provide the \nappropriate name for a version-controlled member will be created\", this\nhints\nthat the baseline collection did not contain collections, it contained \n\"multi-segment\" bindings and now collections need to be created.\n\nBut the DAV:create-new-baseline postcondition says:\n\n       \"The DAV:baseline-collection of the new baseline MUST identify a \n        collection whose members have the same relative name and \n        DAV:checked-in version as the version-controlled members of the \n        request collection\"\n\nThis hints that the bindings are relative names (same as in the original\ncollection).\n\nSo I would say the specification is ambiguous.  If we can clarify this I\nwill\nhappily update the deltaV FAQ to include a good definition of the Baseline\nCollection.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-13503172"}, {"subject": "RE: Legal operations on members of a Baseline Collection..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   The Baseline Collection captures the state of resources that were\n   in the Baseline-Controlled Collection when the Baseline was created\n   or when the Version-Controlled Configuration checked-in.  In my\n   opinion the resources in the Baseline Collection should be frozen\n   (since they just capture state), but, the specification only seems\n   to disallow CHECKOUT of a member of this collection.\n\nYes, the intent was for the dead properties and content of the\nbaseline collection and its members to be frozen.  We can't really say\nwhat happens to live properties (e.g. a \"last accessed time\" property\ncould change).\n\n   Section 12.11 defines (in precondition\n   DAV:must-not-update-baseline-collection) that CHECKOUT cannot be\n   done on a member of a Baseline Collection.  Shouldn't other\n   operations, eg COPY, MOVE, PUT, DELETE, PROPPATCH also be prevented\n   on members of a baseline collection?\n\nSince the members of a BCC are all checked-in VCR's, the only way\nthey can be changed is if they are first checked-out, which is\nwhy it is sufficient to just disallow CHECKOUT.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13514515"}, {"subject": "RE: Clarification on definition of a configuration...", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   The statement in section 12 says: \n\n      \"A configuration is a set of resources that consists of a root\n      collection and all members of that root collection that are not\n      members of another configuration.\"\n\n   So given the collection structure: \n\n   build \n     | \n     +----- include \n     | \n     +----- src \n     | \n     +----- gui \n\n   You cannot have a configuration rooted at build and another\n   configuration rooted at build/src.\n\nWhat in the definition led you to this conclusion?  (This is a real\nquestion, not a rhetorical question, because if something in the text\nled you to this conclusion, it should be fixed).\n\nThe statement you quote above just says that the members of the\nnested (e.g. /build/src) configuration are not also members of the \nparent (e.g. /build) configuration.\n\n   But later in section 12 it says: \n\n      \"the root collection of a configuration can have a member that \n       is the root collection of one of its components\" \n\n   So you can have a configuration rooted at build and a component\n   rooted at build/src.\n\n   Is my understanding of this correct? \n\nYes, your final conclusion (i.e. that nested configurations are\nallowed) is correct.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13523494"}, {"subject": "DAV:merge-preview Report, MERGE and UPDATE response", "content": "The DAV:merge-preview Report's response used to look like\nthe responses of MERGE and UPDATE, but then DAV:ignore-set\nwas dropped from MERGE and UPDATE, and MERGE and UPDATE's\nresponses were brought in line with Multi-Status format\nfollowing Tim Ellison's suggestion on August 21:\n\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JulSep/0240.html\n\nDoes it make sense to bring the DAV:merge-preview Report\nrequest and response format in line with the current format\nfor MERGE and UPDATE?\n\nAlso, as of draft-18, DAV:merge-preview Report identifies\nthe common ancestor version for merge targets that need\nlogical content merging by clients, but MERGE does not\n(though of course of client can still request a\nDAV:version-tree Report and compute the common ancestor\nitself). Does it make sense to introduce a mechanism (such\nas a property) for the server to identify common ancestor\nversions after a MERGE?\n\nThanks,\nRoy\n\n\n\n", "id": "lists-006-13532474"}, {"subject": "Re: Clarification on what exactly is captured in the Baseline Collect ion..", "content": "The baseline collection is deep, for example, it is the collection\nstructure that you would see if you initialized a new workspace from that\nbaseline.\n\nThe confusion may have arisen since a 'baseline of a collection' (i.e., not\na baseline-collection, <sigh>) is a non-collection resource.  Terminology\nconfusion I think.\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n                                                                                                             \n                    Peter Raymond                                                                            \n                    <Peter.Raymond@merant.co       To:     ietf-dav-versioning@w3.org                        \n                    m>                             cc:                                                       \n                    Sent by:                       Subject:     Clarification on what exactly is captured in \n                    ietf-dav-versioning-requ        the Baseline Collect  ion...                             \n                    est@w3.org                                                                               \n                                                                                                             \n                                                                                                             \n                    2001-09-27 10:50 AM                                                                      \n                    Please respond to Peter                                                                  \n                    Raymond                                                                                  \n                                                                                                             \n                                                                                                             \n\n\n\n\n\n\nHi,\n\nI thought I understood what was captured in the Baseline Collection (the\ncollection which captures the state of the Baseline-Controlled Collection),\nbut reading the spec in more detail with others in MERANT some seeds of\ndoubt have been sown.\n\nBelow is a detailed explanation, but I guess the basic question is, given:\n\nbuild\n? |\n? + include ---- globals.h\n\nWhere build and include are collections and globals.h is a VCR.\n\nDoes the Baseline Collection contain either:\n\n1) A binding to a collection where that collection contains a binding to a\n?? VCR for globals.h.\n\nor\n\n2) One binding called \"include/globals.h\" which points to the VCR for\nglobals.h.\n\nIs the Baseline Collection \"deep\" (containing collections and their\nmembers) or \"shallow\"\ndoes it only contain VCRs and have \"multi-segment\" bindings to indicate the\npresence\nof collections?\n\n\nHere is my analysis of the specification which shows this is\nambiguous......\n\nSection 12 says:\n\n?????? \"In order to allow efficient baseline implementation, the state of a\n??????? baseline of a collection is limited to be a set of versions and\ntheir\n??????? names relative to the collection\"\n\nIs it a set of versions or a set of VCRs pointing to versions?? I thought\nit was the\nlatter.? Section 12.3.1 describes the members of the Baseline Collection to\nbe VCRs\nnot versions.\n\nIn the postcondition DAV:select-existing-baseline it also talks about VCRs\nbeing\ncreated for each \"version in the baseline\", this gives the impression that\nversions\n(not VCRs) are captured by the baseline collection.\n\nAre the bindings to the VCRs in the Baseline Collection \"multi-segment\", eg\nbuild/src/gui/main.c or does the Baseline Collection capture the\ncollections that\nwere members of the original collection?\n\nWe talk about the baseline capturing the state of the version-controlled\nmembers\nof a collection, but does it actually also capture the state of the\ncollections\nthat are in the configuration rooted at the baseline-controlled collection?\n\nI think the bindings are \"multi-segment\" and the Baseline Collection is\n\"flat\",\nthe only hint to this is in the DAV:select-existing-baseline postcondition\nwhere it says that \"Any nested collections that are needed to provide the\nappropriate name for a version-controlled member will be created\", this\nhints\nthat the baseline collection did not contain collections, it contained\n\"multi-segment\" bindings and now collections need to be created.\n\nBut the DAV:create-new-baseline postcondition says:\n\n?????? \"The DAV:baseline-collection of the new baseline MUST identify a\n??????? collection whose members have the same relative name and\n??????? DAV:checked-in version as the version-controlled members of the\n??????? request collection\"\n\nThis hints that the bindings are relative names (same as in the original\ncollection).\n\nSo I would say the specification is ambiguous.? If we can clarify this I\nwill\nhappily update the deltaV FAQ to include a good definition of the Baseline\nCollection.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-13539979"}, {"subject": "Re: Legal operations on members of a Baseline Collection..", "content": "Yes, all modifications to the baseline collection are illegal -- in many\nimplementations the collection will be a 'virtual' reflection of the\ncontents of the baseline.  Clearly there is already the mechanism within\nDAV to disallow these methods (e.g., supported method set) but calling them\nregular version-controlled resources is misleading -- they are in no way\n'regular'.\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n                                                                                                             \n                    Peter Raymond                                                                            \n                    <Peter.Raymond@merant.co       To:     ietf-dav-versioning@w3.org                        \n                    m>                             cc:                                                       \n                    Sent by:                       Subject:     Legal operations on members of a Baseline    \n                    ietf-dav-versioning-requ        Collection...                                            \n                    est@w3.org                                                                               \n                                                                                                             \n                                                                                                             \n                    2001-09-27 10:42 AM                                                                      \n                    Please respond to Peter                                                                  \n                    Raymond                                                                                  \n                                                                                                             \n                                                                                                             \n\n\n\n\n\n\nHi,\n\nThe Baseline Collection captures the state of resources that were in the\nBaseline-Controlled Collection when the Baseline was created or when the\nVersion-Controlled Configuration checked-in.\nIn my opinion the resources in the Baseline Collection should be frozen\n(since they just capture state), but, the specification only seems to\ndisallow CHECKOUT of a member of this collection.\n\nSection 12.11 defines (in precondition\nDAV:must-not-update-baseline-collection)\nthat CHECKOUT cannot be done on a member of a Baseline Collection.\nShouldn't\nother operations, eg COPY, MOVE, PUT, DELETE, PROPPATCH also be prevented\non\nmembers of a baseline collection?\n\nIf these methods can be done on members of the baseline collection then\nthe baseline is not stable and can be changed without checking out the\nVersion-Controlled Configuration...this seems odd....\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-13554134"}, {"subject": "RE: VCR properties (was: Removing the DAV:activity ...", "content": "I assume by \"a VCR copying all the props of the version\",\nyou mean after an UPDATE request?  To my knowledge, UPDATE\nhas always copied only the dead properties of the version\nto the VCR, not the live properties.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Greg Stein [mailto:gstein@lyra.org]\nSent: Thursday, June 07, 2001 1:37 PM\nTo: ietf-dav-versioning@w3.org\nSubject: VCR properties (was: Removing the DAV:activity ...)\n\n\nOn Thu, Jun 07, 2001 at 12:02:09PM +0100, Tim Ellison wrote:\n> Greg wrote:\n> \n> > > A version is identified by its support for the\n> > > <DAV:version-name> property.\n> >\n> > But also the absence of some other properties. VCRs have the\nversion-name\n> > property on them, too.\n> \n> Nope.  A version-controlled resource does not have a DAV:version-name\n> property.\n\nWoah. Reading the spec on this part closely... it would appear that we\ndropped the whole thing about a VCR copying all the props of the version?\n\nWhat happened here when I wasn't looking? :-)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-1356476"}, {"subject": "RE: Legal operations on members of a Baseline Collection..", "content": "Hi,\n\nThe Baseline Collection is a collection so there is nothing to stop you\ndoing a PUT on that collection.  Unless we explicitly have a precondition\nfor PUT that says you cannot put to a baseline collection.\nSame for destination for a MOVE or COPY.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: 27 September 2001 14:00\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Legal operations on members of a Baseline Collection...\n\n\n   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   The Baseline Collection captures the state of resources that were\n   in the Baseline-Controlled Collection when the Baseline was created\n   or when the Version-Controlled Configuration checked-in.  In my\n   opinion the resources in the Baseline Collection should be frozen\n   (since they just capture state), but, the specification only seems\n   to disallow CHECKOUT of a member of this collection.\n\nYes, the intent was for the dead properties and content of the\nbaseline collection and its members to be frozen.  We can't really say\nwhat happens to live properties (e.g. a \"last accessed time\" property\ncould change).\n\n   Section 12.11 defines (in precondition\n   DAV:must-not-update-baseline-collection) that CHECKOUT cannot be\n   done on a member of a Baseline Collection.  Shouldn't other\n   operations, eg COPY, MOVE, PUT, DELETE, PROPPATCH also be prevented\n   on members of a baseline collection?\n\nSince the members of a BCC are all checked-in VCR's, the only way\nthey can be changed is if they are first checked-out, which is\nwhy it is sufficient to just disallow CHECKOUT.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13566166"}, {"subject": "RE: Clarification on definition of a configuration...", "content": "Hi,\n\nIt was the text in section 12 where it says \"... that are not members of\nanother \nconfiguration\" that leads to the confusion.\n\nLets imagine you have the structure in the e-mail below and you put\nthe build collection under baseline control by issuing a BASELINE-CONTROL\nrequest.\n\nCan you now issue another BASELINE-CONTROL request on build/src?\n\nI guess not since the resulting configuration would contain members\nof the configuration defined by the initial BASELINE-CONTROL request.\nAlso the pre-condition (DAV:version-controlled-configuration-must-not-exist)\nwould be triggered because build/src already has a version-controlled\nconfiguration property.\n\nBUT...I guess you could have done that in the reverse order...eg...\n\nIf I issue a BASELINE-CONTROL method on build/src first I would then be\nable to later put the build collection itself under BASELINE-CONTROL.\n\nIs that right?\n\nWould the second baseline contain members from build and build/include\nbut no members from build/src? Because the second configuration can\nnot contain members from the first configuration?\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: 27 September 2001 14:00\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Clarification on definition of a configuration....\n\n\n\n   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   The statement in section 12 says: \n\n      \"A configuration is a set of resources that consists of a root\n      collection and all members of that root collection that are not\n      members of another configuration.\"\n\n   So given the collection structure: \n\n   build \n     | \n     +----- include \n     | \n     +----- src \n     | \n     +----- gui \n\n   You cannot have a configuration rooted at build and another\n   configuration rooted at build/src.\n\nWhat in the definition led you to this conclusion?  (This is a real\nquestion, not a rhetorical question, because if something in the text\nled you to this conclusion, it should be fixed).\n\nThe statement you quote above just says that the members of the\nnested (e.g. /build/src) configuration are not also members of the \nparent (e.g. /build) configuration.\n\n   But later in section 12 it says: \n\n      \"the root collection of a configuration can have a member that \n       is the root collection of one of its components\" \n\n   So you can have a configuration rooted at build and a component\n   rooted at build/src.\n\n   Is my understanding of this correct? \n\nYes, your final conclusion (i.e. that nested configurations are\nallowed) is correct.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13577253"}, {"subject": "RE: Clarification on what exactly is captured in the Baseline Col lect ion..", "content": "Hi,\n\nJust to be clear, Tim, were you opting for option 1? eg:\n\n\n\nThe confusion arises because it is not clearly stated in the spec.\nThe pieces of text that confuse me most are:\n\n\"Any nested collections that are needed to provide the\nappropriate name for a version-controlled member will be created\"\n\nMakes it sound like a baseline collection will not contain all\nthe collections, eg when you use BASELINE-CONTROL to populate\na collection from a given baseline you need to parse the names\nof the VCRs and create any collection resources needed.\n\nAlso the text that says:\n\n\"In order to allow efficient baseline implementation, the state of a\nbaseline of a collection is limited to be a set of versions and\ntheir names relative to the collection\"\n\nMakes it sound like only bindings to versions are being captured,\nnot bindings to other collections.\n\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\nSent: 27 September 2001 14:31\nTo: ietf-dav-versioning@w3.org\nSubject: Re: Clarification on what exactly is captured in the Baseline\nCollect ion...\n\n\n\nThe baseline collection is deep, for example, it is the collection\nstructure that you would see if you initialized a new workspace from that\nbaseline.\n\nThe confusion may have arisen since a 'baseline of a collection' (i.e., not\na baseline-collection, <sigh>) is a non-collection resource.  Terminology\nconfusion I think.\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n \n\n                    Peter Raymond\n\n                    <Peter.Raymond@merant.co       To:\nietf-dav-versioning@w3.org                        \n                    m>                             cc:\n\n                    Sent by:                       Subject:\nClarification on what exactly is captured in \n                    ietf-dav-versioning-requ        the Baseline Collect\nion...                             \n                    est@w3.org\n\n \n\n \n\n                    2001-09-27 10:50 AM\n\n                    Please respond to Peter\n\n                    Raymond\n\n \n\n \n\n\n\n\n\n\n\nHi,\n\nI thought I understood what was captured in the Baseline Collection (the\ncollection which captures the state of the Baseline-Controlled Collection),\nbut reading the spec in more detail with others in MERANT some seeds of\ndoubt have been sown.\n\nBelow is a detailed explanation, but I guess the basic question is, given:\n\nbuild\n? |\n? + include ---- globals.h\n\nWhere build and include are collections and globals.h is a VCR.\n\nDoes the Baseline Collection contain either:\n\n1) A binding to a collection where that collection contains a binding to a\n?? VCR for globals.h.\n\nor\n\n2) One binding called \"include/globals.h\" which points to the VCR for\nglobals.h.\n\nIs the Baseline Collection \"deep\" (containing collections and their\nmembers) or \"shallow\"\ndoes it only contain VCRs and have \"multi-segment\" bindings to indicate the\npresence\nof collections?\n\n\nHere is my analysis of the specification which shows this is\nambiguous......\n\nSection 12 says:\n\n?????? \"In order to allow efficient baseline implementation, the state of a\n??????? baseline of a collection is limited to be a set of versions and\ntheir\n??????? names relative to the collection\"\n\nIs it a set of versions or a set of VCRs pointing to versions?? I thought\nit was the\nlatter.? Section 12.3.1 describes the members of the Baseline Collection to\nbe VCRs\nnot versions.\n\nIn the postcondition DAV:select-existing-baseline it also talks about VCRs\nbeing\ncreated for each \"version in the baseline\", this gives the impression that\nversions\n(not VCRs) are captured by the baseline collection.\n\nAre the bindings to the VCRs in the Baseline Collection \"multi-segment\", eg\nbuild/src/gui/main.c or does the Baseline Collection capture the\ncollections that\nwere members of the original collection?\n\nWe talk about the baseline capturing the state of the version-controlled\nmembers\nof a collection, but does it actually also capture the state of the\ncollections\nthat are in the configuration rooted at the baseline-controlled collection?\n\nI think the bindings are \"multi-segment\" and the Baseline Collection is\n\"flat\",\nthe only hint to this is in the DAV:select-existing-baseline postcondition\nwhere it says that \"Any nested collections that are needed to provide the\nappropriate name for a version-controlled member will be created\", this\nhints\nthat the baseline collection did not contain collections, it contained\n\"multi-segment\" bindings and now collections need to be created.\n\nBut the DAV:create-new-baseline postcondition says:\n\n?????? \"The DAV:baseline-collection of the new baseline MUST identify a\n??????? collection whose members have the same relative name and\n??????? DAV:checked-in version as the version-controlled members of the\n??????? request collection\"\n\nThis hints that the bindings are relative names (same as in the original\ncollection).\n\nSo I would say the specification is ambiguous.? If we can clarify this I\nwill\nhappily update the deltaV FAQ to include a good definition of the Baseline\nCollection.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-13589230"}, {"subject": "RE: Clarification on what exactly is captured in the Baseline Col  lect ion..", "content": "Hi,\n\nTo make this even clearer I have attached some powerpoint slides showing a\ncollection\nhierarchy before BASELINE-CONTROL and after BASELINE-CONTROL.\n\n\nDoes it look correct?\n\nIf it is, does the group think this would be useful to have avilable on\nwww.webdav.org/deltav\nto help explain the baseline concept?\n\nRegards,\n-- \nPeter Raymond - MERANT \nPrincipal Architect (PVCS) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: 27 September 2001 15:14\nTo: Tim Ellison; ietf-dav-versioning@w3.org\nSubject: RE: Clarification on what exactly is captured in the Baseline Col\nlect ion...\n\n\nHi, \nJust to be clear, Tim, were you opting for option 1? eg: \n\n\n\nThe confusion arises because it is not clearly stated in the spec. \nThe pieces of text that confuse me most are: \n\"Any nested collections that are needed to provide the \nappropriate name for a version-controlled member will be created\" \nMakes it sound like a baseline collection will not contain all \nthe collections, eg when you use BASELINE-CONTROL to populate \na collection from a given baseline you need to parse the names \nof the VCRs and create any collection resources needed. \nAlso the text that says: \n\"In order to allow efficient baseline implementation, the state of a \nbaseline of a collection is limited to be a set of versions and \ntheir names relative to the collection\" \nMakes it sound like only bindings to versions are being captured, \nnot bindings to other collections. \n-- \nPeter Raymond - MERANT \nPrincipal Architect (PVCS) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n\n\n\n-----Original Message----- \nFrom: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com] \nSent: 27 September 2001 14:31 \nTo: ietf-dav-versioning@w3.org \nSubject: Re: Clarification on what exactly is captured in the Baseline \nCollect ion... \n\n\n\nThe baseline collection is deep, for example, it is the collection \nstructure that you would see if you initialized a new workspace from that \nbaseline. \nThe confusion may have arisen since a 'baseline of a collection' (i.e., not \na baseline-collection, <sigh>) is a non-collection resource.  Terminology \nconfusion I think. \nRegards, \nTim Ellison \nJava Technology Centre, MP146 \nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN \ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452 \n\n\n \n\n                    Peter Raymond\n\n                    <Peter.Raymond@merant.co       To:\nietf-dav-versioning@w3.org                        \n                    m>                             cc:\n\n                    Sent by:                       Subject:\nClarification on what exactly is captured in \n                    ietf-dav-versioning-requ        the Baseline Collect\nion...                             \n                    est@w3.org\n\n \n\n \n\n                    2001-09-27 10:50 AM\n\n                    Please respond to Peter\n\n                    Raymond\n\n \n\n \n\n\n\n\n\n\n\nHi, \nI thought I understood what was captured in the Baseline Collection (the \ncollection which captures the state of the Baseline-Controlled Collection), \nbut reading the spec in more detail with others in MERANT some seeds of \ndoubt have been sown. \nBelow is a detailed explanation, but I guess the basic question is, given: \nbuild \n  | \n  + include ---- globals.h \nWhere build and include are collections and globals.h is a VCR. \nDoes the Baseline Collection contain either: \n1) A binding to a collection where that collection contains a binding to a \n   VCR for globals.h. \nor \n2) One binding called \"include/globals.h\" which points to the VCR for \nglobals.h. \nIs the Baseline Collection \"deep\" (containing collections and their \nmembers) or \"shallow\" \ndoes it only contain VCRs and have \"multi-segment\" bindings to indicate the \npresence \nof collections? \n\n\nHere is my analysis of the specification which shows this is \nambiguous...... \nSection 12 says: \n       \"In order to allow efficient baseline implementation, the state of a \n        baseline of a collection is limited to be a set of versions and \ntheir \n        names relative to the collection\" \nIs it a set of versions or a set of VCRs pointing to versions?  I thought \nit was the \nlatter.  Section 12.3.1 describes the members of the Baseline Collection to \nbe VCRs \nnot versions. \nIn the postcondition DAV:select-existing-baseline it also talks about VCRs \nbeing \ncreated for each \"version in the baseline\", this gives the impression that \nversions \n(not VCRs) are captured by the baseline collection. \nAre the bindings to the VCRs in the Baseline Collection \"multi-segment\", eg \nbuild/src/gui/main.c or does the Baseline Collection capture the \ncollections that \nwere members of the original collection? \nWe talk about the baseline capturing the state of the version-controlled \nmembers \nof a collection, but does it actually also capture the state of the \ncollections \nthat are in the configuration rooted at the baseline-controlled collection? \nI think the bindings are \"multi-segment\" and the Baseline Collection is \n\"flat\", \nthe only hint to this is in the DAV:select-existing-baseline postcondition \nwhere it says that \"Any nested collections that are needed to provide the \nappropriate name for a version-controlled member will be created\", this \nhints \nthat the baseline collection did not contain collections, it contained \n\"multi-segment\" bindings and now collections need to be created. \nBut the DAV:create-new-baseline postcondition says: \n       \"The DAV:baseline-collection of the new baseline MUST identify a \n        collection whose members have the same relative name and \n        DAV:checked-in version as the version-controlled members of the \n        request collection\" \nThis hints that the bindings are relative names (same as in the original \ncollection). \nSo I would say the specification is ambiguous.  If we can clarify this I \nwill \nhappily update the deltaV FAQ to include a good definition of the Baseline \nCollection. \nRegards, \n-- \nPeter Raymond - MERANT \nPrincipal Architect (PVCS) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n\n\n\n\n\n\napplication/vnd.ms-powerpoint attachment: Baselines.ppt\n\n\n\n\n", "id": "lists-006-13604934"}, {"subject": "RE: Legal operations on members of a Baseline Collection..", "content": "The definition of the DAV:baseline-collection property states:\n\n\"each member of this collection has the same \nDAV:checked-in version and relative name as a \nmember of the baseline-controlled collection at\nthe time the baseline was created\"\n\nI believe this makes it sufficiently clear that no operations\nthat would add/remove/change members of the DAV:baseline-collection\nare allowed.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Thursday, September 27, 2001 9:46 AM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: RE: Legal operations on members of a Baseline Collection...\n\n\nHi, \nThe Baseline Collection is a collection so there is nothing to stop you \ndoing a PUT on that collection.  Unless we explicitly have a precondition \nfor PUT that says you cannot put to a baseline collection. \nSame for destination for a MOVE or COPY. \n\n\n\n", "id": "lists-006-13622765"}, {"subject": "RE: Clarification on definition of a configuration...", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   It was the text in section 12 where it says \"... that are not\n   members of another configuration\" that leads to the confusion.\n   Lets imagine you have the structure in the e-mail below and you put\n   the build collection under baseline control by issuing a\n   BASELINE-CONTROL request.  Can you now issue another\n   BASELINE-CONTROL request on build/src?  I guess not since the\n   resulting configuration would contain members of the configuration\n   defined by the initial BASELINE-CONTROL request.  Also the\n   pre-condition (DAV:version-controlled-configuration-must-not-exist)\n   would be triggered because build/src already has a\n   version-controlled configuration property.\n\nYes, that is correct.\n\n   BUT...I guess you could\n   have done that in the reverse order...eg...  If I issue a\n   BASELINE-CONTROL method on build/src first I would then be able to\n   later put the build collection itself under BASELINE-CONTROL.  Is\n   that right?\n\nYes.  You could also take  a collection that was under baseline\ncontrol and MOVE it under another configuration (it would not \nbecome part of that other configuration, but just would be located\nunder it from a namespace perspective).\n\n   Would the second baseline contain members from build\n   and build/include but no members from build/src? Because the second\n   configuration can not contain members from the first configuration?\n\nYes, also correct.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13631797"}, {"subject": "RE: Legal operations on members of a Baseline Collection..", "content": "Hi,\n\nOK...I guess that section does make it clear.\n\nBut, how much of the normative text should be captured in pre and post\nconditions? Without any pre or post condition to enforce the paragraph\nthat you quoted do vendors have to obey that paragraph?\n\nWould I am getting at is that other areas where we are enforcing something\nwe explicitly enforce it using pre or post conditions.  But not this one.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: 27 September 2001 16:00\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Legal operations on members of a Baseline Collection...\n\n\nThe definition of the DAV:baseline-collection property states:\n\n\"each member of this collection has the same \nDAV:checked-in version and relative name as a \nmember of the baseline-controlled collection at\nthe time the baseline was created\"\n\nI believe this makes it sufficiently clear that no operations\nthat would add/remove/change members of the DAV:baseline-collection\nare allowed.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Thursday, September 27, 2001 9:46 AM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: RE: Legal operations on members of a Baseline Collection...\n\n\nHi, \nThe Baseline Collection is a collection so there is nothing to stop you \ndoing a PUT on that collection.  Unless we explicitly have a precondition \nfor PUT that says you cannot put to a baseline collection. \nSame for destination for a MOVE or COPY. \n\n\n\n", "id": "lists-006-13640681"}, {"subject": "RE: Deleting version", "content": "Julian, Stefan, and I had a side thread on the question of\nMicrosoft IIS support for lock-null resources.  I figured\nits results might be of general interest.  Summary:\n\nIIS does allow you to issue a LOCK against a null resource,\nbut it does not create a lock-null resource as defined by\nWebDAV -- it just creates an empty file and locks it.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n\nUpdate: MKCOL on an IIS lock-null resource gives 405 NOT ALLOWED.\nSo, IIS internally creates an empty file and does not know about\nlock-null resources.\n\nRegards, Stefan\n\n> -----Urspr?ngliche Nachricht-----\n> Von: Clemm, Geoff [mailto:gclemm@rational.com]\n> Gesendet: Donnerstag, 7. Juni 2001 15:47\n> An: Julian F. Reschke\n> Cc: Stefan Eissing\n> Betreff: RE: Deleting versions\n>\n>\n> Have you ever tried to truncate the message flow to see what\n> actually is left in the file system after the LOCK if no\n> PUT follows it?\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n> Sent: Thursday, June 07, 2001 9:36 AM\n> To: Clemm, Geoff\n> Cc: Stefan Eissing\n> Subject: RE: Deleting versions\n>\n>\n> Geoff,\n>\n> attached is a lengthy trace from Word2000.\n>\n> Search for \"foo2.doc\". You'll see that Word creates a lock-null, and then\n> uses the lock token for a PUT.\n>\n> Julian\n>\n> > -----Original Message-----\n> > From: Clemm, Geoff [mailto:gclemm@rational.com]\n> > Sent: Thursday, June 07, 2001 3:28 PM\n> > To: Julian F. Reschke\n> > Subject: RE: Deleting versions\n> >\n> >\n> > How did you use \"save as\" to create a lock null resource?\n> > When I do a \"save as\", it just creates a regular file.\n> > Or did you watch the protocol sequence as it passed over\n> > the wire, and noticed that the \"LOCK\" came before the first\n> > \"PUT\"?\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n> > Sent: Thursday, June 07, 2001 4:12 AM\n> > To: Clemm, Geoff\n> > Cc: Stefan Eissing\n> > Subject: RE: Deleting versions\n> >\n> >\n> > Microsoft Word 2000.\n> >\n> > > -----Original Message-----\n> > > From: Clemm, Geoff [mailto:gclemm@rational.com]\n> > > Sent: Thursday, June 07, 2001 12:45 AM\n> > > To: 'julian.reschke@greenbytes.de'\n> > > Subject: RE: Deleting versions\n> > >\n> > >\n> > > Interesting.  I was not able to get IIS to create a lock null\n> > > resource (although I must admit, I didn't try that hard).\n> > > What client did you use?\n> > >\n> > > Cheers,\n> > > Geoff\n> > >\n> > > -----Original Message-----\n> > > From: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\n> > > Sent: Wednesday, June 06, 2001 5:51 PM\n> > > To: Clemm, Geoff; DeltaV\n> > > Subject: RE: Deleting versions\n> > >\n> > >\n> > > Geoff,\n> > >\n> > > last time I checked, MS Office was creating lock-null resources\n> > > when doing a\n> > > \"save as\" on an open document (for which Office already had a lock).\n> > >\n> > > Julian\n> > >\n> > > >\n> > >\n> > >\n> >\n>\n\n\n\n", "id": "lists-006-1365005"}, {"subject": "RE: Legal operations on members of a Baseline Collection..", "content": "Yes, we normally prefer to define constraints in the form of preconditions,\nbut in this case, the single statement \"must never change\" in the property\ndefinition was so much simpler that repeating it in each \"mutating\" method.\nBut I agree that this normative aspect of the property\ndefinition should be highlighted.  I suggest we change the \"has\" to a\n\"MUST have\" in the definition to make this point (a change that fits the\n\"no-repagination\" goal :-).\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Thursday, September 27, 2001 11:16 AM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: RE: Legal operations on members of a Baseline Collection...\n\n\nHi, \nOK...I guess that section does make it clear. \nBut, how much of the normative text should be captured in pre and post \nconditions? Without any pre or post condition to enforce the paragraph \nthat you quoted do vendors have to obey that paragraph? \nWould I am getting at is that other areas where we are enforcing something \nwe explicitly enforce it using pre or post conditions.  But not this one. \nRegards, \n\n\n\n", "id": "lists-006-13651974"}, {"subject": "RE: Clarification on what exactly is captured in the Baseline Col lection..", "content": "Looks good to me.  It would be great if you could put this slide set (and\nthe others you have created) up on a web site that we could link to from the\ndeltav site.  If you don't have access to a public web site you can author,\nwe could also just post the .ppt files directly on the deltav site (I try to\nminimize the number of fat files we put up on the deltav site itself, to not\nuse up an excessive amount of Greg's disk space, and .ppt files are known to\nbe not skinny:-).\n \nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Thursday, September 27, 2001 10:36 AM\nTo: Tim Ellison; ietf-dav-versioning@w3.org\nSubject: RE: Clarification on what exactly is captured in the Baseline Col\nlect ion...\n\n\n\nHi, \n\nTo make this even clearer I have attached some powerpoint slides showing a\ncollection \nhierarchy before BASELINE-CONTROL and after BASELINE-CONTROL. \n\n\nDoes it look correct? \n\nIf it is, does the group think this would be useful to have avilable on\nwww.webdav.org/deltav \nto help explain the baseline concept? \n\nRegards, \n-- \nPeter Raymond - MERANT \nPrincipal Architect (PVCS) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com <mailto:Peter.Raymond@merant.com>  \nWWW: http://www.merant.com <http://www.merant.com>  \n-----Original Message----- \nFrom: Peter Raymond [ mailto:Peter.Raymond@merant.com\n<mailto:Peter.Raymond@merant.com> ] \nSent: 27 September 2001 15:14 \nTo: Tim Ellison; ietf-dav-versioning@w3.org \nSubject: RE: Clarification on what exactly is captured in the Baseline Col\nlect ion... \n\n\nHi, \nJust to be clear, Tim, were you opting for option 1? eg: \n\n\n\nThe confusion arises because it is not clearly stated in the spec. \nThe pieces of text that confuse me most are: \n\"Any nested collections that are needed to provide the \nappropriate name for a version-controlled member will be created\" \nMakes it sound like a baseline collection will not contain all \nthe collections, eg when you use BASELINE-CONTROL to populate \na collection from a given baseline you need to parse the names \nof the VCRs and create any collection resources needed. \nAlso the text that says: \n\"In order to allow efficient baseline implementation, the state of a \nbaseline of a collection is limited to be a set of versions and \ntheir names relative to the collection\" \nMakes it sound like only bindings to versions are being captured, \nnot bindings to other collections. \n-- \nPeter Raymond - MERANT \nPrincipal Architect (PVCS) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com <mailto:Peter.Raymond@merant.com>  \nWWW: http://www.merant.com <http://www.merant.com>  \n\n\n\n-----Original Message----- \nFrom: Tim Ellison [ mailto:Tim_Ellison@uk.ibm.com\n<mailto:Tim_Ellison@uk.ibm.com> ] \nSent: 27 September 2001 14:31 \nTo: ietf-dav-versioning@w3.org \nSubject: Re: Clarification on what exactly is captured in the Baseline \nCollect ion... \n\n\n\nThe baseline collection is deep, for example, it is the collection \nstructure that you would see if you initialized a new workspace from that \nbaseline. \nThe confusion may have arisen since a 'baseline of a collection' (i.e., not \na baseline-collection, <sigh>) is a non-collection resource.  Terminology \nconfusion I think. \nRegards, \nTim Ellison \nJava Technology Centre, MP146 \nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN \ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452 \n\n\n \n\n                    Peter Raymond\n\n                    <Peter.Raymond@merant.co       To:\nietf-dav-versioning@w3.org                        \n                    m>                             cc:\n\n                    Sent by:                       Subject:\nClarification on what exactly is captured in \n                    ietf-dav-versioning-requ        the Baseline Collect\nion...                             \n                    est@w3.org\n\n \n\n \n\n                    2001-09-27 10:50 AM\n\n                    Please respond to Peter\n\n                    Raymond\n\n \n\n \n\n\n\n\n\n\n\nHi, \nI thought I understood what was captured in the Baseline Collection (the \ncollection which captures the state of the Baseline-Controlled Collection), \nbut reading the spec in more detail with others in MERANT some seeds of \ndoubt have been sown. \nBelow is a detailed explanation, but I guess the basic question is, given: \nbuild \n  | \n  + include ---- globals.h \nWhere build and include are collections and globals.h is a VCR. \nDoes the Baseline Collection contain either: \n1) A binding to a collection where that collection contains a binding to a \n   VCR for globals.h. \nor \n2) One binding called \"include/globals.h\" which points to the VCR for \nglobals.h. \nIs the Baseline Collection \"deep\" (containing collections and their \nmembers) or \"shallow\" \ndoes it only contain VCRs and have \"multi-segment\" bindings to indicate the \npresence \nof collections? \n\n\nHere is my analysis of the specification which shows this is \nambiguous...... \nSection 12 says: \n       \"In order to allow efficient baseline implementation, the state of a \n        baseline of a collection is limited to be a set of versions and \ntheir \n        names relative to the collection\" \nIs it a set of versions or a set of VCRs pointing to versions?  I thought \nit was the \nlatter.  Section 12.3.1 describes the members of the Baseline Collection to \nbe VCRs \nnot versions. \nIn the postcondition DAV:select-existing-baseline it also talks about VCRs \nbeing \ncreated for each \"version in the baseline\", this gives the impression that \nversions \n(not VCRs) are captured by the baseline collection. \nAre the bindings to the VCRs in the Baseline Collection \"multi-segment\", eg \nbuild/src/gui/main.c or does the Baseline Collection capture the \ncollections that \nwere members of the original collection? \nWe talk about the baseline capturing the state of the version-controlled \nmembers \nof a collection, but does it actually also capture the state of the \ncollections \nthat are in the configuration rooted at the baseline-controlled collection? \nI think the bindings are \"multi-segment\" and the Baseline Collection is \n\"flat\", \nthe only hint to this is in the DAV:select-existing-baseline postcondition \nwhere it says that \"Any nested collections that are needed to provide the \nappropriate name for a version-controlled member will be created\", this \nhints \nthat the baseline collection did not contain collections, it contained \n\"multi-segment\" bindings and now collections need to be created. \nBut the DAV:create-new-baseline postcondition says: \n       \"The DAV:baseline-collection of the new baseline MUST identify a \n        collection whose members have the same relative name and \n        DAV:checked-in version as the version-controlled members of the \n        request collection\" \nThis hints that the bindings are relative names (same as in the original \ncollection). \nSo I would say the specification is ambiguous.  If we can clarify this I \nwill \nhappily update the deltaV FAQ to include a good definition of the Baseline \nCollection. \nRegards, \n-- \nPeter Raymond - MERANT \nPrincipal Architect (PVCS) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com <mailto:Peter.Raymond@merant.com>  \nWWW: http://www.merant.com <http://www.merant.com>  \n\n\n\n", "id": "lists-006-13661278"}, {"subject": "RE: merge-preview Report, MERGE and UPDATE response", "content": "I think it is useful to keep the DAV:merge-preview semantics\nthe way they currently are.  If a client wants to guide the merge\nprocess, they would use the DAV:merge-preview report, and take\nadvantage of the detailed information (such as common ancestor)\nprovided there.  The MERGE method is there for clients that just\nwant servers to do all the work.  If a client has used the MERGE\nmethod, and then wants to give the user some more help with a particular\nmerge, it would ask for the DAV:merge-preview report for that\nparticular merge.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Roy Seto [mailto:Roy.Seto@oracle.com]\nSent: Thursday, September 27, 2001 9:22 AM\nTo: ietf-dav-versioning@w3.org\nSubject: DAV:merge-preview Report, MERGE and UPDATE responses\n\n\nThe DAV:merge-preview Report's response used to look like\nthe responses of MERGE and UPDATE, but then DAV:ignore-set\nwas dropped from MERGE and UPDATE, and MERGE and UPDATE's\nresponses were brought in line with Multi-Status format\nfollowing Tim Ellison's suggestion on August 21:\n\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JulSep/0240.html\n\nDoes it make sense to bring the DAV:merge-preview Report\nrequest and response format in line with the current format\nfor MERGE and UPDATE?\n\nAlso, as of draft-18, DAV:merge-preview Report identifies\nthe common ancestor version for merge targets that need\nlogical content merging by clients, but MERGE does not\n(though of course of client can still request a\nDAV:version-tree Report and compute the common ancestor\nitself). Does it make sense to introduce a mechanism (such\nas a property) for the server to identify common ancestor\nversions after a MERGE?\n\nThanks,\nRoy\n\n\n\n", "id": "lists-006-13681413"}, {"subject": "RE: Clarification of DAV:update-merge-set when rerunning MERG", "content": "Change #1 has been made in draft-19.  Change #2 is also very reasonable,\nand there just happens to be an extra blank line on that page, so I can\nsqueeze in the extra sentence.  \n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Roy Seto [mailto:roy.seto@oracle.com]\nSent: Monday, September 17, 2001 1:43 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: Clarification of DAV:update-merge-set when rerunning MERGE\n\n\nGeoff,\n\nThanks for the clarification. What about making the following two edits?\n\n1. I agree that moving the \"must be in a DAV:response\" sentence up into\nthe first or second sentence of the DAV:update-merge-set postcondition\nwould make the intent clearer.\n\n2. I think I was confused by the text in the opening of Section 11.2, \"The\nresponse to a MERGE request identifies the resources modified by the\nrequest, so that a client can efficiently update any cached state it is\nmaintaining.\" I got confused because DAV:update-merge-set doesn't actually\nchange the target's state when MERGE is rerun. After reading your\nclarification, I understand this text is non-normative and the\nDAV:update-merge-set postcondition is normative, but other readers might\nmake the same mistake I did.\n\nWould it be possible to modify the introductory text above to something\nlike \"The response to a MERGE identifies resources which a client must\nmodify to complete the merge. It also identifies resources modified by the\nrequest, so that a client can efficiently update any cached state it is\nmaintaining.\"\n\nThanks,\nRoy\n\n\"Clemm, Geoff\" wrote:\n\n>    From: Roy Seto [mailto:Roy.Seto@oracle.com]\n>\n>    I'm looking at the behavior of the MERGE method when it is\n>    rerun. I'd like clarification of the DAV:update-merge-set\n>    postcondition in Section 11.2 for this scenario.\n>\n>    Specifically, if a merge target was already checked out\n>    before the second or later MERGE, and its DAV:merge-set or\n>    DAV:auto-merge-set already includes the merge source, does\n>    the merge target appear in a DAV:response XML element in the\n>    response body?\n>\n> Yes, this is required by the last sentence of the DAV:update-merge-set\n> postcondition.\n>\n>    I feel this is ambiguous in draft-18. The\n>    DAV:update-merge-set postcondition does apply to this merge\n>    target, because it was already checked out before the MERGE,\n>    and its DAV:checked-out version is not a descendant of the\n>    merge source (assuming a client has not moved the merge\n>    source from DAV:merge-set to DAV:predecessor-set between the\n>    MERGE requests). However, the state of the merge target does\n>    not actually change in the second MERGE request, since\n>    adding a source to a DAV:merge-set which already contains it\n>    doesn't change the DAV:merge-set property.\n>\n> The last sentence of DAV:update-merge-set applies to any\n> target that matches this postcondition, i.e.:\n>\n>  If the merge target was checked out by the MERGE (or was already\n>  checked out before the MERGE), and if the DAV:checked-out version of\n>  the merge target is not a descendant of the merge source ...\n>\n> There is no dependency on whether or not the the merge source\n> is already in the DAV:merge-set or DAV:auto-merge-set.\n> If this is not clear, I could move the \"must be in a DAV:response\"\n> sentence up into the first sentence of this precondition, if you\n> think that would be clearer.\n>\n> [restart example omitted]\n>\n>    Alternative options I considered for supporting restart:\n>\n>     - The client could do a PROPFIND Depth:infinity\n>       and look for resources which have nonempty\n>       DAV:merge-set or DAV:auto-merge-set properties,\n>       but it seems difficult to make this efficient.\n>       It also requires the client to detect the restart\n>       case and implement it with a different code path.\n>\n> Well, a client has to do this anyway, if the user doesn't\n> remember what MERGE they performed.  But I agree that this\n> would be a challenge to make efficient.  One approach is\n> to play a little fast'n'loose with the PROPFIND semantics,\n> and only have the PROPFIND return results with non-empty\n> DAV:(auto-)merge-set properties, and just use an index\n> on those properties to optimize the speed of the PROPFIND.\n>\n>     - The client could do a DASL query to optimize\n>       the PROPFIND above if DASL were standardized.\n>\n> Yeah, that would be nice (:-).\n>\n> And of course, option 3 is to just use the DAV:merge-preview\n> report to get the info you need.\n>\n>    --\n>\n>    I have a similar question about the behavior of the\n>    DAV:merge-preview REPORT after the corresponding MERGE has\n>    already been done. If a merge target requires a merge, and\n>    its DAV:merge-set or DAV:auto-merge-set already includes the\n>    merge source, does the response body include it in a\n>    DAV:conflict-preview element? (For reasons similar to the\n>    DAV:update-merge-set case, I prefer that it must.)\n>\n> The merge-preview element contains all resources that \"need\n> to be merged\".  Whether or not something needs to be merged\n> is not changed by that version already being in the\n> DAV:merge-set.  So DAV:merge-preview definitely works the\n> way you want (and was intended to do so).\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-13690473"}, {"subject": "RE: Legal operations on members of a Baseline Collection..", "content": "Hi,\n\nStill seems odd that text buried in the definition of a property of \na baseline version is defining the behaviour of methods on the members of\na baseline collection.  But the \"MUST have\" change is certainly an \nimprovement.\n\nA better solution would be to add the definition of the Baseline Collection \nto section 10.2 (Advanced Versioning Terms, we currently define\n\"Configuration\", \n\"Baseline Resource\", \"Baseline-Controlled Collection\" etc, but it does not\ndefine \n\"Baseline Collection\".  I guess there is no room for this definition, I\nthink it \nwould solve all my issues with baseline collections:\n\n\n\"\nBaseline Collection\n\nA Baseline Collection captures the state of the baseline-controlled \ncollection at the time the baseline was created.  Particularly, for \neach version-controlled resource in the configuration rooted at the \nbaseline-controlled collection a new version-controlled resource will \nbe created in the baseline collection that MUST have the same \nDAV:checked-in version and relative name.  Any collections needed to\ncreate a consistent copy of the configuration namespace should also be \nincluded. \n\nThis collection cannot be modified except by checking-out and \nchecking-in a version-controlled configuration.  At most one member \nof this collection can have a DAV:checked-in version from a given \nversion history.\n\"\n\n\nI like the definition because it makes it clear that a Baseline Collection\ncaptures not only version-controlled resources (as the current specification\nincorrectly hints) but that it also captures any collections needed to get\nto \nthose VCRs (in the namespace).  It also makes it clear that the baseline\ncollection should not be modified in any way except when version-controlled\nconfigurations are checked-out and checked-in.\n\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: 27 September 2001 17:54\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Legal operations on members of a Baseline Collection...\n\n\nYes, we normally prefer to define constraints in the form of preconditions,\nbut in this case, the single statement \"must never change\" in the property\ndefinition was so much simpler that repeating it in each \"mutating\" method.\nBut I agree that this normative aspect of the property\ndefinition should be highlighted.  I suggest we change the \"has\" to a\n\"MUST have\" in the definition to make this point (a change that fits the\n\"no-repagination\" goal :-).\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Thursday, September 27, 2001 11:16 AM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: RE: Legal operations on members of a Baseline Collection...\n\n\nHi, \nOK...I guess that section does make it clear. \nBut, how much of the normative text should be captured in pre and post \nconditions? Without any pre or post condition to enforce the paragraph \nthat you quoted do vendors have to obey that paragraph? \nWould I am getting at is that other areas where we are enforcing something \nwe explicitly enforce it using pre or post conditions.  But not this one. \nRegards, \n\n\n\n", "id": "lists-006-13704002"}, {"subject": "RE: Legal operations on members of a Baseline Collection..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   Still seems odd that text buried in the definition of a property of\n   a baseline version is defining the behaviour of methods on the\n   members of a baseline collection.  But the \"MUST have\" change is\n   certainly an improvement.\n\nThe only way to get access to this collection is through the\nDAV:baseline-collection property of a baseline, so I'm not sure that\nthis is reasonably characterized as being \"buried\" (i.e. you'll have\nto read this property definition if you are ever going to access the\nbaseline collection).\n\n   A better solution would be to add the definition of the Baseline\n   Collection to section 10.2 (Advanced Versioning Terms, we currently\n   define \"Configuration\", \"Baseline Resource\", \"Baseline-Controlled\n   Collection\" etc, but it does not define \"Baseline Collection\".  I\n   guess there is no room for this definition, I think it would solve\n   all my issues with baseline collections.\n\nI'd prefer not to define the term \"baseline collection\" because it is\neasy to confuse it with \"baseline-controlled collection\".  This preference\nmay be colored by the re-pagination that would be required to add\nit now (:-), so it would be worth re-raising the issue when we go\nto \"draft standard\".\n\n   Baseline Collection \n   A Baseline Collection captures the state of the baseline-controlled\n   collection at the time the baseline was created.  Particularly, for\n   each version-controlled resource in the configuration rooted at the\n   baseline-controlled collection a new version-controlled resource\n   will be created in the baseline collection that MUST have the same\n   DAV:checked-in version and relative name.  Any collections needed\n   to create a consistent copy of the configuration namespace should\n   also be included.  This collection cannot be modified except by\n   checking-out and checking-in a version-controlled configuration.\n   At most one member of this collection can have a DAV:checked-in\n   version from a given version history.\n\nYou'd want to get rid of the sentence beginning \"This collection\ncannot be modified except by\".  A collection identified by a\nDAV:baseline-collection property cannot be modified.\n\n   I like the definition because it makes it clear that a Baseline\n   Collection captures not only version-controlled resources (as the\n   current specification incorrectly hints) but that it also captures\n   any collections needed to get to those VCRs (in the namespace).\n\nYes, I agree that the current definition of DAV:baseline-collection\ncould make this more explicit (although it does state that the relative\nnames of the members must be the same, which really does mandate the\nintroduction of those intermediate collections).\n\nHow about the following:\n\nThe last sentence of the DAV:baseline-collection is actually\nredundant, because it follows from the CHECKIN preconditions.  If\nI delete that sentence, I have room to emphasizes the creation of any\nneeded intermediate collections.  In particular, the revised\ndefinition of DAV:baseline-collection would be:\n\n\"This property contains a server-defined URL for a collection, where\neach member of this collection either is a version-controlled resource\nwith the same DAV:checked-in version and relative name as a\nversion-controlled member of the baseline-controlled collection at the\ntime the baseline was created, or is a collection needed to provide\nthe relative name for a version-controlled resource.\"\n\nWould anyone object to this change?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13717013"}, {"subject": "Why does MERGE automatically checkin resources related to activit ies", "content": "Hi,\n\nI was reading section 13 with a group of other staff in MERANT and we came \nacross section 13.12 which talks about automatically checking-in any \nchecked-out resources referenced by an activity which is specified as part \nof the DAV:source set for the MERGE.\n\nWhy does MERGE behave like this for activities and not for other resources \n(see the precondition DAV:cannot-merge-checked-out-resource in section 11.2.\n\nThis auto-checkin behaviour seems to add more complexity to the\nimplementation \nof MERGE and seems to be inconsistent.  What was the use case for including\nthis \nauto-checkin behaviour only for activities?\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-13728146"}, {"subject": "RE: Why does MERGE automatically checkin resources related to act ivities", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   I was reading section 13 with a group of other staff in MERANT and\n   we came across section 13.12 which talks about automatically\n   checking-in any checked-out resources referenced by an activity\n   which is specified as part of the DAV:source set for the MERGE.\n\n   Why does MERGE behave like this for activities and not for other\n   resources (see the precondition\n   DAV:cannot-merge-checked-out-resource in section 11.2.\n\n   This auto-checkin behaviour seems to add more complexity to the\n   implementation of MERGE and seems to be inconsistent.  What was the\n   use case for including this auto-checkin behaviour only for\n   activities?\n\nThis was added to allow for an \"atomic\" activity checkin/merge request\n(something needed by the Subversion system), which only supports\nDAV:no-checkout merge requests.  With the new DAV:auto-update\nfunctionality, an alternative way of supporting this functionality\nwould be to allow CHECKIN to be applied to an activity (and having it\nmean \"checkin everything in that activity\").  The DAV:auto-update\nfunctionality would do the MERGE.\n\nGreg: This just means you would replace your activity MERGE request\nwith an activity CHECKIN request.  This would also significantly improve\ninteroperability, since more systems are likely to support\nactivity CHECKIN than are likely to support the MERGE feature.\n\nI believe this would be a significant improvement in consistency, and\nonly requires moving a postcondition from the MERGE method to the\nCHECKIN method.  In addition, these two methods happen to be on the\nsame page of the text draft, so I could make this change without the\ndreaded repagination.\n\nIf there are no objections, I can make this change.  If there\nare *any* objections, I will not make the change, since we are\nso late in the draft process.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13736388"}, {"subject": "Clarification on subbaselines..", "content": "Hi,\n\nI was looking at the subbaseline facility and a few questions came up:\n\n1)  Are the hrefs captured in the DAV:subbaseline-set the URLs of\nbaseline versions? or BCCs or VCCs?\n     I think they are baseline versions, but the specification does not\nspell this out.\n\n2)  To make one baseline a subbaseline of another baseline do you have\nto CHECKOUT\n     the version-controlled configuration, PROPPATCH the subbaseline-set\nand CHECKIN the VCC?\n     It would have been really nice if you could set the subbaseline-set\nas part of the BASELINE-CONTROL\n     method request body.  Because checking in and out causes new\nresources to be created and the state of the\n     baseline-controlled collection to be captured again....this seems\nlike a lot of overhead just to\n     set a property.\n\nAgain I have \"powerpointed\" the concept and attached to this mail and\nwould welcome any comments etc.\nIt looks like I'll have a whole series of \"advanced versioning\" slides.\n\n\nRegards,\nPeter Raymond - MERANT\n\n\n\n\n\napplication/ppt attachment: Subbaselines.ppt\n\n\n\n\n", "id": "lists-006-13746199"}, {"subject": "RE: Clarification on subbaselines..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   1) Are the hrefs captured in the DAV:subbaseline-set the URLs of\n   baseline versions? or BCCs or VCCs? I think they are baseline\n   versions, but the specification does not spell this out.\n\nSection 12.3.2 states that the DAV:subbaseline-set identifies a set\nof baselines.  A BCC is not a baseline, nor is a VCC a baseline ...\nonly a baseline is a baseline (:-).\n\nAs a minor terminology point, a baseline resource is defined to be a\nversion resource, so you usually would not use the term \"baseline\nversion\" since every baseline is a version, i.e. just \"baseline\" suffices.\n\n   2) To make one baseline a subbaseline of another baseline do you\n   have to CHECKOUT the version-controlled configuration, PROPPATCH\n   the subbaseline-set and CHECKIN the VCC?\n\nYes.\n\n   It would have been really\n   nice if you could set the subbaseline-set as part of the\n   BASELINE-CONTROL method request body.  Because checking in and out\n   causes new resources to be created and the state of the\n   baseline-controlled collection to be captured again....this seems\n   like a lot of overhead just to set a property.\n\nWell, this only has to be done once when the collection is first \nput under baseline control.  But I agree that it would be a reasonable\nextension to the BASELINE-CONTROL method to allow for the initial\nsubbaselines to be specified.  I'd rather leave off this optimization\nfor now though, since it really is a useful extension, rather than\nan error or inconsistency.  \n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13754178"}, {"subject": "RE: Why does MERGE automatically checkin resources related to act ivities", "content": "I'm in favor of the change.\n\n\n\n\n\n\"Clemm, Geoff\" <gclemm@rational.com>\nSent by: ietf-dav-versioning-request@w3.org\n09/28/2001 02:10 PM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        RE: Why does MERGE automatically checkin resources related to act ivities?\n\n \n\n   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   I was reading section 13 with a group of other staff in MERANT and\n   we came across section 13.12 which talks about automatically\n   checking-in any checked-out resources referenced by an activity\n   which is specified as part of the DAV:source set for the MERGE.\n\n   Why does MERGE behave like this for activities and not for other\n   resources (see the precondition\n   DAV:cannot-merge-checked-out-resource in section 11.2.\n\n   This auto-checkin behaviour seems to add more complexity to the\n   implementation of MERGE and seems to be inconsistent.  What was the\n   use case for including this auto-checkin behaviour only for\n   activities?\n\nThis was added to allow for an \"atomic\" activity checkin/merge request\n(something needed by the Subversion system), which only supports\nDAV:no-checkout merge requests.  With the new DAV:auto-update\nfunctionality, an alternative way of supporting this functionality\nwould be to allow CHECKIN to be applied to an activity (and having it\nmean \"checkin everything in that activity\").  The DAV:auto-update\nfunctionality would do the MERGE.\n\nGreg: This just means you would replace your activity MERGE request\nwith an activity CHECKIN request.  This would also significantly improve\ninteroperability, since more systems are likely to support\nactivity CHECKIN than are likely to support the MERGE feature.\n\nI believe this would be a significant improvement in consistency, and\nonly requires moving a postcondition from the MERGE method to the\nCHECKIN method.  In addition, these two methods happen to be on the\nsame page of the text draft, so I could make this change without the\ndreaded repagination.\n\nIf there are no objections, I can make this change.  If there\nare *any* objections, I will not make the change, since we are\nso late in the draft process.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-13762759"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "   From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n\n   I see two ways to resolve this issue in the Spec:\n\n   1) Top-Down: the spec defines types of resources and for each\n      type then defines what live properties it holds and what state\n      it can have.\n\n   2) Bottum-Up: The current spec is enhanced by a chapter which\n      algorithmically defines how to detect the resource type from\n      the supported-xxx-set. Ideally this would also describe how\n      future extensions should add to this algorithm for their new\n      types. \n\n   Could the creators of deltaV agree on a way to go forward? Please?\n\nMinimally, I will do #2, by including an enhanced version of Tim's\n\"property-o-rama\" posting (thanks again, Tim!).  The discussion\nof whether or not to extend DAV:resourcetype as well can go on\nin parallel.\n\nNote: one issue with some of the suggested new values for\nDAV:resourcetype is that they would breaks the current protocol\nsemantics that the value of DAV:resourcetype is copied from a\nchecked-out resource to a version by CHECKIN, and from a version to a\nversion-controlled resource by UPDATE.  Clearly we could fix this up\nby talking about what values got added to and deleted from\nDAV:resourcetype by these operations, but it is kind of nice and\nsimple the way it is now.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1377569"}, {"subject": "RE: Property-o-ram", "content": "> Well, I have one small comment. I found the *any* DeltaV resource\n> to be a little confusing below, since it's really \"any resource\n> that supports the option listed next to the property\", not\n> \"any resource at all\".\n\nIndeed, and that goes for all the resources -- each property only appears\n*if* the server supports the listed option.\n\nTim\n\n\n\n", "id": "lists-006-1387042"}, {"subject": "RE: Property-o-ram", "content": "Yes, I thought that was pretty clear from Tim's preliminary statement\nfor the lists, i.e.:\n\n  The defining feature is noted in square brackets (so if your server\n  \"doesn't do activities\" then you don't get to play with any [activity] \n  properties).\n\nJim: If you have an idea on how to reword this to make it clearer, please\nlet me know (but I don't think it best to repeat this in the title of\neach section).\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Tim Ellison [mailto:tim@peir.com]\nSent: Friday, June 08, 2001 3:30 PM\nTo: DeltaV\nSubject: RE: Property-o-rama\n\n\n> Well, I have one small comment. I found the *any* DeltaV resource\n> to be a little confusing below, since it's really \"any resource\n> that supports the option listed next to the property\", not\n> \"any resource at all\".\n\nIndeed, and that goes for all the resources -- each property only appears\n*if* the server supports the listed option.\n\nTim\n\n\n\n", "id": "lists-006-1394200"}, {"subject": "FW: Simple editorial change needed to section 13.", "content": "Hi,\n\nFor some reason this message failed to get through to the group...\n\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n>  -----Original Message-----\n> From: Peter Raymond  \n> Sent:28 September 2001 18:32\n> To:'ietf-dav-versioning@w3.org'\n> Subject:Simple editorial change needed to section 13.9\n> \n> Hi,\n> \n> Spotted a typo in section 13.9, the DAV:update-checked-out-reference\n> postcondition mentions\n> a property called DAV:activity-checkout.  I think it should be\n> DAV:checkout-activity-set.\n> The -set is missing.\n> \n> Regards,\n> --\n> Peter Raymond - MERANT\n> Principal Architect (PVCS)\n> Tel: +44 (0)1727 813362\n> Fax: +44 (0)1727 869804\n> mailto:Peter.Raymond@merant.com\n> WWW: http://www.merant.com\n> \n> \n\n\n\n", "id": "lists-006-14009489"}, {"subject": "Where is the &quot;working baseline&quot; concept defined", "content": "Hi,\n\nWhere is the term \"working baseline\" defined in the specification?\nI cannot see a description of what a \"working baseline\" is, but it is \nreferred to in section 13.12.\n\nI presume you get a working baseline if you checkout a baseline (rather \nthan a Version-Controlled Configuration), or if you checkout the \nVersion-Controlled Configuration and specify DAV:apply-to-version. \n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-14017949"}, {"subject": "Type appendi", "content": "Here's a proposed appendix to the spec to clarify the type discussion we\nhave been having recently.\n\nI suggest we call it \"How to tell the difference between a Duck and an\nAlligator\".\n\nTim\n=========================\nVERSIONING RESOURCE TYPE\n\nA versioning resource's type can be determined by examining the set of live\nproperties it supports.\n\nFor example, the supported live properties for the version history resource\n/foo are retrieved by\n\n>>REQUEST\n\nPROPFIND /foo HTTP/1.1\nHost: bar.com\nContent-Type: text/xml; charset=\"utf-8\"\nContent-Length: xxx\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n    <D:prop>\n<D:supported-live-property-set/>\n    </D:prop>\n</D:propfind>\n\n>> RESPONSE\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml; charset=\"utf-8\"\nContent-Length: xxxx\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n   <D:response>\n      <D:href>http://www.bar.com/foo</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:supported-live-property-set>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"creationdate\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"displayname\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"getcontentlanguage\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"getcontentlength\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"getcontenttype\"/>\n               <D:supported-live-property namespace=\"DAV:\" name=\"getetag\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"getlastmodified\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"lockdiscovery\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"resourcetype\"/>\n               <D:supported-live-property namespace=\"DAV:\" name=\"source\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"supportedlock\"/>\n               <D:supported-live-property namespace=\"DAV:\" name=\"comment\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"creator-displayname\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"supported-method-set\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"supported-live-property-set\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"supported-report-set\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"workspace\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"version-controlled-configuration\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"version-set\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"root-version\"/>\n            </D:supported-live-property-set>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:responsedescription>OK</D:responsedescription>\n</D:multistatus>\n\n\nThe following types are described in the DeltaV specification.  The\nresources type is uniquely determined by the presence or absence of key\nsupported live properties (inclusion in or omission from the reported\nproperty set) as follows:\n\n   Version-controlled resource (+*)\n<DAV:supported-live-property-set> includes <DAV:auto-checkout/>.\n\n   Version (*)\n<DAV:supported-live-property-set> includes <DAV:version-name/>.\n\n   Version history\n<DAV:supported-live-property-set> includes <DAV:root-version/>.\n\n   Workspace\n<DAV:supported-live-property-set> includes <DAV:workspace-checkout-set/>.\n\n   Working resource (*)\n<DAV:supported-live-property-set> includes <DAV:checked-out/>.\nand\n<DAV:supported-live-property-set> does *not* include <DAV:auto-checkout/>.\n\n   Version-controlled configuration (+)\n<DAV:supported-live-property-set> includes\n<DAV:baseline-controlled-collection/>.\n\n   Baseline\n<DAV:supported-live-property-set> includes <DAV:baseline-collection/>.\n\n   Activity\n<DAV:supported-live-property-set> includes <DAV:subactivity-set/>.\n\nEach resource type above marked with a plus-sign(+) can exist in a\nchecked-in or checked-out state.  The checked in state can be determined as\nfollows:\n   <DAV:supported-live-properties> includes <DAV:checked-in>\n      means the resource is checked-in.\n   <DAV:supported-live-properties> includes <DAV:checked-out>\n      means the resource is checked-out.\n\nEach resource type above marked with an asterix(*) can exist as a collection\nresource or a non-collection resource.  Determining whether a resource is a\ncollection is described in RFC2518.\n   <DAV:resourcetype> does not include <DAV:collection/>\nmeans the resource is not a collection.\n   <DAV:resourcetype> includes <DAV:collection/>\nmeans the resource is a collection.\n\n\n\n", "id": "lists-006-1401864"}, {"subject": "Re: Why does MERGE automatically checkin resources related to act ivities", "content": "On Fri, Sep 28, 2001 at 02:10:07PM -0400, Clemm, Geoff wrote:\n>...\n> This was added to allow for an \"atomic\" activity checkin/merge request\n> (something needed by the Subversion system), which only supports\n> DAV:no-checkout merge requests.  With the new DAV:auto-update\n> functionality, an alternative way of supporting this functionality\n> would be to allow CHECKIN to be applied to an activity (and having it\n> mean \"checkin everything in that activity\").  The DAV:auto-update\n> functionality would do the MERGE.\n> \n> Greg: This just means you would replace your activity MERGE request\n> with an activity CHECKIN request.  This would also significantly improve\n> interoperability, since more systems are likely to support\n> activity CHECKIN than are likely to support the MERGE feature.\n\nI presume this would mean that I could check out a Baseline into the\nactivity, and that baseline would be checked back in with the activity? And\nthat the VCC would be updated?\n\n\nBut all that probably isn't going to help anyways. We check out version\nresources. The DAV:auto-update mechanism does not work when dealing with\nversion resources.\n\n>...\n> If there are no objections, I can make this change.  If there\n> are *any* objections, I will not make the change, since we are\n> so late in the draft process.\n\nI object. :-)\n\nThe existing specification provides for an atomic check/merge of a set of\nresources. Dropping the activities from the MERGE would eliminate that.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-14026383"}, {"subject": "Re: Clarification on definition of a configuration...", "content": "On Thu, Sep 27, 2001 at 08:59:48AM -0400, Clemm, Geoff wrote:\n> \n>    From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n> \n>    The statement in section 12 says: \n> \n>       \"A configuration is a set of resources that consists of a root\n>       collection and all members of that root collection that are not\n>       members of another configuration.\"\n>...\n> What in the definition led you to this conclusion?  (This is a real\n> question, not a rhetorical question, because if something in the text\n> led you to this conclusion, it should be fixed).\n\nMaybe change to:\n\n       \"A configuration is a set of resources that consists of a root\n       collection and all members of that root collection except those\n       resources which are members of another configuration.\"\n\nIMO, that is a bit clearer that the resources *can* be in another\nconfiguration, and that they are excluded from the parent collection.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-14035074"}, {"subject": "Re: Where is the &quot;working baseline&quot; concept defined", "content": "On Mon, Oct 01, 2001 at 09:59:54AM +0100, Peter Raymond wrote:\n> Hi,\n> \n> Where is the term \"working baseline\" defined in the specification?\n> I cannot see a description of what a \"working baseline\" is, but it is \n> referred to in section 13.12.\n\nDunno.\n\n> I presume you get a working baseline if you checkout a baseline (rather \n> than a Version-Controlled Configuration), or if you checkout the \n> Version-Controlled Configuration and specify DAV:apply-to-version. \n\nThat is my presumption, too. Especially given that Subversion *uses* working\nbaselines :-)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-14043257"}, {"subject": "Re: Clarification on what exactly is captured in the Baseline Col lection..", "content": "On Thu, Sep 27, 2001 at 01:06:10PM -0400, Clemm, Geoff wrote:\n> Looks good to me.  It would be great if you could put this slide set (and\n> the others you have created) up on a web site that we could link to from the\n> deltav site.  If you don't have access to a public web site you can author,\n> we could also just post the .ppt files directly on the deltav site (I try to\n> minimize the number of fat files we put up on the deltav site itself, to not\n> use up an excessive amount of Greg's disk space, and .ppt files are known to\n> be not skinny:-).\n\nThe webdav.org machine has 15 gigabytes of free disk space. And that disk\nspace is dedicated exclusively for use of webdav.org. Heck, the whole\nmachine is dedicated :-)\n\n[ Thanks go to N-Space for the hardware, and CollabNet for the bandwidth. ]\n\n\nIn other words, please feel free to put the big files up there. I've already\nhad inquiries for mirroring the web site in Australia and Japan. It's a\nmatter of getting a Round Tuit, but having the \"fat files\" up there means\nthey will be mirrored, and those are *exactly* what you want to mirror :-)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-14051266"}, {"subject": "RE: Clarification on definition of a configuration...", "content": "Hi,\n\nGreg's description seems to be clearer, I like it.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Greg Stein [mailto:gstein@lyra.org]\nSent: 01 October 2001 12:28\nTo: Clemm, Geoff\nCc: ietf-dav-versioning@w3.org\nSubject: Re: Clarification on definition of a configuration....\n\n\nOn Thu, Sep 27, 2001 at 08:59:48AM -0400, Clemm, Geoff wrote:\n> \n>    From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n> \n>    The statement in section 12 says: \n> \n>       \"A configuration is a set of resources that consists of a root\n>       collection and all members of that root collection that are not\n>       members of another configuration.\"\n>...\n> What in the definition led you to this conclusion?  (This is a real\n> question, not a rhetorical question, because if something in the text\n> led you to this conclusion, it should be fixed).\n\nMaybe change to:\n\n       \"A configuration is a set of resources that consists of a root\n       collection and all members of that root collection except those\n       resources which are members of another configuration.\"\n\nIMO, that is a bit clearer that the resources *can* be in another\nconfiguration, and that they are excluded from the parent collection.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-14059590"}, {"subject": "Protocol Action: Versioning Extensions to WebDAV to Proposed Standar", "content": "Hurray!\n\nCongratulations to the entire DeltaV working group for reaching this\nmilestone!  This is a significant event as it reflects confidence in the\nwork of the group over a number of years, the first step along the Internet\nStandards track, and protocol stability for client and server developers.\n\nSpecial thanks and credit is deserved, of course, for Geoff Clemm,\nDeltaV-er extraordinaire for his tireless progression of the work.\n\nI'm sure we'll see DeltaV implementations being written to the new Proposed\nStandard imminently.  In the meantime the entire working group should take\na moment to reach over and pat ourselves on the back!\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n----- Forwarded by Tim Ellison/UK/IBM on 2001-10-01 01:13 PM -----\n                                                                                                                  \n                    The IESG                                                                                      \n                    <iesg-secretary       To:     IETF-Announce: ;                                                \n                    @ietf.org>            cc:     RFC Editor <rfc-editor@isi.edu>, Internet Architecture Board    \n                    Sent by:               <iab@isi.edu>, ietf-dav-versioning@w3.org                              \n                    scoya@cnri.rest       Subject:     Protocol Action: Versioning Extensions to WebDAV to        \n                    on.va.us               Proposed     Standard                                                  \n                                                                                                                  \n                                                                                                                  \n                    2001-10-01                                                                                    \n                    11:59 AM                                                                                      \n                    Please respond                                                                                \n                    to The IESG                                                                                   \n                                                                                                                  \n                                                                                                                  \n\n\n\n\n\n\nThe IESG has approved the Internet-Draft 'Versioning Extensions to\nWebDAV' <draft-ietf-deltav-versioning-18.txt> as a Proposed Standard.\nThis document is the product of the Web Versioning and Configuration\nManagement Working Group.  The IESG contact persons are Ned Freed and\nPatrik Faltstrom\n\n\nTechnical Summary\n\n  This specification defines a set of methods, headers, and resource types\n  that define the WebDAV Versioning extensions to the HTTP/1.1 protocol.\n  WebDAV Versioning includes:\n\n       - Automatic versioning for versioning-unaware clients,\n       - Version history management,\n       - Workspace management,\n       - Baseline management,\n       - Activity management, and\n       - URL namespace versioning.\n\nWorking Group Summary\n\n  This document is the product of the Web Versioning and Configuration\n  Management Working Group.\n\nProtocol Quality\n\n  Ned Freed reviewed this document for the IESG.\n\n\n\n", "id": "lists-006-14070487"}, {"subject": "Protocol Action: Versioning Extensions to WebDAV to Proposed    Standar", "content": "[freed from spam filter -rrs]\n\nDate: Mon, 1 Oct 2001 07:00:00 -0400 (EDT)\nMessage-Id: <200110011059.GAA10691@ietf.org>\nTo: IETF-Announce: ;\nCc: RFC Editor <rfc-editor@isi.edu>\nCc: Internet Architecture Board <iab@isi.edu>\nCc: ietf-dav-versioning@w3.org\nFrom: The IESG <iesg-secretary@ietf.org>\n\nThe IESG has approved the Internet-Draft 'Versioning Extensions to\nWebDAV' <draft-ietf-deltav-versioning-18.txt> as a Proposed Standard.\nThis document is the product of the Web Versioning and Configuration\nManagement Working Group.  The IESG contact persons are Ned Freed and\nPatrik Faltstrom\n\n \nTechnical Summary\n \n  This specification defines a set of methods, headers, and resource types\n  that define the WebDAV Versioning extensions to the HTTP/1.1 protocol.\n  WebDAV Versioning includes:\n\n       - Automatic versioning for versioning-unaware clients,\n       - Version history management,\n       - Workspace management,\n       - Baseline management,\n       - Activity management, and\n       - URL namespace versioning.\n\nWorking Group Summary\n\n  This document is the product of the Web Versioning and Configuration\n  Management Working Group.\n\nProtocol Quality\n\n  Ned Freed reviewed this document for the IESG.\n\n\n\n", "id": "lists-006-14081979"}, {"subject": "RE: Protocol Action: Versioning Extensions to WebDAV to Proposed Standar", "content": "Yes!!! What excellent news.\n\nFive and a half years ago we began working on the vision of the Web as a\nwriteable medium, one that could be used for remote collaborative\ndevelopment of software projects, large documentation efforts, and other\nlarge clusters of inter-related documents.  With the approval of the DeltaV\nprotocol as a Proposed Standard, we have taken a large step forward towards\nmaking this vision a tangible reality.\n\nGeoff Clemm receives my thanks and respect for the key role he played in the\ndesign of the DeltaV protocol, and in pushing it forward for so long.\nHowever, it was clearly a collaborative effort, involving the Chair, Jim\nAmsden, the document authors, the DeltaV design team, and the DeltaV working\ngroup. All of your tireless work, sending posts, making reviews, clarifying\npoints, led to a high quality technical standard.\n\nSpecification in hand, we are now well along the rough road to the common\nbyte. I look forward to working with you all in the months and years ahead\nto ensure this specification leads to broad interoperability.\n\n- Jim\n\n> The IESG has approved the Internet-Draft 'Versioning Extensions to\n> WebDAV' <draft-ietf-deltav-versioning-18.txt> as a Proposed Standard.\n> This document is the product of the Web Versioning and Configuration\n> Management Working Group.  The IESG contact persons are Ned Freed and\n> Patrik Faltstrom\n\n\n\n", "id": "lists-006-14091976"}, {"subject": "Re: Why does MERGE automatically checkin resources related to act ivities", "content": "On Mon, Oct 01, 2001 at 09:50:50AM -0400, Clemm, Geoff wrote:\n> Greg: If you split your \"commit\" into an activity \"CHECKIN\"\n> followed by a baseline \"MERGE\", I believe you would have the\n> right framework for doing branching (in particular,\n\nWe use cheap copies, not branching.\n\n> a branch is just a CHECKIN that is not followed by a MERGE).\n> This would have CHECKIN of an activity create a new\n> subversion revision (aka a DeltaV baseline), but this revision\n> wouldn't become the \"current\" one until you did the MERGE.\n\nNot supported.\n\n> If so, I believe this would then remove your need for\n> having CHECKIN be a side effect of MERGE.  But this of course\n> works only if subversion allows a new revision to be created that \n> does not immediately become the current revision.  But don't\n> you have to do that to support branching?\n\nEffectively, we do:\n\n$ svn cp /trunk /branches/gstein-work\n\n\nHmm. I just realized that the original question made it seem like some weird\nside effect. But in the case under discussion, you're doing a MERGE on an\n*activity*. Thus, it makes perfect sense to take all resources contained in\nthat activity as the merge source.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-14100955"}, {"subject": "Re: Why does MERGE automatically checkin resources related to act   ivities", "content": "My implementation has two use cases where we need to MERGE from an activity\nsource without checking in that activity's DAV:activity-checkout-set. I\nstrongly favor Geoff's proposal (activity checkin). If that's not feasible\nbecause there is a requirement for atomic activity checkin/merge, I'd like\nto make the activity checkin an optional part of the activity merge. In\nfact, I was writing a proposal to extend the protocol with such an option\nbefore Peter raised this question. Here's my proposal below.\n\n--\n\nMy implementation has a requirement that the changes in\nmultiple activities be logically merged into a shared\nline of descent upon completion. I would like to model\nthe shared line of descent as an activity.\n\nHere's a summary of my overall use case:\n\n  1. Each user's client initializes a separate\n     workspace so its version-controlled members'\n     DAV:activity-set values include the shared\n     activity. I'll call this the \"integration\n     activity\" for the rest of this discussion.\n\n  2. Each user's client issues MKACTIVITY to create a\n     non-shared activity for making changes on a\n     separate line of descent from the integration\n     activity. I'll call this the \"isolation activity\"\n     for the rest of this discussion. The client then\n     PROPPATCHES the DAV:current-activity-set of its\n     workspace to the isolation activity and issues a\n     number of CHECKOUT, GET, PUT, and CHECKIN requests\n     whose request-URLs are members of the workspace.\n\n  3. At certain times while working on their isolation\n     activities, users would like to logically merge\n     the latest versions in the integration activity's\n     DAV:activity-version-set to their\n     workspaces. (This is the step at which I'd like\n     the option to make checkins of an activity's\n     DAV:activity-checkout-set optional when that\n     activity resource is the DAV:source of a MERGE\n     request. I also have a secondary use case for this\n     extension.)\n\n  4. When users complete work on their isolation\n     activities, their clients issue a series of\n     requests so that the changes in the isolation\n     activities are logically merged to the integration\n     activity. To support this, I will propose (in a\n     separate note) to define the semantics of UPDATE\n     where the source is an activity resource.\n\nExtension proposal: Make checkins of an activity's\nDAV:activity-checkout-set optional when that activity\nresource is the DAV:source of a MERGE request.\n\nPrimary use case: One way to implement step 3 in my\noverall use case above would be to do something like\n\n  MERGE /ws/user_x_work HTTP/1.1\n  Host: www.webdav.org\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n  <D:merge xmlns:D=\"DAV:\">\n    <D:source>\n    <D:href>http://www.webdav.org/act/integ_act</D:href>\n    </D:source>\n    <D:no-activity-checkin-on-merge/>\n  </D:merge>\n\nIn this step of my use case, it would be undesirable to\ncheckin all the VCR's in /act/integ_act's\nDAV:activity-checkout-set. Those checked-out resources\ncould be members of other workspaces whose owners were\nin the middle of logically merging their own isolation\nactivities to /act/integ_act. The\n<D:no-activity-checkin-on-merge/> option in the request\nbody would suppress the DAV:atomic-activity-checkin\nprecondition and DAV:checkin-activity postcondition in\nSection 13.12.\n\nI understand that similar results can be achieved by\nmerging from a baseline (where the members of the\nbaseline's DAV:baseline-collection's DAV:checked-in\nversions include the integration activity in their\nDAV:activity-set). However, merging from the\nintegration activity gives users another option when\nthey wish to incorporate changes newer than the latest\nbaseline into their workspace.\n\nSecondary use case: Support a process in which multiple\nworkspaces perform their checkouts directly in a shared\nactivity (because the workspaces share the same\nDAV:current-activity-set). Each workspace can pick up\nthe latest versions created in the shared activity by\nthe other workspaces by doing a MERGE similar to the\none above.\n\nInformal proposed marshalling: Add an optional element\n(like \"DAV:no-activity-checkin-on-merge\") to the\nrequest body of MERGE. This would change the semantics\nof Section 13.12 in draft-18. If this optional element\nwas present in the request body, the server SHOULD NOT\n(MUST NOT?) checkin the activity's\nDAV:activity-checkout-set before determining the merge\nsources.  Also, add a property (something like\n\"DAV:no-activity-checkin-on-merge\" ?) to activity\nresources that did the same thing, to enable clients\nwhich did not know about this option to support my use\ncase.\n\nCompatibility considerations: Existing clients would be\ncompatible with this change since they would not have\nto use the new optional request-body element, there are\nno additional response-body elements, and optionally\nthe new activity property could be PROPPATCHED to allow\nexisting clients to get the new behavior without\nunderstanding the additional marshalling. Existing\nservers would be compatible with the change if it were\nspecified as a SHOULD NOT, since RFC 2518 Section 14\nrequires that servers ignore XML elements they don't\nunderstand in request bodies. Existing servers would\nneed changes to support the change if it were specified\nas a MUST NOT. (SHOULD NOT/MUST NOT is a tradeoff\nbetween simplicity and compatibility in this case,\nsince MUST NOT would simplify clients which used the\noption.)\n\n\n\"Clemm, Geoff\" wrote:\n\n>    From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n>\n>    I was reading section 13 with a group of other staff in MERANT and\n>    we came across section 13.12 which talks about automatically\n>    checking-in any checked-out resources referenced by an activity\n>    which is specified as part of the DAV:source set for the MERGE.\n>\n>    Why does MERGE behave like this for activities and not for other\n>    resources (see the precondition\n>    DAV:cannot-merge-checked-out-resource in section 11.2.\n>\n>    This auto-checkin behaviour seems to add more complexity to the\n>    implementation of MERGE and seems to be inconsistent.  What was the\n>    use case for including this auto-checkin behaviour only for\n>    activities?\n>\n> This was added to allow for an \"atomic\" activity checkin/merge request\n> (something needed by the Subversion system), which only supports\n> DAV:no-checkout merge requests.  With the new DAV:auto-update\n> functionality, an alternative way of supporting this functionality\n> would be to allow CHECKIN to be applied to an activity (and having it\n> mean \"checkin everything in that activity\").  The DAV:auto-update\n> functionality would do the MERGE.\n>\n> Greg: This just means you would replace your activity MERGE request\n> with an activity CHECKIN request.  This would also significantly improve\n> interoperability, since more systems are likely to support\n> activity CHECKIN than are likely to support the MERGE feature.\n>\n> I believe this would be a significant improvement in consistency, and\n> only requires moving a postcondition from the MERGE method to the\n> CHECKIN method.  In addition, these two methods happen to be on the\n> same page of the text draft, so I could make this change without the\n> dreaded repagination.\n>\n> If there are no objections, I can make this change.  If there\n> are *any* objections, I will not make the change, since we are\n> so late in the draft process.\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-14109415"}, {"subject": "RE: Clarification on definition of a configuration...", "content": "That rewording is fine with me.  I'll make the swap.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\n \nGreg's description seems to be clearer, I like it. \n\n-----Original Message----- \nFrom: Greg Stein [mailto:gstein@lyra.org] \n\nOn Thu, Sep 27, 2001 at 08:59:48AM -0400, Clemm, Geoff wrote: \n> \n>    From: Peter Raymond [mailto:Peter.Raymond@merant.com] \n> \n>    The statement in section 12 says: \n> \n>       \"A configuration is a set of resources that consists of a root \n>       collection and all members of that root collection that are not \n>       members of another configuration.\" \n>... \n> What in the definition led you to this conclusion?  (This is a real \n> question, not a rhetorical question, because if something in the text \n> led you to this conclusion, it should be fixed). \nMaybe change to: \n       \"A configuration is a set of resources that consists of a root \n       collection and all members of that root collection except those \n       resources which are members of another configuration.\" \nIMO, that is a bit clearer that the resources *can* be in another \nconfiguration, and that they are excluded from the parent collection. \nCheers, \n-g \n-- \nGreg Stein, http://www.lyra.org/ \n\n\n\n", "id": "lists-006-14124259"}, {"subject": "RE: Simple editorial change needed to section 13.", "content": "Fixed.  Thanks!  (Actually, it should be DAV:activity-checkout-set, but that\nwas clearly what you meant).\n\nCheers,\nGeoff\n\n-----Original Message----- \nFrom:   Peter Raymond  \n\nSpotted a typo in section 13.9, the DAV:update-checked-out-reference\npostcondition mentions \na property called DAV:activity-checkout.  I think it should be\nDAV:checkout-activity-set. \nThe -set is missing. \n\n\n\n", "id": "lists-006-14133449"}, {"subject": "RE: Type appendi", "content": "Another approach would be to extend the type-o-rama\nappendix to say something like the following:\n\n------------------------------------------------\n\nA client should use the DAV:supported-live-property-set\nand DAV:supported-method-set to classify a resource in\nits GUI (e.g. to determine what icon to display).\n\nSome common combinations of supported live properties\nand methods that can be used to classify a resource include:\n\n... (all the DAV:property-o-rama stuff).\n\n------------------------------------------------\n\nThis will provide the information needed for different\nclients to iconify resources in a consistent way.\nI'm not sure the PROPPATCH example is really needed here\nthough ...\n\nI believe this is better than just looking for a\n\"key\" property, because as folks have pointed out in\nthis thread, it might be reasonable for some later defined\nresource to support a subset of the properties (e.g. just\nDAV:version-name).  Of course, if a client only uses\nthe semantics of DAV:version-name, it should just look\nfor that property, and not check for the full list of\nproperties that a \"version\" must support.\n\nCheers,\nGeoff\n\n\n\n-----Original Message-----\nFrom: Tim Ellison [mailto:tim@peir.com]\nSent: Friday, June 08, 2001 5:07 PM\nTo: DeltaV\nSubject: Type appendix\n\n\nHere's a proposed appendix to the spec to clarify the type discussion we\nhave been having recently.\n\nI suggest we call it \"How to tell the difference between a Duck and an\nAlligator\".\n\nTim\n=========================\nVERSIONING RESOURCE TYPE\n\nA versioning resource's type can be determined by examining the set of live\nproperties it supports.\n\nFor example, the supported live properties for the version history resource\n/foo are retrieved by\n\n>>REQUEST\n\nPROPFIND /foo HTTP/1.1\nHost: bar.com\nContent-Type: text/xml; charset=\"utf-8\"\nContent-Length: xxx\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n    <D:prop>\n<D:supported-live-property-set/>\n    </D:prop>\n</D:propfind>\n\n>> RESPONSE\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml; charset=\"utf-8\"\nContent-Length: xxxx\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n   <D:response>\n      <D:href>http://www.bar.com/foo</D:href>\n      <D:propstat>\n         <D:prop>\n            <D:supported-live-property-set>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"creationdate\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"displayname\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"getcontentlanguage\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"getcontentlength\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"getcontenttype\"/>\n               <D:supported-live-property namespace=\"DAV:\" name=\"getetag\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"getlastmodified\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"lockdiscovery\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"resourcetype\"/>\n               <D:supported-live-property namespace=\"DAV:\" name=\"source\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"supportedlock\"/>\n               <D:supported-live-property namespace=\"DAV:\" name=\"comment\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"creator-displayname\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"supported-method-set\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"supported-live-property-set\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"supported-report-set\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"workspace\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"version-controlled-configuration\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"version-set\"/>\n               <D:supported-live-property namespace=\"DAV:\"\nname=\"root-version\"/>\n            </D:supported-live-property-set>\n         </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n      </D:propstat>\n   </D:response>\n   <D:responsedescription>OK</D:responsedescription>\n</D:multistatus>\n\n\nThe following types are described in the DeltaV specification.  The\nresources type is uniquely determined by the presence or absence of key\nsupported live properties (inclusion in or omission from the reported\nproperty set) as follows:\n\n   Version-controlled resource (+*)\n<DAV:supported-live-property-set> includes <DAV:auto-checkout/>.\n\n   Version (*)\n<DAV:supported-live-property-set> includes <DAV:version-name/>.\n\n   Version history\n<DAV:supported-live-property-set> includes <DAV:root-version/>.\n\n   Workspace\n<DAV:supported-live-property-set> includes\n<DAV:workspace-checkout-set/>.\n\n   Working resource (*)\n<DAV:supported-live-property-set> includes <DAV:checked-out/>.\nand\n<DAV:supported-live-property-set> does *not* include\n<DAV:auto-checkout/>.\n\n   Version-controlled configuration (+)\n<DAV:supported-live-property-set> includes\n<DAV:baseline-controlled-collection/>.\n\n   Baseline\n<DAV:supported-live-property-set> includes\n<DAV:baseline-collection/>.\n\n   Activity\n<DAV:supported-live-property-set> includes <DAV:subactivity-set/>.\n\nEach resource type above marked with a plus-sign(+) can exist in a\nchecked-in or checked-out state.  The checked in state can be determined as\nfollows:\n   <DAV:supported-live-properties> includes <DAV:checked-in>\n      means the resource is checked-in.\n   <DAV:supported-live-properties> includes <DAV:checked-out>\n      means the resource is checked-out.\n\nEach resource type above marked with an asterix(*) can exist as a collection\nresource or a non-collection resource.  Determining whether a resource is a\ncollection is described in RFC2518.\n   <DAV:resourcetype> does not include <DAV:collection/>\nmeans the resource is not a collection.\n   <DAV:resourcetype> includes <DAV:collection/>\nmeans the resource is a collection.\n\n\n\n", "id": "lists-006-1414020"}, {"subject": "RE: Why does MERGE automatically checkin resources related to act  ivities", "content": "As indicated, a single objection to a change at this late\nstate in the process is sufficient to keep the\nfeature (auto-activity-checkin on MERGE) in the protocol.\n\nI do believe Roy made a good case for making this behavior\nbe under client control, so I'd like to modify the marshalling\nof the MERGE request so that there is a DAV:auto-activity-checkin\nflag to MERGE that indicates whether or not the client wants this\nauto-activity-checkin behavior.  Does anyone object to this change?\n(I'd like to make the default to not do the checkin, since this\nis more consistent with the non-activity semantics of MERGE, which\ndoes not merge checked-out resources.\n\nI will make some comments on Greg's message below, since I\nam interested in how subversion will be using the DeltaV protocol,\nbut this is not an attempt to keep this issue open (i.e.\nI believe the DAV:auto-activity-checkin flag addresses the issue).\n\n\n   From: Greg Stein [mailto:gstein@lyra.org]\n\n   On Mon, Oct 01, 2001 at 09:50:50AM -0400, Clemm, Geoff wrote:\n   > Greg: If you split your \"commit\" into an activity \"CHECKIN\"\n   > followed by a baseline \"MERGE\", I believe you would have the\n   > right framework for doing branching (in particular,\n\n   We use cheap copies, not branching.\n\nA \"cheap copy\" is probably a better name for what I had in mind\nanyway, so I'll use that term here instead of \"branching\".\n\nIn particular, I noticed in the subversion \"mapping to WebDAV\" design\nnotes, that you were moving towards using something other than \"COPY\"\nto marshal the creation of a \"cheap copy\".  I believe that\nBASELINE-CONTROL is the appropriate way to marshal this.  The\nDAV:baseline-collection property of a baseline exposes that \"cheap\ncopy\" in an interoperable way.\n\n   > a branch is just a CHECKIN that is not followed by a MERGE).\n   > This would have CHECKIN of an activity create a new\n   > subversion revision (aka a DeltaV baseline), but this revision\n   > wouldn't become the \"current\" one until you did the MERGE.\n\n   Not supported.\n\nIsn't this just what a \"cheap copy\" is (i.e. a new revision that does\nnot replace the current one)?  And don't you provide a way to \"merge\"\none \"cheap copy\" into another (i.e. a MERGE)?\n\nI assume the reason you don't want to always use a CHECKIN/MERGE sequence\nis that your revisions, although cheap, are expensive enough\nyou don't want to create them more often than is necessary\n(i.e. only do the CHECKIN if the MERGE will succeed)?\n\n   > If so, I believe this would then remove your need for\n   > having CHECKIN be a side effect of MERGE.  But this of course\n   > works only if subversion allows a new revision to be created that \n   > does not immediately become the current revision.  But don't\n   > you have to do that to support branching?\n\n   Effectively, we do:\n\n   $ svn cp /trunk /branches/gstein-work\n\nCould that be marshalled as:\n\n<create baseline for /trunk>\nBASELINE-CONTROL /branches/gstein-work \n <D:version> <the-trunk-baseline> </D:version>\n\n   Hmm. I just realized that the original question made it seem like\n   some weird side effect. But in the case under discussion, you're\n   doing a MERGE on an *activity*. Thus, it makes perfect sense to\n   take all resources contained in that activity as the merge source.\n\nYes, if the activity is \"done\".  Roy's examples were for cases\nwhere the activity has an interesting state you want to merge\ninto your workspace, even though the activity is not yet done.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14140601"}, {"subject": "RE: Why does MERGE automatically checkin resources related to act   ivities", "content": "Hi,\n\nDAV:auto-activity-checkin would help.\n\nBut, why only apply the auto-checkin to sources related to an activity?\nIf we are going to add DAV:auto-activity-checkin.  Why not call it\nDAV:auto-checkin and also apply this logic to collections and other\nDAV:source elements?  I think this flag would be useful, eg to auto\ncheckin ANY extracted merge source. \n\nOne of the reasons that I raised the initial question was that\nthe behaviour was inconsistent, eg checked-out resources were\nbeing treated differently by MERGE just because they were related\nto an activity.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: 02 October 2001 14:47\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Why does MERGE automatically checkin resources related to\nact ivities?\n\n\nAs indicated, a single objection to a change at this late\nstate in the process is sufficient to keep the\nfeature (auto-activity-checkin on MERGE) in the protocol.\n\nI do believe Roy made a good case for making this behavior\nbe under client control, so I'd like to modify the marshalling\nof the MERGE request so that there is a DAV:auto-activity-checkin\nflag to MERGE that indicates whether or not the client wants this\nauto-activity-checkin behavior.  Does anyone object to this change?\n(I'd like to make the default to not do the checkin, since this\nis more consistent with the non-activity semantics of MERGE, which\ndoes not merge checked-out resources.\n\nI will make some comments on Greg's message below, since I\nam interested in how subversion will be using the DeltaV protocol,\nbut this is not an attempt to keep this issue open (i.e.\nI believe the DAV:auto-activity-checkin flag addresses the issue).\n\n\n   From: Greg Stein [mailto:gstein@lyra.org]\n\n   On Mon, Oct 01, 2001 at 09:50:50AM -0400, Clemm, Geoff wrote:\n   > Greg: If you split your \"commit\" into an activity \"CHECKIN\"\n   > followed by a baseline \"MERGE\", I believe you would have the\n   > right framework for doing branching (in particular,\n\n   We use cheap copies, not branching.\n\nA \"cheap copy\" is probably a better name for what I had in mind\nanyway, so I'll use that term here instead of \"branching\".\n\nIn particular, I noticed in the subversion \"mapping to WebDAV\" design\nnotes, that you were moving towards using something other than \"COPY\"\nto marshal the creation of a \"cheap copy\".  I believe that\nBASELINE-CONTROL is the appropriate way to marshal this.  The\nDAV:baseline-collection property of a baseline exposes that \"cheap\ncopy\" in an interoperable way.\n\n   > a branch is just a CHECKIN that is not followed by a MERGE).\n   > This would have CHECKIN of an activity create a new\n   > subversion revision (aka a DeltaV baseline), but this revision\n   > wouldn't become the \"current\" one until you did the MERGE.\n\n   Not supported.\n\nIsn't this just what a \"cheap copy\" is (i.e. a new revision that does\nnot replace the current one)?  And don't you provide a way to \"merge\"\none \"cheap copy\" into another (i.e. a MERGE)?\n\nI assume the reason you don't want to always use a CHECKIN/MERGE sequence\nis that your revisions, although cheap, are expensive enough\nyou don't want to create them more often than is necessary\n(i.e. only do the CHECKIN if the MERGE will succeed)?\n\n   > If so, I believe this would then remove your need for\n   > having CHECKIN be a side effect of MERGE.  But this of course\n   > works only if subversion allows a new revision to be created that \n   > does not immediately become the current revision.  But don't\n   > you have to do that to support branching?\n\n   Effectively, we do:\n\n   $ svn cp /trunk /branches/gstein-work\n\nCould that be marshalled as:\n\n<create baseline for /trunk>\nBASELINE-CONTROL /branches/gstein-work \n <D:version> <the-trunk-baseline> </D:version>\n\n   Hmm. I just realized that the original question made it seem like\n   some weird side effect. But in the case under discussion, you're\n   doing a MERGE on an *activity*. Thus, it makes perfect sense to\n   take all resources contained in that activity as the merge source.\n\nYes, if the activity is \"done\".  Roy's examples were for cases\nwhere the activity has an interesting state you want to merge\ninto your workspace, even though the activity is not yet done.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14152097"}, {"subject": "RE: Why does MERGE automatically checkin resources related to act ivities", "content": "The DAV:activity-checkin functionality is required\nto be atomic.  Since an activity is a \"single logical change\", it\nis reasonable to expect a repository to support atomic\noperations on a single logical change.  On the other hand,\nit is not as obvious that a repository can/will support\nthe atomic checkin of an arbitrary set of resources.\n\nSo this is a reasonable issue to discuss, but it is a\nnon-trivial extension beyond the currently defined functionality.\nSo although capturing the current auto-checkin behavior of\nMERGE in an explicit flag has no effect on the semantics,\nextending the behavior to other non-activity checkin is\nnot something that I think reasonably fits in a final editorial\npass.  \n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\nDAV:auto-activity-checkin would help. \nBut, why only apply the auto-checkin to sources related to an activity? \nIf we are going to add DAV:auto-activity-checkin.  Why not call it \nDAV:auto-checkin and also apply this logic to collections and other \nDAV:source elements?  I think this flag would be useful, eg to auto \ncheckin ANY extracted merge source. \nOne of the reasons that I raised the initial question was that \nthe behaviour was inconsistent, eg checked-out resources were \nbeing treated differently by MERGE just because they were related \nto an activity. \n\n\n\n", "id": "lists-006-14165629"}, {"subject": "Standard privileges for DeltaV operations", "content": "So, now that the DeltaV specification has been approved, it begs the\nquestion of whether the Access Control Protocol should define some access\nprivileges for versioning operations.\n\nThe following privileges make sense to me:\n\nDAV:checkout - controls CHECKOUT\nDAV:checkin - controls CHECKIN\nDAV:uncheckout - controls UNCHECKOUT\nDAV:report - controls REPORT\nDAV:version-control - controls VERSION-CONTROL\n\nSo, minimally we would cover versioning capability, where I'm hoping there\nis a lot of commonality among the access control mechanisms of existing\nrepositories.\n\nThoughts?\n\n- Jim\n\n\n\n", "id": "lists-006-14175038"}, {"subject": "RE: [ACL] Standard privileges for DeltaV operations", "content": "I think it is too early to guess what an interoperable set of versioning\nprivileges would be.  In particular, it is unlikely that the underlying\nrepository privileges will be in terms of the particular methods that we\nintroduced in DeltaV.  There is likely to be a \"read\" and\n\"write\" privilege, but not nearly as likely to be a separate \"checkin\" vs.\n\"uncheckout\" privilege (i.e. you can checkin, but you can't uncheckout,\nor vica versa).\n\nSo I'd suggest sticking with the generic privileges that we currently have\n(i.e. DAV:read, DAV:write, etc).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\nSent: Tuesday, October 02, 2001 1:07 PM\nTo: acl@webdav.org; ietf-dav-versioning@w3.org\nSubject: [ACL] Standard privileges for DeltaV operations?\n\n\nSo, now that the DeltaV specification has been approved, it begs the\nquestion of whether the Access Control Protocol should define some access\nprivileges for versioning operations.\n\nThe following privileges make sense to me:\n\nDAV:checkout - controls CHECKOUT\nDAV:checkin - controls CHECKIN\nDAV:uncheckout - controls UNCHECKOUT\nDAV:report - controls REPORT\nDAV:version-control - controls VERSION-CONTROL\n\nSo, minimally we would cover versioning capability, where I'm hoping there\nis a lot of commonality among the access control mechanisms of existing\nrepositories.\n\nThoughts?\n\n- Jim\n\n\n_______________________________________________\nacl mailing list\nacl@webdav.org\nhttp://mailman.webdav.org/mailman/listinfo/acl\n\n\n\n", "id": "lists-006-14182459"}, {"subject": "RE: [ACL] Standard privileges for DeltaV operations", "content": "Actually, I think that the privileges that are needed for versioning will\ncontrol things like who can create workspaces, activities, etc., as write\nshould cover checkin/checkout.\n\n-----Original Message-----\nFrom: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of Clemm,\nGeoff\nSent: Tuesday, October 02, 2001 10:19 AM\nTo: acl@webdav.org; ietf-dav-versioning@w3.org\nSubject: RE: [ACL] Standard privileges for DeltaV operations?\n\nI think it is too early to guess what an interoperable set of versioning\nprivileges would be.  In particular, it is unlikely that the underlying\nrepository privileges will be in terms of the particular methods that we\nintroduced in DeltaV.  There is likely to be a \"read\" and\n\"write\" privilege, but not nearly as likely to be a separate \"checkin\" vs.\n\"uncheckout\" privilege (i.e. you can checkin, but you can't uncheckout,\nor vica versa).\n\nSo I'd suggest sticking with the generic privileges that we currently have\n(i.e. DAV:read, DAV:write, etc).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\nSent: Tuesday, October 02, 2001 1:07 PM\nTo: acl@webdav.org; ietf-dav-versioning@w3.org\nSubject: [ACL] Standard privileges for DeltaV operations?\n\n\nSo, now that the DeltaV specification has been approved, it begs the\nquestion of whether the Access Control Protocol should define some access\nprivileges for versioning operations.\n\nThe following privileges make sense to me:\n\nDAV:checkout - controls CHECKOUT\nDAV:checkin - controls CHECKIN\nDAV:uncheckout - controls UNCHECKOUT\nDAV:report - controls REPORT\nDAV:version-control - controls VERSION-CONTROL\n\nSo, minimally we would cover versioning capability, where I'm hoping there\nis a lot of commonality among the access control mechanisms of existing\nrepositories.\n\nThoughts?\n\n- Jim\n\n\n_______________________________________________\nacl mailing list\nacl@webdav.org\nhttp://mailman.webdav.org/mailman/listinfo/acl\n\n_______________________________________________\nacl mailing list\nacl@webdav.org\nhttp://mailman.webdav.org/mailman/listinfo/acl\n\n\n\n", "id": "lists-006-14192879"}, {"subject": "RE: [ACL] Standard privileges for DeltaV operations", "content": "Note though that DAV:write access to the workspace and activity\ncollections is likely to be sufficient for controlling who can\ncreate workspaces or activities.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Eric Sedlar [mailto:eric.sedlar@oracle.com]\nSent: Tuesday, October 02, 2001 2:42 PM\nTo: Clemm, Geoff; acl@webdav.org; ietf-dav-versioning@w3.org\nSubject: RE: [ACL] Standard privileges for DeltaV operations?\n\n\nActually, I think that the privileges that are needed for versioning will\ncontrol things like who can create workspaces, activities, etc., as write\nshould cover checkin/checkout.\n\n-----Original Message-----\nFrom: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of Clemm,\nGeoff\nSent: Tuesday, October 02, 2001 10:19 AM\nTo: acl@webdav.org; ietf-dav-versioning@w3.org\nSubject: RE: [ACL] Standard privileges for DeltaV operations?\n\nI think it is too early to guess what an interoperable set of versioning\nprivileges would be.  In particular, it is unlikely that the underlying\nrepository privileges will be in terms of the particular methods that we\nintroduced in DeltaV.  There is likely to be a \"read\" and\n\"write\" privilege, but not nearly as likely to be a separate \"checkin\" vs.\n\"uncheckout\" privilege (i.e. you can checkin, but you can't uncheckout,\nor vica versa).\n\nSo I'd suggest sticking with the generic privileges that we currently have\n(i.e. DAV:read, DAV:write, etc).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\nSent: Tuesday, October 02, 2001 1:07 PM\nTo: acl@webdav.org; ietf-dav-versioning@w3.org\nSubject: [ACL] Standard privileges for DeltaV operations?\n\n\nSo, now that the DeltaV specification has been approved, it begs the\nquestion of whether the Access Control Protocol should define some access\nprivileges for versioning operations.\n\nThe following privileges make sense to me:\n\nDAV:checkout - controls CHECKOUT\nDAV:checkin - controls CHECKIN\nDAV:uncheckout - controls UNCHECKOUT\nDAV:report - controls REPORT\nDAV:version-control - controls VERSION-CONTROL\n\nSo, minimally we would cover versioning capability, where I'm hoping there\nis a lot of commonality among the access control mechanisms of existing\nrepositories.\n\nThoughts?\n\n- Jim\n\n\n_______________________________________________\nacl mailing list\nacl@webdav.org\nhttp://mailman.webdav.org/mailman/listinfo/acl\n\n_______________________________________________\nacl mailing list\nacl@webdav.org\nhttp://mailman.webdav.org/mailman/listinfo/acl\n\n\n\n", "id": "lists-006-14205566"}, {"subject": "[Fwd: List of DeltaV questions, issues, and extensions", "content": "Resending since this didn't seem to make it to the list.\n\n\nattached mail follows:\nI have been discussing a DeltaV implementation with\nseveral colleagues at Oracle, and we have a list of\nquestions, issues, and possible extensions to the\nprotocol. I understand the Proposed Standard RFC is in\nits final editing pass so there is very limited scope\nfor change in this RFC iteration. However, I will still\npost these items for discussion in the working group.\n\nBelow is a summary of items I intend to post in more\ndetail ASAP.\n\nRoy\n\n--\n\nClarifications\n\n- Version-controlled collection feature: Does eclipsing\n  a version-controlled collection eclipse its members\n  as well?\n\n- Activity feature: Is there an interoperable way to\n  \"close\" an activity (that is, prevent any more\n  checkouts or checkins in that activity)? Followup: if\n  not, how much demand would there be for standardizing\n  this concept?\n\n\nIs this a bug?\n\n- Baseline feature: Is it possible to construct a\n  workspace which contains multiple VCR's with\n  different DAV:checked-in versions for a given VHR by\n  doing a MOVE of a VCR from one baseline-controlled\n  collection to another, and then UPDATING the VCC's\n  for those BCC's?\n\n\nPossible extensions\n\n- Activity feature, update feature: Define the\n  semantics of UPDATE where the source is an\n  activity. Use case: Provide a performant standard way\n  for clients to ensure that the members of a workspace\n  select the latest version of an activity. This is key\n  to support the concept of merging to an activity (by\n  merging to a workspace which selects the latest\n  versions in that activity). (Note: ideally, this\n  extension would also modify generic UPDATE\n  marshalling so the DAV:update element had a\n  DAV:source child element, like MERGE does, instead of\n  a DAV:version element. An activity resource is not a\n  version resource).\n\n- Merge and update features: Add a flag to make\n  DAV:response elements of UPDATE optional, and to make\n  DAV:response elements of MERGE optional for targets\n  modified by postcondition DAV:descendant-version. Use\n  case: improve response times when the request-URL of\n  the MERGE or UPDATE has an extremely large number of\n  members whose DAV:checked-in versions are modified by\n  the MERGE or UPDATE, and when the client's caching\n  policy will not benefit from the DAV:response\n  elements enough to outweigh the cost of adding the\n  DAV:response elements to the response body.\n\n- Autoversioning (extension), baseline feature (use\n  case): In Section 3.2.2, change the EMPTY elements in\n  the DAV:auto-version property values to ANY, enabling\n  DAV:checkin and DAV:checkout elements with default\n  checkin and checkout options for the autoversioned\n  VCR to be applied at auto-checkin and auto-checkout\n  time. Use case: multiple workspaces share the same\n  DAV:current-activity-set and the same DAV:checked-in\n  baselines for their version-controlled\n  configurations, and those VCCs' DAV:auto-version\n  properties are DAV:checkout. There is a problem\n  because baseline-controlled members of those\n  workspaces cannot be checked in even if they are for\n  different version histories - only the first\n  workspace can auto-checkout its VCC unreserved in the\n  shared DAV:current-activity-set.\n  \n\nResolved\n\n- Merge feature: Should the DAV:merge-preview report\n  have the same response format as the MERGE and UPDATE\n  methods? Resolution: it is acceptable the way it is\n  in draft-18 - clients can request a DAV:merge-preview\n  report to get more detailed information about a merge\n  in a different format than the original MERGE.\n\n- Activity feature: Add a DAV:auto-activity-checkin\n  flag to MERGE from activities, putting the\n  auto-activity-checkin behavior under client\n  control. The use cases have to do with merging from\n  an activity which has an interesting state you want\n  to merge from your workspace, even though the\n  activity is not yet done. Resolution: If the working\n  group accepts Geoff's proposal for an\n  auto-activity-checkin flag to activity merge, that\n  would meet my requirement.\n\n\n-- end of question, issue, and extension list --\n\n\n\n", "id": "lists-006-14218884"}, {"subject": "RE: List of DeltaV questions, issues, and extension", "content": "   From: Roy Seto [mailto:roy.seto@oracle.com]\n\n   Resending since this didn't seem to make it to the list.\n\nThat is strange ... Peter seems to be having similar problems with only\nsome of his posts making it through.\n\n   Clarifications:\n\n   - Version-controlled collection feature: Does eclipsing a\n     version-controlled collection eclipse its members as well?\n\nYes.  A collection consists of a set of bindings.  If you eclipse a\ncollection with a non-collection, there are no members there.  If you\neclipse a collection with a different collection, it is the bindings\nof the eclipsing collection that you see.\n\n   - Activity feature: Is there an interoperable way to \"close\" an\n     activity (that is, prevent any more checkouts or checkins in that\n     activity)? Followup: if not, how much demand would there be for\n     standardizing this concept?\n\nI suggest we should soon start a follow-on \"change request\"\nworking group (we could start under the auspices of the\nWebDAV working group).  In particular, we would then discuss\nvarious states that an activity could be in, and how to\nstandardize transitions between those states (is PROPPATCH\nenough?).  Minimally, we could decide on some standard\nXML element for the state field of an activity, and a few\n\"standard\" state values.  Perhaps a BOF at the Dec IETF?\n\n   Is This A Bug?\n\n   - Baseline feature: Is it possible to construct a workspace which\n     contains multiple VCR's with different DAV:checked-in versions\n     for a given VHR by doing a MOVE of a VCR from one\n     baseline-controlled collection to another, and then UPDATING the\n     VCC's for those BCC's?\n\nI think the intent of the spec is clear (only one VCC for a given\nversion history in a given workspace), but I agree that\nwe are missing a postcondition on the MOVE operation.  A\nworkspace is required to have only one VCR for a given version\nhistory, so any operation that would violate that constraint (which a\nMOVE could) should fail.  Similarly, we should clarify in the extended\nUPDATE semantics, so that it is clear that the UPDATE of a VCC causes\nan existing VCR to be bound into a collection, if there already is a\nVCR for a given version history in the workspace.\n\nSince these semantics can be inferred from the global statement\nthat a workspace can only contain one VCR for a given version\nhistory, I think this clarification can wait for the next rev\nof the spec (not that you were suggesting otherwise).\n\n   Possible extensions\n\n   - Activity feature, update feature: Define the semantics of UPDATE\n     where the source is an activity. Use case: Provide a performant\n     standard way for clients to ensure that the members of a\n     workspace select the latest version of an activity. This is key\n     to support the concept of merging to an activity (by merging to a\n     workspace which selects the latest versions in that\n     activity). (Note: ideally, this extension would also modify\n     generic UPDATE marshalling so the DAV:update element had a\n     DAV:source child element, like MERGE does, instead of a\n     DAV:version element. An activity resource is not a version\n     resource).\n\nI find this not very compelling.  An activity is a logical\nchange set.  Simply \"setting\" some of your versions to those\nselected by some change set sounds like a great way to \nhide parts of existing change sets, and making your workspace\ninconsistent.  So \"MERGE\" on an activity makes sense to me,\nbut \"UPDATE\" does not.  Perhaps you could develop the use case\nin some more detail?\n\n   - Merge and update features: Add a flag to make DAV:response\n     elements of UPDATE optional, and to make DAV:response elements of\n     MERGE optional for targets modified by postcondition\n     DAV:descendant-version. Use case: improve response times when the\n     request-URL of the MERGE or UPDATE has an extremely large number\n     of members whose DAV:checked-in versions are modified by the\n     MERGE or UPDATE, and when the client's caching policy will not\n     benefit from the DAV:response elements enough to outweigh the\n     cost of adding the DAV:response elements to the response body.\n\nA server has to compute all of this information anyway (to do the\nupdate), so all one would be saving would be the cost of sending the\ninfo back (which is rather small chunk of information, compared to\nwhat the net is set up to pass around).  But if this really turns out\nto be an issue in practice, it certainly would be easy to add such an\nextension.  Are you getting actual performance numbers on this that\nconcern you?\n\n   - Autoversioning (extension), baseline feature (use case): In\n     Section 3.2.2, change the EMPTY elements in the DAV:auto-version\n     property values to ANY, enabling DAV:checkin and DAV:checkout\n     elements with default checkin and checkout options for the\n     autoversioned VCR to be applied at auto-checkin and auto-checkout\n     time. Use case: multiple workspaces share the same\n     DAV:current-activity-set and the same DAV:checked-in baselines\n     for their version-controlled configurations, and those VCCs'\n     DAV:auto-version properties are DAV:checkout. There is a problem\n     because baseline-controlled members of those workspaces cannot be\n     checked in even if they are for different version histories -\n     only the first workspace can auto-checkout its VCC unreserved in\n     the shared DAV:current-activity-set.\n\nThat sounds pretty reasonable to me.  I might just give these their\nown property names though, so that it is easier for a client to\ndetermine if this option is supported.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14229500"}, {"subject": "Re: Why does MERGE automatically checkin resources related to act  ivities", "content": "On Tue, Oct 02, 2001 at 09:47:08AM -0400, Clemm, Geoff wrote:\n>...\n> I do believe Roy made a good case for making this behavior\n> be under client control, so I'd like to modify the marshalling\n> of the MERGE request so that there is a DAV:auto-activity-checkin\n> flag to MERGE that indicates whether or not the client wants this\n> auto-activity-checkin behavior.  Does anyone object to this change?\n\nNot a problem here.\n\n> (I'd like to make the default to not do the checkin, since this\n> is more consistent with the non-activity semantics of MERGE, which\n> does not merge checked-out resources.\n\nNot a problem.\n\n>...\n>    From: Greg Stein [mailto:gstein@lyra.org]\n> \n>    On Mon, Oct 01, 2001 at 09:50:50AM -0400, Clemm, Geoff wrote:\n>    > Greg: If you split your \"commit\" into an activity \"CHECKIN\"\n>    > followed by a baseline \"MERGE\", I believe you would have the\n>    > right framework for doing branching (in particular,\n> \n>    We use cheap copies, not branching.\n> \n> A \"cheap copy\" is probably a better name for what I had in mind\n> anyway, so I'll use that term here instead of \"branching\".\n> \n> In particular, I noticed in the subversion \"mapping to WebDAV\" design\n\nCareful with that doc :-)  it could stand some updating...\n\n> notes, that you were moving towards using something other than \"COPY\"\n> to marshal the creation of a \"cheap copy\".  I believe that\n> BASELINE-CONTROL is the appropriate way to marshal this.  The\n> DAV:baseline-collection property of a baseline exposes that \"cheap\n> copy\" in an interoperable way.\n\nActually, I was planning to do a COPY from somewhere in a BC as the\nmarshalling. For example:\n\n    COPY /repos/svn/$svn/bc/567/trunk HTTP/1.0\n    Destination: /repos/svn/$svn/wrk/uuid/branches/gstein-work\n\nThis contains the revision/path to copy, and the destination in a working\ncollection to copy it to.\n\n>    > a branch is just a CHECKIN that is not followed by a MERGE).\n>    > This would have CHECKIN of an activity create a new\n>    > subversion revision (aka a DeltaV baseline), but this revision\n>    > wouldn't become the \"current\" one until you did the MERGE.\n> \n>    Not supported.\n> \n> Isn't this just what a \"cheap copy\" is (i.e. a new revision that does\n> not replace the current one)?\n\nThe copy occurs within a set of working resources. To get a revision, you\nmust check in those resources. That revision is then \"current\".\n\nA cheap copy means that copying a tree does not duplicate the entire tree in\nthe repository. Effectively, we create a symlink within the repository. A\ncopy is unrelated to the revisions -- the latter is a feature of the entire\nrepository, while copies of files/dirs are structural things *within* a\nrepository.\n\n> And don't you provide a way to \"merge\"\n> one \"cheap copy\" into another (i.e. a MERGE)?\n\nWe have code for merging two trees, but the user model for doing that (and\nthe resulting marshalling for the feature) is not yet decided.\n\n[ we merge trees when you checkin an activity, and the changes get merged\n  with the current revision ]\n\n> I assume the reason you don't want to always use a CHECKIN/MERGE sequence\n> is that your revisions, although cheap,\n\nI believe you've led yourself down the wrong path :-)  Our cheap copies are\nnot on a revision basis, but they are about copying files/dirs *within* the\nrepository. A given checkin could have dozens of copy operations. The\nresulting repository looks like a standard tree, but we happen to represent\nit without a lot of duplication, and with history about the copy.\n\n> are expensive enough\n> you don't want to create them more often than is necessary\n> (i.e. only do the CHECKIN if the MERGE will succeed)?\n\nRevisions are cheap. There's no problem with spitting out hundreds of them\n(technically; that many could blow up people's brains)\n\nWe can't do a CHECKIN/MERGE because the checkin operation automatically\nmerges. Thus, we could not support a client that looks at those operations\nas a two step process. Our operation is a single \"checkin and merge\", and\nthe current MERGE semantics models that.\n\nThe basic issue here is that the model used by Subversion (and I suspect a\ngoodly number of other systems) does not provide for checking in a new\n\"head\" revision and hiding it until somebody cares to make it visible.\n\n>    > If so, I believe this would then remove your need for\n>    > having CHECKIN be a side effect of MERGE.  But this of course\n>    > works only if subversion allows a new revision to be created that \n>    > does not immediately become the current revision.  But don't\n>    > you have to do that to support branching?\n> \n>    Effectively, we do:\n> \n>    $ svn cp /trunk /branches/gstein-work\n> \n> Could that be marshalled as:\n> \n> <create baseline for /trunk>\n> BASELINE-CONTROL /branches/gstein-work \n>  <D:version> <the-trunk-baseline> </D:version>\n\nNo. We aren't copying baselines. We're copying the \"/trunk\" directory. The\ndestination is a working resource, not something that would go under\nbaseline control.\n\n>    Hmm. I just realized that the original question made it seem like\n>    some weird side effect. But in the case under discussion, you're\n>    doing a MERGE on an *activity*. Thus, it makes perfect sense to\n>    take all resources contained in that activity as the merge source.\n> \n> Yes, if the activity is \"done\".  Roy's examples were for cases\n> where the activity has an interesting state you want to merge\n> into your workspace, even though the activity is not yet done.\n\nSure... Roy's examples are quite valid. I think the original question was a\nmisdirection.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-14243484"}, {"subject": "RE: Why does MERGE automatically checkin resources related to act ivities", "content": "Sounds like we've got closure on this issue.  I'll submit this change,\nalong with fixes for the reported typos in draft-19, as draft-20.\n\nHere's the full list of changes since draft-18:\n\n---- v20 ---\n\n- 11.2: Add \"identifies the resources that a client must modify to complete\nthe merge\" to the description of what the merge output contains.\n\n- 12: reword sentence describing a configuration to be \"all ... except\"\ninstead of \"all ... not\"\n\n- 12.3.1: change has to \"MUST have\".\n\n- 13: add \"V3\" name to diagram\n\n- 13.9: add \"-set\" to \"activity-checkout\"\n\n- 13.12: allow client to control activity checkin behavior with a\nDAV:activity-checkin parameter to MERGE.\n\n------------ v19 ---------------------\n- 1.2: \"is be\" -> \"is\"\n\n- 1.7: \"a resources\" -> \"a resource\"\n\n- 2.1: \"and versioning-unaware client\" -> \"and versioning-unaware clients\"\n\n- 10.2: definition of cvr: \"captures the dead properties of a\nversion-controlled collection, as well as the names of its\nversion-controlled bindings\"\n\n- 11.2 :add \"or is the same as\" in the \"ancestor version\" and \"descendant\nversion\" postconditions.\n\n- 11.2: add period to \"descendent version\" precondition.\n\n- 11.2: for update-merge-set postcondition, move \"must be added\" to first\nsentence.\n\n- 11.3: should be \"ignore-preview\", not \"ignored-preview\"\n\n- 14.10: \"each non-version-controlled members\" -> \"each\nnon-version-controlled member\"\n\nThanks for the rapid turnaround, everyone!\n\nCheers,\nGeoff\n\n\n\n\n-----Original Message-----\nFrom: Greg Stein [mailto:gstein@lyra.org]\nSent: Wednesday, October 03, 2001 7:30 AM\nTo: Clemm, Geoff\nCc: ietf-dav-versioning@w3.org\nSubject: Re: Why does MERGE automatically checkin resources related to\nact ivities?\n\n\nOn Tue, Oct 02, 2001 at 09:47:08AM -0400, Clemm, Geoff wrote:\n>...\n> I do believe Roy made a good case for making this behavior\n> be under client control, so I'd like to modify the marshalling\n> of the MERGE request so that there is a DAV:auto-activity-checkin\n> flag to MERGE that indicates whether or not the client wants this\n> auto-activity-checkin behavior.  Does anyone object to this change?\n\nNot a problem here.\n\n> (I'd like to make the default to not do the checkin, since this\n> is more consistent with the non-activity semantics of MERGE, which\n> does not merge checked-out resources.\n\nNot a problem.\n\n\n\n", "id": "lists-006-14257303"}, {"subject": "RE: Why does MERGE automatically checkin resources related to act ivities", "content": "   From: Greg Stein [mailto:gstein@lyra.org]\n\n   > In particular, I noticed in the subversion \"mapping to WebDAV\" design\n\n   Careful with that doc :-)  it could stand some updating...\n\nYeah, I figure there's nothing like a bunch of questions to motivate\nupdating the doc (:-).\n\n   > notes, that you were moving towards using something other than \"COPY\"\n   > to marshal the creation of a \"cheap copy\".  I believe that\n   > BASELINE-CONTROL is the appropriate way to marshal this.  The\n   > DAV:baseline-collection property of a baseline exposes that \"cheap\n   > copy\" in an interoperable way.\n\n   Actually, I was planning to do a COPY from somewhere in a BC as the\n   marshalling. For example:\n\n       COPY /repos/svn/$svn/bc/567/trunk HTTP/1.0\n       Destination: /repos/svn/$svn/wrk/uuid/branches/gstein-work\n\n   This contains the revision/path to copy, and the destination in a working\n   collection to copy it to.\n\nThe main problem with that marshalling is how can you tell the\ndifference between:\n\n- someone who wants to create a bunch of new resources, i.e. create a\n  set of new VHRs whose initial versions happen to be initialized by\n  the content of an existing tree of VCRs.\n\n- someone that wants to create new versions for a set of existing VHRs\n\nIn particular, DeltaV defines the semantics of the COPY into a\nworking directory to be the former, i.e. create a set of new VHR's\nwhen the working collection is checked in.\n\nIn order to do the latter, the client would have to CHECKOUT each\nresource that they want to modify (both collection and non-collection),\nupdate the resulting working resources, and then check the result\nback in (e.g. by MERGE with the DAV:activity-checkin flag set).\n\nNote: My comment above about using BASELINE-CONTROL was assuming you\nwanted to create a new set of VCR's for the existing set of VHR's,\nbut it looks like you aren't planning on supporting that functionality.\n\n   >    > a branch is just a CHECKIN that is not followed by a MERGE).\n   >    > This would have CHECKIN of an activity create a new\n   >    > subversion revision (aka a DeltaV baseline), but this revision\n   >    > wouldn't become the \"current\" one until you did the MERGE.\n   > \n   >    Not supported.\n   > \n   > Isn't this just what a \"cheap copy\" is (i.e. a new revision that does\n   > not replace the current one)?\n\n   The copy occurs within a set of working resources. To get a revision, you\n   must check in those resources. That revision is then \"current\".\n\nOK, I misunderstood.  I thought by \"cheap copy\", you meant creating a\nnew tree of VCRs that share the VHRs of an existing tree of VCRs.\nInstead, you meant creating a tree of (non-version-controlled) resources\nwithin a working collection.\n\n   [ we merge trees when you checkin an activity, and the changes get merged\n     with the current revision ]\n\n   We can't do a CHECKIN/MERGE because the checkin operation automatically\n   merges. Thus, we could not support a client that looks at those\noperations\n   as a two step process. Our operation is a single \"checkin and merge\", and\n   the current MERGE semantics models that.\n\nSo you are not going to support \"revision branching\" (i.e. where the\nrevision history itself branches)?  That does sound vaguely familiar,\nso probably you did tell me that a while ago.\n\n   The basic issue here is that the model used by Subversion (and I suspect\na\n   goodly number of other systems) does not provide for checking in a new\n   \"head\" revision and hiding it until somebody cares to make it visible.\n\nI thought it was a fairly central CVS feature to create a new \"branch\"\nof the repository, to do a whole series of checkins on a branch, and\nthen only merge that repository branch on demand (although I agree\nthat it doesn't to the merge part very well)?  That's what separating\nCHECKIN and MERGE is all about.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14268160"}, {"subject": "RE: Resource type: a proposa", "content": "So here's my proposal for resourcetype values ...  I make no further\napologies or arguments for what I consider to be a 'type' vs a 'state', but\nI do address how clients should detect variations in state.\n\nI will however make a couple further argument for resourcetype because I\njust thought of them:\n - clients that don't want to implement DeltaV could still allow users to\nbrowse folders and resources and see if they're \"special\" in some way, just\nby adding these few values to their resourcetype handling.  E.g. a client\nlike IE could display things is added as \"versioned\" even if it didn't know\nhow to checkin/checkout or view old versions.\n - ordering (really, grouping) by resourcetype ought to be easy, if desired\n\nI suspect that the text in this proposal would be scattered throughout the\ntext wherever new resource types are introduced, and in the chapters that\ndiscuss those types.  So, I'll put my text in the same order as the current\ndraft.  Those who are more familiar than I am with chapter 10 and later\nshould review that part carefully.  I'm still a little confused about\nwhether a version history is most usefully considered to be a collection\n(that contains versions) or not; if it's deemed reasonable to call it a\ncollection then <DAV:collection/> should be added to all the version history\nthingys.\n\n------- proposal ------\n\nVersion-Controlled Resource:  An additional element\n\"DAV:version-controlled\"is added to <DAV:resourcetype> to identify\nversion-controlled resources.  E.g.\n  <D:resourcetype><D:version-controlled/></D:resourcetype>\nTo see if a VCR is checked-out, look for the checked-out property presence.\n\nVersion Resource: An additional element \"DAV:version\" is added to\nDAV:resourcetype to identify a version.  E.g.\n  <D:resourcetype><D:version/></D:resourcetype>\n\nVersion History Resource: An additional element \"DAV:version-history\" is\nadded to DAV:resourcetype to identify a Version History Resource.  E.g.\n  <D:resourcetype><D:version-history/></D:resourcetype>\n\nWorkspace: An additional element \"DAV:workspace\" is added along with\n\"DAV:collection\" to identify a Workspace.  E.g.\n  <D:resourcetype><D:collection/><D:workspace/></D:resourcetype>.\n\nBaselines: An additional element \"DAV:baseline\" can be added to indicate\nthat the version-controlled resource, its versions and version-history, are\nrelated to baselines or configurations rather than to regular resources.\nE.g.\n  <D:resourcetype><D:version-controlled/><D:baseline/></D:resourcetype>\n  <D:resourcetype><D:version/><D:baseline/></D:resourcetype>\n  <D:resourcetyep><D:version-history/><D:baseline/></D:resourcetype>\n\nActivity: An additional element \"DAV:activity\" is added to DAV:resourcetype\nto identify an activity.  E.g.\n  <D:resourcetype><D:activity/><D:resourcetype>\n\nVersion-controlled collection:  Existing elements are reused to identify a\nversion-controlled resource. E.g.\n  <D:resourcetype><D:version-controlled/><D:collection></D:resourcetype>\n\n\n----------------------------\n\nlisa\n\n\n\n", "id": "lists-006-1427684"}, {"subject": "Re: merge-preview Report, MERGE and UPDATE response", "content": "This rationale sounds reasonable to me.\n\n\"Clemm, Geoff\" wrote:\n\n> I think it is useful to keep the DAV:merge-preview semantics\n> the way they currently are.  If a client wants to guide the merge\n> process, they would use the DAV:merge-preview report, and take\n> advantage of the detailed information (such as common ancestor)\n> provided there.  The MERGE method is there for clients that just\n> want servers to do all the work.  If a client has used the MERGE\n> method, and then wants to give the user some more help with a particular\n> merge, it would ask for the DAV:merge-preview report for that\n> particular merge.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Roy Seto [mailto:Roy.Seto@oracle.com]\n> Sent: Thursday, September 27, 2001 9:22 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: DAV:merge-preview Report, MERGE and UPDATE responses\n>\n> The DAV:merge-preview Report's response used to look like\n> the responses of MERGE and UPDATE, but then DAV:ignore-set\n> was dropped from MERGE and UPDATE, and MERGE and UPDATE's\n> responses were brought in line with Multi-Status format\n> following Tim Ellison's suggestion on August 21:\n>\n> http://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JulSep/0240.html\n>\n> Does it make sense to bring the DAV:merge-preview Report\n> request and response format in line with the current format\n> for MERGE and UPDATE?\n>\n> Also, as of draft-18, DAV:merge-preview Report identifies\n> the common ancestor version for merge targets that need\n> logical content merging by clients, but MERGE does not\n> (though of course of client can still request a\n> DAV:version-tree Report and compute the common ancestor\n> itself). Does it make sense to introduce a mechanism (such\n> as a property) for the server to identify common ancestor\n> versions after a MERGE?\n>\n> Thanks,\n> Roy\n\n\n\n", "id": "lists-006-14280497"}, {"subject": "Content-Type / charset in RFC2518, deltaV and ACL spec", "content": "Hi,\n\nI just noticed that in their examples, all these specs specify:\n\nContent-type: text/xml; charset=\"utf-8\"\n\nHowever, as far as I understand RFC2616 (section 3.6 and section 3.7), and\nfrom experience when setting the encoding in Java servlets, it should be\n\nContent-type: text/xml; charset=utf-8\n\n(so the value is not quoted).\n\nIn general, I think it really doesn't make sense to specify character sets\nin specs (unless the spec is talking about encodings, of course). The spec\ncontains characters after all (not an octet stream). Of course this also\naffects XML declarations in the specs.\n\nJulian\n\n\n\n", "id": "lists-006-14289552"}, {"subject": "RE: Content-Type / charset in RFC2518, deltaV and ACL spec", "content": "Actually, section 3.6 states that a \"value\" is either a \"token\" or\na \"quoted-string\", so the examples in 2518 are syntactically valid.\nBut that doesn't mean that they are acceptable to common implementations,\nso it's a fair question.\n\nThere is time to strip off the quotes in the DeltaV spec in the final\nediting pass, but that is likely to be soon, so if anyone feels strongly \nabout this, please let me know ASAP.\n\nI don't follow your rationale for why examples in specs should not\ncontain encoding information.  An example is supposed to accurately\nreflect what the client should send and expect to receive, and a client\nshould send encoding information in a charset parameter in the\nContent-Type header.\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\nSent: Wednesday, October 03, 2001 11:20 AM\nTo: Webdav WG; ietf-dav-versioning@w3.org\nSubject: Content-Type / charset in RFC2518, deltaV and ACL specs\n\n\nHi,\n\nI just noticed that in their examples, all these specs specify:\n\nContent-type: text/xml; charset=\"utf-8\"\n\nHowever, as far as I understand RFC2616 (section 3.6 and section 3.7), and\nfrom experience when setting the encoding in Java servlets, it should be\n\nContent-type: text/xml; charset=utf-8\n\n(so the value is not quoted).\n\nIn general, I think it really doesn't make sense to specify character sets\nin specs (unless the spec is talking about encodings, of course). The spec\ncontains characters after all (not an octet stream). Of course this also\naffects XML declarations in the specs.\n\nJulian\n\n\n\n", "id": "lists-006-14299079"}, {"subject": "UPDATE with activity sourc", "content": "I am following up this discussion in a separate thread\nfor clarity.\n\nYesterday, I wrote:\n\n   Possible extensions\n\n   - Activity feature, update feature: Define the\n     semantics of UPDATE where the source is an\n     activity. Use case: Provide a performant standard\n     way for clients to ensure that the members of a\n     workspace select the latest version of an\n     activity. This is key to support the concept of\n     merging to an activity (by merging to a workspace\n     which selects the latest versions in that\n     activity). (Note: ideally, this extension would\n     also modify generic UPDATE marshalling so the\n     DAV:update element had a DAV:source child element,\n     like MERGE does, instead of a DAV:version\n     element. An activity resource is not a version\n     resource).\n\nGeoff replied:\n\n   I find this not very compelling.  An activity is a\n   logical change set.  Simply \"setting\" some of your\n   versions to those selected by some change set sounds\n   like a great way to hide parts of existing change\n   sets, and making your workspace inconsistent.  So\n   \"MERGE\" on an activity makes sense to me, but\n   \"UPDATE\" does not.  Perhaps you could develop the\n   use case in some more detail?\n\nMy more detailed discussion follows below.\n\n--\n\nChange proposal\n\n  Editorial level change: Modify the marshalling of\n  UPDATE in Section 7.1 so DAV:update contains a\n  DAV:source element instead of a DAV:version\n  element. This would make the UPDATE marshalling more\n  consistent with the MERGE marshalling. More\n  importantly, it would make it simpler to extend\n  UPDATE to accept sources which were not version\n  resources if there was a consensus to do so (possibly\n  in the future).\n\n  Feature extension: In addition to the editorial level\n  change, add additional UPDATE semantics to Section 13\n  (the activity feature). Informally, UPDATE with an\n  activity source would set the DAV:checked-in version\n  of each checked-in member of the request-URL to the\n  latest version in the source activity's\n  DAV:activity-version-set, if such a version existed.\n\nUse case\n\n  My overall use case for this feature extension is the\n  same one I posted a couple days ago in\n\n \nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001OctDec/0011.html\n\n  As I will explain below, I would like to use UPDATE\n  with an activity source to implement step 4 in the\n  following overall use case:\n\n  My implementation has a requirement that the changes\n  in multiple activities be logically merged into a\n  shared line of descent upon completion. I would like\n  to model the shared line of descent as an activity.\n\n  Here's a summary of my overall use case:\n\n  1. Each user's client initializes a separate\n     workspace so its version-controlled members'\n     DAV:activity-set values include the shared\n     activity. I'll call this the \"integration\n     activity\" for the rest of this discussion.\n\n  2. Each user's client issues MKACTIVITY to create a\n     non-shared activity for making changes on a\n     separate line of descent from the integration\n     activity. I'll call this the \"isolation activity\"\n     for the rest of this discussion. The client then\n     PROPPATCHES the DAV:current-activity-set of its\n     workspace to the isolation activity and issues a\n     number of CHECKOUT, GET, PUT, and CHECKIN requests\n     whose request-URLs are members of the workspace.\n\n  3. At certain times while working on their isolation\n     activities, users would like to logically merge\n     the latest versions in the integration activity's\n     DAV:activity-version-set to their workspaces. (The\n     DAV:auto-activity-checkin flag to activity merge,\n     which Geoff is adding as the resolution of a\n     different discussion, makes this work cleanly.)\n\n  4. When users complete work on their isolation\n     activities, their clients issue a series of\n     requests so that the changes in the isolation\n     activities are logically merged to the integration\n     activity. This is where I think it would be useful\n     to use UPDATE with an activity source.\n\n  To implement step 4 in the use case above, my thought\n  is to have the client identify a workspace which\n  selects the latest version in the integration\n  activity, if such a version exists, for each\n  version-controlled member of that workspace. Then the\n  client would PROPPATCH the DAV:current-activity-set\n  of that workspace to the integration activity, and\n  request a MERGE where the request-URL was the\n  workspace and the source was the isolation\n  activity. Client completion of the MERGE would\n  guarantee that the latest version in the integration\n  activity was a descendant of the latest version in\n  the isolation activity at the time of the MERGE from\n  the isolation activity.\n\n  Now, how would the client ensure that each\n  version-controlled member of a workspace selected the\n  latest version in the integration activity before\n  using that workspace as the request-URL for the MERGE\n  from the isolation activity? If the workspace members\n  were under baseline control, one way would be to\n  UPDATE the workspace with baselines which selected\n  versions in the integration activity, and then MERGE\n  the integration activity into the workspace to select\n  the latest version. Another way would be to UPDATE\n  each version-controlled member of the workspace so it\n  selected the DAV:root-version of its\n  DAV:version-history, and then MERGE the integration\n  activity into the workspace - this would be simplest\n  if the client knew that all root versions of the\n  version-controlled collection members of the\n  workspace had no bindings. (Thanks to my colleague\n  Alison Macmillan for pointing out this option.)\n\n  I feel the fastest and most straightforward solution\n  would be if the client could issue an UPDATE whose\n  request-URL was the workspace and whose source was\n  the integration activity. Is there an equally fast\n  and straightforward solution already available in\n  draft-18 which I have overlooked?\n\nRoy\n\n\n\n", "id": "lists-006-14309339"}, {"subject": "Eclipsed version-controlled collection", "content": "Thanks. This resolves this question for me.\n\n\"Clemm, Geoff\" wrote:\n> \n>    From: Roy Seto [mailto:roy.seto@oracle.com]\n> \n>    Clarifications:\n> \n>    - Version-controlled collection feature: Does eclipsing a\n>      version-controlled collection eclipse its members as well?\n> \n> Yes.  A collection consists of a set of bindings.  If you eclipse a\n> collection with a non-collection, there are no members there.  If you\n> eclipse a collection with a different collection, it is the bindings\n> of the eclipsing collection that you see.\n\n\n\n", "id": "lists-006-14322316"}, {"subject": "RE: Content-Type / charset in RFC2518, deltaV and ACL spec", "content": "> I think there are good arguments on either side, but I personally\n> believe that the risk of someone blindly copying the example and\n> leaving out a needed charset parameter or an encoding attribute are\n> higher than the risk of someone using a non-UTF-8 encoding, but leaving\n> in the UTF-8 charset parameter and encoding attributes from the example.\n\nBefore we placed the charset parameter in *every* example of the\nspecification, I found that implementations were not including the charset\nparameter at all. Since this would make it very difficult to correctly\nimplement i18n features later, I added the charset parameter to all\nexamples.  I still don't think that all implementations use the charset\nparameter, or use it correctly, but I do believe it helped.\n\nOne thing I learned from the DAV specification was the large normative\neffect the examples have.  Developers sometimes code to the examples, not\nthe specification.\n\n> But I don't feel strongly about this, so if there is working\n> group consensus\n> that these charset/encoding info should be stripped from the examples\n> (or have their values be replaced by \"xxxx\"), I'm happy to make\n> that change\n> to the DeltaV spec (assuming that consensus is reached before the\n> author 48 hour period has expired :-).\n\nI feel very strongly that the charset values should be left in the DeltaV\nspecification, with their current values. This is the form the specification\nwas approved as, and the form in which it passed last call. I would have\nraised an issue during last call if these values were not in the\nspecification.\n\nFurthermore, RFC 3023 (\"XML Media Types\") states that use of the charset\nparameter is STRONGLY RECOMMENDED, and so if we do not use the charset\nparameter, the burden of explanation clearly rests on showing why it is\nbetter to omit it, than to include it.\n\n- Jim\n\n\n\n", "id": "lists-006-14330045"}, {"subject": "RE: Content-Type / charset in RFC2518, deltaV and ACL spec", "content": "Following my standard process, after last call, only unanimously\nsupported changes are made, so Jim's objection to this change will\nkeep the draft in its last call state, i.e. explicit charset and\nencoding values in the examples.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\nSent: Wednesday, October 03, 2001 3:13 PM\nTo: Webdav WG; ietf-dav-versioning@w3.org\nSubject: RE: Content-Type / charset in RFC2518, deltaV and ACL specs\n\n\n\n> I think there are good arguments on either side, but I personally\n> believe that the risk of someone blindly copying the example and\n> leaving out a needed charset parameter or an encoding attribute are\n> higher than the risk of someone using a non-UTF-8 encoding, but leaving\n> in the UTF-8 charset parameter and encoding attributes from the example.\n\nBefore we placed the charset parameter in *every* example of the\nspecification, I found that implementations were not including the charset\nparameter at all. Since this would make it very difficult to correctly\nimplement i18n features later, I added the charset parameter to all\nexamples.  I still don't think that all implementations use the charset\nparameter, or use it correctly, but I do believe it helped.\n\nOne thing I learned from the DAV specification was the large normative\neffect the examples have.  Developers sometimes code to the examples, not\nthe specification.\n\n> But I don't feel strongly about this, so if there is working\n> group consensus\n> that these charset/encoding info should be stripped from the examples\n> (or have their values be replaced by \"xxxx\"), I'm happy to make\n> that change\n> to the DeltaV spec (assuming that consensus is reached before the\n> author 48 hour period has expired :-).\n\nI feel very strongly that the charset values should be left in the DeltaV\nspecification, with their current values. This is the form the specification\nwas approved as, and the form in which it passed last call. I would have\nraised an issue during last call if these values were not in the\nspecification.\n\nFurthermore, RFC 3023 (\"XML Media Types\") states that use of the charset\nparameter is STRONGLY RECOMMENDED, and so if we do not use the charset\nparameter, the burden of explanation clearly rests on showing why it is\nbetter to omit it, than to include it.\n\n- Jim\n\n\n\n", "id": "lists-006-14339912"}, {"subject": "RE: Content-Type / charset in RFC2518, deltaV and ACL spec", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Whitehead\n> Sent: Wednesday, October 03, 2001 9:13 PM\n> To: Webdav WG; ietf-dav-versioning@w3.org\n> Subject: RE: Content-Type / charset in RFC2518, deltaV and ACL specs\n>\n>\n>\n> > I think there are good arguments on either side, but I personally\n> > believe that the risk of someone blindly copying the example and\n> > leaving out a needed charset parameter or an encoding attribute are\n> > higher than the risk of someone using a non-UTF-8 encoding, but leaving\n> > in the UTF-8 charset parameter and encoding attributes from the example.\n>\n> Before we placed the charset parameter in *every* example of the\n> specification, I found that implementations were not including the charset\n> parameter at all. Since this would make it very difficult to correctly\n> implement i18n features later, I added the charset parameter to all\n> examples.  I still don't think that all implementations use the charset\n> parameter, or use it correctly, but I do believe it helped.\n\nWait-a-second. Do you say that there is a *requirement* to declare the\ncharset if we have text/xml, and the actual encoding is UTF-8 (or a subset\nof that)? That would be new to me.\n\n> One thing I learned from the DAV specification was the large normative\n> effect the examples have.  Developers sometimes code to the examples, not\n> the specification.\n\nCorrect.\n\nTherefore I'd say put in an \"xxx\" both in the header and in the XML\ndeclaration, and add a clear description about when and how it needs to be\nset (the answer doesn't seem to be obvious after all...).\n\n> I feel very strongly that the charset values should be left in the DeltaV\n> specification, with their current values. This is the form the\n> specification\n> was approved as, and the form in which it passed last call. I would have\n> raised an issue during last call if these values were not in the\n> specification.\n\nA good point, but this shouldn't stop us from discussing it for future\nspecs.\n\n> Furthermore, RFC 3023 (\"XML Media Types\") states that use of the charset\n> parameter is STRONGLY RECOMMENDED, and so if we do not use the charset\n> parameter, the burden of explanation clearly rests on showing why it is\n> better to omit it, than to include it.\n\nI agree that the specs should conform to RFC3023.\n\nIt seems that RFC3023 uses the quoted charset value as well. This seems to\nconflict with my experience what the servlet API expects...\n\n\n\n", "id": "lists-006-14350384"}, {"subject": "Flag making DAV:response elements of UPDATE and MERGE optiona", "content": "No, I don't have performance numbers to substantiate this\nconcern at this point. \n\nIf the extension is added later, there might be a tradeoff\nbetween simplicity and compatibility with the Proposed\nStandard RFC. I think the simplest semantics would default\nto not returning the DAV:response elements (in other words,\na DAV:return-response flag is simpler than a\nDAV:omit-response flag). Also, I think clients should\nexplicitly ask for the extra response information if they\ninclude cache maintenance logic to use it. On the other\nhand, making the default return the DAV:response elements\nwould preserve the most compatibility with implementations\nof spec as it stands in draft-18.\n\nI think these obstacles can be overcome if necessary.\n\nRoy\n\n\"Clemm, Geoff\" wrote:\n> \n>    From: Roy Seto [mailto:roy.seto@oracle.com]\n> \n>    - Merge and update features: Add a flag to make DAV:response\n>      elements of UPDATE optional, and to make DAV:response elements of\n>      MERGE optional for targets modified by postcondition\n>      DAV:descendant-version. Use case: improve response times when the\n>      request-URL of the MERGE or UPDATE has an extremely large number\n>      of members whose DAV:checked-in versions are modified by the\n>      MERGE or UPDATE, and when the client's caching policy will not\n>      benefit from the DAV:response elements enough to outweigh the\n>      cost of adding the DAV:response elements to the response body.\n> \n> A server has to compute all of this information anyway (to do the\n> update), so all one would be saving would be the cost of sending the\n> info back (which is rather small chunk of information, compared to\n> what the net is set up to pass around).  But if this really turns out\n> to be an issue in practice, it certainly would be easy to add such an\n> extension.  Are you getting actual performance numbers on this that\n> concern you?\n\n\n\n", "id": "lists-006-14362236"}, {"subject": "RE: Content-Type / charset in RFC2518, deltaV and ACL spec", "content": "I think that you should limit unnecessary changes. Quoted\nparameters are valid, and removing things in examples that\nmight not work in some broken implementations doesn't\nseem like it's a \"necessary change\".\n\n\n> In general, I think it really doesn't make sense to specify character sets\n> in specs (unless the spec is talking about encodings, of course). The spec\n> contains characters after all (not an octet stream). Of course this also\n> affects XML declarations in the specs.\n\nThe charset parameter is strongly recommended in\nRFC 3023.\n\n\n\n", "id": "lists-006-14371694"}, {"subject": "Precursor set optional", "content": "Can precursorset be optional?  It can't be calculated on-the-fly; therefore\nit must be stored.  Must all servers store this?\n\nlisa\n\n\n\n", "id": "lists-006-1437718"}, {"subject": "DAV:option", "content": "Sorry for the late comment on the spec:\n\nIn x.x Additional OPTIONS Semantics\n\n  Additional Marshalling:\n  If an XML request body is included, it MUST be a DAV:options XML element.\n\nShould be:\n\n  If an XML request body is included, and the document element is\nDAV:options\n  and the server supports the xxxx feature, the server MUST process a\npossible\n  DAV:xxx-set child element of DAV:options.\n  If the request is successful, the response...\n\nNot every OPTIONS XML request body to a HTTP server must include\nDAV:options, right?\n\n//Stefan\n\n\n\n", "id": "lists-006-14380428"}, {"subject": "Re: Why does MERGE automatically checkin resources related to act ivities", "content": "On Wed, Oct 03, 2001 at 09:32:59AM -0400, Clemm, Geoff wrote:\n>    From: Greg Stein [mailto:gstein@lyra.org]\n>...\n> The main problem with that marshalling is how can you tell the\n> difference between:\n> \n> - someone who wants to create a bunch of new resources, i.e. create a\n>   set of new VHRs whose initial versions happen to be initialized by\n>   the content of an existing tree of VCRs.\n> \n> - someone that wants to create new versions for a set of existing VHRs\n\nDon't need to tell the difference :-)  We only support the former.\n\n> In particular, DeltaV defines the semantics of the COPY into a\n> working directory to be the former, i.e. create a set of new VHR's\n> when the working collection is checked in.\n\nWell, that is just dandy for our case :-)\n\n>...\n> OK, I misunderstood.  I thought by \"cheap copy\", you meant creating a\n> new tree of VCRs that share the VHRs of an existing tree of VCRs.\n> Instead, you meant creating a tree of (non-version-controlled) resources\n> within a working collection.\n\nCorrect. And those new resources become version-controlled upon checkin.\n\n>...\n> So you are not going to support \"revision branching\" (i.e. where the\n> revision history itself branches)?  That does sound vaguely familiar,\n> so probably you did tell me that a while ago.\n\nPurely sequential, global revision numbers. Each revision is effectively a\nbaseline for the whole repository. No branching; just work on stuff in a\ndifferent \"subdirectory\" within the virtual filesystem.\n\n>    The basic issue here is that the model used by Subversion (and I suspect a\n>    goodly number of other systems) does not provide for checking in a new\n>    \"head\" revision and hiding it until somebody cares to make it visible.\n> \n> I thought it was a fairly central CVS feature to create a new \"branch\"\n> of the repository, to do a whole series of checkins on a branch, and\n> then only merge that repository branch on demand (although I agree\n> that it doesn't to the merge part very well)?  That's what separating\n> CHECKIN and MERGE is all about.\n\nBecause CVS sucks so hard at the merge process, nobody ever uses branches\nfor temporary hiding of checkins. They are normally just used for longer\nterm branches.\n\n[ yes, some people *do* create branches for every change. they're masochists ]\n\nAnd creating a branch on *every* commit, just to support the two-phase\nCHECKIN / MERGE? Bah. I don't care for persistent data artifacts that result\nfrom a faulty design spec.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-14388203"}, {"subject": "RE: Why does MERGE automatically checkin resources related to act  ivities", "content": "I've got a few more questions for Greg about the subversion model (so\nthat I can understand its mapping to DeltaV).  This thread may be\ndrifting a bit off topic though, and if so, please send me private\nemail and I can redirect it to a subversion mailing list.\n\n   From: Greg Stein [mailto:gstein@lyra.org]\n\n   Purely sequential, global revision numbers. Each revision is\n   effectively a baseline for the whole repository. No branching; just\n   work on stuff in a different \"subdirectory\" within the virtual\n   filesystem.\n\nDoes subversion allow you to \"merge\" that work in a different\nsubdirectory back to the directory where they came from?  For example,\nif you do:\n\n CHECKOUT /repo/proj/\n => /repo/wr/173\n\n COPY /repo/proj/projA\n Destination: /repo/wr/173/my-projA\n\n CHECKIN /repo/wr/173/my-projA\n\nYou've now got a copy of projA in /repo/my-projA.  You can now make\nchanges to my-projA independent of changes to projA.  But you cannot\nuse MERGE to merge the changes from my-projA back to projA.\nWhereas if you had used a sequence of VERSION-CONTROL requests to\ncreate /repo/proj/my-projA, you could merge my-projA back to projA.\n\n   > I thought it was a fairly central CVS feature to create a new \"branch\"\n   > of the repository, to do a whole series of checkins on a branch, and\n   > then only merge that repository branch on demand.\n\n   Because CVS sucks so hard at the merge process, nobody ever uses\n   branches for temporary hiding of checkins. They are normally just\n   used for longer term branches.\n\nYes, I totally agree that you don't want to create a branch for every\nchange.  In the normal case, you just checkout into some activity the\nfiles you want to change, muck with them for a while on your client,\nupdate the working resources, and then MERGE your activity back to the\nrepository.\n\nWhat I was really asking about was those cases where you actually do\nwant to run in parallel for a while (i.e. doing early dev work on a\nnew release while the current release is being stabilized), but where\nyou want to periodically merge work between those parallel streams.\nIs that going to be supported by Subversion?  And if so, how did you\nplan on marshalling the creation of the parallel area, and the merge\nback?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14398535"}, {"subject": "RE: option", "content": "Every statement in the DeltaV protocol is implicitly wrapped\nwith the prefix \"If the feature of this section is supported, then ...\".\nSo the request body MUST be DAV:options if any of the DeltaV features\nare supported by the server.\n\nBut I agree that it would be more precise to qualify any statement\nabout the response body marshalling with the statement \"if the request\nsucceeds\" (since if it does not, you often get a DAV:error node as\nthe response body).  I will try to squeeze this into the final editing pass.\nThanks for noticing that!\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\nSent: Thursday, October 04, 2001 6:15 AM\nTo: ietf-dav-versioning@w3.org\nSubject: DAV:options\n\n\nSorry for the late comment on the spec:\n\nIn x.x Additional OPTIONS Semantics\n\n  Additional Marshalling:\n  If an XML request body is included, it MUST be a DAV:options XML element.\n\nShould be:\n\n  If an XML request body is included, and the document element is\nDAV:options\n  and the server supports the xxxx feature, the server MUST process a\npossible\n  DAV:xxx-set child element of DAV:options.\n  If the request is successful, the response...\n\nNot every OPTIONS XML request body to a HTTP server must include\nDAV:options, right?\n\n//Stefan\n\n\n\n", "id": "lists-006-14407977"}, {"subject": "RE: Content-Type / charset in RFC2518, deltaV and ACL spec", "content": "[freed from spam filter -rrs]\n\nDate: Thu, 4 Oct 2001 04:13:11 -0400 (EDT)\nMessage-ID: <JIEGINCHMLABHJBIGKBCMELHDCAA.julian.reschke@gmx.de>\nFrom: \"Julian Reschke\" <julian.reschke@gmx.de>\nTo: \"Larry Masinter - LMM@acm.org\" <lmnet@attglobal.net>,\n        \"Clemm, Geoff\" <gclemm@rational.com>,\n        \"Webdav WG\" <w3c-dist-auth@w3c.org>, <ietf-dav-versioning@w3.org>\n\n> From: w3c-dist-auth-request@w3.org\n> [mailto:w3c-dist-auth-request@w3.org]On Behalf Of Larry Masinter -\n> LMM@acm.org\n> Sent: Thursday, October 04, 2001 8:37 AM\n> To: Clemm, Geoff; Webdav WG; ietf-dav-versioning@w3.org\n> Subject: RE: Content-Type / charset in RFC2518, deltaV and ACL specs\n>\n>\n> I think that you should limit unnecessary changes. Quoted\n> parameters are valid, and removing things in examples that\n> might not work in some broken implementations doesn't\n> seem like it's a \"necessary change\".\n\nSo, could you please clarify some more?\n\n1) Both unquoted and quoted parameters are valid (according to HTTP 1.1)?\n2) RFC3023 uses quoted parameters in it's examples, but unquoted parameters\nwould be OK as well?\n3) Known broken implementations regarding quoted parameters are: ...\n\n> > In general, I think it really doesn't make sense to specify\n> character sets\n> > in specs (unless the spec is talking about encodings, of\n> course). The spec\n> > contains characters after all (not an octet stream). Of course this also\n> > affects XML declarations in the specs.\n>\n> The charset parameter is strongly recommended in\n> RFC 3023.\n\nYes. But my point is that an encoding declaration is only meaningful for a\ngiven octet stream -- which we don't have in an example in an RFC. If these\ndeclarations are in, they should come with a warning that this example\nassumes that the request/response body actually *is* encoded in UTF-8 (or a\nsubset of it), and that otherwise it must match the actual encoding.\n\nBTW: as XML parsers may reject any encoding other than Unicode (and\nsubsets), I'd also propose to add wording that request/response bodies\nSHOULD be encoded in one of the standard XML encodings (or refer to a\nsection in RFC3023 that says that).\n\nI've seen \"WebDAV\" implementations that send reponse bodies in\n(properly-declared) Windows encodings (it is Hotmail) :-)\n\n\n\n", "id": "lists-006-14416562"}, {"subject": "RE: option", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> \n> Every statement in the DeltaV protocol is implicitly wrapped\n> with the prefix \"If the feature of this section is supported, then ...\".\n> So the request body MUST be DAV:options if any of the DeltaV features\n> are supported by the server.\n\nSuppose I invent the Value-Added-Dummy Protocol and have a super feature\nthat allows clients to send VAD:options XML request bodies in OPTIONS\nmethods. Would every deltaV-compliant server choke on such client\nrequests or just ignore the VAD:options request bodies?\n\n//Stefan\n\n> But I agree that it would be more precise to qualify any statement\n> about the response body marshalling with the statement \"if the request\n> succeeds\" (since if it does not, you often get a DAV:error node as\n> the response body).  I will try to squeeze this into the final \n> editing pass.\n> Thanks for noticing that!\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n> Sent: Thursday, October 04, 2001 6:15 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: DAV:options\n> \n> \n> Sorry for the late comment on the spec:\n> \n> In x.x Additional OPTIONS Semantics\n> \n>   Additional Marshalling:\n>   If an XML request body is included, it MUST be a DAV:options \n> XML element.\n> \n> Should be:\n> \n>   If an XML request body is included, and the document element is\n> DAV:options\n>   and the server supports the xxxx feature, the server MUST process a\n> possible\n>   DAV:xxx-set child element of DAV:options.\n>   If the request is successful, the response...\n> \n> Not every OPTIONS XML request body to a HTTP server must include\n> DAV:options, right?\n> \n> //Stefan\n> \n> \n> \n> \n> \n\n\n\n", "id": "lists-006-14428918"}, {"subject": "List of DeltaV questions, issues, and extension", "content": "I have been discussing a DeltaV implementation with\nseveral colleagues at Oracle, and we have a list of\nquestions, issues, and possible extensions to the\nprotocol. I understand the Proposed Standard RFC is in\nits final editing pass so there is very limited scope\nfor change in this RFC iteration. However, I will still\npost these items for discussion in the working group.\n\nBelow is a summary of items I intend to post in more\ndetail ASAP.\n\nRoy\n\n--\n\nClarifications\n\n- Version-controlled collection feature: Does eclipsing\n  a version-controlled collection eclipse its members\n  as well?\n\n- Activity feature: Is there an interoperable way to\n  \"close\" an activity (that is, prevent any more\n  checkouts or checkins in that activity)? Followup: if\n  not, how much demand would there be for standardizing\n  this concept?\n\n\nIs this a bug?\n\n- Baseline feature: Is it possible to construct a\n  workspace which contains multiple VCR's with\n  different DAV:checked-in versions for a given VHR by\n  doing a MOVE of a VCR from one baseline-controlled\n  collection to another, and then UPDATING the VCC's\n  for those BCC's?\n\n\nPossible extensions\n\n- Activity feature, update feature: Define the\n  semantics of UPDATE where the source is an\n  activity. Use case: Provide a performant standard way\n  for clients to ensure that the members of a workspace\n  select the latest version of an activity. This is key\n  to support the concept of merging to an activity (by\n  merging to a workspace which selects the latest\n  versions in that activity). (Note: ideally, this\n  extension would also modify generic UPDATE\n  marshalling so the DAV:update element had a\n  DAV:source child element, like MERGE does, instead of\n  a DAV:version element. An activity resource is not a\n  version resource).\n\n- Merge and update features: Add a flag to make\n  DAV:response elements of UPDATE optional, and to make\n  DAV:response elements of MERGE optional for targets\n  modified by postcondition DAV:descendant-version. Use\n  case: improve response times when the request-URL of\n  the MERGE or UPDATE has an extremely large number of\n  members whose DAV:checked-in versions are modified by\n  the MERGE or UPDATE, and when the client's caching\n  policy will not benefit from the DAV:response\n  elements enough to outweigh the cost of adding the\n  DAV:response elements to the response body.\n\n- Autoversioning (extension), baseline feature (use\n  case): In Section 3.2.2, change the EMPTY elements in\n  the DAV:auto-version property values to ANY, enabling\n  DAV:checkin and DAV:checkout elements with default\n  checkin and checkout options for the autoversioned\n  VCR to be applied at auto-checkin and auto-checkout\n  time. Use case: multiple workspaces share the same\n  DAV:current-activity-set and the same DAV:checked-in\n  baselines for their version-controlled\n  configurations, and those VCCs' DAV:auto-version\n  properties are DAV:checkout. There is a problem\n  because baseline-controlled members of those\n  workspaces cannot be checked in even if they are for\n  different version histories - only the first\n  workspace can auto-checkout its VCC unreserved in the\n  shared DAV:current-activity-set.\n  \n\nResolved\n\n- Merge feature: Should the DAV:merge-preview report\n  have the same response format as the MERGE and UPDATE\n  methods? Resolution: it is acceptable the way it is\n  in draft-18 - clients can request a DAV:merge-preview\n  report to get more detailed information about a merge\n  in a different format than the original MERGE.\n\n- Activity feature: Add a DAV:auto-activity-checkin\n  flag to MERGE from activities, putting the\n  auto-activity-checkin behavior under client\n  control. The use cases have to do with merging from\n  an activity which has an interesting state you want\n  to merge from your workspace, even though the\n  activity is not yet done. Resolution: If the working\n  group accepts Geoff's proposal for an\n  auto-activity-checkin flag to activity merge, that\n  would meet my requirement.\n\n\n-- end of question, issue, and extension list --\n\n\n\n", "id": "lists-006-14438839"}, {"subject": "Confusion: Removing a resource from version contro", "content": "I'm confused about this paragraph in 15.1, section 2.2.1:\n\n\"In order to remove a resource from version control, a client can COPY the\nversion-controlled resource to a temporary location, DELETE the\nversion-controlled resource, and then MOVE the copy from the temporary\nlocation back to the original URL.  The versions created for that resource\nwhile it was under version control will continue to exist at their\nserver-defined locations.\"\n\nI'd parse the first sentence to mean that when the COPY is done, only one\nversion is created at the destination.  Then when the MOVE back is done,\nonly one version is available at the original location.  This has the effect\nof replacing 'n' versions with 1 version, and replacing a VCR with a\nnon-version-controlled (ordinary) resource.\n\nThen I read the second sentence, and I get confused.  The versions all still\nexist?  Why?  What's the point?  How can that be?\n\nlisa\n\n\n\n", "id": "lists-006-1444626"}, {"subject": "RE: options (* contains proposed editorial change to DeltaV *", "content": "   From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n\n   Suppose I invent the Value-Added-Dummy Protocol and have a super feature\n   that allows clients to send VAD:options XML request bodies in OPTIONS\n   methods. Would every deltaV-compliant server choke on such client\n   requests or just ignore the VAD:options request bodies?\n\nGood point.  It doesn't make sense to require that the request body\nof an existing method (e.g. OPTIONS) be something not defined in the\noriginal\ndefinition of that method (since this would just lead to the kind\nof conflict that Stefan identified).\n\nI propose that we reword the OPTIONS extensions to say:\n\"If the request body is DAV:options, then the response body MUST\nbe DAV:options-respose.\"  This then allows these kinds of parallel\nextensions to the OPTIONS method to coexist.\n\nThis is of course very late in the cycle, but since this changes\nnone of the semantics of the DeltaV protocol, but does allow for\nbetter interoperation between parallel extensions to the OPTIONS\nmethod, I would like to make this change if nobody objects.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14449758"}, {"subject": "Allowing non-default options for auto-checkout and -checki", "content": "I'm following up on this discussion from \n\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001OctDec/0021.html\n\nin a separate thread. Would it be appropriate to\nconsider part of these changes in the editorial pass\nfor the initial RFC?\n\n\nI wrote:\n\n   - Autoversioning (extension), baseline feature (use\n     case): In Section 3.2.2, change the EMPTY elements\n     in the DAV:auto-version property values to ANY,\n     enabling DAV:checkin and DAV:checkout elements\n     with default checkin and checkout options for the\n     autoversioned VCR to be applied at auto-checkin\n     and auto-checkout time. Use case: multiple\n     workspaces share the same DAV:current-activity-set\n     and the same DAV:checked-in baselines for their\n     version-controlled configurations, and those VCCs'\n     DAV:auto-version properties are\n     DAV:checkout. There is a problem because\n     baseline-controlled members of those workspaces\n     cannot be checked in even if they are for\n     different version histories - only the first\n     workspace can auto-checkout its VCC unreserved in\n     the shared DAV:current-activity-set.\n\nGeoff replied:\n\n     That sounds pretty reasonable to me.  I might just\n     give these their own property names though, so\n     that it is easier for a client to determine if\n     this option is supported.\n\n-- \n\nContinuing this discussion, is there a possibility that\nsome of the following changes might be made in the first\nRFC?\n\n   - In Section 3.2.2, change the EMPTY elements in the\n     DAV:auto-version property values to ANY to enable\n     better extensibility of those property\n     values. \n\n     (The extension I have in mind is to include a\n     DAV:checkout or DAV:checkin element within the\n     DAV:auto-version property value to allow options\n     to be specified in auto-checkout and auto-checkin\n     operations.)\n\n  or, \n\n   - Around Section 3.2.2, define additional property\n     names to hold options for auto-checkout and\n     auto-checkin operations.\n\n\nHere is my use case in more detail.\n\nMultiple users want to collaborate fairly closely on\nchanges to an existing set of resources, but they still\nwant some isolation. Their DeltaV server supports the\nadvanced server workspace package. The users' editing\nclients only support the basic server workspace\npackage, but they also have an advanced versioning\n\"helper\" client to perform workspace setup tasks.\n\nThe users make their edits in separate workspaces to\ngain some degree of isolation. They start working from\nthe same starting point. This is implemented by\ninitially putting the workspaces under the control of\nthe same baseline(s). Because the users wish to\ncollaborate closely, they work in the same activity to\navoid performing logical content merging among\nthemselves.\n\nAn advanced versioning \"helper\" client sets up the\nusers' workspaces by setting up the initial state of\ntheir baseline-controlled collections and\nDAV:current-activity-set property values. This helper\nclient can also import other users' checkins from the\nshared activity into each workspace by requesting a\nMERGE from that activity into the workspace with the\nactivity checkin parameter turned off.\n\nTo allow the users' editing clients, which understand\nthe basic server workspace package, but not the\nadvanced features, to checkin baseline-controlled\nworkspace members, those baselines' version-controlled\nconfigurations' DAV:auto-version property values are\nDAV:checkout.\n\nThis is where I run into trouble if there is no way to\ndeviate from the default options for checkout and\ncheckin when they happen during autoversioning. When\nthe first checkin request for a baseline-controlled\nworkspace member is processed, its version-controlled\nconfiguration is automatically checked out by\nautoversioning. This checkout occurs in the workspace's\n(shared) DAV:current-activity-set, and 13.10 seems to\nimply that the checkout should be the reserved\ndefault. Now, when a second workspace also processes a\ncheckin request for a member under the control of the\nsame baseline, the server will attempt an auto-checkout\nfor the second workspace's version-controlled\nconfiguration in the same shared activity. Unless the\nauto-checkout is allowed be unreserved instead of the\nreserved default, this second auto-checkout MUST fail\nby precondition\nDAV:one-checkout-per-activity-per-history in 13.10.\n\nRoy\n\n\n\n", "id": "lists-006-14458001"}, {"subject": "&quot;Closing&quot; an activit", "content": "I'm following up on this discussion from \n\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001OctDec/0021.html\n\nin a separate thread. At this point, I'm just looking \nfor clarification whether my interpretation of the \nspec is accurate.\n\nI wrote:\n\n   - Activity feature: Is there an interoperable way to\n     \"close\" an activity (that is, prevent any more\n     checkouts or checkins in that activity)? Followup:\n     if not, how much demand would there be for\n     standardizing this concept?\n\nGeoff replied:\n\n     I suggest we should soon start a follow-on \"change\n     request\" working group (we could start under the\n     auspices of the WebDAV working group).  In\n     particular, we would then discuss various states\n     that an activity could be in, and how to\n     standardize transitions between those states (is\n     PROPPATCH enough?).  Minimally, we could decide on\n     some standard XML element for the state field of\n     an activity, and a few \"standard\" state values.\n     Perhaps a BOF at the Dec IETF?\n\n--\n\nContinuing this discussion, Geoff's proposal sounds\nreasonable to me, though I'm not sure I have any\nactivity states to propose beyond \"closed\" and \"not\nclosed.\"\n\nTo validate my understanding of the spec, it seems to\nme that there is currently no interoperable way to\nprevent checkouts and checkins from occurring in an\nactivity. \n\nIn particular, RFC 2518 write locks on the activity\nresource don't do this because RFC 2518 Section 9.3\nsays\n\n   While those without a write lock may not alter a\n   property on a resource it is still possible for the\n   values of live properties to change, even while\n   locked, due to the requirements of their schemas.\n   Only dead properties and live properties defined to\n   respect locks are guaranteed not to change while\n   write locked.\n\nSo taking a write lock on the activity resource does\nnot restrict changes on that activity's\nDAV:activity-version-set or DAV:activity-checkout-set\nproperty values.\n\nAlso, draft-ietf-webdav-acl-06 Section 3.2 says \n\n   The [DAV:write] privilege controls methods that\n   modify the content, dead properties, or (in the case\n   of a collection) membership of a resource, such as\n   PUT or PROPPATCH.\n\nSo restricting the DAV:write privilege in an activity\nresource's DAV:acl property doesn't restrict changes in\nthat activity's DAV:activity-version-set or\nDAV:activity-checkout-set either.\n\nIs my understanding correct?\n\nThanks,\nRoy\n\n\n\n", "id": "lists-006-14469874"}, {"subject": "Re: &quot;Closing&quot; an activit", "content": "One more thing, I also looked at DeltaV draft-18\nSection 1.8, which says\n\n   If a write-locked resource has a non-computed\n   property defined by this document, the property\n   value MUST NOT be changed by a request unless the\n   appropriate lock token is included in the request.\n\nBut since 13.1.1 and 13.1.2 define the\nDAV:activity-version-set and DAV:activity-checkout-set\nproperties of an activity as computed, it still holds\nthat write locks on activity resources do not restrict\ncheckouts or checkins in that activity. \n\nSomeone please correct me if I've missed something.\n\nThanks,\nRoy\n\nRoy Seto wrote:\n> \n> I'm following up on this discussion from\n> \n> http://lists.w3.org/Archives/Public/ietf-dav-versioning/2001OctDec/0021.html\n> \n> in a separate thread. At this point, I'm just looking\n> for clarification whether my interpretation of the\n> spec is accurate.\n> \n> I wrote:\n> \n>    - Activity feature: Is there an interoperable way to\n>      \"close\" an activity (that is, prevent any more\n>      checkouts or checkins in that activity)? Followup:\n>      if not, how much demand would there be for\n>      standardizing this concept?\n> \n> Geoff replied:\n> \n>      I suggest we should soon start a follow-on \"change\n>      request\" working group (we could start under the\n>      auspices of the WebDAV working group).  In\n>      particular, we would then discuss various states\n>      that an activity could be in, and how to\n>      standardize transitions between those states (is\n>      PROPPATCH enough?).  Minimally, we could decide on\n>      some standard XML element for the state field of\n>      an activity, and a few \"standard\" state values.\n>      Perhaps a BOF at the Dec IETF?\n> \n> --\n> \n> Continuing this discussion, Geoff's proposal sounds\n> reasonable to me, though I'm not sure I have any\n> activity states to propose beyond \"closed\" and \"not\n> closed.\"\n> \n> To validate my understanding of the spec, it seems to\n> me that there is currently no interoperable way to\n> prevent checkouts and checkins from occurring in an\n> activity.\n> \n> In particular, RFC 2518 write locks on the activity\n> resource don't do this because RFC 2518 Section 9.3\n> says\n> \n>    While those without a write lock may not alter a\n>    property on a resource it is still possible for the\n>    values of live properties to change, even while\n>    locked, due to the requirements of their schemas.\n>    Only dead properties and live properties defined to\n>    respect locks are guaranteed not to change while\n>    write locked.\n> \n> So taking a write lock on the activity resource does\n> not restrict changes on that activity's\n> DAV:activity-version-set or DAV:activity-checkout-set\n> property values.\n> \n> Also, draft-ietf-webdav-acl-06 Section 3.2 says\n> \n>    The [DAV:write] privilege controls methods that\n>    modify the content, dead properties, or (in the case\n>    of a collection) membership of a resource, such as\n>    PUT or PROPPATCH.\n> \n> So restricting the DAV:write privilege in an activity\n> resource's DAV:acl property doesn't restrict changes in\n> that activity's DAV:activity-version-set or\n> DAV:activity-checkout-set either.\n> \n> Is my understanding correct?\n> \n> Thanks,\n> Roy\n\n\n\n", "id": "lists-006-14479832"}, {"subject": "Creating new version-controlled bindings referencing existing VHR'", "content": "I have a question about version-controlled collections. \n\nIs there currently an interoperable way for clients to add a\nbinding in a version-controlled collection to a VCR whose\nDAV:version-history is an existing VHR? One use case would\nbe client completion of a MERGE whose target was a\nversion-controlled collection, where the server added a\nsource collection version to that target's DAV:merge-set\ninstead of its DAV:auto-merge-set.\n\nI couldn't find a way to do this, though the BIND method\nproposed in the expired Internet-Draft on WebDAV bindings,\n\nhttp://www.ics.uci.edu/pub/ietf/webdav/collection/draft-ietf-webdav-binding-protocol-02.txt\n\nseems like it might work if it were standardized,\nparticularly if BIND were extended to create a new VCR when\nits request-URI was a version resource.\n\nIs there an existing interoperable way to do what I want\nthat I have overlooked? Also, if there isn't, is my thinking\nabout BIND going in a reasonable direction?\n\nThanks,\nRoy\n\n\n\n", "id": "lists-006-14490210"}, {"subject": "RE: Creating new version-controlled bindings referencing existing  VHR'", "content": "   From: Roy Seto [mailto:Roy.Seto@oracle.com]\n\n   I have a question about version-controlled collections. \n\n   Is there currently an interoperable way for clients to add a\n   binding in a version-controlled collection to a VCR whose\n   DAV:version-history is an existing VHR?\n\nYes, just use the VERSION-CONTROL request with a version\nspecified.\n\n   One use case would\n   be client completion of a MERGE whose target was a\n   version-controlled collection, where the server added a\n   source collection version to that target's DAV:merge-set\n   instead of its DAV:auto-merge-set.\n\nYes.\n\n   I couldn't find a way to do this, though the BIND method\n   proposed in the expired Internet-Draft on WebDAV bindings,\n\n \nhttp://www.ics.uci.edu/pub/ietf/webdav/collection/draft-ietf-webdav-binding-\nprotocol-02.txt\n\n   seems like it might work if it were standardized,\n   particularly if BIND were extended to create a new VCR when\n   its request-URI was a version resource.\n\nI wouldn't advocate that approach, since you might want to\nactually bind a version resource into a collection without\nautomatically creating a VCR.\n\n   Is there an existing interoperable way to do what I want\n   that I have overlooked? Also, if there isn't, is my thinking\n   about BIND going in a reasonable direction?\n\nYes (see above), and no (see above :-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14497809"}, {"subject": "RE: &quot;Closing&quot; an activit", "content": "   From: Roy Seto [mailto:Roy.Seto@oracle.com]\n\n   I'm following up on this discussion from \n\n \nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001OctDec/0021.html\n\n   in a separate thread. At this point, I'm just looking for\n   clarification whether my interpretation of the spec is accurate.\n\n   I wrote:\n\n      - Activity feature: Is there an interoperable way to \"close\" an\nactivity (that is, prevent any more checkouts or checkins in\nthat activity)? Followup: if not, how much demand would there\nbe for standardizing this concept?\n\n   Geoff replied:\n\nI suggest we should soon start a follow-on \"change request\"\nworking group (we could start under the auspices of the WebDAV\nworking group).  In particular, we would then discuss various\nstates that an activity could be in, and how to standardize\ntransitions between those states (is PROPPATCH enough?).\nMinimally, we could decide on some standard XML element for\nthe state field of an activity, and a few \"standard\" state\nvalues.  Perhaps a BOF at the Dec IETF?\n\n   Continuing this discussion, Geoff's proposal sounds reasonable to\n   me, though I'm not sure I have any activity states to propose\n   beyond \"closed\" and \"not closed.\"\n\n\"new\" \"open\" \"scheduled\" \"active\" \"fixed\" \"no-plan-to-fix\"\n\"unreproducible\" ...\n\n   To validate my understanding of the spec, it seems to me that there\n   is currently no interoperable way to prevent checkouts and checkins\n   from occurring in an activity.\n\nThat is correct.  We would need to introduce something like the\n\"state\" property that you propose to get this functionality.\nI believe that is significantly superior to trying to use\nLOCK functionality, because there is no need for the complexity\nadded by requiring a lock token.\n\n   In particular, RFC 2518 write locks on the activity resource don't\n   do this because RFC 2518 Section 9.3 says:\n\n      While those without a write lock may not alter a property on a\n      resource it is still possible for the values of live properties\n      to change, even while locked, due to the requirements of their\n      schemas.  Only dead properties and live properties defined to\n      respect locks are guaranteed not to change while write locked.\n\n   So taking a write lock on the activity resource does not restrict\n   changes on that activity's DAV:activity-version-set or\n   DAV:activity-checkout-set property values.\n\n   Also, draft-ietf-webdav-acl-06 Section 3.2 says \n\n      The [DAV:write] privilege controls methods that modify the\n      content, dead properties, or (in the case of a collection)\n      membership of a resource, such as PUT or PROPPATCH.\n\n   So restricting the DAV:write privilege in an activity resource's\n   DAV:acl property doesn't restrict changes in that activity's\n   DAV:activity-version-set or DAV:activity-checkout-set either.\n\n   Is my understanding correct?\n\nYes.  We could of course introduce a special privilege that controls\nchanging the DAV:activity-version-set or DAV:activity-checkout-set,\nbut I believe the activity state field is better for this purpose.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14506987"}, {"subject": "RE: Allowing non-default options for auto-checkout and -checki", "content": "   From: Roy Seto [mailto:Roy.Seto@oracle.com]\n\n   I'm following up on this discussion from \n\n \nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001OctDec/0021.html\n\n   in a separate thread. Would it be appropriate to consider part of\n   these changes in the editorial pass for the initial RFC?\n\nI believe that this functionality can be achieved in a way that is\ncompatible with the current draft, i.e. no changes to the current\ndraft are needed for servers to support this extension.  (Note: I \nwould not want to actually make the extension in the editorial pass).\n\n      - Autoversioning (extension), baseline feature (use case): In\nSection 3.2.2, change the EMPTY elements in the\nDAV:auto-version property values to ANY, enabling DAV:checkin\nand DAV:checkout elements with default checkin and checkout\noptions for the autoversioned VCR to be applied at\nauto-checkin and auto-checkout time. Use case: multiple\nworkspaces share the same DAV:current-activity-set and the\nsame DAV:checked-in baselines for their version-controlled\nconfigurations, and those VCCs' DAV:auto-version properties\nare DAV:checkout. There is a problem because\nbaseline-controlled members of those workspaces cannot be\nchecked in even if they are for different version histories -\nonly the first workspace can auto-checkout its VCC unreserved\nin the shared DAV:current-activity-set.\n\nI agree that this is a reasonable use case.\n\n   Continuing this discussion, is there a possibility that some of the\n   following changes might be made in the first RFC?\n\n      - In Section 3.2.2, change the EMPTY elements in the\nDAV:auto-version property values to ANY to enable better\nextensibility of those property values.\n\n(The extension I have in mind is to include a\nDAV:checkout or DAV:checkin element within the\nDAV:auto-version property value to allow options\nto be specified in auto-checkout and auto-checkin\noperations.)\n\nI wouldn't want to embed it in the DAV:auto-version property values,\nsince that would make it hard for the client to discover whether\nthis extension is supported.\n\n     or, \n\n      - Around Section 3.2.2, define additional property names to hold\noptions for auto-checkout and auto-checkin operations.\n\nThat is how I'd want to define the extensions, but is more than I'd\nwant to do in an editorial pass.  Let's define those new properties in\ndraft form, and add it to the \"proposed extensions\" list.  (we already\nhave one such proposed extension on the web site, the \"checkin URI\"\nextension).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14517715"}, {"subject": "RE: &quot;Closing&quot; an activit", "content": "   From: Roy Seto [mailto:Roy.Seto@oracle.com]\n\n   One more thing, I also looked at DeltaV draft-18 Section 1.8, which\n   says\n\n      If a write-locked resource has a non-computed property defined\n      by this document, the property value MUST NOT be changed by a\n      request unless the appropriate lock token is included in the\n      request.\n\n   But since 13.1.1 and 13.1.2 define the DAV:activity-version-set and\n   DAV:activity-checkout-set properties of an activity as computed, it\n   still holds that write locks on activity resources do not restrict\n   checkouts or checkins in that activity.\n\nCorrect.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14528280"}, {"subject": "Re: Allowing non-default options for auto-checkout and -checki", "content": "\"Clemm, Geoff\" wrote:\n> \n>    From: Roy Seto [mailto:Roy.Seto@oracle.com]\n> \n>    I'm following up on this discussion from\n> \n> \n> http://lists.w3.org/Archives/Public/ietf-dav-versioning/2001OctDec/0021.html\n> \n>    in a separate thread. Would it be appropriate to consider part of\n>    these changes in the editorial pass for the initial RFC?\n> \n> I believe that this functionality can be achieved in a way that is\n> compatible with the current draft, i.e. no changes to the current\n> draft are needed for servers to support this extension.  (Note: I\n> would not want to actually make the extension in the editorial pass).\n\nOk.\n\n>      or,\n> \n>       - Around Section 3.2.2, define additional property names to hold\n>         options for auto-checkout and auto-checkin operations.\n> \n> That is how I'd want to define the extensions, but is more than I'd\n> want to do in an editorial pass.  Let's define those new properties in\n> draft form, and add it to the \"proposed extensions\" list.  (we already\n> have one such proposed extension on the web site, the \"checkin URI\"\n> extension).\n\nOk. That sounds like a reasonable resolution to me.\n\nThanks,\nRoy\n\n\n\n", "id": "lists-006-14535947"}, {"subject": "Question on support for in-place editin", "content": "DeltaV supports an in-place editing model for situations where the server\ndoes not support the Working Resource option, and where the client does not\ndo all their edits on their local copy.\n\nBy \"in-place editing\" I mean that when the VCR is checked out, clients can\ndo any number of PUT, PROPPATCH and other write operations, before finally\nchecking in.  In the meantime, this work-in-progress is available for other\nusers to see if they have permission to read the resource.\n\nFirst question: Does anybody plan to implement DeltaV this way?  [I believe\nSubversion effectively will (correct me if I'm wrong) but in practice\nSubversion clients wouldn't do their write operations until just before\nchecking in, so there would only be a small window of opportunity to see\nworks-in-progress. ]\n\nSecond question:  Is there a way for clients to view working resources and\nonly see the latest checked-in versions?  E.g. I may be uninterested in\nseeing \"works in progress\" affected by in-place editing.  Can I do a\nPROPFIND depth-1 against the latest checked-in versions in a collection,\nrather than the works-in-progress?\n\nlisa\n\n\n\n", "id": "lists-006-1454372"}, {"subject": "Finding the Baseline-Controlled Collection given a working baseli ne..", "content": "Hi,\n\nAs I have mentioned before section 13.12 talks about auto-checkin of a\nworking baseline and seems to \nsuggest that the MERGE method should then use the Baseline-Controlled\nCollection (referenced by the \nworking baseline) as the merge target.  My problem is how to find the\nBaseline-Controlled Collection \ngiven a working baseline.\n\nDoes the working baseline have a property which identifies the\nBaseline-Controlled Collection?\nI do not see this property defined in the specification, so the only way I\ncan see to find a \nBaseline-Controlled Collection given a working baseline would be to:\n\n*Find the Baseline History for this working baseline:\nThis is more than one operation because a checked-out resource does\nnot have a DAV:version-history \nproperty.  You need to find a version in the DAV:checked-out\nproperty and query the DAV:version-history \nfrom that resource.\n\n*Find a Version-Controlled Configuration that references the baseline\nhistory (there should only be one?):\nThis is also not possible in one operation, you must find all VCCs\nin the system (you probably do this \nby assuming they are all rooted in some server defined collection eg\n/vcc) for each one you PROPFIND the\nDAV:version-history property looking for a reference to the desired\nbaseline history.\n\n*Now you have the VCC you can query it's\nDAV:baseline-controlled-collection property!\n\nThis seems like a lot of work, I would propose that we add a\nDAV:baseline-controlled-collection property to \neither the baseline resource and/or the working baseline resource.\n\nQuestions/comments, did I miss something?\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-14544685"}, {"subject": "Removing a collection from baseline-control and deleting VCCs et", "content": "Hi,\n\nI cannot see an obvious way to remove a collection from Baseline-Control.\n\nWould it involve copying the baseline-controlled collection, deleting the\nbaseline etc and then renaming the copy of the collection back to it's \noriginal name? (Similar to removing a resource from version-control)?\nCopying a large configuration (with subbaselines etc) would be costly.\nI know we were saying that perhaps deleting a VHR would remove a resource\nfrom version control...does that also apply to deleting a baseline history?\n\nCan I delete the Version-Controlled Configuration or the Baseline History\nand what effect would this have?\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-14553859"}, {"subject": "How to enforce the preconditions regarding modifying a baseline c ollectio", "content": "Hi,\n\nI was talking with some people in MERANT about the baseline feature and we\nwere\ndiscussing the various preconditions that enforce that members of a\nbaseline-collection\ncannot be modified (eg the DAV:must-not-update-baseline-collection\npreconditions).\n\nIt seems odd that the only way to identify a resource as a member of a\nbaseline-collection\nis by looking at it's URL (eg where it lives in the namespace). Other\npreconditions can be\nenforced by looking at the type of resource (eg by looking either at\nDAV:resource-type or\nby looking at it's properties as in section 22), but these preconditions can\nonly be checked\nby looking at the namespace.\n\nIt would be nice if all members of a baseline-collection had some property\nto identify them\nas such, so that the implementation of the code to enforce the preconditions\ncan be simple\nand so that clients can also identify these resources (perhaps show them\ngreyed-out to \nindicate they cannot be modified).\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-14562051"}, {"subject": "RE: Finding the Baseline-Controlled Collection given a working ba seli ne..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   As I have mentioned before section 13.12 talks about auto-checkin\n   of a working baseline and seems to suggest that the MERGE method\n   should then use the Baseline-Controlled Collection (referenced by\n   the working baseline) as the merge target.  My problem is how to\n   find the Baseline-Controlled Collection given a working baseline.\n\n   Does the working baseline have a property which identifies the\n   Baseline-Controlled Collection?  I do not see this property defined\n   in the specification, so the only way I can see to find a\n   Baseline-Controlled Collection given a working baseline would be\n   to: ...\n\nThe only way a working baseline is useful is if it is checked-out from\na VCC with the DAV:apply-to-version flag (otherwise there would be no\nway to update the members of the configuration).  In this case, the\nDAV:auto-version property identifies the VCC, and the\nDAV:baseline-controlled-collection property of the VCC identifies the\nBCC.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14570682"}, {"subject": "RE: Removing a collection from baseline-control and deleting VCCs  et", "content": "Yes, the situation with baseline-control is the same as that\nfor version-control, i.e. that the COPY/MOVE is the best way\nto take something out of baseline-control.  A server could\nchose to allow the removal of the DAV:version-controlled-configuration\nfrom a baseline-controlled configuration to mean \"remove from\nbaseline control\", but this is not something defined/supported\nin the current protocol.  If a server allowed deletion of the\nbaseline history, then this is likely to \"unbaseline-control\"\nall baseline controlled collections for that baseline history,\nbut here as well, this is not something defined/supported in\nthe current protocol.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Wednesday, October 10, 2001 8:45 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Removing a collection from baseline-control and deleting VCCs etc\n\n\nHi, \nI cannot see an obvious way to remove a collection from Baseline-Control. \nWould it involve copying the baseline-controlled collection, deleting the \nbaseline etc and then renaming the copy of the collection back to it's \noriginal name? (Similar to removing a resource from version-control)? \nCopying a large configuration (with subbaselines etc) would be costly. \nI know we were saying that perhaps deleting a VHR would remove a resource \nfrom version control...does that also apply to deleting a baseline history? \nCan I delete the Version-Controlled Configuration or the Baseline History \nand what effect would this have? \n\n\n\n", "id": "lists-006-14579118"}, {"subject": "RE: How to enforce the preconditions regarding modifying a baseli ne collectio", "content": "I personally don't think \"member of a baseline-collection\" merits a special\nicon or a special property.  The fact that it is read-only is reflected in\nboth the fact that it is checked-in, and for a server that supports the ACL\nspec, the fact that it is marked read-only.  The only thing you can't tell\nis \"and all attempts to check it out will fail\".  I don't think that \"can\nnever check out\" is an important enough piece of information to warrant a\nspecial icon/property.  As for the server, it will know whether or not a\nresource is a member of a baseline-collection (after all, it would have to\ngenerate the property value if we defined one), so it doesn't need a\nproperty to remind it what it already knows (:-).\n \nBut this certainly is a candidate for a DeltaV extension, in which case,\nadding it to the \"extension\" section of the FAQ would be the way to go.\n \nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Wednesday, October 10, 2001 8:55 AM\nTo: ietf-dav-versioning@w3.org\nSubject: How to enforce the preconditions regarding modifying a baseline c\nollection\n\n\n\nHi, \n\nI was talking with some people in MERANT about the baseline feature and we\nwere \ndiscussing the various preconditions that enforce that members of a\nbaseline-collection \ncannot be modified (eg the DAV:must-not-update-baseline-collection\npreconditions). \n\nIt seems odd that the only way to identify a resource as a member of a\nbaseline-collection \nis by looking at it's URL (eg where it lives in the namespace). Other\npreconditions can be \nenforced by looking at the type of resource (eg by looking either at\nDAV:resource-type or \nby looking at it's properties as in section 22), but these preconditions can\nonly be checked \nby looking at the namespace. \n\nIt would be nice if all members of a baseline-collection had some property\nto identify them \nas such, so that the implementation of the code to enforce the preconditions\ncan be simple \nand so that clients can also identify these resources (perhaps show them\ngreyed-out to \nindicate they cannot be modified). \n\nRegards, \n-- \nPeter Raymond - MERANT \nPrincipal Architect (PVCS) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com <mailto:Peter.Raymond@merant.com>  \nWWW: http://www.merant.com <http://www.merant.com>  \n\n\n\n", "id": "lists-006-14588949"}, {"subject": "Proposed editorial change for deltav spec (WAS: [ACL] principal-c ollection-set", "content": "This was posted on the ACL mailing list.  It proposes marshalling\nthe xxx-collection-set as properties, rather than as OPTIONS.\nSee the ACL mailing list for additional messages in this thread.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@Rational.Com]\nSent: Wednesday, October 10, 2001 11:25 AM\nTo: 'Jim Whitehead'; ACL@webdav.org\nSubject: RE: [ACL] principal-collection-set\n\n\nWell, all I can say is \"arghhh\".  I really don't care whether\nthe xxx-collection-set is marshalled via properties or OPTIONS\n(or by REPORT, for that matter).  I've probably changed it 3\nor 4 times in the DeltaV spec as the consensus shifted back and\nforth.  The last shift (a few months ago) settled on using OPTIONS,\nso that's what is in the DeltaV draft.  So although I don't\ncare which way we marshall it, I *do* care that we try to be\nconsistent from one WebDAV application to another.  Having the\nACL spec do it one way and the DeltaV spec do it another way\nwould be very unfortunate.\n\nSo if folks *REALLY* care that it be marshalled as properties\nrather than as OPTIONS, and will vigorously support that\nposition going forward, I would consider trying to surgically\nalter the DeltaV spec in the final editing pass to reflect this\nconsensus.\n\nOn the other hands, if folks don't really care that much about\nit (and I don't really see how one could care that much about it),\nI'd prefer to leave the DeltaV spec alone, and adopt the convention\nthat xxx-collection-set information is marshalled via an OPTIONS\ncall, and reflect this convention in the ACL spec by having the\nDAV:principal-collection-set marshalled via an OPTIONS call.\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\nSent: Thursday, October 04, 2001 4:49 PM\nTo: ACL@webdav.org\nSubject: RE: [ACL] principal-collection-set\n\n\nKeith Wannamaker writes:\n> It was noted on the call a few weeks ago, I think by Geoff,\n> that principal-collection-set should not be a live property.\n> Instead, it should be an element in an OPTIONS body, using\n> the <D:options> / <D:options-response> construct presented\n> in the DeltaV draft.\n>\n> Is this a consensus?  Should the draft be updated?\n\nAfter the development of the WebDAV protocol, it was noted that some of the\nproperties defined in RFC2518 were really \"protocol metadata\" and not\nresource metadata. DAV:supportedlock is one example.\n\nSince that time, I haven't heard a compelling argument for why you would\nprefer to use OPTIONS over PROPFIND for retrieving protocol metadata.\nArguably, you can make an argument in the reverse direction: existing HTTP\nclient libraries do not expect OPTIONS to have a body, and many WebDAV\nlibraries build upon existing HTTP libraries.\n\nI suppose one argument is that since client wanting to set ACLs will do an\nOPTIONS on a resource to retrieve the searchable properties list, it might\nas well also get the list of principal collections at the same time.  Of\ncourse, the same argument works in reverse: if the searchable properties\nlist is placed in a property, then both the searchable properties and the\nprincipal collections could be retrieved with a single PROPFIND.\n\nSince we already have an existing mechanism for retrieving protocol metadata\n(PROPFIND), I'm inclined to *not* use OPTIONS, and make an additional\nproperty for the searchable properties list.\n\n\n\n", "id": "lists-006-14599815"}, {"subject": "RE: [ACL] principal-collection-se", "content": "   From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n\n   > From: Clemm, Geoff\n   >  I really don't care whether the xxx-collection-set is marshalled\n   > via properties or OPTIONS (or by REPORT, for that matter)\n   > ....\n   > Having the ACL spec do it one way and the DeltaV spec do it\n   > another way would be very unfortunate.\n\n   My view is that live properties are WebDAV's way of handling\n   meta information.\n\nNote that the OPTIONS call currently handles meta information as well,\ne.g. the list of deltav features supported by the server that\nimplements the resource identified by the OPTIONS request.\n\nIn the past, most arguments were about aesthetics (i.e. what method\n\"should\" be used for this kind of information), with little practical\ndifference between one way vs. the other.\n\n   Another argument: assuming I extend ACL, allowing administrators to\n   modify the DAV:principal-collection-set (and creating DAV:principal\n   resources via WebDAV PUT in new locations). How do I modify a\n   property with OPTIONS?\n\nYes, this is a difference between marshalling via OPTIONS vs.\nmarshalling via properties.  In practice, the location of the\nprincipals are hard-wired by the server (so it can use the URL to know\nwhen to dispatch the request to a \"principal server\"), so this is\nunlikely to be something that an HTTP client will be allowed to\nchange.\n\nThese counter-arguments are not so much that I care, but rather to\nreinforce that this decision is pretty much of a wash in either\ndirection.\n\n1) Keep DeltaV with OPTIONS, and make ACL use OPTIONS for consistency\n2) Change DeltaV to use properties, and have ACL use properties\n3) Have DeltaV and ACL use different ways to obtain xxx-collection-set\n\nThe main situation I *really* want to avoid is:\n4) Change DeltaV to use properties, and have ACL end up using OPTIONS\n   or some other non-property mechanism inconsistent with DeltaV.\n\nSo for those folks that care about this (probably not many :-),\nwhich choice do you prefer?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14611489"}, {"subject": "RE: [ACL] principal-collection-se", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, October 10, 2001 6:54 PM\n> To: DeltaV (E-mail); ACL@webdav.org\n> Subject: RE: [ACL] principal-collection-set\n> ...\n> These counter-arguments are not so much that I care, but rather to\n> reinforce that this decision is pretty much of a wash in either\n> direction.\n>\n> 1) Keep DeltaV with OPTIONS, and make ACL use OPTIONS for consistency\n> 2) Change DeltaV to use properties, and have ACL use properties\n> 3) Have DeltaV and ACL use different ways to obtain xxx-collection-set\n>\n> The main situation I *really* want to avoid is:\n> 4) Change DeltaV to use properties, and have ACL end up using OPTIONS\n>    or some other non-property mechanism inconsistent with DeltaV.\n>\n> So for those folks that care about this (probably not many :-),\n> which choice do you prefer?\n\nObviously, it MUST be consistent across deltaV, ACL and future WebDAV\nversions.\n\nI honestly think that 2) is the best solution. For instance, it allows a\nclient to collect all it needs to know about a resource with one request.\n\n\n\n", "id": "lists-006-14622242"}, {"subject": "Confusion about what a VCR i", "content": "I keep having to revise my model of what a Version-Controlled Resource is,\nor represents, and I think today I finally figured out where some of the\nsource of my confusion lies.  The early part of the spec is quite clear that\nthe VCR and its latest checked-in version are different things:\n\n\"when a method is applied to a version-controlled resource, it is only\napplied to that version-controlled resource, and is not applied to the\nversion resource that is currently identified by the DAV:checked-in property\nof that version-controlled resource.  Although the content and dead\nproperties of a checked-in version-controlled resource are required to be\nthe same as those of its current DAV:checked-in version...\"\n\nBut the LABEL method takes a different approach:\n\n\"If a LABEL request is applied to a version-controlled resource, the\noperation MUST be applied to the DAV:checked-in version of that\nversion-controlled resource.\"\n\nFor the LABEL method, the VCR is treated as if it is a link to the\nlatest-checked-in version, even though elsewhere that's not the case.\n\nI think this is wrong; a PROPPATCH applied to the VCR changes the properties\nof the VCR and not the latest checked-in version.  LABEL should behave the\nsame way.\n\nIf LABEL behaviour is not changed, then there's no way of applying a label\nbefore checking in.  E.g. I can't label the version I'm about to check in; I\nhave to wait until I've completed the checkin before sending the LABEL\nrequest.\n\nlisa\n\n\n\n", "id": "lists-006-1462823"}, {"subject": "RE: [ACL] principal-collection-se", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, October 10, 2001 6:54 PM\n> To: DeltaV (E-mail); ACL@webdav.org\n> Subject: RE: [ACL] principal-collection-set\n> ...\n> These counter-arguments are not so much that I care, but rather to\n> reinforce that this decision is pretty much of a wash in either\n> direction.\n>\n> 1) Keep DeltaV with OPTIONS, and make ACL use OPTIONS for consistency\n> 2) Change DeltaV to use properties, and have ACL use properties\n> 3) Have DeltaV and ACL use different ways to obtain xxx-collection-set\n>\n> The main situation I *really* want to avoid is:\n> 4) Change DeltaV to use properties, and have ACL end up using OPTIONS\n>    or some other non-property mechanism inconsistent with DeltaV.\n>\n> So for those folks that care about this (probably not many :-),\n> which choice do you prefer?\n\nObviously, it MUST be consistent across deltaV, ACL and future WebDAV\nversions.\n\nI honestly think that 2) is the best solution. For instance, it allows a\nclient to collect all it needs to know about a resource with one request.\n\n\n\n", "id": "lists-006-14632019"}, {"subject": "RE: [ACL] principal-collection-se", "content": "Just to make sure we're on the same page, the interaction between\nthe client and a server will not be to ask each resource \"where is\nyour xxx-collection-set\", but rather to ask the first encountered\nresource in a session \"where are the xxx-collection-set values on\nyour server\", and then use those values for the rest of the session.\n\nThis means that you would not be combining requests for xxx-collection-set\ninformation with the other property information, but rather will be\nasking for xxx-collection-set information around the same time you\nare asking for OPTIONS information (i.e. what options are supported\nby your server), which is why the xxx-collection-set information is\ncurrently marshalled via OPTIONS, since *that* allows you to get all\nthis \"configuration\" information in one request.\n\nCheers,\nGeoff  \n\n-----Original Message-----\nFrom: Julian Reschke [mailto:julian.reschke@gmx.de]\n> 1) Keep DeltaV with OPTIONS, and make ACL use OPTIONS for consistency\n> 2) Change DeltaV to use properties, and have ACL use properties\n> 3) Have DeltaV and ACL use different ways to obtain xxx-collection-set\n>\n> The main situation I *really* want to avoid is:\n> 4) Change DeltaV to use properties, and have ACL end up using OPTIONS\n>    or some other non-property mechanism inconsistent with DeltaV.\n>\n> So for those folks that care about this (probably not many :-),\n> which choice do you prefer?\n\nObviously, it MUST be consistent across deltaV, ACL and future WebDAV\nversions.\n\nI honestly think that 2) is the best solution. For instance, it allows a\nclient to collect all it needs to know about a resource with one request.\n\n\n\n", "id": "lists-006-14641618"}, {"subject": "Re: [ACL] principal-collection-se", "content": "On Wed, Oct 10, 2001 at 12:54:05PM -0400, Clemm, Geoff wrote:\n>...\n> 1) Keep DeltaV with OPTIONS, and make ACL use OPTIONS for consistency\n> 2) Change DeltaV to use properties, and have ACL use properties\n> 3) Have DeltaV and ACL use different ways to obtain xxx-collection-set\n> \n> The main situation I *really* want to avoid is:\n> 4) Change DeltaV to use properties, and have ACL end up using OPTIONS\n>    or some other non-property mechanism inconsistent with DeltaV.\n> \n> So for those folks that care about this (probably not many :-),\n> which choice do you prefer?\n\n\n#1 big time. This high level information belongs in OPTIONS, queried once\nwhen you first contact the server, to determine what it can support. This\nhappens before you know that a PROPFIND can be issued.\n\nIMO, it's always been bogus to have protocol/implementation info as a\nproperty. The DAV:lockdiscovery has always given me a twitch.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-14651245"}, {"subject": "RE: [ACL] principal-collection-se", "content": "> From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> Clemm, Geoff\n> Sent: Wednesday, October 10, 2001 7:07 PM\n> To: DeltaV (E-mail); ACL@webdav.org\n> Subject: RE: [ACL] principal-collection-set\n>\n>\n> Just to make sure we're on the same page, the interaction between\n> the client and a server will not be to ask each resource \"where is\n> your xxx-collection-set\", but rather to ask the first encountered\n> resource in a session \"where are the xxx-collection-set values on\n> your server\", and then use those values for the rest of the session.\n\nMaybe I oversee something, but where's the guarantee that in ACL those sets\nwill be identical for all resources?\n\nI agree with you that some of the arguments are a bit fuzzy (and that I'm\nlate in this discussion)... HTTP (RFC2616) says about OPTIONS:\n\n\"The OPTIONS method represents a request for information about the\ncommunication options available on the\nrequest/response chain identified by the Request-URI. This method allows the\nclient to determine the options\nand/or requirements associated with a resource, or the capabilities of a\nserver, without implying a resource action or\ninitiating a resource retrieval.\"\n\nSo are we talking about \"communication options\" in this case?\n\n> This means that you would not be combining requests for xxx-collection-set\n> information with the other property information, but rather will be\n> asking for xxx-collection-set information around the same time you\n> are asking for OPTIONS information (i.e. what options are supported\n> by your server), which is why the xxx-collection-set information is\n> currently marshalled via OPTIONS, since *that* allows you to get all\n> this \"configuration\" information in one request.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Julian Reschke [mailto:julian.reschke@gmx.de]\n> > 1) Keep DeltaV with OPTIONS, and make ACL use OPTIONS for consistency\n> > 2) Change DeltaV to use properties, and have ACL use properties\n> > 3) Have DeltaV and ACL use different ways to obtain xxx-collection-set\n> >\n> > The main situation I *really* want to avoid is:\n> > 4) Change DeltaV to use properties, and have ACL end up using OPTIONS\n> >    or some other non-property mechanism inconsistent with DeltaV.\n> >\n> > So for those folks that care about this (probably not many :-),\n> > which choice do you prefer?\n>\n> Obviously, it MUST be consistent across deltaV, ACL and future WebDAV\n> versions.\n>\n> I honestly think that 2) is the best solution. For instance, it allows a\n> client to collect all it needs to know about a resource with one request.\n> _______________________________________________\n> acl mailing list\n> acl@webdav.org\n> http://mailman.webdav.org/mailman/listinfo/acl\n>\n\n\n\n", "id": "lists-006-14659519"}, {"subject": "RE: Finding the Baseline-Controlled Collection given a working ba  seli ne..", "content": "Hi,\n\n[Geoff wrote]:\n\n>The only way a working baseline is useful is if it is checked-out from\n>a VCC with the DAV:apply-to-version flag (otherwise there would be no\n>way to update the members of the configuration).  In this case, the\n>DAV:auto-version property identifies the VCC, and the\n>DAV:baseline-controlled-collection property of the VCC identifies the\n>BCC.\n\nOK, this is useful to know and in my opinion should be spelled out in the\nprotocol\ndocument that the only way to create a working baseline is by doing a\nDAV:apply-to-version\ncheckout of a VCC.  Then I would be happy that my server can just look at\nthe\nDAV:baseline-controlled-collection property of the VCC identified by the\nDAV:auto-version.\nAt the moment I cannot guarantee that the working baseline has been created\nby checking\nout a VCC so I have to do the complex looking of properties and collection\nmembers etc\nas in my last e-mail.\n\nOut of interest, are there any clients out there (or clients under design)\nthat\nwould be checking out a baseline to create a working baseline (as opposed to\nchecking\nout a VCC with apply-to-version)?\n\nRegards,\nPeter Raymond - MERANT.\n\n\n\n", "id": "lists-006-14671488"}, {"subject": "RE: [ACL] principal-collection-se", "content": "> From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> Greg Stein\n> Sent: Wednesday, October 10, 2001 7:22 PM\n> To: DeltaV (E-mail); ACL@webdav.org\n> Subject: Re: [ACL] principal-collection-set\n>\n>\n> On Wed, Oct 10, 2001 at 12:54:05PM -0400, Clemm, Geoff wrote:\n> >...\n> > 1) Keep DeltaV with OPTIONS, and make ACL use OPTIONS for consistency\n> > 2) Change DeltaV to use properties, and have ACL use properties\n> > 3) Have DeltaV and ACL use different ways to obtain xxx-collection-set\n> >\n> > The main situation I *really* want to avoid is:\n> > 4) Change DeltaV to use properties, and have ACL end up using OPTIONS\n> >    or some other non-property mechanism inconsistent with DeltaV.\n> >\n> > So for those folks that care about this (probably not many :-),\n> > which choice do you prefer?\n>\n>\n> #1 big time. This high level information belongs in OPTIONS, queried once\n> when you first contact the server, to determine what it can support. This\n> happens before you know that a PROPFIND can be issued.\n\nI think I might agree if the things we're talking abut *really* could be\nqueried once.\n\nAs I said, OPTIONS is for marshalling \"communication options\". Those options\napply to either \"*\" (general options) or to a specific resource. In general,\nyou can't assume that what's true for resource \"x\" is also the case for\nresouce \"y\".\n\n> IMO, it's always been bogus to have protocol/implementation info as a\n> property. The DAV:lockdiscovery has always given me a twitch.\n>\n> Cheers,\n> -g\n>\n> --\n> Greg Stein, http://www.lyra.org/\n> _______________________________________________\n> acl mailing list\n> acl@webdav.org\n> http://mailman.webdav.org/mailman/listinfo/acl\n>\n\n\n\n", "id": "lists-006-14680133"}, {"subject": "Didn't we agree to change supported-live-property-set", "content": "My memory from mailing list discussions was the supported-live-property-set\nshould present property names the same way they're presented in other XML,\ne.g. in propfind requests and responses.\n\nThe spec says:\n\n3.1.4           DAV:supported-live-property-set (protected)\nThis property identifies the live properties that are supported by the\nresource.  A live property is supported by a resource if that property has\nthe semantics defined for that property.  The value of this property MUST\nidentify all live properties defined by this document that are supported by\nthe resource, and SHOULD identify all live properties that are supported by\nthe resource.\n\n<!ELEMENT supported-live-property-set (supported-live-property*)>\n<!ELEMENT supported-live-property name>\n<!ELEMENT name ANY>\nANY value: a property element type\n\nI believe this should read:\n\n3.1.4           DAV:supported-live-property-set (protected)\nThis property identifies the live properties that are supported by the\nresource.  A live property is supported by a resource if that property has\nthe semantics defined for that property.  The value of this property MUST\nidentify all live properties defined by this document that are supported by\nthe resource, and SHOULD identify all live properties that are supported by\nthe resource.\n\n<!ELEMENT supported-live-property-set (supported-live-property*)>\n<!ELEMENT supported-live-property prop>\n<!ELEMENT prop ANY>\nANY value: a property element type\n\n-- Lisa\n\n\n\n", "id": "lists-006-14690809"}, {"subject": "RE: Didn't we agree to change supported-live-property-set", "content": "This is the last message I could find regarding this issue:\n\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JulSep/0201.html\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: Wednesday, October 10, 2001 8:18 PM\n> To: DeltaV\n> Subject: Didn't we agree to change supported-live-property-set?\n>\n>\n>\n> My memory from mailing list discussions was the\n> supported-live-property-set\n> should present property names the same way they're presented in other XML,\n> e.g. in propfind requests and responses.\n>\n> The spec says:\n>\n> 3.1.4           DAV:supported-live-property-set (protected)\n> This property identifies the live properties that are supported by the\n> resource.  A live property is supported by a resource if that property has\n> the semantics defined for that property.  The value of this property MUST\n> identify all live properties defined by this document that are\n> supported by\n> the resource, and SHOULD identify all live properties that are\n> supported by\n> the resource.\n>\n> <!ELEMENT supported-live-property-set (supported-live-property*)>\n> <!ELEMENT supported-live-property name>\n> <!ELEMENT name ANY>\n> ANY value: a property element type\n>\n> I believe this should read:\n>\n> 3.1.4           DAV:supported-live-property-set (protected)\n> This property identifies the live properties that are supported by the\n> resource.  A live property is supported by a resource if that property has\n> the semantics defined for that property.  The value of this property MUST\n> identify all live properties defined by this document that are\n> supported by\n> the resource, and SHOULD identify all live properties that are\n> supported by\n> the resource.\n>\n> <!ELEMENT supported-live-property-set (supported-live-property*)>\n> <!ELEMENT supported-live-property prop>\n> <!ELEMENT prop ANY>\n> ANY value: a property element type\n>\n> -- Lisa\n>\n>\n\n\n\n", "id": "lists-006-14699865"}, {"subject": "RE: [ACL] principal-collection-se", "content": "The argument that \"if it can vary on a host, then it should be\nmarshalled as a property, not as OPTIONS\" could equally well be\napplied to the DAV header.  After all, often only part of the\nURL space on a host supports a given level of WebDAV, as reflected\nin the DAV header.  So are you arguing that the next draft of 2518\nshould convert the DAV header to a DAV:dav property on every resource?  \n\nNote that the \"*\" argument to OPTIONS is just bogus.  It lets\nyou ask for information about one of the servers on\na host (probably the server that implements \"/\") but not for any of\nthe other servers on that host.\n\nSo I see currently two supporters of (2) and one supporter of (1)\n(with Jim an apparent additional supporter of (2)).  Anyone else\ncare?  Anyone want to change their mind?\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Julian Reschke [mailto:julian.reschke@gmx.de]\nSent: Wednesday, October 10, 2001 1:25 PM\nTo: Greg Stein; DeltaV (E-mail); ACL@webdav.org\nSubject: RE: [ACL] principal-collection-set\n\n\n> From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> Greg Stein\n> Sent: Wednesday, October 10, 2001 7:22 PM\n> To: DeltaV (E-mail); ACL@webdav.org\n> Subject: Re: [ACL] principal-collection-set\n>\n>\n> On Wed, Oct 10, 2001 at 12:54:05PM -0400, Clemm, Geoff wrote:\n> >...\n> > 1) Keep DeltaV with OPTIONS, and make ACL use OPTIONS for consistency\n> > 2) Change DeltaV to use properties, and have ACL use properties\n> > 3) Have DeltaV and ACL use different ways to obtain xxx-collection-set\n> >\n> > The main situation I *really* want to avoid is:\n> > 4) Change DeltaV to use properties, and have ACL end up using OPTIONS\n> >    or some other non-property mechanism inconsistent with DeltaV.\n> >\n> > So for those folks that care about this (probably not many :-),\n> > which choice do you prefer?\n>\n>\n> #1 big time. This high level information belongs in OPTIONS, queried once\n> when you first contact the server, to determine what it can support. This\n> happens before you know that a PROPFIND can be issued.\n\nI think I might agree if the things we're talking abut *really* could be\nqueried once.\n\nAs I said, OPTIONS is for marshalling \"communication options\". Those options\napply to either \"*\" (general options) or to a specific resource. In general,\nyou can't assume that what's true for resource \"x\" is also the case for\nresouce \"y\".\n\n> IMO, it's always been bogus to have protocol/implementation info as a\n> property. The DAV:lockdiscovery has always given me a twitch.\n>\n\n\n\n", "id": "lists-006-14710573"}, {"subject": "A DAV:principal-match REPOR", "content": "A very useful request is \"find all resources in this collection\nthat I own\".  Currently, there is no interoperable way to do this\nin the ACL protocol.  To remedy this situation, I propose that we\nadd a DAV:principal-match REPORT:\n\n------------------------------------\n\n9ACCESS CONTROL REPORTS\n\n9.1DAV:principal-match REPORT\n\nThe DAV:principal-match REPORT is used to identify all members of a\ncollection that have a specified relationship with the current user.\nIn particular, if the collection contains principals, the report can\nbe used to identify all members of the collection that match the\ncurrent user.  Alternatively, if the collection contains resources\nthat have a property that identifies a principal (e.g. DAV:owner),\nthen the report can be used to identify all members of the collection\nwhose property identifies a principal that matches the current user.\n\nMarshalling:\n\nThe request body MUST be a DAV:principal-match XML element.\n\n<!ELEMENT principal-match ((principal-property|self), prop)>\n<!ELEMENT principal-match ANY>\nANY value: an element whose type identifies a property\n<!ELEMENT self EMPTY>\nprop: see RFC 2518, Section 12.11\n\nThe response body for a successful request MUST be a DAV:multistatus\nXML element.\n\nmultistatus: see RFC 2518, Section 12.9\n\nThe response body for a successful DAV:principal-match REPORT request\nMUST contain a DAV:response element for each member of the collection\nthat has the specified relationship with the current user.  If\nDAV:prop is specified in the request body, the properties specified in\nthe DAV:prop element MUST be reported in the DAV:response elements.\n\n9.1.1Example - DAV:principal-match REPORT\n\nThe following example identifies the members of the /doc\ncollection that are owned by the current user.\n     \n>>REQUEST\n\n  REPORT /doc HTTP/1.1\n  Host: www.webdav.org\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx \n\n  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n  <D:principal-match xmlns:D=\"DAV:\">\n    <D:principal-property>\n      <D:owner/>\n    </D:principal-property>\n  </D:principal-match>\n\n>>RESPONSE\n\n  HTTP/1.1 207 Multi-Status\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n  <D:multistatus xmlns:D=\"DAV:\">\n    <D:response>\n      <D:href>http://www.webdav.org/doc/foo.html</D:href>\n      <D:status>HTTP/1.1 200 OK</D:status>\n    </D:response>\n    <D:response>\n      <D:href>http://www.webdav.org/doc/img/bar.gif</D:href>\n      <D:status>HTTP/1.1 200 OK</D:status>\n    </D:response>\n  </D:multistatus>\n\n------------------------------------\n\nComments?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1471291"}, {"subject": "RE: Didn't we agree to change supported-live-property-set", "content": "That makes sense and would be fine with me (\"name\" and \"prop\" even\nhave the same number of characters :-).\n\nIf nobody objects, I'll make that change.  I think this easily fits\nwithin the \"minor editorial change\" criteria.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Wednesday, October 10, 2001 2:18 PM\nTo: DeltaV\nSubject: Didn't we agree to change supported-live-property-set?\n\n\n\nMy memory from mailing list discussions was the supported-live-property-set\nshould present property names the same way they're presented in other XML,\ne.g. in propfind requests and responses.\n\nThe spec says:\n\n3.1.4           DAV:supported-live-property-set (protected)\nThis property identifies the live properties that are supported by the\nresource.  A live property is supported by a resource if that property has\nthe semantics defined for that property.  The value of this property MUST\nidentify all live properties defined by this document that are supported by\nthe resource, and SHOULD identify all live properties that are supported by\nthe resource.\n\n<!ELEMENT supported-live-property-set (supported-live-property*)>\n<!ELEMENT supported-live-property name>\n<!ELEMENT name ANY>\nANY value: a property element type\n\nI believe this should read:\n\n3.1.4           DAV:supported-live-property-set (protected)\nThis property identifies the live properties that are supported by the\nresource.  A live property is supported by a resource if that property has\nthe semantics defined for that property.  The value of this property MUST\nidentify all live properties defined by this document that are supported by\nthe resource, and SHOULD identify all live properties that are supported by\nthe resource.\n\n<!ELEMENT supported-live-property-set (supported-live-property*)>\n<!ELEMENT supported-live-property prop>\n<!ELEMENT prop ANY>\nANY value: a property element type\n\n-- Lisa\n\n\n\n", "id": "lists-006-14722069"}, {"subject": "RE: Didn't we agree to change supported-live-property-set", "content": "Yes, that was what I remembered (i.e. the question was asked,\nthe reason for not doing so was given, and there was no further\ndiscussion).  But given the minor nature of the marshalling change, if \nnobody disagrees, I'd be willing to make the change.  But even\na single disagreement would veto the change.  Any vetos?\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\nSent: Wednesday, October 10, 2001 2:31 PM\nTo: Lisa Dusseault; DeltaV\nSubject: RE: Didn't we agree to change supported-live-property-set?\n\n\nThis is the last message I could find regarding this issue:\n\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JulSep/0201.html\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: Wednesday, October 10, 2001 8:18 PM\n> To: DeltaV\n> Subject: Didn't we agree to change supported-live-property-set?\n>\n>\n>\n> My memory from mailing list discussions was the\n> supported-live-property-set\n> should present property names the same way they're presented in other XML,\n> e.g. in propfind requests and responses.\n>\n> The spec says:\n>\n> 3.1.4           DAV:supported-live-property-set (protected)\n> This property identifies the live properties that are supported by the\n> resource.  A live property is supported by a resource if that property has\n> the semantics defined for that property.  The value of this property MUST\n> identify all live properties defined by this document that are\n> supported by\n> the resource, and SHOULD identify all live properties that are\n> supported by\n> the resource.\n>\n> <!ELEMENT supported-live-property-set (supported-live-property*)>\n> <!ELEMENT supported-live-property name>\n> <!ELEMENT name ANY>\n> ANY value: a property element type\n>\n> I believe this should read:\n>\n> 3.1.4           DAV:supported-live-property-set (protected)\n> This property identifies the live properties that are supported by the\n> resource.  A live property is supported by a resource if that property has\n> the semantics defined for that property.  The value of this property MUST\n> identify all live properties defined by this document that are\n> supported by\n> the resource, and SHOULD identify all live properties that are\n> supported by\n> the resource.\n>\n> <!ELEMENT supported-live-property-set (supported-live-property*)>\n> <!ELEMENT supported-live-property prop>\n> <!ELEMENT prop ANY>\n> ANY value: a property element type\n>\n> -- Lisa\n>\n>\n\n\n\n", "id": "lists-006-14731725"}, {"subject": "RE: [ACL] principal-collection-se", "content": "I vote for #1, for consistency with the use of OPTIONS and the DAV header\nin RFC2518, which we don't have the ability to change at this point.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, October 10, 2001 11:33 AM\n> To: Greg Stein; DeltaV (E-mail)\n> Subject: RE: [ACL] principal-collection-set\n>\n>\n> The argument that \"if it can vary on a host, then it should be\n> marshalled as a property, not as OPTIONS\" could equally well be\n> applied to the DAV header.  After all, often only part of the\n> URL space on a host supports a given level of WebDAV, as reflected\n> in the DAV header.  So are you arguing that the next draft of 2518\n> should convert the DAV header to a DAV:dav property on every resource?\n>\n> Note that the \"*\" argument to OPTIONS is just bogus.  It lets\n> you ask for information about one of the servers on\n> a host (probably the server that implements \"/\") but not for any of\n> the other servers on that host.\n>\n> So I see currently two supporters of (2) and one supporter of (1)\n> (with Jim an apparent additional supporter of (2)).  Anyone else\n> care?  Anyone want to change their mind?\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Julian Reschke [mailto:julian.reschke@gmx.de]\n> Sent: Wednesday, October 10, 2001 1:25 PM\n> To: Greg Stein; DeltaV (E-mail); ACL@webdav.org\n> Subject: RE: [ACL] principal-collection-set\n>\n>\n> > From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> > Greg Stein\n> > Sent: Wednesday, October 10, 2001 7:22 PM\n> > To: DeltaV (E-mail); ACL@webdav.org\n> > Subject: Re: [ACL] principal-collection-set\n> >\n> >\n> > On Wed, Oct 10, 2001 at 12:54:05PM -0400, Clemm, Geoff wrote:\n> > >...\n> > > 1) Keep DeltaV with OPTIONS, and make ACL use OPTIONS for consistency\n> > > 2) Change DeltaV to use properties, and have ACL use properties\n> > > 3) Have DeltaV and ACL use different ways to obtain xxx-collection-set\n> > >\n> > > The main situation I *really* want to avoid is:\n> > > 4) Change DeltaV to use properties, and have ACL end up using OPTIONS\n> > >    or some other non-property mechanism inconsistent with DeltaV.\n> > >\n> > > So for those folks that care about this (probably not many :-),\n> > > which choice do you prefer?\n> >\n> >\n> > #1 big time. This high level information belongs in OPTIONS,\n> queried once\n> > when you first contact the server, to determine what it can\n> support. This\n> > happens before you know that a PROPFIND can be issued.\n>\n> I think I might agree if the things we're talking abut *really* could be\n> queried once.\n>\n> As I said, OPTIONS is for marshalling \"communication options\".\n> Those options\n> apply to either \"*\" (general options) or to a specific resource.\n> In general,\n> you can't assume that what's true for resource \"x\" is also the case for\n> resouce \"y\".\n>\n> > IMO, it's always been bogus to have protocol/implementation info as a\n> > property. The DAV:lockdiscovery has always given me a twitch.\n> >\n>\n>\n\n\n\n", "id": "lists-006-14743195"}, {"subject": "RE: [ACL] principal-collection-se", "content": "Please remind me why then supported-method-set was added to deltaV...\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Eric Sedlar\n> Sent: Wednesday, October 10, 2001 9:01 PM\n> To: DeltaV (E-mail); Acl@Webdav.Org\n> Subject: RE: [ACL] principal-collection-set\n>\n>\n> I vote for #1, for consistency with the use of OPTIONS and the DAV header\n> in RFC2518, which we don't have the ability to change at this point.\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > Sent: Wednesday, October 10, 2001 11:33 AM\n> > To: Greg Stein; DeltaV (E-mail)\n> > Subject: RE: [ACL] principal-collection-set\n> >\n> >\n> > The argument that \"if it can vary on a host, then it should be\n> > marshalled as a property, not as OPTIONS\" could equally well be\n> > applied to the DAV header.  After all, often only part of the\n> > URL space on a host supports a given level of WebDAV, as reflected\n> > in the DAV header.  So are you arguing that the next draft of 2518\n> > should convert the DAV header to a DAV:dav property on every resource?\n> >\n> > Note that the \"*\" argument to OPTIONS is just bogus.  It lets\n> > you ask for information about one of the servers on\n> > a host (probably the server that implements \"/\") but not for any of\n> > the other servers on that host.\n> >\n> > So I see currently two supporters of (2) and one supporter of (1)\n> > (with Jim an apparent additional supporter of (2)).  Anyone else\n> > care?  Anyone want to change their mind?\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: Julian Reschke [mailto:julian.reschke@gmx.de]\n> > Sent: Wednesday, October 10, 2001 1:25 PM\n> > To: Greg Stein; DeltaV (E-mail); ACL@webdav.org\n> > Subject: RE: [ACL] principal-collection-set\n> >\n> >\n> > > From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> > > Greg Stein\n> > > Sent: Wednesday, October 10, 2001 7:22 PM\n> > > To: DeltaV (E-mail); ACL@webdav.org\n> > > Subject: Re: [ACL] principal-collection-set\n> > >\n> > >\n> > > On Wed, Oct 10, 2001 at 12:54:05PM -0400, Clemm, Geoff wrote:\n> > > >...\n> > > > 1) Keep DeltaV with OPTIONS, and make ACL use OPTIONS for\n> consistency\n> > > > 2) Change DeltaV to use properties, and have ACL use properties\n> > > > 3) Have DeltaV and ACL use different ways to obtain\n> xxx-collection-set\n> > > >\n> > > > The main situation I *really* want to avoid is:\n> > > > 4) Change DeltaV to use properties, and have ACL end up\n> using OPTIONS\n> > > >    or some other non-property mechanism inconsistent with DeltaV.\n> > > >\n> > > > So for those folks that care about this (probably not many :-),\n> > > > which choice do you prefer?\n> > >\n> > >\n> > > #1 big time. This high level information belongs in OPTIONS,\n> > queried once\n> > > when you first contact the server, to determine what it can\n> > support. This\n> > > happens before you know that a PROPFIND can be issued.\n> >\n> > I think I might agree if the things we're talking abut *really* could be\n> > queried once.\n> >\n> > As I said, OPTIONS is for marshalling \"communication options\".\n> > Those options\n> > apply to either \"*\" (general options) or to a specific resource.\n> > In general,\n> > you can't assume that what's true for resource \"x\" is also the case for\n> > resouce \"y\".\n> >\n> > > IMO, it's always been bogus to have protocol/implementation info as a\n> > > property. The DAV:lockdiscovery has always given me a twitch.\n> > >\n> >\n> >\n>\n>\n>\n\n\n\n", "id": "lists-006-14756329"}, {"subject": "Missing reference in DeltaV - XML schem", "content": "The deltaV spec doesn't say where the XML specification language used is\nitself defined.  It is defined in\nhttp://www.w3.org/TR/2000/REC-xml-20001006.\n\nlisa\n\n\n\n", "id": "lists-006-14771327"}, {"subject": "Baselines and Binding", "content": "The protocol seems to allow a workspace to contain multiple bindings\n(names) for a single version-controlled resource.  We're trying to\nunderstand how multiple bindings coexist with workspaces and baselines,\nfor our implementation.\n\nThe multiple bindings are introduced in the MERGE and UPDATE semantic\nadditions of the VERSION-CONTROLLED-COLLECTION feature. The\nDAV:update-version-controlled-collection-members postcondition includes\nthe following condition on new version-controlled member creation:\n\n\n>          If a new version-controlled member is in a workspace that already\n>          has a version-controlled resource for that version history, then\n>          the new version-controlled member MUST be just a binding (i.e.\n>          another name for) that existing version-controlled resource.\n>\n\nAnd an earlier thread talked about UPDATE of a Version Controlled\nConfiguration:\n\n\n>      Is This A Bug?\n>\n>      - Baseline feature: Is it possible to construct a workspace which\n>        contains multiple VCR's with different DAV:checked-in versions\n>        for a given VHR by doing a MOVE of a VCR from one\n>        baseline-controlled collection to another, and then UPDATING the\n>        VCC's for those BCC's?\n>\n>   I think the intent of the spec is clear (only one VCC for a given\n>   version history in a given workspace), but I agree that\n>   we are missing a postcondition on the MOVE operation.  A\n>   workspace is required to have only one VCR for a given version\n>   history, so any operation that would violate that constraint (which a\n>   MOVE could) should fail.  Similarly, we should clarify in the extended\n>   UPDATE semantics, so that it is clear that the UPDATE of a VCC causes\n>   an existing VCR to be bound into a collection, if there already is a\n>   VCR for a given version history in the workspace.\n>\n\nI interpreted the last sentence of the reply to mean that the\nDAV:set-baseline-controlled-collection-members postcondition added by\nBASELINE to UPDATE (and\nMERGE), should include a statement similar to that in\nDAV:update-version-controlled-collection-members,  requiring the\ncreation of a binding to an existing\nVCR in the workspace.  Is this the right interpretation?\n\nIs it also right to imply that the DAV:checked-in version of the VCR\n(assuming that it is checked-in) remains as it was preceding the MERGE /\nUPDATE, in particular the DAV:checked-in version does _not_ necessarily\nmatch the version held in the baseline?\n\nShould there be a similar extension to the DAV:select-existing-baseline\npostcondition? This would cover the case of initializing a collection\nfrom an existing baseline, where the collection is a member of a\nworkspace, and both the workspace and baseline contain VCRs for the same\nversion history.\n\nAlso, how should BASELINE-CONTROL behave on a workspace containing such\nduplicate bindings? For example, suppose a workspace contains\n/ws/cmp1/src/foo.html and /ws/cmp2/src/bar.html, and that\n/ws/cmp2/src/bar.html is a binding (another name for) the resource,\n/ws/cmp1/src/foo.html.  If you  first\nBASELINE-CONTROL /ws/cmp1, and then BASELINE-CONTROL /ws/cmp2, should\nthe second BASELINE-CONTROL operation  omit the VCR identified by\n/ws/cmp2/src/bar.html (because it is already a member of a configuration\ncreated by baseline-controlling  /ws/cmp1)? If it is omitted, then it\nseems like the baseline of cmp2 has lost some important information\nabout the structure of component 2 (cmp2). If it is not omitted, then it\nseems to conflict with the description of configuration membership.\n\nThanks,\nAlison.\n--\n -------------------------------------------------------------\n The statements and opinions expressed here are my own\n and do not necessarily represent those of Oracle Corporation.\n -------------------------------------------------------------\n\n\n\n", "id": "lists-006-14778520"}, {"subject": "RE: Missing reference in DeltaV - XML schem", "content": "We actually inherited a bunch of references from RFC 2518 which\nwe did not repeat.  I personally think that's OK.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Wednesday, October 10, 2001 2:39 PM\nTo: DeltaV\nSubject: Missing reference in DeltaV - XML schema\n\n\n\n\nThe deltaV spec doesn't say where the XML specification language used is\nitself defined.  It is defined in\nhttp://www.w3.org/TR/2000/REC-xml-20001006.\n\nlisa\n\n\n\n", "id": "lists-006-14789626"}, {"subject": "RE: Missing reference in DeltaV - XML schem", "content": "Agreed.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, October 10, 2001 11:30 PM\n> To: DeltaV\n> Subject: RE: Missing reference in DeltaV - XML schema\n> \n> \n> We actually inherited a bunch of references from RFC 2518 which\n> we did not repeat.  I personally think that's OK.\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: Lisa Dusseault [mailto:lisa@xythos.com]\n> Sent: Wednesday, October 10, 2001 2:39 PM\n> To: DeltaV\n> Subject: Missing reference in DeltaV - XML schema\n> \n> \n> \n> \n> The deltaV spec doesn't say where the XML specification language used is\n> itself defined.  It is defined in\n> http://www.w3.org/TR/2000/REC-xml-20001006.\n> \n> lisa\n> \n> \n> \n\n\n\n", "id": "lists-006-14798029"}, {"subject": "RE: [ACL] principal-collection-se", "content": "DAV:supported-method-set was added because different\nresources on the same server will have different DAV:supported-method-set,\ntherefore when you are populating a GUI, you need this information\nfor each resource separately (to help determine what icon to display\nfor the resource), and this can be retrieved in one roundtrip with\na Depth PROPFIND.\n\nThis is in contrast to DAV:xxx-collection-set, which usually is consistent\nacross the resources in a given GUI tree display, and therefore would be\nwasteful/redundant to request separately for each resource in that display.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Julian F. Reschke [mailto:julian.reschke@greenbytes.de]\nSent: Wednesday, October 10, 2001 3:01 PM\nTo: Eric Sedlar; DeltaV (E-mail); Acl@Webdav.Org\nSubject: RE: [ACL] principal-collection-set\n\n\nPlease remind me why then supported-method-set was added to deltaV...\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Eric Sedlar\n> Sent: Wednesday, October 10, 2001 9:01 PM\n> To: DeltaV (E-mail); Acl@Webdav.Org\n> Subject: RE: [ACL] principal-collection-set\n>\n>\n> I vote for #1, for consistency with the use of OPTIONS and the DAV header\n> in RFC2518, which we don't have the ability to change at this point.\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > Sent: Wednesday, October 10, 2001 11:33 AM\n> > To: Greg Stein; DeltaV (E-mail)\n> > Subject: RE: [ACL] principal-collection-set\n> >\n> >\n> > The argument that \"if it can vary on a host, then it should be\n> > marshalled as a property, not as OPTIONS\" could equally well be\n> > applied to the DAV header.  After all, often only part of the\n> > URL space on a host supports a given level of WebDAV, as reflected\n> > in the DAV header.  So are you arguing that the next draft of 2518\n> > should convert the DAV header to a DAV:dav property on every resource?\n> >\n> > Note that the \"*\" argument to OPTIONS is just bogus.  It lets\n> > you ask for information about one of the servers on\n> > a host (probably the server that implements \"/\") but not for any of\n> > the other servers on that host.\n> >\n> > So I see currently two supporters of (2) and one supporter of (1)\n> > (with Jim an apparent additional supporter of (2)).  Anyone else\n> > care?  Anyone want to change their mind?\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: Julian Reschke [mailto:julian.reschke@gmx.de]\n> > Sent: Wednesday, October 10, 2001 1:25 PM\n> > To: Greg Stein; DeltaV (E-mail); ACL@webdav.org\n> > Subject: RE: [ACL] principal-collection-set\n> >\n> >\n> > > From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> > > Greg Stein\n> > > Sent: Wednesday, October 10, 2001 7:22 PM\n> > > To: DeltaV (E-mail); ACL@webdav.org\n> > > Subject: Re: [ACL] principal-collection-set\n> > >\n> > >\n> > > On Wed, Oct 10, 2001 at 12:54:05PM -0400, Clemm, Geoff wrote:\n> > > >...\n> > > > 1) Keep DeltaV with OPTIONS, and make ACL use OPTIONS for\n> consistency\n> > > > 2) Change DeltaV to use properties, and have ACL use properties\n> > > > 3) Have DeltaV and ACL use different ways to obtain\n> xxx-collection-set\n> > > >\n> > > > The main situation I *really* want to avoid is:\n> > > > 4) Change DeltaV to use properties, and have ACL end up\n> using OPTIONS\n> > > >    or some other non-property mechanism inconsistent with DeltaV.\n> > > >\n> > > > So for those folks that care about this (probably not many :-),\n> > > > which choice do you prefer?\n> > >\n> > >\n> > > #1 big time. This high level information belongs in OPTIONS,\n> > queried once\n> > > when you first contact the server, to determine what it can\n> > support. This\n> > > happens before you know that a PROPFIND can be issued.\n> >\n> > I think I might agree if the things we're talking abut *really* could be\n> > queried once.\n> >\n> > As I said, OPTIONS is for marshalling \"communication options\".\n> > Those options\n> > apply to either \"*\" (general options) or to a specific resource.\n> > In general,\n> > you can't assume that what's true for resource \"x\" is also the case for\n> > resouce \"y\".\n> >\n> > > IMO, it's always been bogus to have protocol/implementation info as a\n> > > property. The DAV:lockdiscovery has always given me a twitch.\n> > >\n> >\n> >\n>\n>\n>\n\n\n\n", "id": "lists-006-14807519"}, {"subject": "RE: Precursor set optional", "content": "The intent was to require a server to store this.\nAlthough it does require storage on the server, it is just\njust a single URL.  But I personally don't care much whether\nit is required or not.  Does anyone feel strongly one way\nor the other (I guess by default, I'd go with MUST, since\nthat is friendlier to clients).\n\nCheers,\nGeoff \n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Tuesday, June 12, 2001 3:05 PM\nTo: DeltaV\nSubject: Precursor set optional?\n\n\n\nCan precursorset be optional?  It can't be calculated on-the-fly; therefore\nit must be stored.  Must all servers store this?\n\nlisa\n\n\n\n", "id": "lists-006-1481136"}, {"subject": "RE: Missing reference in DeltaV - XML schem", "content": "Geoff Clemm writes:\n> We actually inherited a bunch of references from RFC 2518 which\n> we did not repeat.  I personally think that's OK.\n\nThere is a fair amount of overlap between the references for the HTTP/1.1\nspecification (RFC 2616), and the HTTP Authentication specification (RFC\n2617), even though they are intended to be consumed as a pair.\n\nI think the references should be repeated, or it should be noted that the\nreference can be found in reference section of RFC 2518. From the\nperspective of a first-time reader who starts reading the DeltaV\nspecification first, and who has no knowledge of XML, they will be confused\nby the lack of a reference. While such a case may seem unlikely today, 15 or\n20 years hence it may be more common. My recollection is that nroff,\nWordstar, and SGML were the dominant markup languages in 1981...\n\n- Jim\n\n\n\n", "id": "lists-006-14823321"}, {"subject": "RE: Baselines and Binding", "content": "   From: Alison Macmillan [mailto:alison.macmillan@oracle.com]\n\n   ... the DAV:set-baseline-controlled-collection-members\n   postcondition added by BASELINE to UPDATE (and MERGE), should\n   include a statement similar to that in\n   DAV:update-version-controlled-collection-members, requiring the\n   creation of a binding to an existing VCR in the workspace.  Is this\n   the right interpretation?\n\nYes.\n\n   Is it also right to imply that the DAV:checked-in version of the VCR\n   (assuming that it is checked-in) remains as it was preceding the MERGE /\n   UPDATE, in particular the DAV:checked-in version does _not_ necessarily\n   match the version held in the baseline?\n\nNo, the DAV:checked-in version will be updated.\nFor an UPDATE, the version should be set to be the version held in the\nbaseline.  For MERGE, it should be the MERGE of the version held in\nthe baseline with the version held in the workspace (i.e. whichever\none is the descendent of the other, otherwise checked out with the\nmerge version added to the DAV:merge-set).\n\n   Should there be a similar extension to the DAV:select-existing-baseline\n   postcondition? This would cover the case of initializing a collection\n   from an existing baseline, where the collection is a member of a\n   workspace, and both the workspace and baseline contain VCRs for the same\n   version history.\n\nYes (this would set the existing VCR to be the version specified in\nthe baseline).\n\n   Also, how should BASELINE-CONTROL behave on a workspace containing such\n   duplicate bindings? For example, suppose a workspace contains\n   /ws/cmp1/src/foo.html and /ws/cmp2/src/bar.html, and that\n   /ws/cmp2/src/bar.html is a binding (another name for) the resource,\n   /ws/cmp1/src/foo.html.  If you  first\n   BASELINE-CONTROL /ws/cmp1, and then BASELINE-CONTROL /ws/cmp2, should\n   the second BASELINE-CONTROL operation  omit the VCR identified by\n   /ws/cmp2/src/bar.html (because it is already a member of a configuration\n   created by baseline-controlling  /ws/cmp1)? If it is omitted, then it\n   seems like the baseline of cmp2 has lost some important information\n   about the structure of component 2 (cmp2). If it is not omitted, then it\n   seems to conflict with the description of configuration membership.\n\nYes, in this case, the baseline of cmp2 would not contain a version\nof /ws/cmp2/src/bar.html (that would have to be provided by a baseline\nof cmp1).  If you have versioned collections, the version of \n/ws/cmp2/src would indicate that it has a member (named bar.html), and\nwould know its version history, but the version would need to be\nspecified by a baseline of cmp1.  If you made a baseline of cmp1 a\nsub-baseline of the baseline of cmp2, this would ensure that a version\nwould be selected any time that baseline of cmp2 was selected.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14831317"}, {"subject": "RE: Finding the Baseline-Controlled Collection given a working ba  seline..", "content": "One note: the abbreviation \"VCC\" could be either version-controlled\nconfiguration or version-controlled collection.  In this thread, it\nmeant version-controlled configuration.   Sorry if this caused any\nconfusion.  I'll use VCCl and VCCn from now on.\n\n   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   [Geoff wrote]: \n   >The only way a working baseline is useful is if it is checked-out\n   >from a VCCn with the DAV:apply-to-version flag (otherwise there\n   >would be no way to update the members of the configuration).  In\n   >this case, the DAV:auto-version property identifies the VCCn, and\n   >the DAV:baseline-controlled-collection property of the VCCn\n   >identifies the BCC.\n\n   OK, this is useful to know and in my opinion should be spelled out\n   in the protocol document that the only way to create a working\n   baseline is by doing a DAV:apply-to-version checkout of a VCCn.\n\nWell, it's not the only way, but rather the main useful\nway (the protocol does allow you to do some non-useful things :-).\nThere is one minor use case for which it makes sense to checkout\na baseline directly (instead of checking out a VCCn).  In particular,\nif you just want to modify one of the dead properties of a baseline,\nor the DAV:subbaseline-set property, then you could just checkout the\nbaseline, make the change, and check it back in.  But if you want to\nhave the new baseline select different versions, you would need to\ncheckout a VCCn.\n\n   Then I would be happy that my server can just look at the\n   DAV:baseline-controlled-collection property of the VCC identified\n   by the DAV:auto-version.  At the moment I cannot guarantee that the\n   working baseline has been created by checking out a VCC so I have\n   to do the complex looking of properties and collection members etc\n   as in my last e-mail.\n\nYou should never to that looking around.  If someone creates a working\nresource for a configuration other than by checking out a VCCn, then\nit is *not* associated with any BCC, and the only thing they can do to\nthat working resource is change the dead properties or\nDAV:subbaseline-set property.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14841301"}, {"subject": "RE: How to enforce the preconditions regarding modifying a baseli  ne collectio", "content": "Hi,\n\nIt's not only \"can never checkout\" it's also...\"can never COPY into this\ncollection\", \n\"can never MOVE out of or into this collection\".  The Baseline Collection\nitself is\nnot VERSION-CONTROLLED and as such does not need to be checkedout to be\nmodified.\n\nI agree it is something for an extension.  I may propose an extension to the\nbaseline\nfeature to make the behaviour of working baselines, the protection of the\nbaseline\ncollection, and the behaviour of deleteing various resources (eg how to \nun-baseline-control) etc.\n\nI agree with all your answers to my recent questions about the baseline\nfeature.\nI just feel we need to capture them somewhere more \"concrete\" than simply in\na\ne-mail thread otherwise different vendors may miss some of these \"subtle\"\npoints.\n\nP.S.  I also like the VCCl and VCCn abbreviations and will use those in\nfuture.\n\nRegards,\n-- \nPeter Raymond - MERANT \nPrincipal Architect (PVCS) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: 10 October 2001 17:08\nTo: ietf-dav-versioning@w3.org\nSubject: RE: How to enforce the preconditions regarding modifying a baseli\nne collection\n\n\nI personally don't think \"member of a baseline-collection\" merits a special\nicon or a special property.  The fact that it is read-only is reflected in\nboth the fact that it is checked-in, and for a server that supports the ACL\nspec, the fact that it is marked read-only.  The only thing you can't tell\nis \"and all attempts to check it out will fail\".  I don't think that \"can\nnever check out\" is an important enough piece of information to warrant a\nspecial icon/property.  As for the server, it will know whether or not a\nresource is a member of a baseline-collection (after all, it would have to\ngenerate the property value if we defined one), so it doesn't need a\nproperty to remind it what it already knows (:-).\n\nBut this certainly is a candidate for a DeltaV extension, in which case,\nadding it to the \"extension\" section of the FAQ would be the way to go.\n\nCheers,\nGeoff\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\nSent: Wednesday, October 10, 2001 8:55 AM\nTo: ietf-dav-versioning@w3.org\nSubject: How to enforce the preconditions regarding modifying a baseline c\nollection\n\n\nHi, \nI was talking with some people in MERANT about the baseline feature and we\nwere \ndiscussing the various preconditions that enforce that members of a\nbaseline-collection \ncannot be modified (eg the DAV:must-not-update-baseline-collection\npreconditions). \nIt seems odd that the only way to identify a resource as a member of a\nbaseline-collection \nis by looking at it's URL (eg where it lives in the namespace). Other\npreconditions can be \nenforced by looking at the type of resource (eg by looking either at\nDAV:resource-type or \nby looking at it's properties as in section 22), but these preconditions can\nonly be checked \nby looking at the namespace. \nIt would be nice if all members of a baseline-collection had some property\nto identify them \nas such, so that the implementation of the code to enforce the preconditions\ncan be simple \nand so that clients can also identify these resources (perhaps show them\ngreyed-out to \nindicate they cannot be modified). \nRegards, \n-- \nPeter Raymond - MERANT \nPrincipal Architect (PVCS) \nTel: +44 (0)1727 813362 \nFax: +44 (0)1727 869804 \nmailto:Peter.Raymond@merant.com \nWWW: http://www.merant.com \n\n\n\n", "id": "lists-006-14850771"}, {"subject": "RE: [ACL] principal-collection-se", "content": "> From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> Clemm, Geoff\n>\n> Just to make sure we're on the same page, the interaction between\n> the client and a server will not be to ask each resource \"where is\n> your xxx-collection-set\", but rather to ask the first encountered\n> resource in a session \"where are the xxx-collection-set values on\n> your server\", and then use those values for the rest of the session.\n\nYes, that's what I'm concerned about. Without going too much into\ndetail, I have a server with an internal plugin-structure and all\n\"server\" protocol values (xxx-set, DAV header, methods) can and will\nvary. For now, they can vary with each collection. If we have BINDINGs\nin the future, it may vary with each resource.\n\nSo, getting those values \"once for the session\" is wrong and clients\nfollowing that advice are broken.\n\n//Stefan\n\n> This means that you would not be combining requests for xxx-collection-set\n> information with the other property information, but rather will be\n> asking for xxx-collection-set information around the same time you\n> are asking for OPTIONS information (i.e. what options are supported\n> by your server), which is why the xxx-collection-set information is\n> currently marshalled via OPTIONS, since *that* allows you to get all\n> this \"configuration\" information in one request.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Julian Reschke [mailto:julian.reschke@gmx.de]\n> > 1) Keep DeltaV with OPTIONS, and make ACL use OPTIONS for consistency\n> > 2) Change DeltaV to use properties, and have ACL use properties\n> > 3) Have DeltaV and ACL use different ways to obtain xxx-collection-set\n> >\n> > The main situation I *really* want to avoid is:\n> > 4) Change DeltaV to use properties, and have ACL end up using OPTIONS\n> >    or some other non-property mechanism inconsistent with DeltaV.\n> >\n> > So for those folks that care about this (probably not many :-),\n> > which choice do you prefer?\n>\n> Obviously, it MUST be consistent across deltaV, ACL and future WebDAV\n> versions.\n>\n> I honestly think that 2) is the best solution. For instance, it allows a\n> client to collect all it needs to know about a resource with one request.\n> _______________________________________________\n> acl mailing list\n> acl@webdav.org\n> http://mailman.webdav.org/mailman/listinfo/acl\n>\n\n\n\n", "id": "lists-006-14864135"}, {"subject": "RE: [ACL] principal-collection-se", "content": "Hi,\n\nLet me make sure I understand your \"multiple server\" scenario correctly:\n\nImagine some parts of the namespace are being maintained by different\nservers\nthe namespaces used to store version-histories, baselines, workspaces,\nactivities, \nprincipals etc may differ.\n\nConsider the situation where I have a workspace hosted at:\n\nhttp://www.server1.merant.com/dav/project1\n\nand in that workspace we have a collection which has a binding to a resource\non some \nother server), eg:\n\nhttp://www.server1.merant.com/dav/project1/src has a member which is a\nbinding to\nhttp://www.server2.merant.com/dav/project2/src/main.c\n\nIf my client connects to server1 and does a OPTIONS on /dav and gets back\nthe\nDAV:version-history-set they might get:\n\nhttp://www.server1.merant.com/dav/vhr\n\nIf the client did a PROPFIND on\nhttp://www.server2.merant.com/dav/project2/src/main.c\nfor it's DAV:version-history property it might return:\n\nhttp://www.server2.merant.com/dav/vhr\n\nIt seems to make sense that the version histories for resources live on the\nsame\nserver as those resources.  Which implies that if you have \"cross-server\"\nbindings\nthen different collection sets apply to different parts of the namespace.\n\nSo I guess I support option number 2.\n\nI also like the idea of all the specifications being consistent.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\nSent: 11 October 2001 09:38\nTo: Clemm, Geoff; DeltaV (E-mail); ACL@webdav.org\nSubject: RE: [ACL] principal-collection-set\n\n\n> From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> Clemm, Geoff\n>\n> Just to make sure we're on the same page, the interaction between\n> the client and a server will not be to ask each resource \"where is\n> your xxx-collection-set\", but rather to ask the first encountered\n> resource in a session \"where are the xxx-collection-set values on\n> your server\", and then use those values for the rest of the session.\n\nYes, that's what I'm concerned about. Without going too much into\ndetail, I have a server with an internal plugin-structure and all\n\"server\" protocol values (xxx-set, DAV header, methods) can and will\nvary. For now, they can vary with each collection. If we have BINDINGs\nin the future, it may vary with each resource.\n\nSo, getting those values \"once for the session\" is wrong and clients\nfollowing that advice are broken.\n\n//Stefan\n\n> This means that you would not be combining requests for xxx-collection-set\n> information with the other property information, but rather will be\n> asking for xxx-collection-set information around the same time you\n> are asking for OPTIONS information (i.e. what options are supported\n> by your server), which is why the xxx-collection-set information is\n> currently marshalled via OPTIONS, since *that* allows you to get all\n> this \"configuration\" information in one request.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Julian Reschke [mailto:julian.reschke@gmx.de]\n> > 1) Keep DeltaV with OPTIONS, and make ACL use OPTIONS for consistency\n> > 2) Change DeltaV to use properties, and have ACL use properties\n> > 3) Have DeltaV and ACL use different ways to obtain xxx-collection-set\n> >\n> > The main situation I *really* want to avoid is:\n> > 4) Change DeltaV to use properties, and have ACL end up using OPTIONS\n> >    or some other non-property mechanism inconsistent with DeltaV.\n> >\n> > So for those folks that care about this (probably not many :-),\n> > which choice do you prefer?\n>\n> Obviously, it MUST be consistent across deltaV, ACL and future WebDAV\n> versions.\n>\n> I honestly think that 2) is the best solution. For instance, it allows a\n> client to collect all it needs to know about a resource with one request.\n> _______________________________________________\n> acl mailing list\n> acl@webdav.org\n> http://mailman.webdav.org/mailman/listinfo/acl\n>\n\n\n\n", "id": "lists-006-14875651"}, {"subject": "RE: A DAV:principal-match REPOR", "content": "This sounds to me more like a good application for DASL, since it is\na simple query on a particular property value.  If DASL can't do this,\nit is pretty much good for nothing.\n\nAlso, shouldn't you copy the ACL mailing list on this?\n\n--Eric\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Tuesday, June 12, 2001 12:36 PM\n> To: DeltaV (E-mail)\n> Subject: A DAV:principal-match REPORT\n> \n> \n> A very useful request is \"find all resources in this collection\n> that I own\".  Currently, there is no interoperable way to do this\n> in the ACL protocol.  To remedy this situation, I propose that we\n> add a DAV:principal-match REPORT:\n> \n> ------------------------------------\n> \n> 9ACCESS CONTROL REPORTS\n> \n> 9.1DAV:principal-match REPORT\n> \n> The DAV:principal-match REPORT is used to identify all members of a\n> collection that have a specified relationship with the current user.\n> In particular, if the collection contains principals, the report can\n> be used to identify all members of the collection that match the\n> current user.  Alternatively, if the collection contains resources\n> that have a property that identifies a principal (e.g. DAV:owner),\n> then the report can be used to identify all members of the collection\n> whose property identifies a principal that matches the current user.\n> \n> Marshalling:\n> \n> The request body MUST be a DAV:principal-match XML element.\n> \n> <!ELEMENT principal-match ((principal-property|self), prop)>\n> <!ELEMENT principal-match ANY>\n> ANY value: an element whose type identifies a property\n> <!ELEMENT self EMPTY>\n> prop: see RFC 2518, Section 12.11\n> \n> The response body for a successful request MUST be a DAV:multistatus\n> XML element.\n> \n> multistatus: see RFC 2518, Section 12.9\n> \n> The response body for a successful DAV:principal-match REPORT request\n> MUST contain a DAV:response element for each member of the collection\n> that has the specified relationship with the current user.  If\n> DAV:prop is specified in the request body, the properties specified in\n> the DAV:prop element MUST be reported in the DAV:response elements.\n> \n> 9.1.1Example - DAV:principal-match REPORT\n> \n> The following example identifies the members of the /doc\n> collection that are owned by the current user.\n>      \n> >>REQUEST\n> \n>   REPORT /doc HTTP/1.1\n>   Host: www.webdav.org\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx \n> \n>   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n>   <D:principal-match xmlns:D=\"DAV:\">\n>     <D:principal-property>\n>       <D:owner/>\n>     </D:principal-property>\n>   </D:principal-match>\n> \n> >>RESPONSE\n> \n>   HTTP/1.1 207 Multi-Status\n>   Content-Type: text/xml; charset=\"utf-8\"\n>   Content-Length: xxxx\n> \n>   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n>   <D:multistatus xmlns:D=\"DAV:\">\n>     <D:response>\n>       <D:href>http://www.webdav.org/doc/foo.html</D:href>\n>       <D:status>HTTP/1.1 200 OK</D:status>\n>     </D:response>\n>     <D:response>\n>       <D:href>http://www.webdav.org/doc/img/bar.gif</D:href>\n>       <D:status>HTTP/1.1 200 OK</D:status>\n>     </D:response>\n>   </D:multistatus>\n> \n> ------------------------------------\n> \n> Comments?\n> \n> Cheers,\n> Geoff\n> \n> \n\n\n\n", "id": "lists-006-1488647"}, {"subject": "RE: Baselines and Binding", "content": "Hi,\n\nI understand why the baseline of cmp2 would not contain a\nversion of /ws/cmp2/src/bar.html, but this does seem odd.\n\nI can think of a common use case for which this may cause problems:\n\nImagine you have a workspace:\n\n/ws/project1\n\nThis is web site and various pages on the site use a common JAVA Script \nbased advert banner.  So in your workspace you have:\n\n/ws/project1/adverts.js        (this is a VCR)\n/ws/project1/default.htm       (this is a VCR)\n/ws/project1/news              (this is a collection)\n/ws/project1/news/adverts.js   (rather than another copy of advert.js this\nis just a binding to\n                                the VCR at /ws/project1/adverts.js).\n/ws/project1/news/default.htm  (this is a VCR).\n\nSo you have the adverts.js file used at both the top level of the web site\nand in the news section of the website.\n\nNow lets imagine you do a BASELINE-CONTROL on /ws/project1/news to capture\nthe news section\nof the site in a baseline.  The baseline collection will have a member which\nis a binding to\n/ws/project1/adverts.js (since the baseline-controlled collection had a\nbinding to this VCR).\n\nNow imagine you do a BASELINE-CONTROL on /ws/project1 according to Geoffs\ne-mail I think\nthis will NOT contain adverts.js, it will only capture the default.htm,\nbecause the VCR\nfor adverts.js already has a DAV:version-controlled-configuration property\nand so cannot\nbe a member of two configurations.\n\n\nThis seems really odd, because now if you use BASELINE-CONTROL to populate a\nnew collection\nwith the contents of the baseline that you took of /ws/project1 it will NOT\ncreate a advert.js\nat the top level and so the web page would be broken!  Even if the baseline\nof /ws/project1/news\nwas a subbaseline of the baseline of /ws/project1, the adverts.js would\nstill NOT be created\nat the top level when the /ws/project1 baseline is used.\n\nI don't have a good answer to how I would propose we fix this, but it\ncertainly seems like\na problem.  We could always just capture one baseline of /ws/project1 and\nNOT capture\n/ws/project1/news as a baseline (eg just have one baseline of the whole\nthing), but this\nis forcing the user down this route, they may have wanted to track\n/ws/project1/news\nas a component.\n\nAm I on track?\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: 11 October 2001 04:59\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Baselines and Bindings\n\n\n\n   From: Alison Macmillan [mailto:alison.macmillan@oracle.com]\n\n   ... the DAV:set-baseline-controlled-collection-members\n   postcondition added by BASELINE to UPDATE (and MERGE), should\n   include a statement similar to that in\n   DAV:update-version-controlled-collection-members, requiring the\n   creation of a binding to an existing VCR in the workspace.  Is this\n   the right interpretation?\n\nYes.\n\n   Is it also right to imply that the DAV:checked-in version of the VCR\n   (assuming that it is checked-in) remains as it was preceding the MERGE /\n   UPDATE, in particular the DAV:checked-in version does _not_ necessarily\n   match the version held in the baseline?\n\nNo, the DAV:checked-in version will be updated.\nFor an UPDATE, the version should be set to be the version held in the\nbaseline.  For MERGE, it should be the MERGE of the version held in\nthe baseline with the version held in the workspace (i.e. whichever\none is the descendent of the other, otherwise checked out with the\nmerge version added to the DAV:merge-set).\n\n   Should there be a similar extension to the DAV:select-existing-baseline\n   postcondition? This would cover the case of initializing a collection\n   from an existing baseline, where the collection is a member of a\n   workspace, and both the workspace and baseline contain VCRs for the same\n   version history.\n\nYes (this would set the existing VCR to be the version specified in\nthe baseline).\n\n   Also, how should BASELINE-CONTROL behave on a workspace containing such\n   duplicate bindings? For example, suppose a workspace contains\n   /ws/cmp1/src/foo.html and /ws/cmp2/src/bar.html, and that\n   /ws/cmp2/src/bar.html is a binding (another name for) the resource,\n   /ws/cmp1/src/foo.html.  If you  first\n   BASELINE-CONTROL /ws/cmp1, and then BASELINE-CONTROL /ws/cmp2, should\n   the second BASELINE-CONTROL operation  omit the VCR identified by\n   /ws/cmp2/src/bar.html (because it is already a member of a configuration\n   created by baseline-controlling  /ws/cmp1)? If it is omitted, then it\n   seems like the baseline of cmp2 has lost some important information\n   about the structure of component 2 (cmp2). If it is not omitted, then it\n   seems to conflict with the description of configuration membership.\n\nYes, in this case, the baseline of cmp2 would not contain a version\nof /ws/cmp2/src/bar.html (that would have to be provided by a baseline\nof cmp1).  If you have versioned collections, the version of \n/ws/cmp2/src would indicate that it has a member (named bar.html), and\nwould know its version history, but the version would need to be\nspecified by a baseline of cmp1.  If you made a baseline of cmp1 a\nsub-baseline of the baseline of cmp2, this would ensure that a version\nwould be selected any time that baseline of cmp2 was selected.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14890416"}, {"subject": "RE: How to enforce the preconditions regarding modifying a baseli  ne collectio", "content": "Yes, I agree that it is  worth formalizing this extension.\nAs we get more experience with multiple implementations, we\nwill be able to better identify which extensions need to\nbe standardized for interoperability.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\nIt's not only \"can never checkout\" it's also...\"can never COPY into\nthis collection\", \"can never MOVE out of or into this collection\".\nThe Baseline Collection itself is not VERSION-CONTROLLED and as such\ndoes not need to be checkedout to be modified.  I agree it is\nsomething for an extension.  I may propose an extension to the\nbaseline feature to make the behaviour of working baselines, the\nprotection of the baseline collection, and the behaviour of deleteing\nvarious resources (eg how to un-baseline-control) etc.  I agree with\nall your answers to my recent questions about the baseline feature.  I\njust feel we need to capture them somewhere more \"concrete\" than\nsimply in a e-mail thread otherwise different vendors may miss some of\nthese \"subtle\" points.  P.S.  I also like the VCCl and VCCn\nabbreviations and will use those in future.\n\n\n\n", "id": "lists-006-14904614"}, {"subject": "RE: [ACL] principal-collection-se", "content": "\"Once per session\" was probably not the best analogy here.\nI should have said: \"A client issues an OPTIONS call once\nfor each server with which it interacts, and a PROPFIND call\nonce for each resource with which it interacts\".  If the client\nhas no idea where the server boundaries are, then yes, it might\nhave to issue an OPTIONS call for every resource, but the\nDAV protocol requires it to do this anyway, since that's the\nonly way to discover the DAV feature level (via the DAV header).\n\nThe key point for me here is that DAV has already made\nthe decision to make the feature set supported by a server\navailable through an OPTIONS call (via the DAV header), and\nnot through live properties.  To be consistent with this\nchoice, other server level options (such as xxx-collection-set)\nshould be marshalled this way as well.\n\nBut as I indicated earlier, I personally don't think it matters\nmuch which way we go here, but the process for editorial updates\nto the DeltaV protocol is that only unanimous (minor) changes\nget made.  This is a minor change, but it is not unanimous (i.e.\nGreg is strongly against it, and Eric prefers to keep it the way\nit is), so that means that DeltaV stays as it is (the last call\nperiod is over).  Which then means I am strongly in favor of\nmarshalling xxx-collection-set in ACL in OPTIONS, to keep it \nconsistent with DeltaV (and DAV).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\nSent: Thursday, October 11, 2001 4:38 AM\nTo: Clemm, Geoff; DeltaV (E-mail); ACL@webdav.org\nSubject: RE: [ACL] principal-collection-set\n\n\n> From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> Clemm, Geoff\n>\n> Just to make sure we're on the same page, the interaction between\n> the client and a server will not be to ask each resource \"where is\n> your xxx-collection-set\", but rather to ask the first encountered\n> resource in a session \"where are the xxx-collection-set values on\n> your server\", and then use those values for the rest of the session.\n\nYes, that's what I'm concerned about. Without going too much into\ndetail, I have a server with an internal plugin-structure and all\n\"server\" protocol values (xxx-set, DAV header, methods) can and will\nvary. For now, they can vary with each collection. If we have BINDINGs\nin the future, it may vary with each resource.\n\nSo, getting those values \"once for the session\" is wrong and clients\nfollowing that advice are broken.\n\n\n\n", "id": "lists-006-14913099"}, {"subject": "RE: Baselines and Binding", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   I understand why the baseline of cmp2 would not contain a \n   version of /ws/cmp2/src/bar.html, but this does seem odd. \n\n   I can think of a common use case for which this may cause problems: \n   ...\n   /ws/project1/news/adverts.js is just a binding to \n   the VCR at /ws/project1/adverts.js.\n\n   BASELINE-CONTROL on /ws/project1/news\n   BASELINE-CONTROL on /ws/project1\n\n   according to Geoffs e-mail I think this will NOT contain\n   adverts.js, it will only capture the default.htm, because the VCR\n   for adverts.js already has a DAV:version-controlled-configuration\n   property and so cannot be a member of two configurations.\n\nCorrect.\n\n   This seems really odd, because now if you use BASELINE-CONTROL to\n   populate a new collection with the contents of the baseline that\n   you took of /ws/project1 it will NOT create a advert.js at the top\n   level and so the web page would be broken!\n\nYes, because baselines of project1 depend on baselines of news,\nso you only get consistent states if you have baselines of project1\ncontain a subbaseline of news.\n\n   Even if the baseline of\n   /ws/project1/news was a subbaseline of the baseline of\n   /ws/project1, the adverts.js would still NOT be created at the top\n   level when the /ws/project1 baseline is used.\n\nWhy not?  Although the protocol does not require the baseline to\nremember the names of members from other baselines, it certainly\ncan do so, in which case it will know to populate /ws/project1/advert.js\nwith a binding to the same VCR as /ws/project1/news/advert.js.\nIf the server supports VCCls, then if for sure will track this information\nin the binding-set of the collection version for /ws/project1.\n\n   I don't have a good\n   answer to how I would propose we fix this, but it certainly seems\n   like a problem.  We could always just capture one baseline of\n   /ws/project1 and NOT capture /ws/project1/news as a baseline (eg\n   just have one baseline of the whole thing), but this is forcing the\n   user down this route, they may have wanted to track\n   /ws/project1/news as a component.  Am I on track? \n\nI think the only thing you missed is that a baseline is allowed\n(and if it supports VCls, required) to track the names of members\nfrom other configurations.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14923783"}, {"subject": "RE: Baselines and Binding", "content": "Hi,\n\n[Geoff wrote]:\n\n>Although the protocol does not require the baseline to\n>remember the names of members from other baselines, it certainly\n>can do so...\n\nThanks Geoff, that makes sense.\n\n1. Why not make this the recommended behaviour (that servers SHOULD capture\nthe names of resources\nthat appear in other configurations, rather than not include those resources\nin the baseline).\n\n2. Another possibility would be to make this client-driven, eg let the\nclient send a XML element \nin the body of the BASELINE-CONTROL or CHECKIN of a VCCn request to indicate\nthat it wants \nnames captured for resources that appear in other configurations).\n\n\nIt seems like such crucial data (in order to make the baseline a consistent\nsnapshot of the\nbaseline-controlled collection).\n\nAny preferences as to which of the above approaches?\n\nI could add it to my proposed baseline feature extensions/clarifications?\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: 11 October 2001 13:43\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Baselines and Bindings\n\n\n   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   I understand why the baseline of cmp2 would not contain a \n   version of /ws/cmp2/src/bar.html, but this does seem odd. \n\n   I can think of a common use case for which this may cause problems: \n   ...\n   /ws/project1/news/adverts.js is just a binding to \n   the VCR at /ws/project1/adverts.js.\n\n   BASELINE-CONTROL on /ws/project1/news\n   BASELINE-CONTROL on /ws/project1\n\n   according to Geoffs e-mail I think this will NOT contain\n   adverts.js, it will only capture the default.htm, because the VCR\n   for adverts.js already has a DAV:version-controlled-configuration\n   property and so cannot be a member of two configurations.\n\nCorrect.\n\n   This seems really odd, because now if you use BASELINE-CONTROL to\n   populate a new collection with the contents of the baseline that\n   you took of /ws/project1 it will NOT create a advert.js at the top\n   level and so the web page would be broken!\n\nYes, because baselines of project1 depend on baselines of news,\nso you only get consistent states if you have baselines of project1\ncontain a subbaseline of news.\n\n   Even if the baseline of\n   /ws/project1/news was a subbaseline of the baseline of\n   /ws/project1, the adverts.js would still NOT be created at the top\n   level when the /ws/project1 baseline is used.\n\nWhy not?  Although the protocol does not require the baseline to\nremember the names of members from other baselines, it certainly\ncan do so, in which case it will know to populate /ws/project1/advert.js\nwith a binding to the same VCR as /ws/project1/news/advert.js.\nIf the server supports VCCls, then if for sure will track this information\nin the binding-set of the collection version for /ws/project1.\n\n   I don't have a good\n   answer to how I would propose we fix this, but it certainly seems\n   like a problem.  We could always just capture one baseline of\n   /ws/project1 and NOT capture /ws/project1/news as a baseline (eg\n   just have one baseline of the whole thing), but this is forcing the\n   user down this route, they may have wanted to track\n   /ws/project1/news as a component.  Am I on track? \n\nI think the only thing you missed is that a baseline is allowed\n(and if it supports VCls, required) to track the names of members\nfrom other configurations.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-14933141"}, {"subject": "RE: Baselines and Binding", "content": "I believe that capturing the relative names of resources\nfrom other configurations should be required baseline behavior\n(i.e. a MUST).  If you could include that in your baseline\nextension writeup, that would be great!  If someone comes\nup with an important reason for this information not to be\ncaptured, I would be willing to weaken this to SHOULD, but\nI believe we should first try for MUST.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n[Geoff wrote]: \n>Although the protocol does not require the baseline to \n>remember the names of members from other baselines, it certainly \n>can do so... \n\nThanks Geoff, that makes sense. \n1. Why not make this the recommended behaviour (that servers SHOULD capture\nthe names of resources \nthat appear in other configurations, rather than not include those resources\nin the baseline). \n2. Another possibility would be to make this client-driven, eg let the\nclient send a XML element \nin the body of the BASELINE-CONTROL or CHECKIN of a VCCn request to indicate\nthat it wants \nnames captured for resources that appear in other configurations). \n\n\nIt seems like such crucial data (in order to make the baseline a consistent\nsnapshot of the \nbaseline-controlled collection). \nAny preferences as to which of the above approaches? \nI could add it to my proposed baseline feature extensions/clarifications? \n\n\n\n", "id": "lists-006-14945068"}, {"subject": "RE: Submission: deltav subse", "content": "I'm inclined to declare victory on our DeltaV charter and let some servers \nget built on what we have before we start making a lot of immediate \nchanges. Of course I would welcome any BOF to determine level of interest \nin extensions, new packages, etc. DeltaV is now firmly on the standards \ntrack. The next step is to get some implementation and determine \ninteroperability issues. If the community fragments immediately on \ndifferent packages that aren't interoperable in meaningful ways, then \ncertainly that's good information for the standards process that would \nneed to be addressed. But I think the community would benefit from \nattempting to implement the spec as written so we encourage \ninteroperability.\n\nAs for shutting down DeltaV, we're only at proposed standard. We could \nconsider updating the charter to move to the next stage in the lifecycle. \nI would be happy to entertain suggestions as to the content of such a \ncharter, and if there's sufficient interest, we can propose the next set \nof work items to the AD's as either continuation of DeltaV (with a new \ncharter), or other working groups focused on more specific tasks.\n\n\n\n\n\n\"Jim Whitehead\" <ejw@cse.ucsc.edu>\n10/18/2001 06:36 PM\n\n \n        To:     \"Clemm, Geoff\" <gclemm@rational.com>, \"'Lisa Dusseault'\" \n<lisa@xythos.com>, \"Jim Amsden\" <jamsden@us.ibm.com>\n        cc: \n        Subject:        RE: Submission: deltav subset\n\n \n\n\nGeoff Clemm writes:\n> I think it is more appropriate to keep it as an\n> individual submission until the working group has had\n> a chance to review/iterate on it.\n\nThis may be true, but IETF policy does say that it is the Chair's \ndiscretion\non whether a document is a WG draft or an individual submission.\n\nI was just pointing out that Jim may cause friction with the ADs if, by\nmaking a new WG draft, he extends the life of DeltaV when they think it's\nclose to being shut down. I imagine they are keen to avoid another WebDAV\n:-)\n\nBut, even if Jim does decide that it should not be a new draft, it would \nbe\nwell within Lisa's rights to hold a BOF at the next IETF with an eye \ntowards\ncreating a new WG, \"SDV\" (simple Delta V), say.\n\n- Jim\n\n\n\n", "id": "lists-006-14953249"}, {"subject": "RE: Submission: deltav subse", "content": "I would like to see some work on server defined attribute sets (categories\nand attributes) as a new level of webDAV support.\n\n--Dylan\n\n\n\n", "id": "lists-006-14964271"}, {"subject": "Change Request Management (was: Submission: deltav subset", "content": "I agree with Jim's position on collecting implementation experience\nbefore mutating/extending/subsetting the versioning specification.\n\nSpeaking of interesting follow-on work for DeltaV, one thing we (very\nsensibly) defined as out-of-scope initially was \"change request\nmanagement\".  This is a core feature in all \"web content management\"\nsystems, in many cases as much if not more important than versioning.\n\nThis topic came up a few weeks ago (in the context of defining some\n\"states\" for an activity).  This would probably be a very interesting\nand valuable topic to pursue as we are gaining implementation\nexperience with the DeltaV specification.\n\nIs this of interest to anyone?\n\nCheers,\nGeoff\n\n   From: Jim Amsden [mailto:jamsden@us.ibm.com]\n\n   I'm inclined to declare victory on our DeltaV charter and let some\n   servers get built on what we have before we start making a lot of\n   immediate changes. Of course I would welcome any BOF to determine\n   level of interest in extensions, new packages, etc. DeltaV is now\n   firmly on the standards track. The next step is to get some\n   implementation and determine interoperability issues. If the\n   community fragments immediately on different packages that aren't\n   interoperable in meaningful ways, then certainly that's good\n   information for the standards process that would need to be\n   addressed. But I think the community would benefit from attempting\n   to implement the spec as written so we encourage interoperability.\n\n   As for shutting down DeltaV, we're only at proposed standard. We\n   could consider updating the charter to move to the next stage in\n   the lifecycle. I would be happy to entertain suggestions as to the\n   content of such a charter, and if there's sufficient interest, we\n   can propose the next set of work items to the AD's as either\n   continuation of DeltaV (with a new charter), or other working\n   groups focused on more specific tasks.\n\n\n\n", "id": "lists-006-14971920"}, {"subject": "RE: Submission: deltav subse", "content": "I think now that work on deltaV and ACL nears completion, we *badly* need to\ngo back resolving issues on the WebDAV core (maybe including parts of\nbindings, redirect refs, ordered collections and SEARCH).\n  -----Original Message-----\n  From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Dylan Barrell\n  Sent: Friday, October 19, 2001 3:05 AM\n  To: Jim Amsden; ietf-dav-versioning@w3.org\n  Subject: RE: Submission: deltav subset\n\n\n  I would like to see some work on server defined attribute sets (categories\nand attributes) as a new level of webDAV support.\n\n  --Dylan\n\n\n\n", "id": "lists-006-14981309"}, {"subject": "RE: Submission: deltav subse", "content": "Not to mention all the wonderful live properties (DAV:supported-xxx) which\nreally should be part\nof a WebDAV core spec. Maybe that's what Dylan has in mind?\n  -----Original Message-----\n  From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Julian Reschke\n  Sent: Friday, October 19, 2001 9:31 AM\n  To: Dylan Barrell; Jim Amsden; ietf-dav-versioning@w3.org\n  Subject: RE: Submission: deltav subset\n\n\n  I think now that work on deltaV and ACL nears completion, we *badly* need\nto go back resolving issues on the WebDAV core (maybe including parts of\nbindings, redirect refs, ordered collections and SEARCH).\n    -----Original Message-----\n    From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Dylan Barrell\n    Sent: Friday, October 19, 2001 3:05 AM\n    To: Jim Amsden; ietf-dav-versioning@w3.org\n    Subject: RE: Submission: deltav subset\n\n\n    I would like to see some work on server defined attribute sets\n(categories and attributes) as a new level of webDAV support.\n\n    --Dylan\n\n\n\n", "id": "lists-006-14990698"}, {"subject": "Re: Change Request Management (was: Submission: deltav subset", "content": ">> Clemm, Geoff wrote:\n>> Is this of interest to anyone?\n\nYes\n\nRegards,\nSteve Speicher\n\n\n\n", "id": "lists-006-15001721"}, {"subject": "RE: Confusion about what a VCR i", "content": "The only time this could cause a race condition is if you allow mutable\nversions, which I think Geoff tends to block out of his brain because\nthey are so yucky, and that's basically what you get for using them.\nWhich begs the question of why we don't just kill that feature in the\nspec...\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: Tuesday, June 12, 2001 12:25 PM\n> To: DeltaV\n> Subject: Confusion about what a VCR is\n>\n>\n>\n> I keep having to revise my model of what a Version-Controlled Resource is,\n> or represents, and I think today I finally figured out where some of the\n> source of my confusion lies.  The early part of the spec is quite\n> clear that\n> the VCR and its latest checked-in version are different things:\n>\n> \"when a method is applied to a version-controlled resource, it is only\n> applied to that version-controlled resource, and is not applied to the\n> version resource that is currently identified by the\n> DAV:checked-in property\n> of that version-controlled resource.  Although the content and dead\n> properties of a checked-in version-controlled resource are required to be\n> the same as those of its current DAV:checked-in version...\"\n>\n> But the LABEL method takes a different approach:\n>\n> \"If a LABEL request is applied to a version-controlled resource, the\n> operation MUST be applied to the DAV:checked-in version of that\n> version-controlled resource.\"\n>\n> For the LABEL method, the VCR is treated as if it is a link to the\n> latest-checked-in version, even though elsewhere that's not the case.\n>\n> I think this is wrong; a PROPPATCH applied to the VCR changes the\n> properties\n> of the VCR and not the latest checked-in version.  LABEL should behave the\n> same way.\n>\n> If LABEL behaviour is not changed, then there's no way of applying a label\n> before checking in.  E.g. I can't label the version I'm about to\n> check in; I\n> have to wait until I've completed the checkin before sending the LABEL\n> request.\n>\n> lisa\n>\n>\n\n\n\n", "id": "lists-006-1500424"}, {"subject": "RE: Submission: deltav subse", "content": "No, what I have in mind is the ability for a server to define attribute sets\n(categories) that are associated with collections some of these attributes\nand/or categories are mandatory (i.e. must be given a non empty valid value)\nwhen creating new resources in the collection, the client MUST supply values\nfor these mandatory attributes otherwise the resource cannot be created.\n\nThis is used widely in document management and record management systems.\n\nHowever it is a complex topic and does tie into RDF.\n\n--Dylan\n  -----Original Message-----\n  From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n  Sent: Friday, October 19, 2001 3:51 AM\n  To: Julian Reschke; Dylan Barrell; Jim Amsden; ietf-dav-versioning@w3.org\n  Subject: RE: Submission: deltav subset\n\n\n  Not to mention all the wonderful live properties (DAV:supported-xxx) which\nreally should be part\n  of a WebDAV core spec. Maybe that's what Dylan has in mind?\n    -----Original Message-----\n    From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Julian Reschke\n    Sent: Friday, October 19, 2001 9:31 AM\n    To: Dylan Barrell; Jim Amsden; ietf-dav-versioning@w3.org\n    Subject: RE: Submission: deltav subset\n\n\n    I think now that work on deltaV and ACL nears completion, we *badly*\nneed to go back resolving issues on the WebDAV core (maybe including parts\nof bindings, redirect refs, ordered collections and SEARCH).\n      -----Original Message-----\n      From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Dylan Barrell\n      Sent: Friday, October 19, 2001 3:05 AM\n      To: Jim Amsden; ietf-dav-versioning@w3.org\n      Subject: RE: Submission: deltav subset\n\n\n      I would like to see some work on server defined attribute sets\n(categories and attributes) as a new level of webDAV support.\n\n      --Dylan\n\n\n\n", "id": "lists-006-15009274"}, {"subject": "RE: Submission: deltav subse", "content": "However, creating a resource and setting properties can not be done in a\nsingle operation, right?\n  -----Original Message-----\n  From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Dylan Barrell\n  Sent: Friday, October 19, 2001 3:26 PM\n  To: Stefan Eissing; Julian Reschke; Jim Amsden; ietf-dav-versioning@w3.org\n  Subject: RE: Submission: deltav subset\n\n\n  No, what I have in mind is the ability for a server to define attribute\nsets (categories) that are associated with collections some of these\nattributes and/or categories are mandatory (i.e. must be given a non empty\nvalid value) when creating new resources in the collection, the client MUST\nsupply values for these mandatory attributes otherwise the resource cannot\nbe created.\n\n  This is used widely in document management and record management systems.\n\n  However it is a complex topic and does tie into RDF.\n\n  --Dylan\n    -----Original Message-----\n    From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n    Sent: Friday, October 19, 2001 3:51 AM\n    To: Julian Reschke; Dylan Barrell; Jim Amsden;\nietf-dav-versioning@w3.org\n    Subject: RE: Submission: deltav subset\n\n\n    Not to mention all the wonderful live properties (DAV:supported-xxx)\nwhich really should be part\n    of a WebDAV core spec. Maybe that's what Dylan has in mind?\n      -----Original Message-----\n      From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Julian Reschke\n      Sent: Friday, October 19, 2001 9:31 AM\n      To: Dylan Barrell; Jim Amsden; ietf-dav-versioning@w3.org\n      Subject: RE: Submission: deltav subset\n\n\n      I think now that work on deltaV and ACL nears completion, we *badly*\nneed to go back resolving issues on the WebDAV core (maybe including parts\nof bindings, redirect refs, ordered collections and SEARCH).\n        -----Original Message-----\n        From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Dylan Barrell\n        Sent: Friday, October 19, 2001 3:05 AM\n        To: Jim Amsden; ietf-dav-versioning@w3.org\n        Subject: RE: Submission: deltav subset\n\n\n        I would like to see some work on server defined attribute sets\n(categories and attributes) as a new level of webDAV support.\n\n        --Dylan\n\n\n\n", "id": "lists-006-15021391"}, {"subject": "RE: Submission: deltav subse", "content": "It cannot right now - but there is no reason that a multi-part mime could\nnot contain both attribute and content information. We would simply have to\ndefine the syntax and semantics of this multi part mime request.\n  -----Original Message-----\n  From: Julian Reschke [mailto:julian.reschke@greenbytes.de]\n  Sent: Friday, October 19, 2001 9:31 AM\n  To: Dylan Barrell; Stefan Eissing; Jim Amsden; ietf-dav-versioning@w3.org\n  Subject: RE: Submission: deltav subset\n\n\n  However, creating a resource and setting properties can not be done in a\nsingle operation, right?\n    -----Original Message-----\n    From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Dylan Barrell\n    Sent: Friday, October 19, 2001 3:26 PM\n    To: Stefan Eissing; Julian Reschke; Jim Amsden;\nietf-dav-versioning@w3.org\n    Subject: RE: Submission: deltav subset\n\n\n    No, what I have in mind is the ability for a server to define attribute\nsets (categories) that are associated with collections some of these\nattributes and/or categories are mandatory (i.e. must be given a non empty\nvalid value) when creating new resources in the collection, the client MUST\nsupply values for these mandatory attributes otherwise the resource cannot\nbe created.\n\n    This is used widely in document management and record management\nsystems.\n\n    However it is a complex topic and does tie into RDF.\n\n    --Dylan\n      -----Original Message-----\n      From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n      Sent: Friday, October 19, 2001 3:51 AM\n      To: Julian Reschke; Dylan Barrell; Jim Amsden;\nietf-dav-versioning@w3.org\n      Subject: RE: Submission: deltav subset\n\n\n      Not to mention all the wonderful live properties (DAV:supported-xxx)\nwhich really should be part\n      of a WebDAV core spec. Maybe that's what Dylan has in mind?\n        -----Original Message-----\n        From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Julian Reschke\n        Sent: Friday, October 19, 2001 9:31 AM\n        To: Dylan Barrell; Jim Amsden; ietf-dav-versioning@w3.org\n        Subject: RE: Submission: deltav subset\n\n\n        I think now that work on deltaV and ACL nears completion, we *badly*\nneed to go back resolving issues on the WebDAV core (maybe including parts\nof bindings, redirect refs, ordered collections and SEARCH).\n          -----Original Message-----\n          From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Dylan Barrell\n          Sent: Friday, October 19, 2001 3:05 AM\n          To: Jim Amsden; ietf-dav-versioning@w3.org\n          Subject: RE: Submission: deltav subset\n\n\n          I would like to see some work on server defined attribute sets\n(categories and attributes) as a new level of webDAV support.\n\n          --Dylan\n\n\n\n", "id": "lists-006-15034929"}, {"subject": "RE: Submission: deltav subse", "content": "Excellent point.  Not to mention, rev'ing 2518!\n \nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Julian Reschke [mailto:julian.reschke@greenbytes.de]\nSent: Friday, October 19, 2001 3:31 AM\nTo: Dylan Barrell; Jim Amsden; ietf-dav-versioning@w3.org\nSubject: RE: Submission: deltav subset\n\n\nI think now that work on deltaV and ACL nears completion, we *badly* need to\ngo back resolving issues on the WebDAV core (maybe including parts of\nbindings, redirect refs, ordered collections and SEARCH).\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Dylan Barrell\nSent: Friday, October 19, 2001 3:05 AM\nTo: Jim Amsden; ietf-dav-versioning@w3.org\nSubject: RE: Submission: deltav subset\n\n\nI would like to see some work on server defined attribute sets (categories\nand attributes) as a new level of webDAV support.\n \n--Dylan\n \n\n\n\n", "id": "lists-006-15049013"}, {"subject": "DeltaV validation suite (was: Submission: deltav subset", "content": "\"Julian Reschke\" <julian.reschke@greenbytes.de> wrote:\n> I think now that work on deltaV and ACL nears completion, we *badly* need to\n> go back resolving issues on the WebDAV core (maybe including parts of\n> bindings, redirect refs, ordered collections and SEARCH).\nWhile I agree that DeltaV nears completion now I see one thing still to do.\nOnce upon a time someone wrote a DeltaV scenarios document. This document\nshould be updated to the newest draft so it could help people understanding\nDeltaV by giving some detailed use cases. OTOH it could give implementors\nsort of a validation suite they could test their clients and servers against.\n\nCheers, Edgar\n\n\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-15058112"}, {"subject": "How to patch with SQUID", "content": "Hi,\n      I am using Redhat 6.0. The squid version geing used is \nsquid2.2.stable4-5.I have the webdav patch for it.Kindly tell me the \nprocedure to patch with squid.Please help it's urgent!!!!!\n\nregards\nKrischrist\n\nWelcome to my Homepage!!!!!\nhttp://Krischrist.xaper.com\nhttp://Krischrist.tripod.com\n\n\n\n", "id": "lists-006-15066139"}, {"subject": "MS webfolder bug on COPY/MOV", "content": "During testing we found the following issue with the Microsoft webfolder\nclient (sent here so it is propertly archived):\n\nGiven a WebDAV collection mounted as:\n\nhttp://host/localdir,\n\na collection resource\n\nhttp://host/localdir/collection\n\nand a member\n\nhttp://host/localdir/file\n\nUpon trying to move \"file\" into \"collection\", the MS webfolder client will\nsend the following request:\n\nMOVE http://host/file HTTP/1.0\nHost: lisa.greenbytes.de:8080\nDestination: http://host/localdir/collection/file\nTranslate: f\nProxy-Connection: Keep-Alive\nContent-Length: 0\nOverwrite: F\nPragma: no-cache\nContent-Language: en-us\nUser-Agent: Microsoft Data Access Internet Publishing Provider DAV\nAccept-Language: de, en-us;q=0.2\n\nSo in the request URI, the path is wrong. Note that this only happens if the\nwebfolder client \"thinks\" that it's operating in the root of the mounted\nnamespace -- that is, if http://host is mounted instead of\nhttp://host/localdir, the request URI will be correct.\n\nJulian\n\n\n\n", "id": "lists-006-15072905"}, {"subject": "RE: Submission: deltav subse", "content": "I'll explain some of the background to this message, since I started the\nthread below its cc' list was expanded.  Initially, I asked Jim Amsden if he\nwanted a new deltav-related internet-draft to be a working group draft or an\nindividual submission.  This explains the history and reasons behind the new\ninternet-draft...\n\nI've talked to various people in the last few months, both those involved\ndirectly in the DeltaV WG and those mostly involved in WebDAV but keeping an\neye on DeltaV.  A common theme has been some uncertainty what features\nshould be implemented for simple versioning, in software not intended for\nsource control but just for web authoring or document management.  The\nexisting packages defined in DeltaV are a good start, but there's still lot\nof possible variation in how to implement a DeltaV server or client even\nonce a package has been chosen.\n\nThus, I've been working on a document to make it easier for simple WebDAV\nauthoring clients to implement DeltaV, by selecting a number of features and\na number of simplifications that a server can make.  If a server advertises\nthese simplifications, then the client's job is much easier (the client\nwon't have to worry about forking, multiple checkouts, older versions\ngetting checked out, or older versions being targetted).  Both the server\nand the client can still be DeltaV compatible.\n\nI've posted the initial draft on\nhttp://www.sharemation.com/~milele/public/dav, and it should soon be\navailable on the IETF site as well.  I'm very much interested in hearing\ncomments, suggestions, etc.  Much thanks to Peter Raymond, Alan Kent and\nMark Hale for their initial comments.\n\nLisa\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\nSent: October 18, 2001 4:35 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Submission: deltav subset\n\n\n\nI'm inclined to declare victory on our DeltaV charter and let some servers\nget built on what we have before we start making a lot of immediate changes.\nOf course I would welcome any BOF to determine level of interest in\nextensions, new packages, etc. DeltaV is now firmly on the standards track.\nThe next step is to get some implementation and determine interoperability\nissues. If the community fragments immediately on different packages that\naren't interoperable in meaningful ways, then certainly that's good\ninformation for the standards process that would need to be addressed. But I\nthink the community would benefit from attempting to implement the spec as\nwritten so we encourage interoperability.\n\nAs for shutting down DeltaV, we're only at proposed standard. We could\nconsider updating the charter to move to the next stage in the lifecycle. I\nwould be happy to entertain suggestions as to the content of such a charter,\nand if there's sufficient interest, we can propose the next set of work\nitems to the AD's as either continuation of DeltaV (with a new charter), or\nother working groups focused on more specific tasks.\n\n\n\n\"Jim Whitehead\" <ejw@cse.ucsc.edu>\n10/18/2001 06:36 PM\n\n        To:        \"Clemm, Geoff\" <gclemm@rational.com>, \"'Lisa Dusseault'\"\n<lisa@xythos.com>, \"Jim Amsden\" <jamsden@us.ibm.com>\n        cc:\n        Subject:        RE: Submission: deltav subset\n\n\n\n\n\nGeoff Clemm writes:\n> I think it is more appropriate to keep it as an\n> individual submission until the working group has had\n> a chance to review/iterate on it.\n\nThis may be true, but IETF policy does say that it is the Chair's discretion\non whether a document is a WG draft or an individual submission.\n\nI was just pointing out that Jim may cause friction with the ADs if, by\nmaking a new WG draft, he extends the life of DeltaV when they think it's\nclose to being shut down. I imagine they are keen to avoid another WebDAV\n:-)\n\nBut, even if Jim does decide that it should not be a new draft, it would be\nwell within Lisa's rights to hold a BOF at the next IETF with an eye towards\ncreating a new WG, \"SDV\" (simple Delta V), say.\n\n- Jim\n\n\n\n", "id": "lists-006-15081710"}, {"subject": "RE: Submission: deltav subse", "content": "Clients should be written in such a way that they do not depend on \nspecific server restrictions. Certainly a client can expose whatever \nDeltaV behavior meets its user's needs. Such clients should be written to \nwork with any DeltaV server that supports the necessary options. That is, \nclients shouldn't depend on some specific server restriction to make it \neasier to perform some logic as this would limit interoperability.\n\nIt looks like most of the guarantees below all result from linerar version \nhistories. Its not clear why you would want the last restriction as it \nwould make it impossible to ever roll back to an older version without \nmaking it \"look\" like a newer version (checkout, copy contents and \nproperties of some old version onto the working resource, checkin).\n\nI guess I don't see what is being added here. Clients should be written to \nrequest what they need from a server. The server should refuse to do \nanything it can't support. Clients should expect this and be tested \nagainst specific servers that meet their needs. Taking this approach will \nensure clients will interoperate with new servers or upgrades to existing \nservers that provide additional capabilities.\n\n\n\n\n\"Lisa Dusseault\" <lisa@xythos.com>\n10/22/2001 01:04 PM\n\n \n        To:     \"Clemm, Geoff\" <gclemm@rational.com>, \"'Jim Whitehead'\" \n<ejw@cse.ucsc.edu>, \"Jim Amsden\" <jamsden@us.ibm.com>\n        cc: \n        Subject:        RE: Submission: deltav subset\n\n \n\nThe \"deltav-subset\" isn't a package.  Although it does bear some \nresemblance\nto a package because it selects and recommends some major features, it \nalso\nmakes some other guarantees.  Why is this necessary?\n\nCurrently, there is no way for a server to advertise the following\nguarantees:\n - that it will only produce linear version histories\n - that it will only allow one checkout at a time\n - that it will only allow the latest version to be checked out\n - that it will only allow the latest version to be the version reflected \nin\nthe VCR\n\nAll of these guarantees, particularly combined, make it much easier to \nwrite\na simple DeltaV client.  Particularly, they help that client know what's\ngoing on and present that to the user.  E.g. it's much easier to find out \nif\na resource is already checked out because only the latest version need be\nlooked at.\n\nWe could separate these guarantees as individual strings in the OPTIONS\nresponse, but some of them go together, so that might be hard.  We could\nalso rename the string \"deltav-subset\" in the OPTIONS response to make it\nmore accurate.\n\nLisa\n\n> -----Original Message-----\n> From: Clemm, Geoff [mailto:gclemm@rational.com]\n> Sent: October 18, 2001 2:29 PM\n> To: 'Jim Whitehead'; Lisa Dusseault; jamsden@us.ibm.com\n> Subject: RE: Submission: deltav subset\n>\n>\n> Jim makes a good point.  Introducing another \"package\" at this point\n> muddies the water for someone trying to write an interoperable client.\n> We have 5 packages defined already ... I believe it would\n> be better to rework those package definitions later, based on actual\n> experience\n> with interoperating implementations, rather than defining additional\n> packages now.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\n> Sent: Thursday, October 18, 2001 5:07 PM\n> To: Lisa Dusseault; jamsden@us.ibm.com\n> Cc: gclemm@Rational.Com\n> Subject: RE: Submission: deltav subset\n>\n>\n> A couple of notes:\n>\n> * The packages concept was intended to support subsets like this\n> -- why are\n> they insufficient?\n>\n> * It might be necessary to rev. the charter of the DeltaV working group \nto\n> do this work.  It's a judgement call between the Chair and the A-Ds.  I\n> suspect the A-Ds are thinking that DeltaV, having achieved its\n> goals, should\n> now shut down.\n>\n> - Jim\n>\n>\n>\n> > -----Original Message-----\n> > From: Lisa Dusseault [mailto:lisa@xythos.com]\n> > Sent: Thursday, October 18, 2001 1:56 PM\n> > To: jamsden@us.ibm.com\n> > Cc: Jim Whitehead; gclemm@rational.com\n> > Subject: Submission: deltav subset\n> >\n> >\n> >\n> > I've finally gotten around to formatting the subset spec properly.\n> >\n> > Do we want to make this a working group document?  Right now\n> it's named as\n> > an individual submission.\n> >\n> > I've received a lot of interest in this subset from various\n> groups: Adobe,\n> > Merant, Teamstream, interwoven, CyberTeams.\n> >\n> > lisa\n> >\n> > PS -- the DeltaV home page on www.webdav.org doesn't list Jim Amsden \nas\n> > chair, or his email address.\n> >\n\n\n\n", "id": "lists-006-15094919"}, {"subject": "RE: [ACL] RE: A DAV:principal-match REPOR", "content": "Oops!  Apologies to the folks on the versioning mailing list ...\n\nThe DAV:principal-match proposal was supposed to just go to the ACL\nmailing list (please prune any followups so that they just go to the\nACL list ... I've BCC'ed this message to versioning list to start that\npruning process).\n\n   From: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\n\n   This sounds to me more like a good application for DASL, since it\n   is a simple query on a particular property value.  If DASL can't do\n   this, it is pretty much good for nothing.\n\nWhether or not DASL is \"good for nothing\" is an interesting\nquestion (:-), but until it is a standard (or at least, a\nstandards track document), it cannot be used for interoperable\nqueries.  This is the same reason why a couple of key\nversioning reports are defined in the versioning protocol.\n\nIn addition, the \"matches current principal\" is a very ACL specific\n\"match\" operation, and it is unclear whether it is reasonable to\nexpect DASL to have such a built-in operation for such a purpose.\n\nSo the combination of these two reasons makes me believe that\nthe DAV:principal-match query is an important one to provide\ndirectly in the ACL spec.\n\nI'll attach a copy of the proposal to the bottom of this note, to\nminimize confusion caused by my original misdirection of this message.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom:  Clemm, Geoff\n\nA very useful request is \"find all resources in this collection\nthat I own\".  Currently, there is no interoperable way to do this\nin the ACL protocol.  To remedy this situation, I propose that we\nadd a DAV:principal-match REPORT:\n\n------------------------------------\n\n9ACCESS CONTROL REPORTS\n\n9.1DAV:principal-match REPORT\n\nThe DAV:principal-match REPORT is used to identify all members of a\ncollection that have a specified relationship with the current user.\nIn particular, if the collection contains principals, the report can\nbe used to identify all members of the collection that match the\ncurrent user.  Alternatively, if the collection contains resources\nthat have a property that identifies a principal (e.g. DAV:owner),\nthen the report can be used to identify all members of the collection\nwhose property identifies a principal that matches the current user.\n\nMarshalling:\n\nThe request body MUST be a DAV:principal-match XML element.\n\n<!ELEMENT principal-match ((principal-property|self), prop)>\n<!ELEMENT principal-match ANY>\nANY value: an element whose type identifies a property\n<!ELEMENT self EMPTY>\nprop: see RFC 2518, Section 12.11\n\nThe response body for a successful request MUST be a DAV:multistatus\nXML element.\n\nmultistatus: see RFC 2518, Section 12.9\n\nThe response body for a successful DAV:principal-match REPORT request\nMUST contain a DAV:response element for each member of the collection\nthat has the specified relationship with the current user.  If\nDAV:prop is specified in the request body, the properties specified in\nthe DAV:prop element MUST be reported in the DAV:response elements.\n\n9.1.1Example - DAV:principal-match REPORT\n\nThe following example identifies the members of the /doc\ncollection that are owned by the current user.\n     \n>>REQUEST\n\n  REPORT /doc HTTP/1.1\n  Host: www.webdav.org\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx \n\n  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n  <D:principal-match xmlns:D=\"DAV:\">\n    <D:principal-property>\n      <D:owner/>\n    </D:principal-property>\n  </D:principal-match>\n\n>>RESPONSE\n\n  HTTP/1.1 207 Multi-Status\n  Content-Type: text/xml; charset=\"utf-8\"\n  Content-Length: xxxx\n\n  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n  <D:multistatus xmlns:D=\"DAV:\">\n    <D:response>\n      <D:href>http://www.webdav.org/doc/foo.html</D:href>\n      <D:status>HTTP/1.1 200 OK</D:status>\n    </D:response>\n    <D:response>\n      <D:href>http://www.webdav.org/doc/img/bar.gif</D:href>\n      <D:status>HTTP/1.1 200 OK</D:status>\n    </D:response>\n  </D:multistatus>\n\n------------------------------------\n\nComments?\n\n\n\n", "id": "lists-006-1510549"}, {"subject": "Re: Submission: deltav subse", "content": "If the WG shuts down, what is the accepted mechanism for\nhashing out protocol usage issues that surface during\nimplementation?\n\nRoy\n\nJim Amsden wrote:\n\n>\n> I'm inclined to declare victory on our DeltaV charter and\n> let some servers get built on what we have before we start\n> making a lot of immediate changes. Of course I would\n> welcome any BOF to determine level of interest in\n> extensions, new packages, etc. DeltaV is now firmly on the\n> standards track. The next step is to get some\n> implementation and determine interoperability issues. If\n> the community fragments immediately on different packages\n> that aren't interoperable in meaningful ways, then\n> certainly that's good information for the standards\n> process that would need to be addressed. But I think the\n> community would benefit from attempting to implement the\n> spec as written so we encourage interoperability.\n>\n> As for shutting down DeltaV, we're only at proposed\n> standard. We could consider updating the charter to move\n> to the next stage in the lifecycle. I would be happy to\n> entertain suggestions as to the content of such a charter,\n> and if there's sufficient interest, we can propose the\n> next set of work items to the AD's as either continuation\n> of DeltaV (with a new charter), or other working groups\n> focused on more specific tasks.\n>\n>\n>\n>  \"Jim Whitehead\"\n   <ejw@cse.ucsc.edu>                To:        \"Clemm,\n                             Geoff\" <gclemm@rational.com>,\n   10/18/2001 06:36 PM       \"'Lisa Dusseault'\"\n                             <lisa@xythos.com>, \"Jim Amsden\"\n                             <jamsden@us.ibm.com>\n                                     cc:\n                                     Subject:        RE:\n                             Submission: deltav subset\n\n\n>\n>\n>\n> Geoff Clemm writes:\n> > I think it is more appropriate to keep it as an\n> > individual submission until the working group has had\n> > a chance to review/iterate on it.\n>\n> This may be true, but IETF policy does say that it is the\n> Chair's discretion\n> on whether a document is a WG draft or an individual\n> submission.\n>\n> I was just pointing out that Jim may cause friction with\n> the ADs if, by\n> making a new WG draft, he extends the life of DeltaV when\n> they think it's\n> close to being shut down. I imagine they are keen to avoid\n> another WebDAV\n> :-)\n>\n> But, even if Jim does decide that it should not be a new\n> draft, it would be\n> well within Lisa's rights to hold a BOF at the next IETF\n> with an eye towards\n> creating a new WG, \"SDV\" (simple Delta V), say.\n>\n> - Jim\n>\n>\n>\n\n\n\n", "id": "lists-006-15109762"}, {"subject": "RE: Submission: deltav subse", "content": "Roy Seto writes:\n> If the WG shuts down, what is the accepted mechanism \n> for hashing out protocol usage issues that surface \n> during implementation?  \n\nA little bit of clarification is probably in order here.\n\nFirst, the normal life cycle of a working group is to form, develop one or more protocol specifications, then shut down. The act of shutting down simply means the WG doesn't intend on performing any more new protocol development, and is not expected to hold additional WG meetings at IETF conferences.\n\nThe mailing list used by the working group typically remains active (for example, the HTTP working group mailing list still works), and interoperability and protocol usage discussions take place there.\n\nThere is no established process for revision of RFCs. In the case of HTTP 1.1 going from Proposed to Draft, the process took place on the HTTP WG mailing list, and there were HTTP WG meetings at the IETF during this process. But, it is also acceptable for just the document editors to hash out changes needed to go from Proposed to Draft.  This was the case with RFC 2396 on the URI syntax.\n\nIn the case of DeltaV, I think it makes sense to have protocol revision discussion take place on the lists. It also makes sense to keep the WG alive, at least in a quiescent state, so that face to face IETF meetings could be held in the future, if necessary. It would be good for the Chair, Jim Amsden, to confirm with the Application Area directors that this is an acceptable plan, and to see if revision of the charter is necessary to accomplish this.  Without any further input, the ADs may decide that DeltaV is done, and should close, leaving further development to the DeltaV developer community.\n\nIn any case, the mailing list will remain up.\n\n- Jim\n\n\n \n\n\n\n", "id": "lists-006-15120446"}, {"subject": "Re: Submission: deltav subse", "content": "Roy,\nWe're not talking about shutting down DeltaV just yet. As I pointed out \nbelow, the spec isn't an Internet Standard yet, we still have quite a ways \nto go. However, the current working group has fulfilled its charter and \nits time to update it or create a new one. The work that remains is to see \nhow well the spec is adopted, both by clients and servers, and how well we \nmet our goals, including interoperability objectives. To do this I think \nwe need some \"quiet time\" where we aren't making substantive changes to \nthe spec so developers have something stable to build from. Once we have \nmore experience, we should see what work is left to do and establish a new \ncharter to address it. This doesn't need to be a continuation of DeltaV, \nbut it could be. We have an established community and infrastructure \n(webdav.org and the DeltaV mailing list). Depending on what surfaces, we \nmay want to leverage the existing working group for continuity.\n\nIn an case, if DeltaV did shutdown, the process would be to hold a BOF at \nan IETF meeting to introduce ideas and gather interest, develop a new \ncharter spelling out the activities of a new working group, getting AD \napproval, and doing the work by submitting Internet drafts. This is \ncertainly the right way to go for significant new features like change \nmanagement for example. But for expedience, fixing details and \ninteroperability problems in the current spec should probably be done in \nthe context of the current working group. \n\n\n\n\nRoy Seto <Roy.Seto@oracle.com>\nSent by: ietf-dav-versioning-request@w3.org\n10/22/2001 04:55 PM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        Re: Submission: deltav subset\n\n \n\nIf the WG shuts down, what is the accepted mechanism for hashing out \nprotocol usage issues that surface during implementation? \nRoy \nJim Amsden wrote: \n  \nI'm inclined to declare victory on our DeltaV charter and let some servers \nget built on what we have before we start making a lot of immediate \nchanges. Of course I would welcome any BOF to determine level of interest \nin extensions, new packages, etc. DeltaV is now firmly on the standards \ntrack. The next step is to get some implementation and determine \ninteroperability issues. If the community fragments immediately on \ndifferent packages that aren't interoperable in meaningful ways, then \ncertainly that's good information for the standards process that would \nneed to be addressed. But I think the community would benefit from \nattempting to implement the spec as written so we encourage \ninteroperability. \nAs for shutting down DeltaV, we're only at proposed standard. We could \nconsider updating the charter to move to the next stage in the lifecycle. \nI would be happy to entertain suggestions as to the content of such a \ncharter, and if there's sufficient interest, we can propose the next set \nof work items to the AD's as either continuation of DeltaV (with a new \ncharter), or other working groups focused on more specific tasks. \n \n \n \n\n\"Jim Whitehead\" <ejw@cse.ucsc.edu> \n10/18/2001 06:36 PM\n\n        To:        \"Clemm, Geoff\" <gclemm@rational.com>, \"'Lisa \nDusseault'\" <lisa@xythos.com>, \"Jim Amsden\" <jamsden@us.ibm.com> \n        cc:  \n        Subject:        RE: Submission: deltav subset \n \n\n \nGeoff Clemm writes: \n> I think it is more appropriate to keep it as an \n> individual submission until the working group has had \n> a chance to review/iterate on it. \nThis may be true, but IETF policy does say that it is the Chair's \ndiscretion \non whether a document is a WG draft or an individual submission. \nI was just pointing out that Jim may cause friction with the ADs if, by \nmaking a new WG draft, he extends the life of DeltaV when they think it's \nclose to being shut down. I imagine they are keen to avoid another WebDAV \n:-) \nBut, even if Jim does decide that it should not be a new draft, it would \nbe \nwell within Lisa's rights to hold a BOF at the next IETF with an eye \ntowards \ncreating a new WG, \"SDV\" (simple Delta V), say. \n- Jim \n \n \n \n\n\n\n", "id": "lists-006-15129334"}, {"subject": "RE: Submission: deltav subse", "content": "I think the definition of this deltav subset is very much needed\nand that Lisa has made a very good start with it. To be more specific:\n\n- Our server falls (from deltav point of view) into the same group\n  as sharemation does: linear versioning on resources, no versioning\n  on collections. There is definitly a need for such servers.\n- DeltaV is so rich (and for good reasons) that as an implementor\n  you have to make quite a lot of choices. The definition of a subset\n  would give guidance in this process and ensure interoperability.\n  Without such a definition, I see interworking between deltav\n  servers and clients as a much longer and more painful process\n  than it needs to be.\n\n//Stefan\n\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n>\n> I'll explain some of the background to this message, since I started the\n> thread below its cc' list was expanded.  Initially, I asked Jim\n> Amsden if he\n> wanted a new deltav-related internet-draft to be a working group\n> draft or an\n> individual submission.  This explains the history and reasons\n> behind the new\n> internet-draft...\n>\n> I've talked to various people in the last few months, both those involved\n> directly in the DeltaV WG and those mostly involved in WebDAV but\n> keeping an\n> eye on DeltaV.  A common theme has been some uncertainty what features\n> should be implemented for simple versioning, in software not intended for\n> source control but just for web authoring or document management.  The\n> existing packages defined in DeltaV are a good start, but there's\n> still lot\n> of possible variation in how to implement a DeltaV server or client even\n> once a package has been chosen.\n>\n> Thus, I've been working on a document to make it easier for simple WebDAV\n> authoring clients to implement DeltaV, by selecting a number of\n> features and\n> a number of simplifications that a server can make.  If a server\n> advertises\n> these simplifications, then the client's job is much easier (the client\n> won't have to worry about forking, multiple checkouts, older versions\n> getting checked out, or older versions being targetted).  Both the server\n> and the client can still be DeltaV compatible.\n>\n> I've posted the initial draft on\n> http://www.sharemation.com/~milele/public/dav, and it should soon be\n> available on the IETF site as well.  I'm very much interested in hearing\n> comments, suggestions, etc.  Much thanks to Peter Raymond, Alan Kent and\n> Mark Hale for their initial comments.\n>\n> Lisa\n>\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> Sent: October 18, 2001 4:35 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Submission: deltav subset\n>\n>\n>\n> I'm inclined to declare victory on our DeltaV charter and let some servers\n> get built on what we have before we start making a lot of\n> immediate changes.\n> Of course I would welcome any BOF to determine level of interest in\n> extensions, new packages, etc. DeltaV is now firmly on the\n> standards track.\n> The next step is to get some implementation and determine interoperability\n> issues. If the community fragments immediately on different packages that\n> aren't interoperable in meaningful ways, then certainly that's good\n> information for the standards process that would need to be\n> addressed. But I\n> think the community would benefit from attempting to implement the spec as\n> written so we encourage interoperability.\n>\n> As for shutting down DeltaV, we're only at proposed standard. We could\n> consider updating the charter to move to the next stage in the\n> lifecycle. I\n> would be happy to entertain suggestions as to the content of such\n> a charter,\n> and if there's sufficient interest, we can propose the next set of work\n> items to the AD's as either continuation of DeltaV (with a new\n> charter), or\n> other working groups focused on more specific tasks.\n>\n>\n>\n> \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n> 10/18/2001 06:36 PM\n>\n>         To:        \"Clemm, Geoff\" <gclemm@rational.com>, \"'Lisa\n> Dusseault'\"\n> <lisa@xythos.com>, \"Jim Amsden\" <jamsden@us.ibm.com>\n>         cc:\n>         Subject:        RE: Submission: deltav subset\n>\n>\n>\n>\n>\n> Geoff Clemm writes:\n> > I think it is more appropriate to keep it as an\n> > individual submission until the working group has had\n> > a chance to review/iterate on it.\n>\n> This may be true, but IETF policy does say that it is the Chair's\n> discretion\n> on whether a document is a WG draft or an individual submission.\n>\n> I was just pointing out that Jim may cause friction with the ADs if, by\n> making a new WG draft, he extends the life of DeltaV when they think it's\n> close to being shut down. I imagine they are keen to avoid another WebDAV\n> :-)\n>\n> But, even if Jim does decide that it should not be a new draft,\n> it would be\n> well within Lisa's rights to hold a BOF at the next IETF with an\n> eye towards\n> creating a new WG, \"SDV\" (simple Delta V), say.\n>\n> - Jim\n>\n>\n>\n\n\n\n", "id": "lists-006-15142228"}, {"subject": "MS webfolder bug on COPY/MOV", "content": "During testing we found the following issue with the Microsoft webfolder\nclient (sent here so it is propertly archived):\n\nGiven a WebDAV collection mounted as:\n\nhttp://host/localdir,\n\na collection resource\n\nhttp://host/localdir/collection\n\nand a member\n\nhttp://host/localdir/file\n\nUpon trying to move \"file\" into \"collection\", the MS webfolder client will\nsend the following request:\n\nMOVE http://host/file HTTP/1.0\nHost: lisa.greenbytes.de:8080\nDestination: http://host/localdir/collection/file\nTranslate: f\nProxy-Connection: Keep-Alive\nContent-Length: 0\nOverwrite: F\nPragma: no-cache\nContent-Language: en-us\nUser-Agent: Microsoft Data Access Internet Publishing Provider DAV\nAccept-Language: de, en-us;q=0.2\n\nSo in the request URI, the path is wrong. Note that this only happens if the\nwebfolder client \"thinks\" that it's operating in the root of the mounted\nnamespace -- that is, if http://host is mounted instead of\nhttp://host/localdir, the request URI will be correct.\n\nJulian\n\n\n\n", "id": "lists-006-15158036"}, {"subject": "Guidance of DAV: namespace usage in draft", "content": "Hi,\n\nI think I've come across an issue with the way WebDAV related drafts use the\nDAV: namespace. While this mainly applies to individual submissions (like\nours: [1]), it also applies in some way to deltaV and ACL.\n\nIn section 1.5 [2], deltaV says:\n\nAlthough WebDAV request and response bodies can be extended by arbitrary\nXML elements, which can be ignored by the message recipient, an XML element\nin the DAV namespace MUST NOT be used in the request or response body of a\nversioning method unless that XML element is explicitly defined in an IETF\nRFC.\n\nWhich I thing is a good thing. However this leaves us with the question:\nwhich namespace *should* be used in drafts that are *planned* to become an\nRFC?\n\n- Putting elements into the DAV: namespace might not be a good idea, *even*\nfor deltaV or ACL until they reach RFC status. By using a different\nnamespace, ambiguities about what version of the spec is supported could be\navoided. This would be similar to the W3C practice of using a new namespace\neach time a Working Draft changes incompatibily.\n\n- \"DAV:experimental\" seems to be an option, although this would require that\nthe registrar of the DAV: URI scheme finally defines the syntax of it\n(hint).\n\n- Another approach would be to use a \"private\" namespace for individual\nsubmissions (probably the cleanest approach).\n\nThe reason why I'm raising this right now is that our WebDAV server\n(obviously) supports the extensions we have proposed (of which two need\nextension elements). The IDs (Internet Drafts) use the DAV: namespace. We\nnow have the choice of either actually *implementing* the extension using\nthe DAV: namespace (which doesn't seem to be good style), or to use a custom\nnamespace (and to bring the IDs in line with that).\n\nFeedback appreciated.\n\nJulian\n\n\n\n[1] <http://www.greenbytes.de/tech/webdav/>\n[2]\n<http://www.greenbytes.de/tech/webdav/draft-ietf-deltav-versioning-20.htm#_T\noc524830510>\n\n\n\n", "id": "lists-006-15166380"}, {"subject": "I-D ACTION:draft-dusseault-deltav-subset-00.tx", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\n\n\nTitle: DeltaV Subset for Simple Authoring\nAuthor(s): L. Dusseault\nFilename: draft-dusseault-deltav-subset-00.txt\nPages: 19\nDate: 22-Oct-01\n\nThis document specifies a consistent profile or subset of the \nfeatures from the DeltaV specification [DeltaV].  The subset is \nsuitable for simple linear document versioning in a WebDAV [RFC2518] \nenvironment.  The subset is intended to limit functionality in order \nto improve predictability and thus interoperability.  If a server \nadvertises support for this subset, then a client can interoperate \nwith that server very easily due to its predictability.  A server \nadvertising support for this subset MUST also support DeltaV.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-dusseault-deltav-subset-00.txt\n\nTo remove yourself from the IETF Announcement list, send a message to \nietf-announce-request with the word unsubscribe in the body of the message.\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-dusseault-deltav-subset-00.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-dusseault-deltav-subset-00.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n\n\n\nMessage/External-body attachment: stored\n\n\n\n\n", "id": "lists-006-15175930"}, {"subject": "I-D ACTION:draft-ietf-deltav-versioning-19.tx", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Web Versioning and Configuration Management Working Group of the IETF.\n\nTitle: Versioning Extensions to WebDAV\nAuthor(s): G. Clemm, J. Amsden, T. Ellison, C. Kaler, \n                          J. Whitehead\nFilename: draft-ietf-deltav-versioning-19.txt\nPages: 106\nDate: 22-Oct-01\n\nThis document specifies a set of methods, headers, and resource types \nthat define the WebDAV Versioning extensions to the HTTP/1.1 protocol. \nWebDAV Versioning will minimize the complexity of clients that are\ncapable of interoperating with a variety of versioning repository\nmanagers, to facilitate widespread deployment of applications capable of\nutilizing the WebDAV Versioning services.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-19.txt\n\nTo remove yourself from the IETF Announcement list, send a message to \nietf-announce-request with the word unsubscribe in the body of the message.\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-deltav-versioning-19.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-deltav-versioning-19.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n\n\n\nMessage/External-body attachment: stored\n\n\n\n\n", "id": "lists-006-15184989"}, {"subject": "RE: Submission: deltav subse", "content": "I have my doubts that defining a common subset of DeltaV that makes sense to\na big group of people is achievable (I remember similar discussions in\nxml-dev about removing \"unnecessary\" features from XML: everybody agreed\nthat there are some, but it wasn't possible to agree about *which* were\nunnecessary).\n\nIn particular, Lisa's proposal says that a server MUST support the\nversion-history feature. Ours doesn't (and can't be easily changed to\nsupport it). Yet, information about the existing versions can be retrieved\nusing REPORT, so *I* would argue this is an unnecessary feature :-).\n\nThat said, it is certainly a good thing to publish detailed information\nabout specific deltaV implementations (and their recommended usage).\nHowever, I'm not so sure that this belongs into an Internet Draft.\n\nJulian\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Stefan Eissing\n> Sent: Tuesday, October 23, 2001 10:11 AM\n> To: Lisa Dusseault; Jim Amsden; ietf-dav-versioning@w3.org\n> Subject: RE: Submission: deltav subset\n>\n>\n> I think the definition of this deltav subset is very much needed\n> and that Lisa has made a very good start with it. To be more specific:\n>\n> - Our server falls (from deltav point of view) into the same group\n>   as sharemation does: linear versioning on resources, no versioning\n>   on collections. There is definitly a need for such servers.\n> - DeltaV is so rich (and for good reasons) that as an implementor\n>   you have to make quite a lot of choices. The definition of a subset\n>   would give guidance in this process and ensure interoperability.\n>   Without such a definition, I see interworking between deltav\n>   servers and clients as a much longer and more painful process\n>   than it needs to be.\n>\n> //Stefan\n>\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> >\n> > I'll explain some of the background to this message, since I started the\n> > thread below its cc' list was expanded.  Initially, I asked Jim\n> > Amsden if he\n> > wanted a new deltav-related internet-draft to be a working group\n> > draft or an\n> > individual submission.  This explains the history and reasons\n> > behind the new\n> > internet-draft...\n> >\n> > I've talked to various people in the last few months, both\n> those involved\n> > directly in the DeltaV WG and those mostly involved in WebDAV but\n> > keeping an\n> > eye on DeltaV.  A common theme has been some uncertainty what features\n> > should be implemented for simple versioning, in software not\n> intended for\n> > source control but just for web authoring or document management.  The\n> > existing packages defined in DeltaV are a good start, but there's\n> > still lot\n> > of possible variation in how to implement a DeltaV server or client even\n> > once a package has been chosen.\n> >\n> > Thus, I've been working on a document to make it easier for\n> simple WebDAV\n> > authoring clients to implement DeltaV, by selecting a number of\n> > features and\n> > a number of simplifications that a server can make.  If a server\n> > advertises\n> > these simplifications, then the client's job is much easier (the client\n> > won't have to worry about forking, multiple checkouts, older versions\n> > getting checked out, or older versions being targetted).  Both\n> the server\n> > and the client can still be DeltaV compatible.\n> >\n> > I've posted the initial draft on\n> > http://www.sharemation.com/~milele/public/dav, and it should soon be\n> > available on the IETF site as well.  I'm very much interested in hearing\n> > comments, suggestions, etc.  Much thanks to Peter Raymond, Alan Kent and\n> > Mark Hale for their initial comments.\n> >\n> > Lisa\n> >\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> > Sent: October 18, 2001 4:35 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: RE: Submission: deltav subset\n> >\n> >\n> >\n> > I'm inclined to declare victory on our DeltaV charter and let\n> some servers\n> > get built on what we have before we start making a lot of\n> > immediate changes.\n> > Of course I would welcome any BOF to determine level of interest in\n> > extensions, new packages, etc. DeltaV is now firmly on the\n> > standards track.\n> > The next step is to get some implementation and determine\n> interoperability\n> > issues. If the community fragments immediately on different\n> packages that\n> > aren't interoperable in meaningful ways, then certainly that's good\n> > information for the standards process that would need to be\n> > addressed. But I\n> > think the community would benefit from attempting to implement\n> the spec as\n> > written so we encourage interoperability.\n> >\n> > As for shutting down DeltaV, we're only at proposed standard. We could\n> > consider updating the charter to move to the next stage in the\n> > lifecycle. I\n> > would be happy to entertain suggestions as to the content of such\n> > a charter,\n> > and if there's sufficient interest, we can propose the next set of work\n> > items to the AD's as either continuation of DeltaV (with a new\n> > charter), or\n> > other working groups focused on more specific tasks.\n> >\n> >\n> >\n> > \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n> > 10/18/2001 06:36 PM\n> >\n> >         To:        \"Clemm, Geoff\" <gclemm@rational.com>, \"'Lisa\n> > Dusseault'\"\n> > <lisa@xythos.com>, \"Jim Amsden\" <jamsden@us.ibm.com>\n> >         cc:\n> >         Subject:        RE: Submission: deltav subset\n> >\n> >\n> >\n> >\n> >\n> > Geoff Clemm writes:\n> > > I think it is more appropriate to keep it as an\n> > > individual submission until the working group has had\n> > > a chance to review/iterate on it.\n> >\n> > This may be true, but IETF policy does say that it is the Chair's\n> > discretion\n> > on whether a document is a WG draft or an individual submission.\n> >\n> > I was just pointing out that Jim may cause friction with the ADs if, by\n> > making a new WG draft, he extends the life of DeltaV when they\n> think it's\n> > close to being shut down. I imagine they are keen to avoid\n> another WebDAV\n> > :-)\n> >\n> > But, even if Jim does decide that it should not be a new draft,\n> > it would be\n> > well within Lisa's rights to hold a BOF at the next IETF with an\n> > eye towards\n> > creating a new WG, \"SDV\" (simple Delta V), say.\n> >\n> > - Jim\n> >\n> >\n> >\n>\n>\n>\n>\n\n\n\n", "id": "lists-006-15194041"}, {"subject": "FW: Submission: deltav subse", "content": " Hi all,\n \n we (a colleague and me) are currently implementing a DeltaV \n compliant webdav server. Our reflections about a \"basic\" webdav \n server are very close to the deltav subset. The actual state of the \n implementation looks very close to lisas subset, excluding the version \n history feature. We haven't taken a closer look at this yet. \n \n We think, this subset is quite a goot idea for implementing \n the basic operations for a webdav server without having a \n deeper knowledge of the DeltaV standard. We actually really \n enjoyed reading it. \n\n The subset seems to be a first impression about the most important\noperations\n and properties of DeltaV. If other is needed, one can consult the \n DeltaV standard.\n\n We are of course open for discussions. \n \n greetings\n \n Cristina\n> \n> > -----Original Message-----\n> > From: Julian Reschke [mailto:julian.reschke@greenbytes.de]\n> > Sent: Dienstag, 23. Oktober 2001 14:01\n> > To: Stefan Eissing; Lisa Dusseault; Jim Amsden;\n> > ietf-dav-versioning@w3.org\n> > Subject: RE: Submission: deltav subset\n> > \n> > \n> > I have my doubts that defining a common subset of DeltaV that \n> > makes sense to\n> > a big group of people is achievable (I remember similar \n> discussions in\n> > xml-dev about removing \"unnecessary\" features from XML: \n> > everybody agreed\n> > that there are some, but it wasn't possible to agree about \n> > *which* were\n> > unnecessary).\n> > \n> > In particular, Lisa's proposal says that a server MUST support the\n> > version-history feature. Ours doesn't (and can't be easily \n> changed to\n> > support it). Yet, information about the existing versions can \n> > be retrieved\n> > using REPORT, so *I* would argue this is an unnecessary feature :-).\n> > \n> > That said, it is certainly a good thing to publish detailed \n> > information\n> > about specific deltaV implementations (and their recommended usage).\n> > However, I'm not so sure that this belongs into an Internet Draft.\n> > \n> > Julian\n> > \n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of \n> > Stefan Eissing\n> > > Sent: Tuesday, October 23, 2001 10:11 AM\n> > > To: Lisa Dusseault; Jim Amsden; ietf-dav-versioning@w3.org\n> > > Subject: RE: Submission: deltav subset\n> > >\n> > >\n> > > I think the definition of this deltav subset is very much needed\n> > > and that Lisa has made a very good start with it. To be \n> > more specific:\n> > >\n> > > - Our server falls (from deltav point of view) into the same group\n> > >   as sharemation does: linear versioning on resources, no \n> versioning\n> > >   on collections. There is definitly a need for such servers.\n> > > - DeltaV is so rich (and for good reasons) that as an implementor\n> > >   you have to make quite a lot of choices. The definition \n> > of a subset\n> > >   would give guidance in this process and ensure interoperability.\n> > >   Without such a definition, I see interworking between deltav\n> > >   servers and clients as a much longer and more painful process\n> > >   than it needs to be.\n> > >\n> > > //Stefan\n> > >\n> > > > From: ietf-dav-versioning-request@w3.org\n> > > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of \n> > Lisa Dusseault\n> > > >\n> > > > I'll explain some of the background to this message, \n> > since I started the\n> > > > thread below its cc' list was expanded.  Initially, I asked Jim\n> > > > Amsden if he\n> > > > wanted a new deltav-related internet-draft to be a working group\n> > > > draft or an\n> > > > individual submission.  This explains the history and reasons\n> > > > behind the new\n> > > > internet-draft...\n> > > >\n> > > > I've talked to various people in the last few months, both\n> > > those involved\n> > > > directly in the DeltaV WG and those mostly involved in \n> WebDAV but\n> > > > keeping an\n> > > > eye on DeltaV.  A common theme has been some uncertainty \n> > what features\n> > > > should be implemented for simple versioning, in software not\n> > > intended for\n> > > > source control but just for web authoring or document \n> > management.  The\n> > > > existing packages defined in DeltaV are a good start, \n> but there's\n> > > > still lot\n> > > > of possible variation in how to implement a DeltaV server \n> > or client even\n> > > > once a package has been chosen.\n> > > >\n> > > > Thus, I've been working on a document to make it easier for\n> > > simple WebDAV\n> > > > authoring clients to implement DeltaV, by selecting a number of\n> > > > features and\n> > > > a number of simplifications that a server can make.  If a server\n> > > > advertises\n> > > > these simplifications, then the client's job is much \n> > easier (the client\n> > > > won't have to worry about forking, multiple checkouts, \n> > older versions\n> > > > getting checked out, or older versions being targetted).  Both\n> > > the server\n> > > > and the client can still be DeltaV compatible.\n> > > >\n> > > > I've posted the initial draft on\n> > > > http://www.sharemation.com/~milele/public/dav, and it \n> > should soon be\n> > > > available on the IETF site as well.  I'm very much \n> > interested in hearing\n> > > > comments, suggestions, etc.  Much thanks to Peter \n> > Raymond, Alan Kent and\n> > > > Mark Hale for their initial comments.\n> > > >\n> > > > Lisa\n> > > >\n> > > > -----Original Message-----\n> > > > From: ietf-dav-versioning-request@w3.org\n> > > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of \n> Jim Amsden\n> > > > Sent: October 18, 2001 4:35 PM\n> > > > To: ietf-dav-versioning@w3.org\n> > > > Subject: RE: Submission: deltav subset\n> > > >\n> > > >\n> > > >\n> > > > I'm inclined to declare victory on our DeltaV charter and let\n> > > some servers\n> > > > get built on what we have before we start making a lot of\n> > > > immediate changes.\n> > > > Of course I would welcome any BOF to determine level of \n> > interest in\n> > > > extensions, new packages, etc. DeltaV is now firmly on the\n> > > > standards track.\n> > > > The next step is to get some implementation and determine\n> > > interoperability\n> > > > issues. If the community fragments immediately on different\n> > > packages that\n> > > > aren't interoperable in meaningful ways, then certainly \n> > that's good\n> > > > information for the standards process that would need to be\n> > > > addressed. But I\n> > > > think the community would benefit from attempting to implement\n> > > the spec as\n> > > > written so we encourage interoperability.\n> > > >\n> > > > As for shutting down DeltaV, we're only at proposed \n> > standard. We could\n> > > > consider updating the charter to move to the next stage in the\n> > > > lifecycle. I\n> > > > would be happy to entertain suggestions as to the \n> content of such\n> > > > a charter,\n> > > > and if there's sufficient interest, we can propose the \n> > next set of work\n> > > > items to the AD's as either continuation of DeltaV (with a new\n> > > > charter), or\n> > > > other working groups focused on more specific tasks.\n> > > >\n> > > >\n> > > >\n> > > > \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n> > > > 10/18/2001 06:36 PM\n> > > >\n> > > >         To:        \"Clemm, Geoff\" <gclemm@rational.com>, \"'Lisa\n> > > > Dusseault'\"\n> > > > <lisa@xythos.com>, \"Jim Amsden\" <jamsden@us.ibm.com>\n> > > >         cc:\n> > > >         Subject:        RE: Submission: deltav subset\n> > > >\n> > > >\n> > > >\n> > > >\n> > > >\n> > > > Geoff Clemm writes:\n> > > > > I think it is more appropriate to keep it as an\n> > > > > individual submission until the working group has had\n> > > > > a chance to review/iterate on it.\n> > > >\n> > > > This may be true, but IETF policy does say that it is \n> the Chair's\n> > > > discretion\n> > > > on whether a document is a WG draft or an individual submission.\n> > > >\n> > > > I was just pointing out that Jim may cause friction with \n> > the ADs if, by\n> > > > making a new WG draft, he extends the life of DeltaV when they\n> > > think it's\n> > > > close to being shut down. I imagine they are keen to avoid\n> > > another WebDAV\n> > > > :-)\n> > > >\n> > > > But, even if Jim does decide that it should not be a new draft,\n> > > > it would be\n> > > > well within Lisa's rights to hold a BOF at the next IETF with an\n> > > > eye towards\n> > > > creating a new WG, \"SDV\" (simple Delta V), say.\n> > > >\n> > > > - Jim\n> > > >\n> > > >\n> > > >\n> > >\n> > >\n> > >\n> > >\n> > \n> > \n> \n\n\n\n", "id": "lists-006-15212958"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   I'm confused about this paragraph in 15.1, section 2.2.1:\n\n   \"In order to remove a resource from version control, a client can\n   COPY the version-controlled resource to a temporary location,\n   DELETE the version-controlled resource, and then MOVE the copy from\n   the temporary location back to the original URL.  The versions\n   created for that resource while it was under version control will\n   continue to exist at their server-defined locations.\"\n\n   I'd parse the first sentence to mean that when the COPY is done,\n   only one version is created at the destination.\n\nIn order for a resource to ever \"not be under version control\", it is\nnecessary that the server not automatically put all newly created\nresources under version control.  So that means that the COPY will do\nthe default thing, and create a non-version-controlled resource at the\ndestination of the COPY (but one whose content and dead properties are\nthe same as those of the version-controlled resource at the time of\nthe COPY).\n\n   Then when the MOVE\n   back is done, only one version is available at the original\n   location.\n\nAfter the MOVE, there are no versions available at the original\nlocation, just the new non-version-controlled resource.\n(In some generic sense of the word \"version\", there is a new\n\"version\" at the original location, but in the specific sense\nin which \"version\" is defined by DeltaV, there is no \"version\"\nresource available at the original location.\n\n   This has the effect of replacing 'n' versions with 1\n   version, and replacing a VCR with a non-version-controlled\n   (ordinary) resource.\n\nThe former, no, the latter, yes.\n\n   Then I read the second sentence, and I get confused.  The versions\n   all still exist?  Why?  What's the point?  How can that be?\n\nPossibly the confusion is caused by the first sentence of this\nparagraph.  It is not really a way to \"remove a resource from\nversion control\", but rather to \"remove the resource identified\nby a given URL from version control\".  How about the following\nrewording:\n\n\"In order to remove a resource at a given URL from version control, the\nclient can replace the resource under version control with a\nnon-version-controlled copy of that resource.  For example, a client\ncan COPY the version-controlled resource to a temporary location,\nDELETE the version-controlled resource, and then MOVE the copy from\nthe temporary location back to the original URL.  Note that the\nversions already created for the version-controlled resource will\ncontinue to exist at their server-defined locations.\"\n\nIs that clearer?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1522046"}, {"subject": "RE: Submission: deltav subse", "content": "We struggled since the beginning of DeltaV trying to determine THE minimal \nsubset everyone would build. No matter how we sliced it, someone wasn't \nhappy, so we'd slice it again. This consumed many hours in the design and \nworking group meetings and many mailing list submissions, and it looks \nlike we're not done yet. \n\nThe current spec addresses this problem the best way we could. It \nspecifies extremely minimal core versioning semantics that must be \nsupported by all DeltaV compliant servers, a number of optional features, \nand a set of recommended packages of features to provide functionality \nconsistent with common practice. This was an attempt to strike a balance \nbetween flexible implementation options for server writers with the need \nto minimize client complexity and encourage interoperability. We realize \nthe core versioning features are generally insufficient for any production \nversioning server, and some optional features must be implemented. The \npackages are our best effort at coming up with useful feature sets. If \nthese prove to be either wrong or insufficient in practice, then we should \nchange them as part of the natural evolution of the spec.\n\nHowever, I think it is important to work with what we have before \nintroducing a lot of new packages. Taken to its logical extreme, we'd have \none package per server vendor. This isn't necessarily bad, but it will \ncomplicate clients and inhibit interoperability. So I would encourage all \nserver writers to 1) focus first on the clients you expect to support, \ntheir use cases and required features. 2) Pick a package from the DeltaV \nspec that best meets you client needs. 3) Implement as much as you can \nfrom the package, and return error conditions for specific things you \ncan't support in such a way that clients can make requests consistent with \nthe package, and get reasonable feedback from a server that can't do them \nat the moment. 4) over time, address the features you don't fully support, \nand consider adding additional features to support other packages so you \ncan better support more clients.\n\n\n\n\n\n\"Julian Reschke\" <julian.reschke@greenbytes.de>\n10/23/2001 08:00 AM\n\n \n        To:     \"Stefan Eissing\" <stefan.eissing@greenbytes.de>, \"Lisa Dusseault\" \n<lisa@xythos.com>, \"Jim Amsden\" <jamsden@us.ibm.com>, \n<ietf-dav-versioning@w3.org>\n        cc: \n        Subject:        RE: Submission: deltav subset\n\n \n\nI have my doubts that defining a common subset of DeltaV that makes sense \nto\na big group of people is achievable (I remember similar discussions in\nxml-dev about removing \"unnecessary\" features from XML: everybody agreed\nthat there are some, but it wasn't possible to agree about *which* were\nunnecessary).\n\nIn particular, Lisa's proposal says that a server MUST support the\nversion-history feature. Ours doesn't (and can't be easily changed to\nsupport it). Yet, information about the existing versions can be retrieved\nusing REPORT, so *I* would argue this is an unnecessary feature :-).\n\nThat said, it is certainly a good thing to publish detailed information\nabout specific deltaV implementations (and their recommended usage).\nHowever, I'm not so sure that this belongs into an Internet Draft.\n\nJulian\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Stefan Eissing\n> Sent: Tuesday, October 23, 2001 10:11 AM\n> To: Lisa Dusseault; Jim Amsden; ietf-dav-versioning@w3.org\n> Subject: RE: Submission: deltav subset\n>\n>\n> I think the definition of this deltav subset is very much needed\n> and that Lisa has made a very good start with it. To be more specific:\n>\n> - Our server falls (from deltav point of view) into the same group\n>   as sharemation does: linear versioning on resources, no versioning\n>   on collections. There is definitly a need for such servers.\n> - DeltaV is so rich (and for good reasons) that as an implementor\n>   you have to make quite a lot of choices. The definition of a subset\n>   would give guidance in this process and ensure interoperability.\n>   Without such a definition, I see interworking between deltav\n>   servers and clients as a much longer and more painful process\n>   than it needs to be.\n>\n> //Stefan\n>\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> >\n> > I'll explain some of the background to this message, since I started \nthe\n> > thread below its cc' list was expanded.  Initially, I asked Jim\n> > Amsden if he\n> > wanted a new deltav-related internet-draft to be a working group\n> > draft or an\n> > individual submission.  This explains the history and reasons\n> > behind the new\n> > internet-draft...\n> >\n> > I've talked to various people in the last few months, both\n> those involved\n> > directly in the DeltaV WG and those mostly involved in WebDAV but\n> > keeping an\n> > eye on DeltaV.  A common theme has been some uncertainty what features\n> > should be implemented for simple versioning, in software not\n> intended for\n> > source control but just for web authoring or document management.  The\n> > existing packages defined in DeltaV are a good start, but there's\n> > still lot\n> > of possible variation in how to implement a DeltaV server or client \neven\n> > once a package has been chosen.\n> >\n> > Thus, I've been working on a document to make it easier for\n> simple WebDAV\n> > authoring clients to implement DeltaV, by selecting a number of\n> > features and\n> > a number of simplifications that a server can make.  If a server\n> > advertises\n> > these simplifications, then the client's job is much easier (the \nclient\n> > won't have to worry about forking, multiple checkouts, older versions\n> > getting checked out, or older versions being targetted).  Both\n> the server\n> > and the client can still be DeltaV compatible.\n> >\n> > I've posted the initial draft on\n> > http://www.sharemation.com/~milele/public/dav, and it should soon be\n> > available on the IETF site as well.  I'm very much interested in \nhearing\n> > comments, suggestions, etc.  Much thanks to Peter Raymond, Alan Kent \nand\n> > Mark Hale for their initial comments.\n> >\n> > Lisa\n> >\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> > Sent: October 18, 2001 4:35 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: RE: Submission: deltav subset\n> >\n> >\n> >\n> > I'm inclined to declare victory on our DeltaV charter and let\n> some servers\n> > get built on what we have before we start making a lot of\n> > immediate changes.\n> > Of course I would welcome any BOF to determine level of interest in\n> > extensions, new packages, etc. DeltaV is now firmly on the\n> > standards track.\n> > The next step is to get some implementation and determine\n> interoperability\n> > issues. If the community fragments immediately on different\n> packages that\n> > aren't interoperable in meaningful ways, then certainly that's good\n> > information for the standards process that would need to be\n> > addressed. But I\n> > think the community would benefit from attempting to implement\n> the spec as\n> > written so we encourage interoperability.\n> >\n> > As for shutting down DeltaV, we're only at proposed standard. We could\n> > consider updating the charter to move to the next stage in the\n> > lifecycle. I\n> > would be happy to entertain suggestions as to the content of such\n> > a charter,\n> > and if there's sufficient interest, we can propose the next set of \nwork\n> > items to the AD's as either continuation of DeltaV (with a new\n> > charter), or\n> > other working groups focused on more specific tasks.\n> >\n> >\n> >\n> > \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n> > 10/18/2001 06:36 PM\n> >\n> >         To:        \"Clemm, Geoff\" <gclemm@rational.com>, \"'Lisa\n> > Dusseault'\"\n> > <lisa@xythos.com>, \"Jim Amsden\" <jamsden@us.ibm.com>\n> >         cc:\n> >         Subject:        RE: Submission: deltav subset\n> >\n> >\n> >\n> >\n> >\n> > Geoff Clemm writes:\n> > > I think it is more appropriate to keep it as an\n> > > individual submission until the working group has had\n> > > a chance to review/iterate on it.\n> >\n> > This may be true, but IETF policy does say that it is the Chair's\n> > discretion\n> > on whether a document is a WG draft or an individual submission.\n> >\n> > I was just pointing out that Jim may cause friction with the ADs if, \nby\n> > making a new WG draft, he extends the life of DeltaV when they\n> think it's\n> > close to being shut down. I imagine they are keen to avoid\n> another WebDAV\n> > :-)\n> >\n> > But, even if Jim does decide that it should not be a new draft,\n> > it would be\n> > well within Lisa's rights to hold a BOF at the next IETF with an\n> > eye towards\n> > creating a new WG, \"SDV\" (simple Delta V), say.\n> >\n> > - Jim\n> >\n> >\n> >\n>\n>\n>\n>\n\n\n\n", "id": "lists-006-15233554"}, {"subject": "Small mistake in section 16.", "content": "Hi,\n\nIn Section 16.2 of the deltav document we specify that:\n\n\"A WebDAV versioning client should be designed to handle a mixture \nof 200 (OK) and 404 (Forbidden) responses\"\n\nI believe the 404 code is wrong, it should be 403.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-15255246"}, {"subject": "Eclipsed resources..", "content": "Hi,\n\nThe deltav draft (section 14.1.1) says that a non version-controlled\nresource can \n\"eclipse\" a version-controlled resource.  When the non version-controlled\nresource\nis deleted or moved the version-controlled member is exposed.\n\nI have a few questions/issues regarding this concept:\n\n1) What happens if a VERSION-CONTROL request is issued on the non\nversion-controlled\n   member that is eclipsing the version-controlled resource?\n\n2) BASELINE-CONTROL can be issued with a baseline URL in the request body\n(in order to\n   populate the collection), if there is a non version-controlled resource\nat the \n   destination whose binding name clashes with the name of a member in the\nbaseline does \n   eclipsing occur?  It seems like the same scenario but eclipsing is not\ndefined here.\n\n3) Why was this defined this way around? Surely the version-controlled\nmember should\n   take precedence over the non version-controlled resource.\n\n4) Why was this behaviour defined instead of just failing the UPDATE or\nMERGE request.\n   This eclipsing behaviour seems odd and it may confuse end users to have\ntheir resources\n   masked by some other resource.\n\nDoes anyone in the group have any good material explaining the \"hows and\nwhys\" of eclipsed\nversions? How did it get into the spec in the first place, was there use\ncases etc?\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-15262976"}, {"subject": "RE: Submission: deltav subse", "content": "I have my doubts about whether selecting a common subset is achievable too,\nbut I think it's worth a try given all the feedback I've heard.\n\nI debated about putting version history in, left it out tentatively then put\nit in again at the end.  The final reasons I put it in were:\n - we support it (hey, it's somewhere to start, and we support it for the\nfollowing reasons)\n - the best way I've found so far to make something unversioned, besides\ninventing a new syntax, is to support deleting the version history and have\nthe server clean up the VCR to become a regular resource\n - it's the only resource that can have custom properties that apply to all\nversions -- global properties\n\nSo I have a bunch of questions for you then, and anybody else who's\ninterested:\n\n - Have you considered supporting version histories as \"fake\" resources?\nThey don't need to have their own regular URLs -- they could be given URLs\nlike http://foo/bar/vcr.doc?access=version-history.  They don't need storage\nallocated for them.  All the server has to do is be able to pretend they\nexist.  Forgive me if you've already thought along these lines, but after\nall a specification is really about what's on the wire, not what's in the\ncode.\n\n - Do you think making something unversioned is not required in simple\nlinear versioning?\n - Do you think global properties are not required in simple linear\nversioning?\n\n - If you think making something unversioned is required, but still don't\nwant to support version history resources, how would you propose going about\nit?  Do you think it would be OK for \"DeltaV-subset\" to define new syntaxes?\n(Well, at the very least, we'd then have to rename the specification!)  So\nfar, I've carefully avoided defining anything new so far other than the\nOPTIONS string for deltav-subset.\n\nLisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Julian Reschke\n> Sent: October 23, 2001 5:01 AM\n> To: Stefan Eissing; Lisa Dusseault; Jim Amsden;\n> ietf-dav-versioning@w3.org\n> Subject: RE: Submission: deltav subset\n>\n>\n> I have my doubts that defining a common subset of DeltaV that\n> makes sense to\n> a big group of people is achievable (I remember similar discussions in\n> xml-dev about removing \"unnecessary\" features from XML: everybody agreed\n> that there are some, but it wasn't possible to agree about *which* were\n> unnecessary).\n>\n> In particular, Lisa's proposal says that a server MUST support the\n> version-history feature. Ours doesn't (and can't be easily changed to\n> support it). Yet, information about the existing versions can be retrieved\n> using REPORT, so *I* would argue this is an unnecessary feature :-).\n>\n> That said, it is certainly a good thing to publish detailed information\n> about specific deltaV implementations (and their recommended usage).\n> However, I'm not so sure that this belongs into an Internet Draft.\n>\n> Julian\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Stefan Eissing\n> > Sent: Tuesday, October 23, 2001 10:11 AM\n> > To: Lisa Dusseault; Jim Amsden; ietf-dav-versioning@w3.org\n> > Subject: RE: Submission: deltav subset\n> >\n> >\n> > I think the definition of this deltav subset is very much needed\n> > and that Lisa has made a very good start with it. To be more specific:\n> >\n> > - Our server falls (from deltav point of view) into the same group\n> >   as sharemation does: linear versioning on resources, no versioning\n> >   on collections. There is definitly a need for such servers.\n> > - DeltaV is so rich (and for good reasons) that as an implementor\n> >   you have to make quite a lot of choices. The definition of a subset\n> >   would give guidance in this process and ensure interoperability.\n> >   Without such a definition, I see interworking between deltav\n> >   servers and clients as a much longer and more painful process\n> >   than it needs to be.\n> >\n> > //Stefan\n> >\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> > >\n> > > I'll explain some of the background to this message, since I\n> started the\n> > > thread below its cc' list was expanded.  Initially, I asked Jim\n> > > Amsden if he\n> > > wanted a new deltav-related internet-draft to be a working group\n> > > draft or an\n> > > individual submission.  This explains the history and reasons\n> > > behind the new\n> > > internet-draft...\n> > >\n> > > I've talked to various people in the last few months, both\n> > those involved\n> > > directly in the DeltaV WG and those mostly involved in WebDAV but\n> > > keeping an\n> > > eye on DeltaV.  A common theme has been some uncertainty what features\n> > > should be implemented for simple versioning, in software not\n> > intended for\n> > > source control but just for web authoring or document management.  The\n> > > existing packages defined in DeltaV are a good start, but there's\n> > > still lot\n> > > of possible variation in how to implement a DeltaV server or\n> client even\n> > > once a package has been chosen.\n> > >\n> > > Thus, I've been working on a document to make it easier for\n> > simple WebDAV\n> > > authoring clients to implement DeltaV, by selecting a number of\n> > > features and\n> > > a number of simplifications that a server can make.  If a server\n> > > advertises\n> > > these simplifications, then the client's job is much easier\n> (the client\n> > > won't have to worry about forking, multiple checkouts, older versions\n> > > getting checked out, or older versions being targetted).  Both\n> > the server\n> > > and the client can still be DeltaV compatible.\n> > >\n> > > I've posted the initial draft on\n> > > http://www.sharemation.com/~milele/public/dav, and it should soon be\n> > > available on the IETF site as well.  I'm very much interested\n> in hearing\n> > > comments, suggestions, etc.  Much thanks to Peter Raymond,\n> Alan Kent and\n> > > Mark Hale for their initial comments.\n> > >\n> > > Lisa\n> > >\n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> > > Sent: October 18, 2001 4:35 PM\n> > > To: ietf-dav-versioning@w3.org\n> > > Subject: RE: Submission: deltav subset\n> > >\n> > >\n> > >\n> > > I'm inclined to declare victory on our DeltaV charter and let\n> > some servers\n> > > get built on what we have before we start making a lot of\n> > > immediate changes.\n> > > Of course I would welcome any BOF to determine level of interest in\n> > > extensions, new packages, etc. DeltaV is now firmly on the\n> > > standards track.\n> > > The next step is to get some implementation and determine\n> > interoperability\n> > > issues. If the community fragments immediately on different\n> > packages that\n> > > aren't interoperable in meaningful ways, then certainly that's good\n> > > information for the standards process that would need to be\n> > > addressed. But I\n> > > think the community would benefit from attempting to implement\n> > the spec as\n> > > written so we encourage interoperability.\n> > >\n> > > As for shutting down DeltaV, we're only at proposed standard. We could\n> > > consider updating the charter to move to the next stage in the\n> > > lifecycle. I\n> > > would be happy to entertain suggestions as to the content of such\n> > > a charter,\n> > > and if there's sufficient interest, we can propose the next\n> set of work\n> > > items to the AD's as either continuation of DeltaV (with a new\n> > > charter), or\n> > > other working groups focused on more specific tasks.\n> > >\n> > >\n> > >\n> > > \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n> > > 10/18/2001 06:36 PM\n> > >\n> > >         To:        \"Clemm, Geoff\" <gclemm@rational.com>, \"'Lisa\n> > > Dusseault'\"\n> > > <lisa@xythos.com>, \"Jim Amsden\" <jamsden@us.ibm.com>\n> > >         cc:\n> > >         Subject:        RE: Submission: deltav subset\n> > >\n> > >\n> > >\n> > >\n> > >\n> > > Geoff Clemm writes:\n> > > > I think it is more appropriate to keep it as an\n> > > > individual submission until the working group has had\n> > > > a chance to review/iterate on it.\n> > >\n> > > This may be true, but IETF policy does say that it is the Chair's\n> > > discretion\n> > > on whether a document is a WG draft or an individual submission.\n> > >\n> > > I was just pointing out that Jim may cause friction with the\n> ADs if, by\n> > > making a new WG draft, he extends the life of DeltaV when they\n> > think it's\n> > > close to being shut down. I imagine they are keen to avoid\n> > another WebDAV\n> > > :-)\n> > >\n> > > But, even if Jim does decide that it should not be a new draft,\n> > > it would be\n> > > well within Lisa's rights to hold a BOF at the next IETF with an\n> > > eye towards\n> > > creating a new WG, \"SDV\" (simple Delta V), say.\n> > >\n> > > - Jim\n> > >\n> > >\n> > >\n> >\n> >\n> >\n> >\n>\n\n\n\n", "id": "lists-006-15271710"}, {"subject": "Issues with section 22 of the deltav protocol document..", "content": "Hi,\n\nI have been reading through section 22 of the deltav document with other\nstaff here at MERANT.\nWe noted a few issues:\n\n22.3 (DeltaV-Compliant Collection) should support the MERGE method.  A\ncollection can be\n      a target for a MERGE operation.\n\n22.7 (Checked-In Version-Controlled Resource) should support the LABEL\nmethod.  \n     Label can be applied to a checked-in VCR.\n \n22.13 (Activity) The DAV:unreserved live property should be listed as a\nsupported live property.\n\n22.18 (Checked-Out Version-Controlled Configuration) should support all\nchecked-out version controlled\n      resource properties and methods as well as supporting all\nversion-controlled configuration \n      properties and methods.\n\nWhy isn't there a section for Checked-Out Version-Controlled Collection? Is\nit assumed that this\nresource is just a checked-out version controlled resource?\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-15293853"}, {"subject": "RE: Submission: deltav subse", "content": "Lisa,\n\nour server currently doesn't seem to support to make something unversioned\nexplicitly, nor do we feel that we need global properties. I guess this\nmakes our deltaV support \"simpler\" than yours :-)\n\nAnd yes, we have thought about emulating a VHR, but didn't find a compelling\nreason to do so.\n\nJulian\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: Tuesday, October 23, 2001 7:00 PM\n> To: Julian Reschke; Stefan Eissing; Jim Amsden;\n> ietf-dav-versioning@w3.org\n> Subject: RE: Submission: deltav subset\n>\n>\n> I have my doubts about whether selecting a common subset is\n> achievable too,\n> but I think it's worth a try given all the feedback I've heard.\n>\n> I debated about putting version history in, left it out\n> tentatively then put\n> it in again at the end.  The final reasons I put it in were:\n>  - we support it (hey, it's somewhere to start, and we support it for the\n> following reasons)\n>  - the best way I've found so far to make something unversioned, besides\n> inventing a new syntax, is to support deleting the version\n> history and have\n> the server clean up the VCR to become a regular resource\n>  - it's the only resource that can have custom properties that\n> apply to all\n> versions -- global properties\n>\n> So I have a bunch of questions for you then, and anybody else who's\n> interested:\n>\n>  - Have you considered supporting version histories as \"fake\" resources?\n> They don't need to have their own regular URLs -- they could be given URLs\n> like http://foo/bar/vcr.doc?access=version-history.  They don't\n> need storage\n> allocated for them.  All the server has to do is be able to pretend they\n> exist.  Forgive me if you've already thought along these lines, but after\n> all a specification is really about what's on the wire, not what's in the\n> code.\n>\n>  - Do you think making something unversioned is not required in simple\n> linear versioning?\n>  - Do you think global properties are not required in simple linear\n> versioning?\n>\n>  - If you think making something unversioned is required, but still don't\n> want to support version history resources, how would you propose\n> going about\n> it?  Do you think it would be OK for \"DeltaV-subset\" to define\n> new syntaxes?\n> (Well, at the very least, we'd then have to rename the specification!)  So\n> far, I've carefully avoided defining anything new so far other than the\n> OPTIONS string for deltav-subset.\n>\n> Lisa\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Julian Reschke\n> > Sent: October 23, 2001 5:01 AM\n> > To: Stefan Eissing; Lisa Dusseault; Jim Amsden;\n> > ietf-dav-versioning@w3.org\n> > Subject: RE: Submission: deltav subset\n> >\n> >\n> > I have my doubts that defining a common subset of DeltaV that\n> > makes sense to\n> > a big group of people is achievable (I remember similar discussions in\n> > xml-dev about removing \"unnecessary\" features from XML: everybody agreed\n> > that there are some, but it wasn't possible to agree about *which* were\n> > unnecessary).\n> >\n> > In particular, Lisa's proposal says that a server MUST support the\n> > version-history feature. Ours doesn't (and can't be easily changed to\n> > support it). Yet, information about the existing versions can\n> be retrieved\n> > using REPORT, so *I* would argue this is an unnecessary feature :-).\n> >\n> > That said, it is certainly a good thing to publish detailed information\n> > about specific deltaV implementations (and their recommended usage).\n> > However, I'm not so sure that this belongs into an Internet Draft.\n> >\n> > Julian\n> >\n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Stefan Eissing\n> > > Sent: Tuesday, October 23, 2001 10:11 AM\n> > > To: Lisa Dusseault; Jim Amsden; ietf-dav-versioning@w3.org\n> > > Subject: RE: Submission: deltav subset\n> > >\n> > >\n> > > I think the definition of this deltav subset is very much needed\n> > > and that Lisa has made a very good start with it. To be more specific:\n> > >\n> > > - Our server falls (from deltav point of view) into the same group\n> > >   as sharemation does: linear versioning on resources, no versioning\n> > >   on collections. There is definitly a need for such servers.\n> > > - DeltaV is so rich (and for good reasons) that as an implementor\n> > >   you have to make quite a lot of choices. The definition of a subset\n> > >   would give guidance in this process and ensure interoperability.\n> > >   Without such a definition, I see interworking between deltav\n> > >   servers and clients as a much longer and more painful process\n> > >   than it needs to be.\n> > >\n> > > //Stefan\n> > >\n> > > > From: ietf-dav-versioning-request@w3.org\n> > > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> Lisa Dusseault\n> > > >\n> > > > I'll explain some of the background to this message, since I\n> > started the\n> > > > thread below its cc' list was expanded.  Initially, I asked Jim\n> > > > Amsden if he\n> > > > wanted a new deltav-related internet-draft to be a working group\n> > > > draft or an\n> > > > individual submission.  This explains the history and reasons\n> > > > behind the new\n> > > > internet-draft...\n> > > >\n> > > > I've talked to various people in the last few months, both\n> > > those involved\n> > > > directly in the DeltaV WG and those mostly involved in WebDAV but\n> > > > keeping an\n> > > > eye on DeltaV.  A common theme has been some uncertainty\n> what features\n> > > > should be implemented for simple versioning, in software not\n> > > intended for\n> > > > source control but just for web authoring or document\n> management.  The\n> > > > existing packages defined in DeltaV are a good start, but there's\n> > > > still lot\n> > > > of possible variation in how to implement a DeltaV server or\n> > client even\n> > > > once a package has been chosen.\n> > > >\n> > > > Thus, I've been working on a document to make it easier for\n> > > simple WebDAV\n> > > > authoring clients to implement DeltaV, by selecting a number of\n> > > > features and\n> > > > a number of simplifications that a server can make.  If a server\n> > > > advertises\n> > > > these simplifications, then the client's job is much easier\n> > (the client\n> > > > won't have to worry about forking, multiple checkouts,\n> older versions\n> > > > getting checked out, or older versions being targetted).  Both\n> > > the server\n> > > > and the client can still be DeltaV compatible.\n> > > >\n> > > > I've posted the initial draft on\n> > > > http://www.sharemation.com/~milele/public/dav, and it should soon be\n> > > > available on the IETF site as well.  I'm very much interested\n> > in hearing\n> > > > comments, suggestions, etc.  Much thanks to Peter Raymond,\n> > Alan Kent and\n> > > > Mark Hale for their initial comments.\n> > > >\n> > > > Lisa\n> > > >\n> > > > -----Original Message-----\n> > > > From: ietf-dav-versioning-request@w3.org\n> > > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> > > > Sent: October 18, 2001 4:35 PM\n> > > > To: ietf-dav-versioning@w3.org\n> > > > Subject: RE: Submission: deltav subset\n> > > >\n> > > >\n> > > >\n> > > > I'm inclined to declare victory on our DeltaV charter and let\n> > > some servers\n> > > > get built on what we have before we start making a lot of\n> > > > immediate changes.\n> > > > Of course I would welcome any BOF to determine level of interest in\n> > > > extensions, new packages, etc. DeltaV is now firmly on the\n> > > > standards track.\n> > > > The next step is to get some implementation and determine\n> > > interoperability\n> > > > issues. If the community fragments immediately on different\n> > > packages that\n> > > > aren't interoperable in meaningful ways, then certainly that's good\n> > > > information for the standards process that would need to be\n> > > > addressed. But I\n> > > > think the community would benefit from attempting to implement\n> > > the spec as\n> > > > written so we encourage interoperability.\n> > > >\n> > > > As for shutting down DeltaV, we're only at proposed\n> standard. We could\n> > > > consider updating the charter to move to the next stage in the\n> > > > lifecycle. I\n> > > > would be happy to entertain suggestions as to the content of such\n> > > > a charter,\n> > > > and if there's sufficient interest, we can propose the next\n> > set of work\n> > > > items to the AD's as either continuation of DeltaV (with a new\n> > > > charter), or\n> > > > other working groups focused on more specific tasks.\n> > > >\n> > > >\n> > > >\n> > > > \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n> > > > 10/18/2001 06:36 PM\n> > > >\n> > > >         To:        \"Clemm, Geoff\" <gclemm@rational.com>, \"'Lisa\n> > > > Dusseault'\"\n> > > > <lisa@xythos.com>, \"Jim Amsden\" <jamsden@us.ibm.com>\n> > > >         cc:\n> > > >         Subject:        RE: Submission: deltav subset\n> > > >\n> > > >\n> > > >\n> > > >\n> > > >\n> > > > Geoff Clemm writes:\n> > > > > I think it is more appropriate to keep it as an\n> > > > > individual submission until the working group has had\n> > > > > a chance to review/iterate on it.\n> > > >\n> > > > This may be true, but IETF policy does say that it is the Chair's\n> > > > discretion\n> > > > on whether a document is a WG draft or an individual submission.\n> > > >\n> > > > I was just pointing out that Jim may cause friction with the\n> > ADs if, by\n> > > > making a new WG draft, he extends the life of DeltaV when they\n> > > think it's\n> > > > close to being shut down. I imagine they are keen to avoid\n> > > another WebDAV\n> > > > :-)\n> > > >\n> > > > But, even if Jim does decide that it should not be a new draft,\n> > > > it would be\n> > > > well within Lisa's rights to hold a BOF at the next IETF with an\n> > > > eye towards\n> > > > creating a new WG, \"SDV\" (simple Delta V), say.\n> > > >\n> > > > - Jim\n> > > >\n> > > >\n> > > >\n> > >\n> > >\n> > >\n> > >\n> >\n>\n>\n\n\n\n", "id": "lists-006-15302619"}, {"subject": "DTD for supported-method-set (3.1.3", "content": "DeltaV Draft 20 says:\n\n--\n\n3.1.3           DAV:supported-method-set (protected)\nThis property identifies the methods that are supported by the resource.  A\nmethod is supported by a resource if there is some state of that resource\nfor which an application of that method will successfully satisfy all\npostconditions of that method, including any additional postconditions added\nby the features supported by that resource.\n\n<!ELEMENT supported-method-set (supported-method*)>\n\n<!ELEMENT supported-method ANY>\n\n<!ATTLIST supported-method name NMTOKEN #REQUIRED>\n\nname value: a method name\n\n--\n\na) Why is the content model for supported-method \"ANY\"? Just for extensions?\n\nb) Do we agree that the attribute name is not qualified (so it is in no\nnamespace)?\n\nIn retrospective, just defining properties in terms of DTDs -- while DTDs\ncan by definition not be normative for WebDAV (*) -- isn't a good idea.\n\n(*) DTDs can not properly capture namespace information. Neither can they\nadequately model the extensible model defined in section C.2.2 of RFC2518\n(<http://www.greenbytes.de/tech/webdav/rfc2518.html#rfc.section.C.2.2>).\n\nJulian\n\n\n\n", "id": "lists-006-15327192"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "> the temporary location back to the original URL.  Note that the\n> versions already created for the version-controlled resource will\n> continue to exist at their server-defined locations.\"\n\nThis is clearer, but still problematic.  You've disguised a normative\nrequirement as a clarification.  Without this \"Note\" on the end, my\nimplementation would have done away with (deleted, gone, byebye) all the\nversions that are no longer associated with a version-controlled resource.\n\nIf it is a requirement that the versions already created MUST stay around,\neven when the version-controlled resource is replaced by a\nnon-version-controlled resource, then this must be a MUST.\n\nI'd prefer to say that the versions that are no longer associated with a VCR\nMAY be gone.\n\nlisa\n\n\n\n", "id": "lists-006-1532845"}, {"subject": "RE: Guidance of DAV: namespace usage in draft", "content": "I agree that using a custom namespace is the right way to go\nfor properties defined in individual submissions.\nI think it is better for early implementors to have a\n\"custom else DAV switch\", than for the DAV namespace to\nbecome uncontrolled.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Julian Reschke [mailto:julian.reschke@gmx.de]\nSent: Tuesday, October 23, 2001 4:37 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Guidance of DAV: namespace usage in drafts\n\n\nHi,\n\nI think I've come across an issue with the way WebDAV related drafts use the\nDAV: namespace. While this mainly applies to individual submissions (like\nours: [1]), it also applies in some way to deltaV and ACL.\n\nIn section 1.5 [2], deltaV says:\n\nAlthough WebDAV request and response bodies can be extended by\narbitrary\nXML elements, which can be ignored by the message recipient, an XML element\nin the DAV namespace MUST NOT be used in the request or response body of a\nversioning method unless that XML element is explicitly defined in an IETF\nRFC.\n\nWhich I thing is a good thing. However this leaves us with the question:\nwhich namespace *should* be used in drafts that are *planned* to become an\nRFC?\n\n- Putting elements into the DAV: namespace might not be a good idea, *even*\nfor deltaV or ACL until they reach RFC status. By using a different\nnamespace, ambiguities about what version of the spec is supported could be\navoided. This would be similar to the W3C practice of using a new namespace\neach time a Working Draft changes incompatibily.\n\n- \"DAV:experimental\" seems to be an option, although this would require that\nthe registrar of the DAV: URI scheme finally defines the syntax of it\n(hint).\n\n- Another approach would be to use a \"private\" namespace for individual\nsubmissions (probably the cleanest approach).\n\nThe reason why I'm raising this right now is that our WebDAV server\n(obviously) supports the extensions we have proposed (of which two need\nextension elements). The IDs (Internet Drafts) use the DAV: namespace. We\nnow have the choice of either actually *implementing* the extension using\nthe DAV: namespace (which doesn't seem to be good style), or to use a custom\nnamespace (and to bring the IDs in line with that).\n\nFeedback appreciated.\n\nJulian\n\n\n\n[1] <http://www.greenbytes.de/tech/webdav/>\n[2]\n<http://www.greenbytes.de/tech/webdav/draft-ietf-deltav-versioning-20.htm#_T\noc524830510>\n\n\n\n", "id": "lists-006-15336402"}, {"subject": "Re: Submission: deltav subse", "content": "My 0.5 US cents worth (after currency exchange rates).\n\nI look at the subset submission from the view of what has happened\nwith Z39.50 (a search and retrieval protocol). The protocol has\nso many options and variations, no-one implements them all.\nSo profiles started to appear. There are a small number of such\nprofiles. This allowed people to say 'we conform to this profile'.\nNot everyone supports all the profiles. Some people don't support\nany of the profiles. But it has advantages in that new people\ncoming along can see some subsets some groups of people agreed to.\nIt helps newbies pick a subset with a degree of confidence that\nits not a silly subset - at least one other person agrees!\n\nSo I have no trouble with the idea of profiles being defined\noutside the DeltaV spec. Profiles should not be defined based\non what *everyone* thinks is minimal. They should be defined\non what a group thinks is minimal (where the group could be\na single person :-). Others can either decide to support the\nprofile, partially support the profile, or not support the profile.\nThey can even choose to write their own profile.\nBut it makes it easier to understand what different people support.\nEg: \"I support the 'Lisa' profile except for this bit.\" Over time\nthe profiles may change or profiles may merge or whatever.\nSounds fine to me - as long as they are not a part of the spec.\nThey are more like implementor agreements etc outside the spec.\n\nSo I personally encourage Lisa to define a profile. Lisa can\nchoose from other people's comments what she thinks should and\nshould not be included. Others can then choose to support it\nor not support it. Just as long as it stays out of the official\nstandard. DeltaV is complex enough as it is.\n\nAlan\n\n\n\n", "id": "lists-006-15346430"}, {"subject": "RE: DTD for supported-method-set (3.1.3", "content": "  From: Julian Reschke [mailto:julian.reschke@gmx.de]\n\n   DeltaV Draft 20 says:\n\n   <!ELEMENT supported-method-set (supported-method*)>\n   <!ELEMENT supported-method ANY>\n   <!ATTLIST supported-method name NMTOKEN #REQUIRED>\n   name value: a method name\n\n   a) Why is the content model for supported-method \"ANY\"? Just for\nextensions?\n\nYes.\n\n   b) Do we agree that the attribute name is not qualified (so it is in no\n   namespace)?\n\nThe intention was for every element and attribute type to be declared\nin the DAV: namespace, so the attribute \"name\" is declared in the\nDAV:namespace, as is the element type \"supported-method-set\" and\nthe element type \"supported-method\".\n\n   In retrospective, just defining properties in terms of DTDs -- while DTDs\n   can by definition not be normative for WebDAV (*) -- isn't a good idea.\n   (*) DTDs can not properly capture namespace information. Neither can they\n   adequately model the extensible model defined in section C.2.2 of RFC2518\n   (<http://www.greenbytes.de/tech/webdav/rfc2518.html#rfc.section.C.2.2>).\n\nI'll let the folks that like DTD's respond to that (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-15355054"}, {"subject": "RE: Eclipsed resources..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   The deltav draft (section 14.1.1) says that a non\n   version-controlled resource can \"eclipse\" a version-controlled\n   resource.  When the non version-controlled resource is deleted or\n   moved the version-controlled member is exposed.\n\n   I have a few questions/issues regarding this concept: \n\n   1) What happens if a VERSION-CONTROL request is issued on the non\n      version-controlled member that is eclipsing the\n      version-controlled resource?\n\nThe VERSION-CONTROL request would fail because there already is a\nversion-controlled binding with that name.\n\n   2) BASELINE-CONTROL can be issued with a baseline URL in the\n      request body (in order to populate the collection), if there is\n      a non version-controlled resource at the destination whose\n      binding name clashes with the name of a member in the baseline\n      does eclipsing occur?  It seems like the same scenario but\n      eclipsing is not defined here.\n\nIf the server supports versioned collections, it is a regular eclipse.\nIf the server does not, then it is server defined, but for consistency,\na baselining server should demonstrate eclipsing behavior, even if\nit does not support versioned-collections.\n\n   3) Why was this defined this way around? Surely the\n      version-controlled member should take precedence over the non\n      version-controlled resource.\n\nMoving the non-version-controlled members out of the way to expose\nthe version-controlled members is always possible, while moving a\nversion-controlled member out of the way would require checking out\nthe version-controlled collection.\n\n   4) Why was this behaviour defined instead of just failing the\n      UPDATE or MERGE request.  This eclipsing behaviour seems odd and\n      it may confuse end users to have their resources masked by some\n      other resource.\n\nIn client workspace implementations, the non-version-controlled resources\nare commonly local resources on the client, with only version-controlled\nresources being stored on the server.  This means that a client-workspace\nserver would not know when an UPDATE or MERGE would cause a\nversion-controlled\nresource to be \"eclipsed\" by some local resource on the client.\nThe eclipsing functionality provides more consistent behavior for a client\ndesigned to work against both client-workspace and server-workspace\nimplementations.  In particular, the JSR-147 effort will take advantage of\nthis consistent behavior to define a single client library that unifies\ninteraction with client-workspace and server-workspace servers.\n\n   Does anyone in the group have any good material explaining the\n   \"hows and whys\" of eclipsed versions? How did it get into the spec\n   in the first place, was there use cases etc?\n\nIt was pretty much just the preceding paragraph.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-15363946"}, {"subject": "RE: Small mistake in section 16.", "content": "Sure enough, thanks for catching that!\nWill fix in final post-nroffing editorial pass.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\nIn Section 16.2 of the deltav document we specify that: \n\"A WebDAV versioning client should be designed to handle a mixture \nof 200 (OK) and 404 (Forbidden) responses\" \nI believe the 404 code is wrong, it should be 403. \n\n\n\n", "id": "lists-006-15373719"}, {"subject": "RE: DTD for supported-method-set (3.1.3", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, October 24, 2001 6:05 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: DTD for supported-method-set (3.1.3)\n>\n> ...\n>\n>    b) Do we agree that the attribute name is not qualified (so it is in no\n>    namespace)?\n>\n> The intention was for every element and attribute type to be declared\n> in the DAV: namespace, so the attribute \"name\" is declared in the\n> DAV:namespace, as is the element type \"supported-method-set\" and\n> the element type \"supported-method\".\n\nWell.\n\nFirst of all, this is a very uncommon way to use attributes. In vocabularies\nlike XSLT, XSL-FO or XHTML, attributes are declared with no namespace and\nrely on their context. Namespaced prefixes usually only appear in\nvocabularies where the attributes can appear on elements in other\nnamespaces, such as xml:lang (XML itself), xlink:role (XLink) or xsi:type\n(XML Schema).\n\nSo besides that this would be very strange, the DTD fragment doesn't specify\nit (well, it can't really, because DTDs do not know about namespaces).\n\nThe closest thing you *could* write as DTD would be something like:\n\n<!ELEMENT supported-method ANY>\n\n<!ATTLIST supported-method dav:name NMTOKEN #REQUIRED>\n\nand then have normative text explain what the prefix is supposed to mean\nthere.\n\nSo my suggestion would be\n\na) to define that the name attribute is in no namespace,\n\nb) fix the DTD fragment,\n\nc) add examples to this (and maybe other) definitions. (Sorry).\n\n>    In retrospective, just defining properties in terms of DTDs --\n> while DTDs\n>    can by definition not be normative for WebDAV (*) -- isn't a good idea.\n>    (*) DTDs can not properly capture namespace information.\n> Neither can they\n>    adequately model the extensible model defined in section C.2.2\n> of RFC2518\n>\n> (<http://www.greenbytes.de/tech/webdav/rfc2518.html#rfc.section.C.2.2>).\n>\n> I'll let the folks that like DTD's respond to that (:-).\n\nDid I open a can of worms? DTDs can not be used for normative descriptions\nof XML vocabularies like WebDAV's. Even the W3C doesn't attempt to do that.\n\n\n\n", "id": "lists-006-15381148"}, {"subject": "RE: DTD for supported-method-set (3.1.3", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, October 24, 2001 6:05 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: DTD for supported-method-set (3.1.3)\n>\n> ..\n>\n>    b) Do we agree that the attribute name is not qualified (so it is in no\n>    namespace)?\n>\n> The intention was for every element and attribute type to be declared\n> in the DAV: namespace, so the attribute \"name\" is declared in the\n> DAV:namespace, as is the element type \"supported-method-set\" and\n> the element type \"supported-method\".\n\nTo further clarify. Neither with\n\n<D:supported-method-set xmlns:D=\"DAV:\">\n<D:supported-method name=\"PROPFIND\" />\n</D:supported-method-set>\n\nnor with\n\n<supported-method-set xmlns=\"DAV:\">\n<supported-method name=\"PROPFIND\" />\n</supported-method-set>\n\nthe name attribute would be in a namespace. For an attribute to be in a\nnamespace, it MUST be qualified, such as:\n\n<D:supported-method-set xmlns:D=\"DAV:\">\n<D:supported-method D:name=\"PROPFIND\" />\n</D:supported-method-set>\n\nor\n\n<supported-method-set xmlns=\"DAV:\">\n<supported-method D:name=\"PROPFIND\" xmlns:D=\"DAV:\" />\n</supported-method-set>\n\nHowever I think that the *first* two versions use the intended format,\nright?\n\n\n\n", "id": "lists-006-15391926"}, {"subject": "I-D ACTION:draft-ietf-deltav-versioning-20.tx", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Web Versioning and Configuration Management Working Group of the IETF.\n\nTitle: Versioning Extensions to WebDAV\nAuthor(s): G. Clemm, J. Amsden, T. Ellison, \n                          C. Kaler, J. Whitehead\nFilename: draft-ietf-deltav-versioning-20.txt\nPages: 106\nDate: 23-Oct-01\n\nThis document specifies a set of methods, headers, and resource types \nthat define the WebDAV Versioning extensions to the HTTP/1.1 protocol. \nWebDAV Versioning will minimize the complexity of clients that are\ncapable of interoperating with a variety of versioning repository\nmanagers, to facilitate widespread deployment of applications capable of\nutilizing the WebDAV Versioning services.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-20.txt\n\nTo remove yourself from the IETF Announcement list, send a message to \nietf-announce-request with the word unsubscribe in the body of the message.\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-deltav-versioning-20.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-deltav-versioning-20.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n\n\n\nMessage/External-body attachment: stored\n\n\n\n\n", "id": "lists-006-15401568"}, {"subject": "RE: Submission: deltav subse", "content": "Hi,\n\nI agree with Jim that deltav needs some time to see what issues people\nfind during implementation and to iron out some of the issues we already\nknow about.\n\nIn my opinion the group needs to spend some time looking at existing issues,\n\nworking on scenarios, FAQs, clarifications to the specification, sorting out\npackaging issues, etc.  Many members of deltav are also in the webdav group,\n\nthat specification needs to be revised (to move along the standards track), \nACL, DASL and advanced collections need to be completed.  This sounds like \nplenty of work to keep the group busy :-)\n\nOver time APIs like the proposed JSR-147 will help get implementations up\nand\nrunning and we can see what issues we find during interop testing.\n\nI would be interested in proposals to extend deltav for:\n\nChange/Issue Management (and simple Workflow),\nEvent Notification (servers letting clients know when resources/properties\nchange),\nMulti-part mime requests (setting properties and doing an operation in one\nrequest),\nStrong typed properties (eg this property only contains dates/numbers/list\nof valid values etc).\n\nThe larger specs like Change Management could run in a separate working\ngroup.\nAs WebDAV becomes more widely adopted and the web is used as a writeable\nmedium I \nexpect many users will require some kind of change/task/issue management and\nworkflow \nto help them control and manage the changes.\n  \nMERANT has been doing some work on Change Management extensions to WebDAV\ninternally,\nI would be interested to see how our thoughts on this subject match up (or\nnot) with \nthose of other members of the WebDAV community.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Jim Amsden [mailto:jamsden@us.ibm.com]\nSent: 23 October 2001 01:41\nTo: ietf-dav-versioning@w3.org\nSubject: Re: Submission: deltav subset\n\n\nRoy,\nWe're not talking about shutting down DeltaV just yet. As I pointed out \nbelow, the spec isn't an Internet Standard yet, we still have quite a ways \nto go. However, the current working group has fulfilled its charter and \nits time to update it or create a new one. The work that remains is to see \nhow well the spec is adopted, both by clients and servers, and how well we \nmet our goals, including interoperability objectives. To do this I think \nwe need some \"quiet time\" where we aren't making substantive changes to \nthe spec so developers have something stable to build from. Once we have \nmore experience, we should see what work is left to do and establish a new \ncharter to address it. This doesn't need to be a continuation of DeltaV, \nbut it could be. We have an established community and infrastructure \n(webdav.org and the DeltaV mailing list). Depending on what surfaces, we \nmay want to leverage the existing working group for continuity.\n\nIn an case, if DeltaV did shutdown, the process would be to hold a BOF at \nan IETF meeting to introduce ideas and gather interest, develop a new \ncharter spelling out the activities of a new working group, getting AD \napproval, and doing the work by submitting Internet drafts. This is \ncertainly the right way to go for significant new features like change \nmanagement for example. But for expedience, fixing details and \ninteroperability problems in the current spec should probably be done in \nthe context of the current working group. \n\n\n\n\nRoy Seto <Roy.Seto@oracle.com>\nSent by: ietf-dav-versioning-request@w3.org\n10/22/2001 04:55 PM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        Re: Submission: deltav subset\n\n \n\nIf the WG shuts down, what is the accepted mechanism for hashing out \nprotocol usage issues that surface during implementation? \nRoy \nJim Amsden wrote: \n  \nI'm inclined to declare victory on our DeltaV charter and let some servers \nget built on what we have before we start making a lot of immediate \nchanges. Of course I would welcome any BOF to determine level of interest \nin extensions, new packages, etc. DeltaV is now firmly on the standards \ntrack. The next step is to get some implementation and determine \ninteroperability issues. If the community fragments immediately on \ndifferent packages that aren't interoperable in meaningful ways, then \ncertainly that's good information for the standards process that would \nneed to be addressed. But I think the community would benefit from \nattempting to implement the spec as written so we encourage \ninteroperability. \nAs for shutting down DeltaV, we're only at proposed standard. We could \nconsider updating the charter to move to the next stage in the lifecycle. \nI would be happy to entertain suggestions as to the content of such a \ncharter, and if there's sufficient interest, we can propose the next set \nof work items to the AD's as either continuation of DeltaV (with a new \ncharter), or other working groups focused on more specific tasks. \n \n \n \n\n\"Jim Whitehead\" <ejw@cse.ucsc.edu> \n10/18/2001 06:36 PM\n\n        To:        \"Clemm, Geoff\" <gclemm@rational.com>, \"'Lisa \nDusseault'\" <lisa@xythos.com>, \"Jim Amsden\" <jamsden@us.ibm.com> \n        cc:  \n        Subject:        RE: Submission: deltav subset \n \n\n \nGeoff Clemm writes: \n> I think it is more appropriate to keep it as an \n> individual submission until the working group has had \n> a chance to review/iterate on it. \nThis may be true, but IETF policy does say that it is the Chair's \ndiscretion \non whether a document is a WG draft or an individual submission. \nI was just pointing out that Jim may cause friction with the ADs if, by \nmaking a new WG draft, he extends the life of DeltaV when they think it's \nclose to being shut down. I imagine they are keen to avoid another WebDAV \n:-) \nBut, even if Jim does decide that it should not be a new draft, it would \nbe \nwell within Lisa's rights to hold a BOF at the next IETF with an eye \ntowards \ncreating a new WG, \"SDV\" (simple Delta V), say. \n- Jim \n \n \n \n\n\n\n", "id": "lists-006-15410586"}, {"subject": "RE: Question on support for in-place editin", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   DeltaV supports an in-place editing model for situations where the server\n   does not support the Working Resource option, and where the client does\nnot\n   do all their edits on their local copy.\n\nNote though that this is not a \"package\", this is just a \"feature\"\nthat is used in the \"workspace\" packages.\n\n   By \"in-place editing\" I mean that when the VCR is checked out, clients\ncan\n   do any number of PUT, PROPPATCH and other write operations, before\nfinally\n   checking in.  In the meantime, this work-in-progress is available for\nother\n   users to see if they have permission to read the resource.\n\n   First question: Does anybody plan to implement DeltaV this way?\n\nWe will be supporting the advanced-server-workspace package,\nwhich includes the in-place-checkout feature.\n\n  [I believe\n   Subversion effectively will (correct me if I'm wrong) but in practice\n   Subversion clients wouldn't do their write operations until just before\n   checking in, so there would only be a small window of opportunity to see\n   works-in-progress. ]\n\nNo, subversion supports the advanced-client-workspace package, so\nit provides the working-resource feature, not the in-place-checkout\nfeature.\n\n   Second question: Is there a way for clients to view working\n   resources and only see the latest checked-in versions?  E.g. I may\n   be uninterested in seeing \"works in progress\" affected by in-place\n   editing.  Can I do a PROPFIND depth-1 against the latest checked-in\n   versions in a collection, rather than the works-in-progress?\n\nThis question is really only relevant for the workspace packages, with\nin-place checkouts and not working resources.  This is because working\nresources are sprinkled around the URL space at the server's whim, and\nare not collected into a collection that you can \"PROPFIND Depth:1\".\nSo with working resources, the *only* kind of version-controlled\nresources you see in collections are checked-in ones, so you would\nnever see \"works in progress\".\n\nNote though, that if your server does support in-place checkouts, you\ncan get the behavior Lisa describes by using the DAV:expand-property\nreport.  In particular, you would ask to expand the DAV:checked-in and\nDAV:checked-out properties of the version-controlled resources.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1541250"}, {"subject": "RE: Submission: deltav subse", "content": "RE: Submission: deltav subsetPeter,\n\nregarding \"Strong typed properties (eg this property only contains\ndates/numbers/list of valid values etc)\": I would be interested to get some\nfeedback on my proposal \"datatype for WebDAV properties\" [1], which is\nalready supported by our server.\n\nJulian\n\n\n[1]\n<http://www.greenbytes.de/tech/webdav/draft-reschke-webdav-property-datatype\ns-latest.html>\n\n\n  -----Original Message-----\n  From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Peter Raymond\n  Sent: Wednesday, October 24, 2001 2:33 PM\n  To: Jim Amsden; ietf-dav-versioning@w3.org\n  Subject: RE: Submission: deltav subset\n\n\n  Hi,\n\n  I agree with Jim that deltav needs some time to see what issues people\n  find during implementation and to iron out some of the issues we already\n  know about.\n\n  In my opinion the group needs to spend some time looking at existing\nissues,\n  working on scenarios, FAQs, clarifications to the specification, sorting\nout\n  packaging issues, etc.  Many members of deltav are also in the webdav\ngroup,\n  that specification needs to be revised (to move along the standards\ntrack),\n  ACL, DASL and advanced collections need to be completed.  This sounds like\n  plenty of work to keep the group busy :-)\n\n  Over time APIs like the proposed JSR-147 will help get implementations up\nand\n  running and we can see what issues we find during interop testing.\n\n  I would be interested in proposals to extend deltav for:\n\n  Change/Issue Management (and simple Workflow),\n  Event Notification (servers letting clients know when resources/properties\nchange),\n  Multi-part mime requests (setting properties and doing an operation in one\nrequest),\n  Strong typed properties (eg this property only contains dates/numbers/list\nof valid values etc).\n\n  The larger specs like Change Management could run in a separate working\ngroup.\n  As WebDAV becomes more widely adopted and the web is used as a writeable\nmedium I\n  expect many users will require some kind of change/task/issue management\nand workflow\n  to help them control and manage the changes.\n\n  MERANT has been doing some work on Change Management extensions to WebDAV\ninternally,\n  I would be interested to see how our thoughts on this subject match up (or\nnot) with\n  those of other members of the WebDAV community.\n\n  Regards,\n  --\n  Peter Raymond - MERANT\n  Principal Architect (PVCS)\n  Tel: +44 (0)1727 813362\n  Fax: +44 (0)1727 869804\n  mailto:Peter.Raymond@merant.com\n  WWW: http://www.merant.com\n\n\n\n\n  -----Original Message-----\n  From: Jim Amsden [mailto:jamsden@us.ibm.com]\n  Sent: 23 October 2001 01:41\n  To: ietf-dav-versioning@w3.org\n  Subject: Re: Submission: deltav subset\n\n\n\n  Roy,\n  We're not talking about shutting down DeltaV just yet. As I pointed out\n  below, the spec isn't an Internet Standard yet, we still have quite a ways\n  to go. However, the current working group has fulfilled its charter and\n  its time to update it or create a new one. The work that remains is to see\n  how well the spec is adopted, both by clients and servers, and how well we\n  met our goals, including interoperability objectives. To do this I think\n  we need some \"quiet time\" where we aren't making substantive changes to\n  the spec so developers have something stable to build from. Once we have\n  more experience, we should see what work is left to do and establish a new\n  charter to address it. This doesn't need to be a continuation of DeltaV,\n  but it could be. We have an established community and infrastructure\n  (webdav.org and the DeltaV mailing list). Depending on what surfaces, we\n  may want to leverage the existing working group for continuity.\n\n  In an case, if DeltaV did shutdown, the process would be to hold a BOF at\n  an IETF meeting to introduce ideas and gather interest, develop a new\n  charter spelling out the activities of a new working group, getting AD\n  approval, and doing the work by submitting Internet drafts. This is\n  certainly the right way to go for significant new features like change\n  management for example. But for expedience, fixing details and\n  interoperability problems in the current spec should probably be done in\n  the context of the current working group.\n\n\n\n\n\n  Roy Seto <Roy.Seto@oracle.com>\n  Sent by: ietf-dav-versioning-request@w3.org\n  10/22/2001 04:55 PM\n\n\n          To:     ietf-dav-versioning@w3.org\n          cc:\n          Subject:        Re: Submission: deltav subset\n\n\n\n  If the WG shuts down, what is the accepted mechanism for hashing out\n  protocol usage issues that surface during implementation?\n  Roy\n  Jim Amsden wrote:\n\n  I'm inclined to declare victory on our DeltaV charter and let some servers\n  get built on what we have before we start making a lot of immediate\n  changes. Of course I would welcome any BOF to determine level of interest\n  in extensions, new packages, etc. DeltaV is now firmly on the standards\n  track. The next step is to get some implementation and determine\n  interoperability issues. If the community fragments immediately on\n  different packages that aren't interoperable in meaningful ways, then\n  certainly that's good information for the standards process that would\n  need to be addressed. But I think the community would benefit from\n  attempting to implement the spec as written so we encourage\n  interoperability.\n  As for shutting down DeltaV, we're only at proposed standard. We could\n  consider updating the charter to move to the next stage in the lifecycle.\n  I would be happy to entertain suggestions as to the content of such a\n  charter, and if there's sufficient interest, we can propose the next set\n  of work items to the AD's as either continuation of DeltaV (with a new\n  charter), or other working groups focused on more specific tasks.\n\n\n\n\n  \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n  10/18/2001 06:36 PM\n\n          To:        \"Clemm, Geoff\" <gclemm@rational.com>, \"'Lisa\n  Dusseault'\" <lisa@xythos.com>, \"Jim Amsden\" <jamsden@us.ibm.com>\n          cc:\n          Subject:        RE: Submission: deltav subset\n\n\n\n  Geoff Clemm writes:\n  > I think it is more appropriate to keep it as an\n  > individual submission until the working group has had\n  > a chance to review/iterate on it.\n  This may be true, but IETF policy does say that it is the Chair's\n  discretion\n  on whether a document is a WG draft or an individual submission.\n  I was just pointing out that Jim may cause friction with the ADs if, by\n  making a new WG draft, he extends the life of DeltaV when they think it's\n  close to being shut down. I imagine they are keen to avoid another WebDAV\n  :-)\n  But, even if Jim does decide that it should not be a new draft, it would\n  be\n  well within Lisa's rights to hold a BOF at the next IETF with an eye\n  towards\n  creating a new WG, \"SDV\" (simple Delta V), say.\n  - Jim\n\n\n\n", "id": "lists-006-15427185"}, {"subject": "RE: DTD for supported-method-set (3.1.3", "content": "   From: Julian Reschke [mailto:julian.reschke@greenbytes.de]\n\n   > From: ietf-dav-versioning-request@w3.org\n   > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n   > Sent: Wednesday, October 24, 2001 6:05 AM\n   > To: ietf-dav-versioning@w3.org\n   > Subject: RE: DTD for supported-method-set (3.1.3)\n   >\n   > ...\n   >\n   >    b) Do we agree that the attribute name is not qualified (so it is in\nno\n   >    namespace)?\n   >\n   > The intention was for every element and attribute type to be declared\n   > in the DAV: namespace, so the attribute \"name\" is declared in the\n   > DAV:namespace, as is the element type \"supported-method-set\" and\n   > the element type \"supported-method\".\n\nActually, in looking at the DAV:expand-property example, we clearly did\nnot intend for the attributes to be in the DAV: namespace (since they\nare not qualified with \"D:\" to indicate they are in the DAV: namespace).\nSo I'll change that to \"the intention was for every element to be declared\nin the DAV:namespace and every attribute to be in the default namespace\".\n\n   Well.\n\n   First of all, this is a very uncommon way to use attributes. In\n   vocabularies like XSLT, XSL-FO or XHTML, attributes are declared\n   with no namespace and rely on their context. Namespaced prefixes\n   usually only appear in vocabularies where the attributes can appear\n   on elements in other namespaces, such as xml:lang (XML itself),\n   xlink:role (XLink) or xsi:type (XML Schema).\n\nOK, I'm sold (:-).\n\n   So besides that this would be very strange, the DTD fragment\n   doesn't specify it (well, it can't really, because DTDs do not know\n   about namespaces).\n\nYeah, that doesn't really argue either way, since as you say, \nDTD fragments cannot declare anything about namespaces.\n\n   So my suggestion would be\n\n   a) to define that the name attribute is in no namespace,\n\nI'll go with that.\n\n   b) fix the DTD fragment,\n\nI wouldn't do that (since it would be a non-standard usage of DTDs).\n\n   c) add examples to this (and maybe other) definitions. (Sorry).\n\nI'll try to squeeze in an example of the DAV:supported-method-set\nproperty in the final editing pass.\n\n   >    In retrospective, just defining properties in terms of DTDs --\n   > while DTDs\n   >    can by definition not be normative for WebDAV (*) -- isn't a good\nidea.\n   >    (*) DTDs can not properly capture namespace information.\n   > Neither can they\n   >    adequately model the extensible model defined in section C.2.2\n   > of RFC2518\n   >\n   >\n(<http://www.greenbytes.de/tech/webdav/rfc2518.html#rfc.section.C.2.2>).\n   >\n   > I'll let the folks that like DTD's respond to that (:-).\n\n   Did I open a can of worms? DTDs can not be used for normative\ndescriptions\n   of XML vocabularies like WebDAV's. Even the W3C doesn't attempt to do\nthat.\n\nWell, if it's a can of worms, it's one we inherited from 2518 (:-).\nI did at one time suggest we purge DTD's from the spec, but this was\nnot something the working group supported.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-15445119"}, {"subject": "RE: DTD for supported-method-set (3.1.3", "content": "Yes, for consistency with the use of attributes in\nthe DAV:expanded-property REPORT, the \"name\" attribute in\nDAV:supported-method would be in the default namespace,\nnot in the DAV: namespace.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Julian Reschke [mailto:julian.reschke@greenbytes.de]\nSent: Wednesday, October 24, 2001 3:20 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: DTD for supported-method-set (3.1.3)\n\n\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, October 24, 2001 6:05 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: DTD for supported-method-set (3.1.3)\n>\n> ..\n>\n>    b) Do we agree that the attribute name is not qualified (so it is in no\n>    namespace)?\n>\n> The intention was for every element and attribute type to be declared\n> in the DAV: namespace, so the attribute \"name\" is declared in the\n> DAV:namespace, as is the element type \"supported-method-set\" and\n> the element type \"supported-method\".\n\nTo further clarify. Neither with\n\n<D:supported-method-set xmlns:D=\"DAV:\">\n<D:supported-method name=\"PROPFIND\" />\n</D:supported-method-set>\n\nnor with\n\n<supported-method-set xmlns=\"DAV:\">\n<supported-method name=\"PROPFIND\" />\n</supported-method-set>\n\nthe name attribute would be in a namespace. For an attribute to be in a\nnamespace, it MUST be qualified, such as:\n\n<D:supported-method-set xmlns:D=\"DAV:\">\n<D:supported-method D:name=\"PROPFIND\" />\n</D:supported-method-set>\n\nor\n\n<supported-method-set xmlns=\"DAV:\">\n<supported-method D:name=\"PROPFIND\" xmlns:D=\"DAV:\" />\n</supported-method-set>\n\nHowever I think that the *first* two versions use the intended format,\nright?\n\n\n\n", "id": "lists-006-15456770"}, {"subject": "RE: DTD for supported-method-set (3.1.3", "content": "> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, October 24, 2001 4:22 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: DTD for supported-method-set (3.1.3)\n>\n> ...\n>\n> Actually, in looking at the DAV:expand-property example, we clearly did\n> not intend for the attributes to be in the DAV: namespace (since they\n> are not qualified with \"D:\" to indicate they are in the DAV: namespace).\n> So I'll change that to \"the intention was for every element to be declared\n> in the DAV:namespace and every attribute to be in the default namespace\".\n\nCorrection: not in the default namespace, in *no* namespace. Attributes do\nnot inherit a default namespace.\n\n>    Well.\n>\n>    First of all, this is a very uncommon way to use attributes. In\n>    vocabularies like XSLT, XSL-FO or XHTML, attributes are declared\n>    with no namespace and rely on their context. Namespaced prefixes\n>    usually only appear in vocabularies where the attributes can appear\n>    on elements in other namespaces, such as xml:lang (XML itself),\n>    xlink:role (XLink) or xsi:type (XML Schema).\n>\n> OK, I'm sold (:-).\n>\n>    So besides that this would be very strange, the DTD fragment\n>    doesn't specify it (well, it can't really, because DTDs do not know\n>    about namespaces).\n>\n> Yeah, that doesn't really argue either way, since as you say,\n> DTD fragments cannot declare anything about namespaces.\n>\n>    So my suggestion would be\n>\n>    a) to define that the name attribute is in no namespace,\n>\n> I'll go with that.\n>\n>    b) fix the DTD fragment,\n>\n> I wouldn't do that (since it would be a non-standard usage of DTDs).\n\nCorrect. I should have said: either a) or b). a) was preferred anyway.\n\n>    c) add examples to this (and maybe other) definitions. (Sorry).\n>\n> I'll try to squeeze in an example of the DAV:supported-method-set\n> property in the final editing pass.\n>\n>    >    In retrospective, just defining properties in terms of DTDs --\n>    > while DTDs\n>    >    can by definition not be normative for WebDAV (*) -- isn't a good\n> idea.\n>    >    (*) DTDs can not properly capture namespace information.\n>    > Neither can they\n>    >    adequately model the extensible model defined in section C.2.2\n>    > of RFC2518\n>    >\n>    >\n> (<http://www.greenbytes.de/tech/webdav/rfc2518.html#rfc.section.C.2.2>).\n>    >\n>    > I'll let the folks that like DTD's respond to that (:-).\n>\n>    Did I open a can of worms? DTDs can not be used for normative\n> descriptions\n>    of XML vocabularies like WebDAV's. Even the W3C doesn't attempt to do\n> that.\n>\n> Well, if it's a can of worms, it's one we inherited from 2518 (:-).\n> I did at one time suggest we purge DTD's from the spec, but this was\n> not something the working group supported.\n\nInteresting.\n\n\n\n", "id": "lists-006-15467205"}, {"subject": "RE: DTD for supported-method-set (3.1.3", "content": "Yes, make that \"no namespace\".\n(I'll get it right one of these days :-).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Julian Reschke [mailto:julian.reschke@greenbytes.de]\nSent: Wednesday, October 24, 2001 10:29 AM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: RE: DTD for supported-method-set (3.1.3)\n\n\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, October 24, 2001 4:22 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: DTD for supported-method-set (3.1.3)\n>\n> ...\n>\n> Actually, in looking at the DAV:expand-property example, we clearly did\n> not intend for the attributes to be in the DAV: namespace (since they\n> are not qualified with \"D:\" to indicate they are in the DAV: namespace).\n> So I'll change that to \"the intention was for every element to be declared\n> in the DAV:namespace and every attribute to be in the default namespace\".\n\nCorrection: not in the default namespace, in *no* namespace. Attributes do\nnot inherit a default namespace.\n\n>    Well.\n>\n>    First of all, this is a very uncommon way to use attributes. In\n>    vocabularies like XSLT, XSL-FO or XHTML, attributes are declared\n>    with no namespace and rely on their context. Namespaced prefixes\n>    usually only appear in vocabularies where the attributes can appear\n>    on elements in other namespaces, such as xml:lang (XML itself),\n>    xlink:role (XLink) or xsi:type (XML Schema).\n>\n> OK, I'm sold (:-).\n>\n>    So besides that this would be very strange, the DTD fragment\n>    doesn't specify it (well, it can't really, because DTDs do not know\n>    about namespaces).\n>\n> Yeah, that doesn't really argue either way, since as you say,\n> DTD fragments cannot declare anything about namespaces.\n>\n>    So my suggestion would be\n>\n>    a) to define that the name attribute is in no namespace,\n>\n> I'll go with that.\n>\n>    b) fix the DTD fragment,\n>\n> I wouldn't do that (since it would be a non-standard usage of DTDs).\n\nCorrect. I should have said: either a) or b). a) was preferred anyway.\n\n>    c) add examples to this (and maybe other) definitions. (Sorry).\n>\n> I'll try to squeeze in an example of the DAV:supported-method-set\n> property in the final editing pass.\n>\n>    >    In retrospective, just defining properties in terms of DTDs --\n>    > while DTDs\n>    >    can by definition not be normative for WebDAV (*) -- isn't a good\n> idea.\n>    >    (*) DTDs can not properly capture namespace information.\n>    > Neither can they\n>    >    adequately model the extensible model defined in section C.2.2\n>    > of RFC2518\n>    >\n>    >\n> (<http://www.greenbytes.de/tech/webdav/rfc2518.html#rfc.section.C.2.2>).\n>    >\n>    > I'll let the folks that like DTD's respond to that (:-).\n>\n>    Did I open a can of worms? DTDs can not be used for normative\n> descriptions\n>    of XML vocabularies like WebDAV's. Even the W3C doesn't attempt to do\n> that.\n>\n> Well, if it's a can of worms, it's one we inherited from 2518 (:-).\n> I did at one time suggest we purge DTD's from the spec, but this was\n> not something the working group supported.\n\nInteresting.\n\n\n\n", "id": "lists-006-15479181"}, {"subject": "RE: Issues with section 22 of the deltav protocol document..", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   22.3 (DeltaV-Compliant Collection) should support the MERGE method.\n A collection can be a target for a MERGE operation.\n\nYes.\n\n   22.7 (Checked-In Version-Controlled Resource) should support the\nLABEL method.  Label can be applied to a checked-in VCR.\n\nYes.\n\n   22.13 (Activity) The DAV:unreserved live property should be listed\n      as a supported live property.\n\nDAV:unreserved is a checked-out resource property, not an activity property.\n\n   22.18 (Checked-Out Version-Controlled Configuration) should support\n all checked-out version controlled resource properties and\n methods as well as supporting all version-controlled\n configuration properties and methods.\n\nYes.\n\n   Why isn't there a section for Checked-Out Version-Controlled\n   Collection? Is it assumed that this resource is just a checked-out\n   version controlled resource?\n\nYes.\n\nI'll see if I can squeeze this info into the final editing pass.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-15491217"}, {"subject": "DTD confusion (mail thread from 2001Q1", "content": "Hi,\n\nI just finished reading (parts of) the long discussion that took place 8\nmonths ago and would like to make the following comments:\n\n1) DTDs can not be normative for any WebDAV XML exchange, because WebDAV is\nbased on XML *plus* Namespaces, and explicitly allows any prefix to be used\nas long as the right namespace Uri is mapped. This is something that can't\nbe captured in DTDs.\n\n2) Using a DTD that was supplied inside a request doesn't make sense at all.\n*If* a processor of a WebDAV message is interested in programmatic\nvalidation, the only thing that matters is *his* copy of the DTD (or the\nschema).\n\n3) In WebDAV, messages contain a mix of protocol information and values. For\ninstance, depending on the context, a DAV:href element may be part of the\nmarshalling (child of DAV:response) or may appear *anywhere* in somebody\nelse's dead property. Defining different DTDs for each message won't help,\nbecause this can happen within a single message.\n\nSo,\n\na) If a WebDAV related spec uses DTDs as normative information, it's broken.\nIf it makes any comments about parsing requests using a validating parser,\nthese comments should be removed.\n\nb) Where DTDs are given, the spec should clearly describe how they can be\nused (for instance, describing extensibility, namespace processing and\nsuch...).\n\nc) If there's a strong desire to formally define syntactic constraints,\nwe'll have to use something that actually works with XML + namespaces (XML\nSchema, for instance).\n\nJulian\n\n\n\n", "id": "lists-006-15499629"}, {"subject": "RE: Submission: deltav subse", "content": "> I would be interested in proposals to extend deltav for:\n\n> Change/Issue Management (and simple Workflow),\n> Event Notification (servers letting clients know when resources/properties\nchange),\n> Multi-part mime requests (setting properties and doing an operation in one\nrequest),\n> Strong typed properties (eg this property only contains dates/numbers/list\nof valid values etc).\n\nI'm not sure about the first one, but the rest of these items aren't\ndependent on versioning.  Thus, you might find more interest if you post\nyour suggestions to the wider WebDAV group, and I encourage you to do so.\n\nJosh Cohen has started work on an event notification mechanism for WebDAV,\nand I'm sure he'd appreciate help, input or review.\n\nLisa\n\n\n\n", "id": "lists-006-15508415"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   > the temporary location back to the original URL.  Note that the\n   > versions already created for the version-controlled resource will\n   > continue to exist at their server-defined locations.\"\n\n   This is clearer, but still problematic.  You've disguised a normative\n   requirement as a clarification.\n\nNormative statements are marked with capitalized words (such as MUST),\nso this is not a normative statement.  \n\n   Without this \"Note\" on the end, my\n   implementation would have done away with (deleted, gone, byebye) all the\n   versions that are no longer associated with a version-controlled\nresource.\n\nYour implementation is allowed to delete anything it wants (but you\nmay well encounter clients that are disappointed by this behavior).\n\n   If it is a requirement that the versions already created MUST stay\n   around, even when the version-controlled resource is replaced by a\n   non-version-controlled resource, then this must be a MUST.\n\n   I'd prefer to say that the versions that are no longer associated\n   with a VCR MAY be gone.\n\nI'm happy to either delete this non-normative note, or to replace\nthe \"will continue to exist\" with a \"may continue to exist\".\nDoes anyone else care one way or the other?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1551375"}, {"subject": "RE: DTD for supported-method-set (3.1.3", "content": "If I might suggest that this can be solved by using XML Schemas, which are\nnow a full W3C recommendation.  This will also solve the problem of the DTDs\nhaving so many \"any\" elements, which is a looser spec that may lead to\ninteroperability problems.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Julian Reschke\n> Sent: Wednesday, October 24, 2001 7:29 AM\n> To: Clemm, Geoff; ietf-dav-versioning@w3.org\n> Subject: RE: DTD for supported-method-set (3.1.3)\n>\n>\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > Sent: Wednesday, October 24, 2001 4:22 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: RE: DTD for supported-method-set (3.1.3)\n> >\n> > ...\n> >\n> > Actually, in looking at the DAV:expand-property example, we clearly did\n> > not intend for the attributes to be in the DAV: namespace (since they\n> > are not qualified with \"D:\" to indicate they are in the DAV: namespace).\n> > So I'll change that to \"the intention was for every element to\n> be declared\n> > in the DAV:namespace and every attribute to be in the default\n> namespace\".\n>\n> Correction: not in the default namespace, in *no* namespace. Attributes do\n> not inherit a default namespace.\n>\n> >    Well.\n> >\n> >    First of all, this is a very uncommon way to use attributes. In\n> >    vocabularies like XSLT, XSL-FO or XHTML, attributes are declared\n> >    with no namespace and rely on their context. Namespaced prefixes\n> >    usually only appear in vocabularies where the attributes can appear\n> >    on elements in other namespaces, such as xml:lang (XML itself),\n> >    xlink:role (XLink) or xsi:type (XML Schema).\n> >\n> > OK, I'm sold (:-).\n> >\n> >    So besides that this would be very strange, the DTD fragment\n> >    doesn't specify it (well, it can't really, because DTDs do not know\n> >    about namespaces).\n> >\n> > Yeah, that doesn't really argue either way, since as you say,\n> > DTD fragments cannot declare anything about namespaces.\n> >\n> >    So my suggestion would be\n> >\n> >    a) to define that the name attribute is in no namespace,\n> >\n> > I'll go with that.\n> >\n> >    b) fix the DTD fragment,\n> >\n> > I wouldn't do that (since it would be a non-standard usage of DTDs).\n>\n> Correct. I should have said: either a) or b). a) was preferred anyway.\n>\n> >    c) add examples to this (and maybe other) definitions. (Sorry).\n> >\n> > I'll try to squeeze in an example of the DAV:supported-method-set\n> > property in the final editing pass.\n> >\n> >    >    In retrospective, just defining properties in terms of DTDs --\n> >    > while DTDs\n> >    >    can by definition not be normative for WebDAV (*) --\n> isn't a good\n> > idea.\n> >    >    (*) DTDs can not properly capture namespace information.\n> >    > Neither can they\n> >    >    adequately model the extensible model defined in section C.2.2\n> >    > of RFC2518\n> >    >\n> >    >\n> > (<http://www.greenbytes.de/tech/webdav/rfc2518.html#rfc.section.C.2.2>).\n> >    >\n> >    > I'll let the folks that like DTD's respond to that (:-).\n> >\n> >    Did I open a can of worms? DTDs can not be used for normative\n> > descriptions\n> >    of XML vocabularies like WebDAV's. Even the W3C doesn't attempt to do\n> > that.\n> >\n> > Well, if it's a can of worms, it's one we inherited from 2518 (:-).\n> > I did at one time suggest we purge DTD's from the spec, but this was\n> > not something the working group supported.\n>\n> Interesting.\n>\n>\n>\n\n\n\n", "id": "lists-006-15516730"}, {"subject": "RE: DTD for supported-method-set (3.1.3", "content": "It's too late in the process to insert a normative XML schema\nin the draft, but it would be great if someone could write up\nthe XML schema for posting on the DeltaV web site.  Anyone\nwilling/interested?\n\nCheers,\nGeoff \n\n-----Original Message-----\nFrom: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\nSent: Wednesday, October 24, 2001 12:51 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: DTD for supported-method-set (3.1.3)\n\n\nIf I might suggest that this can be solved by using XML Schemas, which are\nnow a full W3C recommendation.  This will also solve the problem of the DTDs\nhaving so many \"any\" elements, which is a looser spec that may lead to\ninteroperability problems.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Julian Reschke\n> Sent: Wednesday, October 24, 2001 7:29 AM\n> To: Clemm, Geoff; ietf-dav-versioning@w3.org\n> Subject: RE: DTD for supported-method-set (3.1.3)\n>\n>\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > Sent: Wednesday, October 24, 2001 4:22 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: RE: DTD for supported-method-set (3.1.3)\n> >\n> > ...\n> >\n> > Actually, in looking at the DAV:expand-property example, we clearly did\n> > not intend for the attributes to be in the DAV: namespace (since they\n> > are not qualified with \"D:\" to indicate they are in the DAV: namespace).\n> > So I'll change that to \"the intention was for every element to\n> be declared\n> > in the DAV:namespace and every attribute to be in the default\n> namespace\".\n>\n> Correction: not in the default namespace, in *no* namespace. Attributes do\n> not inherit a default namespace.\n>\n> >    Well.\n> >\n> >    First of all, this is a very uncommon way to use attributes. In\n> >    vocabularies like XSLT, XSL-FO or XHTML, attributes are declared\n> >    with no namespace and rely on their context. Namespaced prefixes\n> >    usually only appear in vocabularies where the attributes can appear\n> >    on elements in other namespaces, such as xml:lang (XML itself),\n> >    xlink:role (XLink) or xsi:type (XML Schema).\n> >\n> > OK, I'm sold (:-).\n> >\n> >    So besides that this would be very strange, the DTD fragment\n> >    doesn't specify it (well, it can't really, because DTDs do not know\n> >    about namespaces).\n> >\n> > Yeah, that doesn't really argue either way, since as you say,\n> > DTD fragments cannot declare anything about namespaces.\n> >\n> >    So my suggestion would be\n> >\n> >    a) to define that the name attribute is in no namespace,\n> >\n> > I'll go with that.\n> >\n> >    b) fix the DTD fragment,\n> >\n> > I wouldn't do that (since it would be a non-standard usage of DTDs).\n>\n> Correct. I should have said: either a) or b). a) was preferred anyway.\n>\n> >    c) add examples to this (and maybe other) definitions. (Sorry).\n> >\n> > I'll try to squeeze in an example of the DAV:supported-method-set\n> > property in the final editing pass.\n> >\n> >    >    In retrospective, just defining properties in terms of DTDs --\n> >    > while DTDs\n> >    >    can by definition not be normative for WebDAV (*) --\n> isn't a good\n> > idea.\n> >    >    (*) DTDs can not properly capture namespace information.\n> >    > Neither can they\n> >    >    adequately model the extensible model defined in section C.2.2\n> >    > of RFC2518\n> >    >\n> >    >\n> > (<http://www.greenbytes.de/tech/webdav/rfc2518.html#rfc.section.C.2.2>).\n> >    >\n> >    > I'll let the folks that like DTD's respond to that (:-).\n> >\n> >    Did I open a can of worms? DTDs can not be used for normative\n> > descriptions\n> >    of XML vocabularies like WebDAV's. Even the W3C doesn't attempt to do\n> > that.\n> >\n> > Well, if it's a can of worms, it's one we inherited from 2518 (:-).\n> > I did at one time suggest we purge DTD's from the spec, but this was\n> > not something the working group supported.\n>\n> Interesting.\n>\n>\n>\n\n\n\n", "id": "lists-006-15529659"}, {"subject": "DAV:version-controlled-configuration property..", "content": "Hi,\n\nWhile looking through section 22 of the deltav document it struck me as odd \nthat DAV:version-controlled-configuration is a property of any deltav\ncompliant\nresource.  This is also how the property is defined in section 12.4.1.\n\nInitially I thought that only collections and version-controlled resources \nactually need this property since non-version-controlled resources cannot be\n\ncaptured in a baseline.  Then I noticed that in section 12 it says:\n\n       \"A configuration is a set of resources that consists of a root\n       collection and all members of that root collection except those\n       resources that are members of another configuration\"\n\nIt also says:\n\n\"A baseline is a version resource that captures the state of each\n       version-controlled member of a configuration\"\n\nThe configuration DOES include members that are not version-controlled, but\nthe \nbaseline does NOT capture them.  Right?\n\nSo, my question is:\n\nWill non-version-controlled members of a configuration that is under\nbaseline \ncontrol return a value for the DAV:version-controlled-configuration\nproperty?\n\nI think so, but am not 100% sure.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-15543538"}, {"subject": "FW: DAV:version-controlled-configuration property..", "content": "Hi,\n\nThis didn't make it to the list for some reason...so I am sending it\nagain....\n\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Peter Raymond \nSent: 25 October 2001 12:19\nTo: 'ietf-dav-versioning@w3.org'\nSubject: DAV:version-controlled-configuration property...\n\n\nHi,\n\nWhile looking through section 22 of the deltav document it struck me as odd \nthat DAV:version-controlled-configuration is a property of any deltav\ncompliant\nresource.  This is also how the property is defined in section 12.4.1.\n\nInitially I thought that only collections and version-controlled resources \nactually need this property since non-version-controlled resources cannot be\n\ncaptured in a baseline.  Then I noticed that in section 12 it says:\n\n       \"A configuration is a set of resources that consists of a root\n       collection and all members of that root collection except those\n       resources that are members of another configuration\"\n\nIt also says:\n\n\"A baseline is a version resource that captures the state of each\n       version-controlled member of a configuration\"\n\nThe configuration DOES include members that are not version-controlled, but\nthe \nbaseline does NOT capture them.  Right?\n\nSo, my question is:\n\nWill non-version-controlled members of a configuration that is under\nbaseline \ncontrol return a value for the DAV:version-controlled-configuration\nproperty?\n\nI think so, but am not 100% sure.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-15552646"}, {"subject": "FW: Another error in section 22", "content": "Hi,\n\nAnother e-mail that didn't make it...\n\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Peter Raymond \nSent: 25 October 2001 15:34\nTo: 'ietf-dav-versioning@w3.org'\nSubject: Another error in section 22?\n\n\nHi,\n\nSection 22.8 of the deltav specification lists the supported live properties\nof a \nchecked-out resource, but it does not say that a checked-out resource also\nhas all \nthe live properties of a deltav-compliant resource.\nI think the line saying:\n\n\"- all DeltaV-compliant resource properties.\"\n\nIs missing in this section.\n\nIf a checked-out resource did not have all the properties of a\ndeltav-compliant \nresource then it would not have supported-method-set and other useful\nproperties.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-15562754"}, {"subject": "RE: DAV:version-controlled-configuration property..", "content": "   From: Peter Raymond \n\n    \"A configuration is a set of resources that consists of a root\n    collection and all members of that root collection except those\n    resources that are members of another configuration\"\n\n    \"A baseline is a version resource that captures the state of each\n    version-controlled member of a configuration\"\n\n   The configuration DOES include members that are not\n   version-controlled, but the baseline does NOT capture them.  Right?\n\nCorrect.\n\n   So, my question is: \n\n   Will non-version-controlled members of a configuration that is\n   under baseline control return a value for the\n   DAV:version-controlled-configuration property?  I think so, but am\n   not 100% sure.\n\nCorrect.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-15571387"}, {"subject": "RE: Another error in section 22", "content": "I agree.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\nSection 22.8 of the deltav specification lists the supported live properties\nof a \nchecked-out resource, but it does not say that a checked-out resource also\nhas all \nthe live properties of a deltav-compliant resource. \nI think the line saying: \n\"- all DeltaV-compliant resource properties.\" \nIs missing in this section. \nIf a checked-out resource did not have all the properties of a\ndeltav-compliant \nresource then it would not have supported-method-set and other useful\nproperties. \n\n\n\n", "id": "lists-006-15579066"}, {"subject": "What happened to working baselines in draft 20", "content": "Hi,\n\nVersion 19 of the protocol document had a couple of references to the term\n\"Working Baseline\"\nin section 13.12.  In version 20 of the protocol document this has\ngone....there is now no\nreference to working baselines in the whole document.\n\nWas this change intended? I didn't see it listed in the changes and issues\ndocument.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-15586469"}, {"subject": "RE: What happened to working baselines in draft 20", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   Version 19 of the protocol document had a couple of references to\n   the term \"Working Baseline\" in section 13.12.  In version 20 of the\n   protocol document this has gone....there is now no reference to\n   working baselines in the whole document.  Was this change intended?\n   I didn't see it listed in the changes and issues document.\n\nSection 13.12 was modified for the following bullet (in the\n\"changes/issues\" document):\n\n- 13.12: allow client to control activity checkin behavior with a\n     DAV:activity-checkin parameter to MERGE.\n\nWhen this parameter was added, there no longer was the need to refer\nto \"working baselines\".  You can still check out a baseline (if the\nserver supports both the baseline and the working-resource features),\nto produce a working resource for that baseline, but we didn't need\na special term for such a working resource.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-15594620"}, {"subject": "How to update workspace with UPDATE and MERGE", "content": "I just joined this list, so I am sorry if my questions were already discussed:\n\n1. How the user can update his private workspace: UPDATE method just\nreplace all versions in my workspace with versions from the UPDATE\nsource, MERGE method will handle conflicts and merge my changes with\nthe latest versions but looks like it is not able to handle resource\nrenaming and deletion  (unlike UPDATE). So I am confused how can I do\nsomething like \"cvs update\"?\n\n2. It seem to me to be very convenient to have something like\n<DAV:displaypath/> live property which contains URL of the\ncorrespondent version-controlled resource. It actually contains the\nsame value as returned by <DAV:locate-by-history/> report.\nWhy it is better to have it as property and not as report?\nFor example, I can use PROPFIND method with Label header to extract\nsome configuration of the project marked with specified label. I can\ndo it with one WebDAV request by specifying Infinite depth. But to be\nable to  store this configuration to the local disk, I need to know pathes to\nall these resources. Certainly, for each version I can perform\nlocate-by-history REPORT, but it means that I need to send twice more\nrequests (instead of one PROPFIND + n GET requests, I have to send 1\nPROPFIND + n REPORT + n GET requests)\n\n3. Is there some plan to support sending deltas instead of complete\nresource body by PUT/GET methods?\n\n\n\n-- \nThanks in advance,\n Konstantin                          mailto:KKnizhnik@togetherlab.com\n\n\n\n", "id": "lists-006-15602910"}, {"subject": "RE: Confusion about what a VCR i", "content": "   From: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\n\n   The only time this could cause a race condition is if you allow\n   mutable versions, which I think Geoff tends to block out of his\n   brain because they are so yucky, and that's basically what you get\n   for using them.  Which begs the question of why we don't just kill\n   that feature in the spec...\n\nMutable versions have not existed for a while.  They were replaced\nwith \"variants\", and then the variant feature got deferred to\na separate spec.  So mutable versions in their pernicious form\nare dead and gone.  Mutable versions in their cleaned up useful\nform (variants) are alive but on hold.\n\nBut Eric's basic question still applies: why do you want to\nlabel a version-controlled resource, rather than a version?\nThis would require you to define a bunch of potentially \ncomplicated semantics ... i.e. are two version-controlled\nresources from the same version history allowed to use\nthe same label?  If so, then you'd have to define the\nlabel application semantics at CHECKIN time (replace, or\nfail if already present).  If not, then before it could \napply a label, a server would have to query every version\ncontrolled resource associated with that version history\n(some of which may be on disconnected servers) in order to\nsee if it could apply a label or not.  Neither of these\nalternatives are especially palatable, so we'd need a pretty\ncompelling use case to allow labels to be applied to the\nversion-controlled resource itself.\n\nCheers,\nGeoff\n\n\n   > From: Lisa Dusseault\n   >\n   > I keep having to revise my model of what a Version-Controlled\n   > Resource is, or represents, and I think today I finally figured\n   > out where some of the source of my confusion lies.  The early\n   > part of the spec is quite clear that the VCR and its latest\n   > checked-in version are different things:\n   >\n   > \"when a method is applied to a version-controlled resource, it is only\n   > applied to that version-controlled resource, and is not applied to the\n   > version resource that is currently identified by the\n   > DAV:checked-in property\n   > of that version-controlled resource.  Although the content and dead\n   > properties of a checked-in version-controlled resource are required to\nbe\n   > the same as those of its current DAV:checked-in version...\"\n   >\n   > But the LABEL method takes a different approach:\n   >\n   > \"If a LABEL request is applied to a version-controlled resource, the\n   > operation MUST be applied to the DAV:checked-in version of that\n   > version-controlled resource.\"\n   >\n   > For the LABEL method, the VCR is treated as if it is a link to the\n   > latest-checked-in version, even though elsewhere that's not the case.\n   >\n   > I think this is wrong; a PROPPATCH applied to the VCR changes the\n   > properties\n   > of the VCR and not the latest checked-in version.  LABEL should behave\nthe\n   > same way.\n   >\n   > If LABEL behaviour is not changed, then there's no way of applying a\nlabel\n   > before checking in.  E.g. I can't label the version I'm about to\n   > check in; I\n   > have to wait until I've completed the checkin before sending the LABEL\n   > request.\n   >\n   > lisa\n   >\n   >\n\n\n\n", "id": "lists-006-1560312"}, {"subject": "RE: How to update workspace with UPDATE and MERGE", "content": "   From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\n\n   1. How the user can update his private workspace: UPDATE method just\n   replace all versions in my workspace with versions from the UPDATE\n   source, MERGE method will handle conflicts and merge my changes with\n   the latest versions but looks like it is not able to handle resource\n   renaming and deletion  (unlike UPDATE). So I am confused how can I do\n   something like \"cvs update\"?\n\nThe MERGE method applies the changes (the new versions) to the\n\"corresponding\" VCR in your workspace (i.e. the VCR for the version\nhistory containing the merge version).  The response to the merge\nrequest tells your client what resources were changed, so you can\nupdate any local state you are maintaining on your client.\n\nIn order for a MERGE to reproduce namespace operations (like rename\nand deletion), your server needs to support version-controlled\ncollections or baselines.  In this case, renames and deletions will be\ncaptured\nas new collection versions or in new baselines, that adjust the namespace of\nyour\nprivate workspace when they are merged into it.\n\n   2. It seem to me to be very convenient to have something like\n   <DAV:displaypath/> live property which contains URL of the\n   correspondent version-controlled resource. It actually contains the\n   same value as returned by <DAV:locate-by-history/> report.\n   Why it is better to have it as property and not as report?\n\nWhat resource will have this DAV:displaypath property?  It pretty much\nhas to be a version history resource.  But the displaypath for a given\nversion history will vary from workspace to workspace, which is why a\nreport is required.  You have to say what workspace you are interested\nin.\n\n   For example, I can use PROPFIND method with Label header to extract\n   some configuration of the project marked with specified label.   I\n   can do it with one WebDAV request by specifying Infinite depth.\n\nLabels do not capture namespace information.  If you want to capture\nthe state of a project, including the relative names, you need to\nuse the baseline feature.\n\n   3. Is there some plan to support sending deltas instead of complete\n   resource body by PUT/GET methods?\n\nSee http://search.ietf.org/internet-drafts/draft-mogul-http-delta-10.txt\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-15611826"}, {"subject": "Definition of a configuratio", "content": "Peter Raymond <Peter.Raymond@merant.com> wrote:\n> Initially I thought that only collections and version-controlled resources \n> actually need this property since non-version-controlled resources cannot be\n> \n> captured in a baseline.  Then I noticed that in section 12 it says:\n> \n>        \"A configuration is a set of resources that consists of a root\n>        collection and all members of that root collection except those\n>        resources that are members of another configuration\"\n> \n> It also says:\n> \n> \"A baseline is a version resource that captures the state of each\n>        version-controlled member of a configuration\"\n> \n> The configuration DOES include members that are not version-controlled, but\n> the baseline does NOT capture them.  Right?\nThe spec is saying that but I think it's wrong :-)\nIn my understanding A BASELINE IS A VERSION OF A CONFIGURATION.\nThe purpose of a version is to capture the state of the thing it's a version of.\nSo if a configuration can contain not-version-controlled members and a\nbaseline doesn't capture them a baseline isn't really a version of a configuration.\nAt least in the sense I defined the meaning of 'version' above.\n\nTherefore I would change the definitions Peter cites:\n\n  \"A configuration is a set of resources that consists of a root\n   collection and all version-controlled members of that root collection\n   except those resources that are members of another configuration\"\n\n  \"A baseline is a version resource that captures the state of each\n   member of a configuration.\"\n\n> So, my question is:\n> \n> Will non-version-controlled members of a configuration that is under baseline \n> control return a value for the DAV:version-controlled-configuration property?\nThis question doesn't make sense any more because there aren't such members by\ndefinition. The question Peter would have now is:\n\n  Will non-version-controlled members of a collection that is under baseline \n  control return a value for the DAV:version-controlled-configuration property?\n\nI would answer no. I think we should make clear the difference between the\nconfiguration (The set of version controlled resources. A logical entity) and\nthe collection which just serves as a temporary anchor/root  to \"display\" the\nconfiguration.\nThis root collection can obviously contain non-version-controlled members\nwhich can be added and removed from the configuration by changing their\nversion-control status.\n\nCheers, Edgar \n\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-15621442"}, {"subject": "RE: Definition of a configuratio", "content": "   From: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n\n   Peter Raymond <Peter.Raymond@merant.com> wrote:\n\n   > \"A configuration is a set of resources that consists of a root\n   > collection and all members of that root collection except those\n   > resources that are members of another configuration\"\n\n   > \"A baseline is a version resource that captures the state of each\n   > version-controlled member of a configuration\"\n\n   > The configuration DOES include members that are not\n   > version-controlled, but the baseline does NOT capture them.\n   > Right?\n\nCorrect.\n\n   The spec is saying that but I think it's wrong :-)\n\nOne could define it either way, as long as the definitions are used\nconsistently.  Since the spec has gone through IESG last call, we'll\njust have to live with the current definitions.\n\n   In my understanding A BASELINE IS A VERSION OF A CONFIGURATION.\n   The purpose of a version is to capture the state of the thing it's\n   a version of.  So if a configuration can contain\n   not-version-controlled members and a baseline doesn't capture them\n   a baseline isn't really a version of a configuration.  At least in\n   the sense I defined the meaning of 'version' above.\n\nI think the current approach of the specification is simpler, since it\neffectively says that anything you can find with a depth:infinity\nPROPFIND is a member of that configuration.  But whether or not it\nis simpler, it is what will appear in the standard.\n\n   Therefore I would change the definitions Peter cites:\n\n     \"A configuration is a set of resources that consists of a root\n      collection and all version-controlled members of that root collection\n      except those resources that are members of another configuration\"\n\n     \"A baseline is a version resource that captures the state of each\n      member of a configuration.\"\n\nThis would not allow you to talk about non-version-controlled\nconfigurations.  I think this would be unfortunate, since it is\na useful concept even if you aren't doing versioning.\n\n   > So, my question is:\n   > \n   > Will non-version-controlled members of a configuration that is\n   > under baseline control return a value for the\n   > DAV:version-controlled-configuration property?\n\n   This question doesn't make sense any more because there aren't such\n   members by definition.\n\nBy the definitions in the specification, though, the question does make\nsense and the answer is \"yes\".\n\n The question Peter would have now is:\n\n     Will non-version-controlled members of a collection that is under\n     baseline control return a value for the\n     DAV:version-controlled-configuration property?\n\nThe only difference between these two questions is that Peter's question\nincludes the root collection, while your rephrasing does not.\n\n   I would answer no.\n\nAccording to the specification though, the answer is \"yes\".\n\n   I think we should make clear the difference between the\n   configuration (The set of version controlled resources. A logical\n   entity) and the collection which just serves as a temporary\n   anchor/root to \"display\" the configuration.\n\nThe specification makes a clear distinction between the configuration\n(which is a set of resources), and the root collection of a\nconfiguration (which is a single resource).  How is the root\ncollection any more \"temporary\" than any other part of the\nconfiguration?\n\n   This root collection can obviously contain non-version-controlled\n   members which can be added and removed from the configuration by\n   changing their version-control status.\n\nOne could define it this way, but we didn't (:-).  That's one of the\nnice thing about locking down a standard ... you can stop debating\nover terminology, and get on with the implementations (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-15632026"}, {"subject": "Re: Definition of a configuratio", "content": "\"Clemm, Geoff\" wrote:\n\n>    From: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n>\n>    ...I would change the definitions Peter cites:\n>\n>      \"A configuration is a set of resources that consists of a root\n>       collection and all version-controlled members of that root collection\n>       except those resources that are members of another configuration\"\n>\n>      \"A baseline is a version resource that captures the state of each\n>       member of a configuration.\"\n>\n> This would not allow you to talk about non-version-controlled\n> configurations.  I think this would be unfortunate, since it is\n> a useful concept even if you aren't doing versioning.\n>\n\nI didn't think non-version-controlled configurations were defined by the spec.\nHow do you create and restore such a configuration?\n\nThanks,\nAlison.\n--\n -------------------------------------------------------------\n The statements and opinions expressed here are my own\n and do not necessarily represent those of Oracle Corporation.\n -------------------------------------------------------------\n\n\n\n", "id": "lists-006-15643848"}, {"subject": "RE: Definition of a configuratio", "content": "A \"configuration\" is just a concept defined by the spec\n(i.e. the definition quoted below).  It always existed in\nWebDAV, but didn't have a name (it was the \"Depth:infinity\nstate of a collection\").  You manipulate it with\nstandard operations like PUT/MKCOL/DELETE/COPY (a Depth:Infinity\ncopy allows you to copy an entire configuration from one spot\nto another).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Alison Macmillan [mailto:alison.macmillan@oracle.com]\nSent: Monday, October 29, 2001 5:37 AM\nTo: Clemm, Geoff\nCc: ietf-dav-versioning@w3.org\nSubject: Re: Definition of a configuration\n\n\n\"Clemm, Geoff\" wrote:\n\n>    From: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n>\n>    ...I would change the definitions Peter cites:\n>\n>      \"A configuration is a set of resources that consists of a root\n>       collection and all version-controlled members of that root\ncollection\n>       except those resources that are members of another configuration\"\n>\n>      \"A baseline is a version resource that captures the state of each\n>       member of a configuration.\"\n>\n> This would not allow you to talk about non-version-controlled\n> configurations.  I think this would be unfortunate, since it is\n> a useful concept even if you aren't doing versioning.\n>\n\nI didn't think non-version-controlled configurations were defined by the\nspec.\nHow do you create and restore such a configuration?\n\n\n\n", "id": "lists-006-15652537"}, {"subject": "RE: Definition of a configuratio", "content": "Hi,\n\nSo we have this \"concept\" called a configuration which is ALL resources\nrooted\nat a collection (with Depth:infinity) and we have a concept called a\n\"version-controlled \nconfiguration\" which is all VERSION-CONTROLLED resources rooted at a\ncollection which \nis captured in a baseline.\n\nI think the terminology is a little odd because every member of the\nconfiguration has \nthe DAV:version-controlled-configuration property even though some of the\nmembers of \nthe configuration are not in the \"version-controlled configuration\" (eg they\nare not \nversion-controlled).\n\nI know it's too late to change this, but feel we should have some\nexplanation of this \navailable somewhere, eg in the FAQ, use case doc or somewhere.  It would\nhave been very \neasy for me to miss this subtle point and incorrectly code the property to\nONLY appear \non version-controlled resources.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: 29 October 2001 12:45\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Definition of a configuration\n\n\nA \"configuration\" is just a concept defined by the spec\n(i.e. the definition quoted below).  It always existed in\nWebDAV, but didn't have a name (it was the \"Depth:infinity\nstate of a collection\").  You manipulate it with\nstandard operations like PUT/MKCOL/DELETE/COPY (a Depth:Infinity\ncopy allows you to copy an entire configuration from one spot\nto another).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Alison Macmillan [mailto:alison.macmillan@oracle.com]\nSent: Monday, October 29, 2001 5:37 AM\nTo: Clemm, Geoff\nCc: ietf-dav-versioning@w3.org\nSubject: Re: Definition of a configuration\n\n\n\"Clemm, Geoff\" wrote:\n\n>    From: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n>\n>    ...I would change the definitions Peter cites:\n>\n>      \"A configuration is a set of resources that consists of a root\n>       collection and all version-controlled members of that root\ncollection\n>       except those resources that are members of another configuration\"\n>\n>      \"A baseline is a version resource that captures the state of each\n>       member of a configuration.\"\n>\n> This would not allow you to talk about non-version-controlled\n> configurations.  I think this would be unfortunate, since it is\n> a useful concept even if you aren't doing versioning.\n>\n\nI didn't think non-version-controlled configurations were defined by the\nspec.\nHow do you create and restore such a configuration?\n\n\n\n", "id": "lists-006-15661998"}, {"subject": "RE: Definition of a configuratio", "content": "Hi,\n\nSo we have this \"concept\" called a configuration which is ALL resources\nrooted\nat a collection (with Depth:infinity) and we have a concept called a\n\"version-controlled \nconfiguration\" which is all VERSION-CONTROLLED resources rooted at a\ncollection which \nis captured in a baseline.\n\nI think the terminology is a little odd because every member of the\nconfiguration has \nthe DAV:version-controlled-configuration property even though some of the\nmembers of \nthe configuration are not in the \"version-controlled configuration\" (eg they\nare not \nversion-controlled).\n\nI know it's too late to change this, but feel we should have some\nexplanation of this \navailable somewhere, eg in the FAQ, use case doc or somewhere.  It would\nhave been very \neasy for me to miss this subtle point and incorrectly code the property to\nONLY appear \non version-controlled resources.\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: 29 October 2001 12:45\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Definition of a configuration\n\n\nA \"configuration\" is just a concept defined by the spec\n(i.e. the definition quoted below).  It always existed in\nWebDAV, but didn't have a name (it was the \"Depth:infinity\nstate of a collection\").  You manipulate it with\nstandard operations like PUT/MKCOL/DELETE/COPY (a Depth:Infinity\ncopy allows you to copy an entire configuration from one spot\nto another).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Alison Macmillan [mailto:alison.macmillan@oracle.com]\nSent: Monday, October 29, 2001 5:37 AM\nTo: Clemm, Geoff\nCc: ietf-dav-versioning@w3.org\nSubject: Re: Definition of a configuration\n\n\n\"Clemm, Geoff\" wrote:\n\n>    From: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n>\n>    ...I would change the definitions Peter cites:\n>\n>      \"A configuration is a set of resources that consists of a root\n>       collection and all version-controlled members of that root\ncollection\n>       except those resources that are members of another configuration\"\n>\n>      \"A baseline is a version resource that captures the state of each\n>       member of a configuration.\"\n>\n> This would not allow you to talk about non-version-controlled\n> configurations.  I think this would be unfortunate, since it is\n> a useful concept even if you aren't doing versioning.\n>\n\nI didn't think non-version-controlled configurations were defined by the\nspec.\nHow do you create and restore such a configuration?\n\n\n\n", "id": "lists-006-15674136"}, {"subject": "RE: Definition of a configuratio", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n   So we have this \"concept\" called a configuration which is ALL\n   resources rooted at a collection (with Depth:infinity) and we have\n   a concept called a \"version-controlled configuration\" which is all\n   VERSION-CONTROLLED resources rooted at a collection which is\n   captured in a baseline.  I think the terminology is a little odd\n   because every member of the configuration has the\n   DAV:version-controlled-configuration property even though some of\n   the members of the configuration are not in the \"version-controlled\n   configuration\" (eg they are not version-controlled).\n\nThe best way to think of the DAV:version-controlled-configuration\nproperty on a non-version-controlled resource is that it indicates\nthe VCCn that the non-VCR would become a member of when it is\nput under version control.  One way this property would be used was\nif you were running against a server that required an explicit\nclient checkout of a VCCn in order to change it, the DAV:v-c-cn \nproperty on the non-VCR would tell you what VCCn you would have\nto check out before you could apply VERSION-CONTROL to that non-VCR.\n\n   I know it's too late to change this, but feel we should have some\n   explanation of this available somewhere, eg in the FAQ, use case\n   doc or somewhere.  It would have been very easy for me to miss this\n   subtle point and incorrectly code the property to ONLY appear on\n   version-controlled resources.\n\nThis is now a topic in the FAQ (in the \"Properties\" section).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-15686344"}, {"subject": "RE: Content-Type / charset in RFC2518, deltaV and ACL spec", "content": "Hi,\n\na related discussion is going on in xml-dev right now [1]. It seems to me it\nwould be wise if WebDAV and related specs would switch to use a content type\nof application/xml -- at least both server and client implementors should be\nadvised to accept both.\n\nJulian\n\n\n[1] <http://lists.xml.org/archives/xml-dev/200110/msg01021.html>\n\n\n\n", "id": "lists-006-15694907"}, {"subject": "Re (2): Definition of a configuratio", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n>    From: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n> \n>    Peter Raymond <Peter.Raymond@merant.com> wrote:\n> \n>    > \"A configuration is a set of resources that consists of a root\n>    > collection and all members of that root collection except those\n>    > resources that are members of another configuration\"\n> \n>    > \"A baseline is a version resource that captures the state of each\n>    > version-controlled member of a configuration\"\n> \n>    > The configuration DOES include members that are not\n>    > version-controlled, but the baseline does NOT capture them.\n>    > Right?\n> \n> Correct.\n> \n>    The spec is saying that but I think it's wrong :-)\n> \n> One could define it either way, as long as the definitions are used\n> consistently.\nHere we agree. I also think that the power of the protocol will be the same\neither way.\n\n> Since the spec has gone through IESG last call, we'll just have to live with the\n> current definitions.\nOK, you say it's too late for this discussion now for formal reasons. But will\nthere be another open window sometime in the future when this topic can be\ndiscussed again and a consensus of the group could change the definition of\na configuration ?\nI don't know whether my proposal would get a majority but nevertheless it's \nimportant to know whether now it's the last chance.\nMy experience in developing SW is that it's cheapest to correct problems as soon as\npossible in the lifecycle. You can also find that in the literature :-)\n\n>    In my understanding A BASELINE IS A VERSION OF A CONFIGURATION.\n>    The purpose of a version is to capture the state of the thing it's\n>    a version of.  So if a configuration can contain\n>    not-version-controlled members and a baseline doesn't capture them\n>    a baseline isn't really a version of a configuration.  At least in\n>    the sense I defined the meaning of 'version' above.\n> \n> I think the current approach of the specification is simpler, since it\n> effectively says that anything you can find with a depth:infinity\n> PROPFIND is a member of that configuration.  But whether or not it\n> is simpler, it is what will appear in the standard.\nYes, the definition of a configuration is simpler, but OTOH the definition\nof a baseline is more complex. It's just a matter of moving the restriction\n'version-controlled members' between configuration and baseline.\nI still think that our current definition contradicts the common meaning\nof 'version' (as detailed above). Here I see a source of misconceptions.\nI would regret it if a basic term of 'configuration' management is flawed\nfrom the beginning.\nI expect 'configuration' to become a cornerstone of future versioning\nbecause in SW development and also website management you don't deal with\nindependent resources normally (This doesn't mean that I want to belittle\nthe effort necessary to do core versioning).\n\n>      \"A configuration is a set of resources that consists of a root\n>       collection and all version-controlled members of that root collection\n>       except those resources that are members of another configuration\"\n> \n>      \"A baseline is a version resource that captures the state of each\n>       member of a configuration.\"\n> \n> This would not allow you to talk about non-version-controlled\n> configurations.  I think this would be unfortunate, since it is\n> a useful concept even if you aren't doing versioning.\nWhy not ? If you talk about a root collection which isn't under baseline-control\ncontaining version-controlled resources you talk about a non-version-controlled \nconfiguration.\nAnd if you mean a root collection without version-controlled resources, then\nwhat would be the purpose of calling it a configuration ? If you put it under\nbaseline-control nothing would be captured.  \n\n>    I think we should make clear the difference between the\n>    configuration (The set of version controlled resources. A logical\n>    entity) and the collection which just serves as a temporary\n>    anchor/root to \"display\" the configuration.\n> \n> The specification makes a clear distinction between the configuration\n> (which is a set of resources), and the root collection of a\n> configuration (which is a single resource).  How is the root\n> collection any more \"temporary\" than any other part of the\n> configuration?\nA baseline (which is also a configuration) can exist without a root collection.\nWhen you checkout a baseline to a root collection you can choose (nearly) any\ncollection you want. In this sense the root collection isn't a part of the\nconfiguration. It'a like loading a document to the editor buffer.\nYou wouldn't say that the buffer is a part of the document. It's just a means\nto work with it.\n\n> One could define it this way, but we didn't (:-).  That's one of the\n> nice thing about locking down a standard ... you can stop debating\n> over terminology, and get on with the implementations (:-).\nBut nevertheless I can try it and raise my voice if I think that\nthe terminology is misleading.\nChanging the definitions wouldn't change the functionality, so perhaps I'm \nsort of a purist. Probably this also shows in my favorite programming languages.\nI prefer e.g. Oberon and Python to C and C++ :-)\nBut I don't think many changes in the spec would be necessary. Probably at some\nplaces moving a 'version-controlled resources' or exchanging a 'collection' by\n'configuration'.\n\nCheers, Edgar\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-15703111"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "Intro about me at bottom.\n\n\"In order to remove a resource at a given URL from version control, the\nclient can replace the resource under version control with a\nnon-version-controlled copy of that resource.  For example, a client can\nCOPY the version-controlled resource to a temporary location, DELETE the\nversion-controlled resource, and then MOVE the copy from the temporary\nlocation back to the original URL.  Note that the versions already\ncreated for the version-controlled resource will continue to exist at\ntheir server-defined locations.\"\n\nIs that clearer?\n\nCheers,\nGeoff\n\n=================================================================\n\nWhen you DELETE a version-controlled resource, I strongly believe that\nall information for that VCR and all versions already created should go\nto the great bit bucket in the sky.\n\nAs I understand your formulation, I would have severe problems in\nmodifying my DAV server (with versioning support) to support DELTAV\nusing this behavior.  \n\nI would prefer this formulation / behavior:\n\n\"In order to remove a resource at a given URL from version control, the\nclient can replace the resource under version control with a\nnon-version-controlled copy of that resource.  For example, a client can\nCOPY the version-controlled resource to a temporary location, DELETE the\nversion-controlled resource, and then MOVE the copy from the temporary\nlocation back to the original URL.  Note that the versions already\ncreated for the version-controlled resource will NO LONGER BE AVAILABLE.\nIf you wish to remove a resource at a given URL from version control\nwhile also retaining a previous revision history, then you should MOVE\nthe resource to a new save location and COPY the current version back to\nthe original URL.\"\n\n==========\n\nMy formulation is based explicitly on the idea that some implementations\nand some customers are not keeping track of legal documents and\ntherefore deleting old versions is highly desired if not required.  A\nserver shouldn't be forced to keep data that a client is willing to\nspecifically state that it doesn't want.\n\nI think a far better manner of achieving your goals is simply to allow\nthe VERSION-CONTROL method to turn version-control for a resource at a\ngiven URL off (if supported by the server).  That allows you to achieve\nyour above objectives (no new versions, but keep the old ones at the\nsame URLs) without changing the usefulness of the DELETE command.\n\n======================================================\n\nJohn Hall is an engineer working on the Xythos development team to\nmodify their DAV (with revision additions) server to support DELTAV as\nwell as other-party proprietary DAV versioning systems.\n\n\n\n", "id": "lists-006-1570742"}, {"subject": "RE: Re (2): Definition of a configuratio", "content": "   From: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n\n   \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n\n   > Since the spec has gone through IESG last call, we'll just have\n   > to live with the current definitions.\n\n   OK, you say it's too late for this discussion now for formal reasons.\n\nA discussion is always valuable, since it can clarify points of\nconfusion.  So I wasn't saying that we shouldn't discuss it, but\nthat it is too late to change it for the \"proposed standard\" draft.\n\n   But will there be another open window sometime in the future when\n   this topic can be discussed again and a consensus of the group\n   could change the definition of a configuration ?\n\nDefinitely, when we are going for next standard level (draft\nstandard).  That will be a good time to revise any terminology that\nhas proven to be confusing (such as the notorious \"MOVE is\nCOPY/DELETE\" statement in 2518 ... always fun to pick on that :-).\n\n   >      \"A configuration is a set of resources that consists of a root\n   >       collection and all version-controlled members of that root\ncollection\n   >       except those resources that are members of another configuration\"\n   > \n   >      \"A baseline is a version resource that captures the state of each\n   >       member of a configuration.\"\n   > \n   > This would not allow you to talk about non-version-controlled\n   > configurations.  I think this would be unfortunate, since it is\n   > a useful concept even if you aren't doing versioning.\n\n   Why not ? If you talk about a root collection which isn't under\n   baseline-control containing version-controlled resources you talk\n   about a non-version-controlled configuration.\n\nI meant that \"you couldn't talk about a tree of non-version-controlled\nresources as being a configuration\".  It is common for an IDE these\ndays to rather misleadingly call such a configuration a \"project\", and\nwe definitely didn't want to adopt that term :-).\n\n   And if you mean a root collection without version-controlled\n   resources, then what would be the purpose of calling it a\n   configuration ? If you put it under baseline-control nothing would\n   be captured.\n\nTrue, but you could \"build\" it, and could \"deploy it\", and could ask\n\"what are its interfaces\" (i.e. the kinds of things you would do with\nan IDE project).\n\n   >    I think we should make clear the difference between the\n   >    configuration (The set of version controlled resources. A logical\n   >    entity) and the collection which just serves as a temporary\n   >    anchor/root to \"display\" the configuration.\n\n   > How is the root collection any more \"temporary\" than any other\n   > part of the configuration?\n\n   A baseline (which is also a configuration) can exist without a root\n   collection.\n\nActually, a baseline is not a configuration, but it has a property,\nDAV:baseline-collection, that does identify a configuration.  And\nthe DAV:baseline-collection always has a root collection (as does every\nconfiguration).\n\n   When you checkout a baseline to a root collection you can choose\n   (nearly) any collection you want.\n\nTo be precise, you cannot \"checkout a baseline to a root collection\".\nPerhaps you meant \"when you apply BASELINE-CONTROL with an existing\nbaseline to a non-baseline-controlled collection\"?  This creates a new\ntree of version-controlled resources, corresponding to the members of\nthe baseline, but the root collection is treated pretty much like\nany other member of the configuration.\n\n   In this sense the root collection isn't a part of the\n   configuration. It'a like loading a document to the editor buffer.\n   You wouldn't say that the buffer is a part of the document. It's\n   just a means to work with it.\n\nOr you could say that the root collection is like the first line of\nthe document you are loading.  It is true that all the other lines\ncome after it, but it is just a line, like the other lines.  But I\ncertainly agree that the root collection of a configuration is\n\"special\" (if nothing else, it merits its own term, \"root collection\").\n\n   > One could define it this way, but we didn't (:-).  That's one of the\n   > nice thing about locking down a standard ... you can stop debating\n   > over terminology, and get on with the implementations (:-).\n\n   But nevertheless I can try it and raise my voice if I think that\n   the terminology is misleading.\n\nI agree.  I just wanted to make sure folks understood that this kind\nof change won't happen until we go to draft standard (I promised our\narea director as much).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-15717076"}, {"subject": "Small typo in Section 1.", "content": "Hi,\n\nI don't know if you've still got a chance to fix small typographical errors\nin \nthe deltav draft, but in section 1.3 in the definition of a working resource\nthe \nspecification reads:\n\n\"a working resource is a deleted when it is checked in.\"\n\nIt should be:\n\n\"a working resource is deleted when it is checked in.\"\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-15729406"}, {"subject": "RE: Small typo in Section 1.", "content": "Yes, I get my hands on the spec one last time (after the RFC editor\nconverts it to nroff).  In particular:\n\n   Final Review Period\n\n   Once an RFC has been edited and is ready for publication, author(s)\n   are given 48 hours to look over their document for editorial\n   nits. We STRONGLY suggest that authors check for spelling and\n   missing words and that they make sure the references, contact\n   information are up to date. Also, if your document is a MIB we\n   encourage you to take one last look at your CODE. We DO NOT make\n   changes to RFCs once they have been published, so please look over\n   your document carefully.\n\nSo please do send me any typos, so I can get them fixed in the\nfinal review period!\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\nI don't know if you've still got a chance to fix small typographical\nerrors in the deltav draft, but in section 1.3 in the definition of a\nworking resource the specification reads:\n\n\"a working resource is a deleted when it is checked in.\" \nIt should be: \n\"a working resource is deleted when it is checked in.\" \n\n\n\n", "id": "lists-006-15737571"}, {"subject": "Re (3): Definition of a configuratio", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n>    But will there be another open window sometime in the future when\n>    this topic can be discussed again and a consensus of the group\n>    could change the definition of a configuration ?\n> \n> Definitely, when we are going for next standard level (draft\n> standard).  That will be a good time to revise any terminology that\n> has proven to be confusing (such as the notorious \"MOVE is\n> COPY/DELETE\" statement in 2518 ... always fun to pick on that :-).\nThat's good enough for me. So I won't discuss the definition of a configuration\nany more for the time being.\nOut of curiosity :-) Could I get a feedback from some of the readers\nof the mailing list ? Just a note whether they think this topic should be\ndiscussed in the future or that they think it's irrelevant and I should\nforget about it.\nThen a plea to the parties I think are big players concerning implementing\nDeltaV. Is there any chance of a joint effort for creating a scenarios or\nvalidation suite document.\nFrom the top of my mind I can imagine Rational, Oracle, Merant, Microsoft,\nApache, ...\n\nCheers, Edgar\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-15745687"}, {"subject": "Resource class does not list the REPORT metho", "content": "hi,\n\nI have  a question regarding the Rational Rose model available at the Delta\nV web site.\nWhat is the reason for the Resource class not having the Report method\nlisted as one of the operations.\n\nthanks,\nrajkumar\n\n\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\nEdgar@EdgarSchwarz.de\nSent: Tuesday, October 30, 2001 4:01 PM\nTo: ietf-dav-versioning@w3.org\nCc: Edgar@EdgarSchwarz.de\nSubject: Re (3): Definition of a configuration\n\n\n\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n>    But will there be another open window sometime in the future when\n>    this topic can be discussed again and a consensus of the group\n>    could change the definition of a configuration ?\n>\n> Definitely, when we are going for next standard level (draft\n> standard).  That will be a good time to revise any terminology that\n> has proven to be confusing (such as the notorious \"MOVE is\n> COPY/DELETE\" statement in 2518 ... always fun to pick on that :-).\nThat's good enough for me. So I won't discuss the definition of a\nconfiguration\nany more for the time being.\nOut of curiosity :-) Could I get a feedback from some of the readers\nof the mailing list ? Just a note whether they think this topic should be\ndiscussed in the future or that they think it's irrelevant and I should\nforget about it.\nThen a plea to the parties I think are big players concerning implementing\nDeltaV. Is there any chance of a joint effort for creating a scenarios or\nvalidation suite document.\n>From the top of my mind I can imagine Rational, Oracle, Merant, Microsoft,\nApache, ...\n\nCheers, Edgar\n--\nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-15754526"}, {"subject": "RE: Re (3): Definition of a configuratio", "content": "We're definitely interested in creating a validation suite.\n\nI'm probably going to be focusing on the JSR-147 \"WVCM\" effort for\na while (defining a Java client-side API to the DeltaV/WebDAV\nprotocol), and that effort requires a validations suite.  So\ngiven the close coupling between WVCM and DeltaV/WebDAV, we\nshould be able to derive a DeltaV/WebDAV validation suite from\nthe WVCM validation suite.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n...\nThen a plea to the parties I think are big players concerning implementing\nDeltaV. Is there any chance of a joint effort for creating a scenarios or\nvalidation suite document.\nFrom the top of my mind I can imagine Rational, Oracle, Merant, Microsoft,\nApache, ...\n\n\n\n", "id": "lists-006-15765569"}, {"subject": "RE: Resource class does not list the REPORT metho", "content": "Just a bug (:-).  That model is missing a goodly amount of stuff,\nand should be considered as just a very preliminary pass at creating\nsuch a model.  I am working on a more extensive model for the WVCM\neffort (a client-side API for DeltaV/WebDAV), and I'll post that as\nsoon as it is in a reasonably stable form (unfortunately, I can't\nyet predict when that will happen).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Raj Kumar [mailto:kothapa@intalio.com]\nSent: Tuesday, October 30, 2001 7:26 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Resource class does not list the REPORT method\n\n\nhi,\n\nI have  a question regarding the Rational Rose model available at the Delta\nV web site.\nWhat is the reason for the Resource class not having the Report method\nlisted as one of the operations.\n\nthanks,\nrajkumar\n\n\n\n", "id": "lists-006-15773696"}, {"subject": "RE: Resource class does not list the REPORT metho", "content": "Is the current rational rose model at the Delta V web site for the server\nside or for the\nclient side.\n\nthanks,\nrajkumar\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\nSent: Tuesday, October 30, 2001 7:58 PM\nTo: DeltaV (E-mail)\nSubject: RE: Resource class does not list the REPORT method\n\n\nJust a bug (:-).  That model is missing a goodly amount of stuff,\nand should be considered as just a very preliminary pass at creating\nsuch a model.  I am working on a more extensive model for the WVCM\neffort (a client-side API for DeltaV/WebDAV), and I'll post that as\nsoon as it is in a reasonably stable form (unfortunately, I can't\nyet predict when that will happen).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Raj Kumar [mailto:kothapa@intalio.com]\nSent: Tuesday, October 30, 2001 7:26 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Resource class does not list the REPORT method\n\n\nhi,\n\nI have  a question regarding the Rational Rose model available at the Delta\nV web site.\nWhat is the reason for the Resource class not having the Report method\nlisted as one of the operations.\n\nthanks,\nrajkumar\n\n\n\n", "id": "lists-006-15782627"}, {"subject": "RE: Resource class does not list the REPORT metho", "content": "That model is was for the DeltaV protocol itself, with no\nparticular allignment to either the client or the server.\n\nCheers,\nGeoff \n\n-----Original Message-----\nFrom: Raj Kumar [mailto:kothapa@intalio.com]\nSent: Wednesday, October 31, 2001 2:12 PM\nTo: 'DeltaV (E-mail)'\nSubject: RE: Resource class does not list the REPORT method\n\n\nIs the current rational rose model at the Delta V web site for the server\nside or for the\nclient side.\n\nthanks,\nrajkumar\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\nSent: Tuesday, October 30, 2001 7:58 PM\nTo: DeltaV (E-mail)\nSubject: RE: Resource class does not list the REPORT method\n\n\nJust a bug (:-).  That model is missing a goodly amount of stuff,\nand should be considered as just a very preliminary pass at creating\nsuch a model.  I am working on a more extensive model for the WVCM\neffort (a client-side API for DeltaV/WebDAV), and I'll post that as\nsoon as it is in a reasonably stable form (unfortunately, I can't\nyet predict when that will happen).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Raj Kumar [mailto:kothapa@intalio.com]\nSent: Tuesday, October 30, 2001 7:26 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Resource class does not list the REPORT method\n\n\nhi,\n\nI have  a question regarding the Rational Rose model available at the Delta\nV web site.\nWhat is the reason for the Resource class not having the Report method\nlisted as one of the operations.\n\nthanks,\nrajkumar\n\n\n\n", "id": "lists-006-15792098"}, {"subject": "Do baselines capture live properties of VCRs", "content": "Hi,\n\nWhen a configuration is placed under baseline-control a baseline collection \nis created which captures the state of the version-controlled members of the\n\nconfiguration.\n\nWhile thinking about the implementation of this I realized that the baseline\nfeature does not capture the live properties of the resources under\nbaseline-control.  In section 12 of the specification there is a statement\nthat says:\n\n       \"In order to allow efficient baseline implementation, the state of a \n        baseline of a collection is limited to be a set of versions and\ntheir \n        names relative to the collection\"\n\nAlso section 12.3.1 says:\n\n       \"12.3.1 DAV:baseline-collection (protected)\n\n       This property contains a server-defined URL for a collection, where\n       each member of this collection MUST either be a version-controlled\n       resource with the same DAV:checked-in version and relative name as\n       a version-controlled member of the baseline-controlled collection\n       at the time the baseline was created, or be a collection needed to\n       provide the relative name for a version-controlled resource.\"\n\nThis seems to be saying that live properties like DAV:displayname will not\nbe \ncaptured by the baseline (only DAV:checked-in will be captured).  In my\nopinion \na baseline should record the exact state of the configuration (including\nproperties \nof it's members).   A VCR must have the same content and dead properties as\nit's \nchecked-in version, but it's live properties may differ and would not seem\nto be \ncaptured in the baseline.\n\nIs my understanding of this correct? \n\nDo other members of the group agree that it makes sense to capture other\nlive \nproperties of the VCR that is under baseline-control?\n\nRegards,\n--\nPeter Raymond - MERANT\nPrincipal Architect (PVCS)\nTel: +44 (0)1727 813362\nFax: +44 (0)1727 869804\nmailto:Peter.Raymond@merant.com\nWWW: http://www.merant.com\n\n\n\n", "id": "lists-006-15802382"}, {"subject": "RE: [ACL] RE: lock and access control lists on (working) version", "content": "Isn't \"the ACL list it currently uses to decide who gets to see the version\"\nthe ACL on the version history resource, or is what you want a version-\nindependent ACL that applies to all versions of a resource, that can\noverride the ACL on that particular version?\n\n> -----Original Message-----\n> From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> Yaron Goland\n> Sent: Tuesday, June 12, 2001 2:29 PM\n> To: Clemm, Geoff; ietf-dav-versioning@w3.org\n> Cc: acl@webdav.org\n> Subject: RE: [ACL] RE: lock and access control lists on (working)\n> versions\n>\n>\n> When I version a resource I will also likely want to version the access\n> control list it had when I 'froze' it. This is very important for things\n> like security checks. Imagine that an employee who was fired a year ago\n> turned out to be a corporate spy, you are going to want to check what\n> resources he had access to back then. This means that a version\n> really needs\n> two sets of ACLs. One if the ACL list it had when it was frozen. The other\n> is the ACL list it currently uses to decide who gets to see the version.\n>\n> > -----Original Message-----\n> > From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> > Clemm, Geoff\n> > Sent: Saturday, May 26, 2001 8:27 AM\n> > To: ietf-dav-versioning@w3.org\n> > Cc: acl@webdav.org\n> > Subject: [ACL] RE: lock and access control lists on (working) versions\n> >\n> >\n> > As Tim surmised, the answer to (1) is in fact \"yes\".\n> > Each version is a separate resource, and each resource\n> > can have its own distinct access control list.\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n> > Sent: Wednesday, May 16, 2001 5:42 AM\n> > To: ietf-dav-versioning@w3.org\n> > Cc: acl@webdav.org\n> > Subject: Re: lock and access control lists on (working) versions\n> >\n> >\n> >\n> >\n> > \"Pill, Juergen\" <Juergen.Pill@softwareag.com>\n> > > Hello,\n> > >\n> > > 1) Would it be possible with DETA-V to have different access\n> > control list\n> > > for different versions of a resource, e.g. V1 of resource /foo\n> > will allow\n> > > user A to modify and read, but V2 of resource /foo will allow\n> user A to\n> > read\n> > > read only?\n> >\n> > You'd have to ask the ACL-folk that question, but I would sincerely hope\n> > the answer is 'yes'.\n> >\n> > > 2) Would it be possible to have two distinct locks on two different\n> > > (working) resources?\n> >\n> > Yes.  Working resources have distinct server-defined URLs.  They can be\n> > locked using their URLs just like any other resource.\n> >\n> > > Does that make sense at all?\n> >\n> > Yep.\n> >\n> > Tim\n> >\n> >\n> > _______________________________________________\n> > acl mailing list\n> > acl@webdav.org\n> > http://mailman.webdav.org/mailman/listinfo/acl\n> >\n>\n>\n>\n>\n> _______________________________________________\n> acl mailing list\n> acl@webdav.org\n> http://mailman.webdav.org/mailman/listinfo/acl\n>\n\n\n\n", "id": "lists-006-1581066"}, {"subject": "RE: Do baselines capture live properties of VCRs", "content": "   From: Peter Raymond [mailto:Peter.Raymond@merant.com]\n\n    \"12.3.1 DAV:baseline-collection (protected) \n\n    This property contains a server-defined URL for a collection,\n    where each member of this collection MUST either be a\n    version-controlled resource with the same DAV:checked-in version\n    and relative name as a version-controlled member of the\n    baseline-controlled collection at the time the baseline was\n    created, or be a collection needed to provide the relative name\n    for a version-controlled resource.\"\n\n   This seems to be saying that live properties like DAV:displayname\n   will not be captured by the baseline (only DAV:checked-in will be\n   captured).\n\nThe semantics of DAV:checked-in require that the dead properties\non the VCR are identical to the dead properties on the DAV:checked-in\nversion, but you are correct that this requirement does not apply\nto live properties.\n\nBut the protocol does not prevent a server from capturing live\nproperties, it just does not require it to do so.  In the case\nof D:displayname, I expect that most servers will chose to capture\nthat as part of the version state, but that is up to the server.\n\n   In my opinion a baseline should record the exact state\n   of the configuration (including properties of it's members).  A VCR\n   must have the same content and dead properties as it's checked-in\n   version, but it's live properties may differ and would not seem to\n   be captured in the baseline.\n\nAll the reasons for why we didn't require live properties to be\ncaptured by versions (I'm not sure if that issue made it from the\nmailing list into the FAQ yet) apply to why would wouldn't require\nthem to be captured by baselines.  (examples include the\nDAV:version-controlled-configuration property and the DAV:lockdiscovery\nproperty).\n\n   Is my understanding of this correct? \n\nYes.\n\n   Do other members of the group agree that it makes sense to capture\n   other live properties of the VCR that is under baseline-control?\n\nI agree that a server should be allowed to capture other live\nproperties, but I do not agree that we could/should require that\nall live properties be captured by a version/baseline.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-15811945"}, {"subject": "Copying DAV:comment on CHECKIN and VERSION-CONTRO", "content": "I don't see anything in the spec that requires DAV:comment\nto be copied from checked-out resources to versions on\nCHECKIN, or from unversioned resources to the initial\nversion on VERSION-CONTROL.\n\nIn particular, since DAV:comment is a live property, it\ndoesn't get copied with the dead properties, and it is not\nmentioned explicitly in postcondition\nDAV:initialize-version-content-and-properties of Section 4.4\nor postcondition DAV:put-under-version-conrtrol of Section\n3.5.\n\nIs this the intended behavior?\n\nThanks,\nRoy\n\n\n\n", "id": "lists-006-15821421"}, {"subject": "RE: Copying DAV:comment on CHECKIN and VERSION-CONTRO", "content": "Currently, the server gets to decide which live properties\nof a VCR are captured by versions.\n\nIt would be reasonable to identify a set of live\nproperties that SHOULD/MUST be captured by versions,\nand publish this list in an internet draft and on\nthe DeltaV web site.  This list would then be added\nto the protocol document when we go to the next standard level.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Roy Seto [mailto:Roy.Seto@oracle.com]\nSent: Thursday, November 01, 2001 8:50 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Copying DAV:comment on CHECKIN and VERSION-CONTROL\n\n\nI don't see anything in the spec that requires DAV:comment\nto be copied from checked-out resources to versions on\nCHECKIN, or from unversioned resources to the initial\nversion on VERSION-CONTROL.\n\nIn particular, since DAV:comment is a live property, it\ndoesn't get copied with the dead properties, and it is not\nmentioned explicitly in postcondition\nDAV:initialize-version-content-and-properties of Section 4.4\nor postcondition DAV:put-under-version-conrtrol of Section\n3.5.\n\nIs this the intended behavior?\n\nThanks,\nRoy\n\n\n\n", "id": "lists-006-15829063"}, {"subject": "Re: Copying DAV:comment on CHECKIN and VERSION-CONTRO", "content": "That sounds like a good process to me.\n\nOn DAV:comment, I think the common use case is for authors to use a\nnew comment most times they CHECKIN a new version, to document the\nchanges specific to that version.\n\nTo support this common case, I think the property list should say\nthat servers MUST copy DAV:comment from the checked-out resource to\nthe new version on CHECKIN. This allows clients to consolidate the\nPROPPATCH of DAV:comment with the PROPPATCH of any dead properties\nof the VCR (and other copied live properties) before CHECKIN, and\nmakes the behavior atomic. I also think the property list should\nsay that servers SHOULD NOT copy DAV:comment from the predecessor\nversion to the VCR on CHECKOUT, so that clients do not need to do a\nPROPPATCH to guarantee that DAV:comment was not incorrectly carried\nforward from the previous version.\n\nThanks,\nRoy\n\n\"Clemm, Geoff\" wrote:\n\n> Currently, the server gets to decide which live properties\n> of a VCR are captured by versions.\n>\n> It would be reasonable to identify a set of live\n> properties that SHOULD/MUST be captured by versions,\n> and publish this list in an internet draft and on\n> the DeltaV web site.  This list would then be added\n> to the protocol document when we go to the next standard level.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Roy Seto [mailto:Roy.Seto@oracle.com]\n> Sent: Thursday, November 01, 2001 8:50 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: Copying DAV:comment on CHECKIN and VERSION-CONTROL\n>\n> I don't see anything in the spec that requires DAV:comment\n> to be copied from checked-out resources to versions on\n> CHECKIN, or from unversioned resources to the initial\n> version on VERSION-CONTROL.\n>\n> In particular, since DAV:comment is a live property, it\n> doesn't get copied with the dead properties, and it is not\n> mentioned explicitly in postcondition\n> DAV:initialize-version-content-and-properties of Section 4.4\n> or postcondition DAV:put-under-version-conrtrol of Section\n> 3.5.\n>\n> Is this the intended behavior?\n>\n> Thanks,\n> Roy\n\n\n\n", "id": "lists-006-15838296"}, {"subject": "RE: Copying DAV:comment on CHECKIN and VERSION-CONTRO", "content": "Requiring that the value of DAV:comment of a checked-out\nresource be copied to the version created by CHECKIN sounds\nright to me (and I'll bet it's what all the implementors\nend up doing).  Note that some systems allow you to modify\nthe comment on a version, so we probably don't want to require\nthat it is immutable.  Note that CHECKOUT does not change the\nstate of a VCR, so a server would never copy anything at that\ntime.  Probably what you want here is for the DAV:comment\nproperty to be *removed* as a side-effect of the CHECKOUT\noperation.\n\nJust goes to show that it is a good thing we didn't try to\ndefine general behavior of live properties under versioning!\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Roy Seto [mailto:Roy.Seto@oracle.com]\nSent: Friday, November 02, 2001 6:51 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: Copying DAV:comment on CHECKIN and VERSION-CONTROL\n\n\nThat sounds like a good process to me.\n\nOn DAV:comment, I think the common use case is for authors to use a\nnew comment most times they CHECKIN a new version, to document the\nchanges specific to that version.\n\nTo support this common case, I think the property list should say\nthat servers MUST copy DAV:comment from the checked-out resource to\nthe new version on CHECKIN. This allows clients to consolidate the\nPROPPATCH of DAV:comment with the PROPPATCH of any dead properties\nof the VCR (and other copied live properties) before CHECKIN, and\nmakes the behavior atomic. I also think the property list should\nsay that servers SHOULD NOT copy DAV:comment from the predecessor\nversion to the VCR on CHECKOUT, so that clients do not need to do a\nPROPPATCH to guarantee that DAV:comment was not incorrectly carried\nforward from the previous version.\n\nThanks,\nRoy\n\n\"Clemm, Geoff\" wrote:\n\n> Currently, the server gets to decide which live properties\n> of a VCR are captured by versions.\n>\n> It would be reasonable to identify a set of live\n> properties that SHOULD/MUST be captured by versions,\n> and publish this list in an internet draft and on\n> the DeltaV web site.  This list would then be added\n> to the protocol document when we go to the next standard level.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Roy Seto [mailto:Roy.Seto@oracle.com]\n> Sent: Thursday, November 01, 2001 8:50 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: Copying DAV:comment on CHECKIN and VERSION-CONTROL\n>\n> I don't see anything in the spec that requires DAV:comment\n> to be copied from checked-out resources to versions on\n> CHECKIN, or from unversioned resources to the initial\n> version on VERSION-CONTROL.\n>\n> In particular, since DAV:comment is a live property, it\n> doesn't get copied with the dead properties, and it is not\n> mentioned explicitly in postcondition\n> DAV:initialize-version-content-and-properties of Section 4.4\n> or postcondition DAV:put-under-version-conrtrol of Section\n> 3.5.\n>\n> Is this the intended behavior?\n>\n> Thanks,\n> Roy\n\n\n\n", "id": "lists-006-15848023"}, {"subject": "Merge with activit", "content": "It seems to me that MERGE with activity should cause applying only\nlogical change captured by the activity to the merge target.\nBut I didn't find confirmation of this my assumption in the\nspecification. Moreover it was mentioned here (13.12 additional MERGE\nsemantic) that the latest version selected by this activity is a merge\nsource. So looks like merge with activity is equivalent to a sequence\nof merges with the last versions from the activity. And in this case\nthe role of activity as logical change is lost! It is not\npossible to apply only that changes which are identified by the\nactivity without any changes done in the intermediate versions between\ncommon ancestor and merge source. So it will no be possible for\nexample to apply bug fix from the development of new release project\n(development) to the current release support project\n(production) automatically.\nIf activity is really can be applied as logical change, then why it is\nnot described in the specification?\n\n\n\n", "id": "lists-006-15859193"}, {"subject": "RE: Merge with activit", "content": "   From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\n\n   It seems to me that MERGE with activity should cause applying only\n   logical change captured by the activity to the merge target.\n\nThat would be nice (and I really mean that, it would be nice), but\nthat concept is rarely implemented in practice (for various reasons,\nincluding the infeasibility of automatically applying a \"delta\" to\nmany of the document formats that are used nowadays), and therefore it\nwould not be conducive to interoperability if that were the required\nbehavior.\n\n   But I didn't find confirmation of this my assumption in the\n   specification. Moreover it was mentioned here (13.12 additional\n   MERGE semantic) that the latest version selected by this activity\n   is a merge source. So looks like merge with activity is equivalent\n   to a sequence of merges with the last versions from the\n   activity. And in this case the role of activity as logical change\n   is lost!\n\n\"Lost\" is probably too strong a phrase ... what you risk is the\n(unintentional) capture of changes from one or more other activities.\nAs an added-value service, a server could detect those cases, and\nreturn an error in cases where this unintentional capture would\ntake place.  Even this capability is not sufficiently uniformly\nprovided for us to require this functionality from a repository\nprovider.\n\n   It is not possible to apply only that changes which are identified\n   by the activity without any changes done in the intermediate\n   versions between common ancestor and merge source. So it will no be\n   possible for example to apply bug fix from the development of new\n   release project (development) to the current release support\n   project (production) automatically.  If activity is really can be\n   applied as logical change, then why it is not described in the\n   specification?\n\nIf there is sufficient support from repository implementors for this\nbehavior, then I agree it would be worth standardizing (we'd probably\ndefine a new type of \"source\" element, e.g. DAV:logical-change which\ntakes the URL of an activity as its value).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-15866919"}, {"subject": "Updated model availabl", "content": "I've updated the protocol model to correspond to version-20 of the protocol.\n\nhttp://www.webdav.org/deltav/model/wvcm-net/webdav.htm\n\nI'll be on vacation until 11/15, but will available for any model\nquestions when I return.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-15875817"}, {"subject": "RE: Removing a collection from baseline-control and deleting VCCs  et", "content": "Does moving of baseline-controlled-collection (not part of the\nbaseline-controlled-collection, but the whole collection) cause\nremoving it from baseline-control. Or collection is moved together\nwith it's baseline history?\n\n\n-- \nBest regards,\n Konstantin                          mailto:KKnizhnik@togetherlab.com\n\n\n\n", "id": "lists-006-15882438"}, {"subject": "RE: Removing a collection from baseline-control and deleting VCCs   et", "content": "No, a MOVE does not cause a BCC to be removed from baseline\ncontrol (a MOVE is required to maintain all the DeltaV live\nproperties).  A COPY/DELETE would though.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\n\nDoes moving of baseline-controlled-collection (not part of the\nbaseline-controlled-collection, but the whole collection) cause\nremoving it from baseline-control. Or collection is moved together\nwith it's baseline history?\n\n\n\n", "id": "lists-006-15890259"}, {"subject": "Storing propertie", "content": "Hi !\n\nI'd like to know how does a webdav server to store file properties.\nI undestrand that you put a/some propertie(s) with a PROPPATCH, and you get them with a PROPFIND, but WHERE are these properties on the server ?\nI'm actually working with an Apache server (withe mod_dav module), and I don't understand how does that works...\n\nThanx in advance.\n\n\n\n", "id": "lists-006-15897896"}, {"subject": "RE: Storing propertie", "content": "It doesn't really matter where they are as there is no way for clients and\nservers to interoperate on the semantics of the properties anyway. So unless\nyou're doing something custom on both the client and the server side, the\nproperties might as well not exist as far as the server is concerned.\n\n--Dylan\n  -----Original Message-----\n  From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Elodie Tasia\n  Sent: Thursday, November 29, 2001 9:12 AM\n  To: IETF DAV\n  Subject: Storing properties\n\n\n  Hi !\n\n  I'd like to know how does a webdav server to store file properties.\n  I undestrand that you put a/some propertie(s) with a PROPPATCH, and you\nget them with a PROPFIND, but WHERE are these properties on the server ?\n  I'm actually working with an Apache server (withe mod_dav module), and I\ndon't understand how does that works...\n\n  Thanx in advance.\n\n\n\n", "id": "lists-006-15904991"}, {"subject": "RE: Storing propertie", "content": "I think there was a misunderstanding. I understood the question as: \"where\ndoes mod_dav actually\nstore the properities?\". Last time I looked, mod_dav stored them in\nfiles/directories starting with '.'\non the file system. If you have a UNIX shell on the server, just type\n'ls -a' and you will see...\n\nBest Regards, Stefan\n  -----Original Message-----\n  From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Dylan Barrell\n  Sent: Thursday, November 29, 2001 4:10 PM\n  To: Elodie Tasia; IETF DAV\n  Subject: RE: Storing properties\n\n\n  It doesn't really matter where they are as there is no way for clients and\nservers to interoperate on the semantics of the properties anyway. So unless\nyou're doing something custom on both the client and the server side, the\nproperties might as well not exist as far as the server is concerned.\n\n  --Dylan\n    -----Original Message-----\n    From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Elodie Tasia\n    Sent: Thursday, November 29, 2001 9:12 AM\n    To: IETF DAV\n    Subject: Storing properties\n\n\n    Hi !\n\n    I'd like to know how does a webdav server to store file properties.\n    I undestrand that you put a/some propertie(s) with a PROPPATCH, and you\nget them with a PROPFIND, but WHERE are these properties on the server ?\n    I'm actually working with an Apache server (withe mod_dav module), and I\ndon't understand how does that works...\n\n    Thanx in advance.\n\n\n\n", "id": "lists-006-15913737"}, {"subject": "version resource and lockin", "content": "Hello,\n\nThe Delta-V standard introduces the resource type \"version resource\". Would\nyou expect the webdav (un)lock command to work on a \"version resource\" too.\nA server may implement the delete method on a \"version resource\".\n\nAm I correct with the assumption, that (un)lock should work on a \"version\nhistory resource\" and a \"version controlled resource\" too.\n\nBest regards\n\nJuergen Pill\n\n\n\n", "id": "lists-006-15923344"}, {"subject": "VR / VHR and check in/ou", "content": "Hello,\n\nThe Delta-V standard introduces the resource type \"version resource\" (VR)\nand \"version history resource\" (VHR). \n\nAm I correct with the assumption, that the (un)check in/out methods should\nNOT work on a \"version history resource\" and a \"version resource\" ?\n\nThe only resource type, that can be checked out/in is a \"version controlled\nresource\" (VCR).\n\nBest regards\n\nJuergen Pill\n\n\n\n", "id": "lists-006-15931327"}, {"subject": "RE: version resource and lockin", "content": "The primary use cases requiring lock/unlock are for version-controlled\nresources.\n\nA server certainly could also support locking on a version resource,\nbut since a version resource is largely immutable (except for its\nlive properties, where whether or not they are immutable depends\non the characteristics of that live property), servers may not\nbother with supporting locks on them (unless they get that functionality\nfor free from their underlying implementation).\n\nJust for interests sake, did you have a client scenario in which\nversion locking was  interesting?\n\nSimilarly, it is unlikely that a \"lock\" on a version history resource\nwill be of much interest to a client, and servers may not support it.\n\nNote though that unlike LOCKing, which is only really interesting on\nversion-controlled resources, ACLs support is interesting and worthwhile\non all resource types, including versions (to control \"delete\" behavior)\nand version histories (to control who can add versions to that version\nhistory)\n\nCheers,\nGeoff\n\n\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Pill, Juergen [mailto:Juergen.Pill@softwareag.com]\nSent: Wednesday, December 05, 2001 7:45 AM\nTo: 'ietf-dav-versioning@w3.org'\nSubject: version resource and locking\n\n\nHello,\n\nThe Delta-V standard introduces the resource type \"version resource\". Would\nyou expect the webdav (un)lock command to work on a \"version resource\" too.\nA server may implement the delete method on a \"version resource\".\n\nAm I correct with the assumption, that (un)lock should work on a \"version\nhistory resource\" and a \"version controlled resource\" too.\n\nBest regards\n\nJuergen Pill\n\n\n\n", "id": "lists-006-15939160"}, {"subject": "RE: VR / VHR and check in/ou", "content": "It is correct that checkout/checkin should not work on version\nhistory resources.\n\nIf the server supports the working resource feature, then checkout\nwould work against a version resource (but checkin still would not).\nCheckout of a version creates a working resource, and a working\nresource supports the checkin operation (but not the checkout operation).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Pill, Juergen [mailto:Juergen.Pill@softwareag.com]\nSent: Wednesday, December 05, 2001 7:48 AM\nTo: 'ietf-dav-versioning@w3.org'\nSubject: VR / VHR and check in/out\n\n\nHello,\n\nThe Delta-V standard introduces the resource type \"version resource\" (VR)\nand \"version history resource\" (VHR). \n\nAm I correct with the assumption, that the (un)check in/out methods should\nNOT work on a \"version history resource\" and a \"version resource\" ?\n\nThe only resource type, that can be checked out/in is a \"version controlled\nresource\" (VCR).\n\nBest regards\n\nJuergen Pill\n\n\n\n", "id": "lists-006-15948666"}, {"subject": "RE: version resource and lockin", "content": "Hello Geoff,\n\nthanks for your answer. \n\nI mostly work on a WebDAV server implementation (Jakarta Slide) and\ncurrently I am preparing a method/resource compatibility matrix. If you are\ninterested, I can post it soon.\n\nBest regards\n\nJuergen\n\nPS. I want to start working on the client side too starting next year.\n(http://www.jcp.org/jsr/detail/147.jsp).\n\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: Mittwoch, 5. Dezember 2001 15:01\nTo: 'ietf-dav-versioning@w3.org'\nSubject: RE: version resource and locking\n\n\nThe primary use cases requiring lock/unlock are for version-controlled\nresources.\n\nA server certainly could also support locking on a version resource,\nbut since a version resource is largely immutable (except for its\nlive properties, where whether or not they are immutable depends\non the characteristics of that live property), servers may not\nbother with supporting locks on them (unless they get that functionality\nfor free from their underlying implementation).\n\nJust for interests sake, did you have a client scenario in which\nversion locking was  interesting?\n\nSimilarly, it is unlikely that a \"lock\" on a version history resource\nwill be of much interest to a client, and servers may not support it.\n\nNote though that unlike LOCKing, which is only really interesting on\nversion-controlled resources, ACLs support is interesting and worthwhile\non all resource types, including versions (to control \"delete\" behavior)\nand version histories (to control who can add versions to that version\nhistory)\n\nCheers,\nGeoff\n\n\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Pill, Juergen [mailto:Juergen.Pill@softwareag.com]\nSent: Wednesday, December 05, 2001 7:45 AM\nTo: 'ietf-dav-versioning@w3.org'\nSubject: version resource and locking\n\n\nHello,\n\nThe Delta-V standard introduces the resource type \"version resource\". Would\nyou expect the webdav (un)lock command to work on a \"version resource\" too.\nA server may implement the delete method on a \"version resource\".\n\nAm I correct with the assumption, that (un)lock should work on a \"version\nhistory resource\" and a \"version controlled resource\" too.\n\nBest regards\n\nJuergen Pill\n\n\n\n", "id": "lists-006-15957484"}, {"subject": "RE: VR / VHR and check in/ou", "content": "Thanks a lot, added to the compatibility table.\n\nBest regards\n\nJuergen\n\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: Mittwoch, 5. Dezember 2001 15:01\nTo: 'ietf-dav-versioning@w3.org'\nSubject: RE: VR / VHR and check in/out\n\n\nIt is correct that checkout/checkin should not work on version\nhistory resources.\n\nIf the server supports the working resource feature, then checkout\nwould work against a version resource (but checkin still would not).\nCheckout of a version creates a working resource, and a working\nresource supports the checkin operation (but not the checkout operation).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Pill, Juergen [mailto:Juergen.Pill@softwareag.com]\nSent: Wednesday, December 05, 2001 7:48 AM\nTo: 'ietf-dav-versioning@w3.org'\nSubject: VR / VHR and check in/out\n\n\nHello,\n\nThe Delta-V standard introduces the resource type \"version resource\" (VR)\nand \"version history resource\" (VHR). \n\nAm I correct with the assumption, that the (un)check in/out methods should\nNOT work on a \"version history resource\" and a \"version resource\" ?\n\nThe only resource type, that can be checked out/in is a \"version controlled\nresource\" (VCR).\n\nBest regards\n\nJuergen Pill\n\n\n\n", "id": "lists-006-15968525"}, {"subject": "RE: version resource and lockin", "content": "Yes, please do post the method/resource compatibility matrix.\nAnd that's great to hear that you'll be working on a client!\nDid your reference to jsr-147 indicate that you hope to use\nthat as your client API?  If so, that's great to hear as well!\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Pill, Juergen [mailto:Juergen.Pill@softwareag.com]\nSent: Wednesday, December 05, 2001 10:46 AM\nTo: 'Clemm, Geoff'; 'ietf-dav-versioning@w3.org'\nSubject: RE: version resource and locking\n\n\nHello Geoff,\n\nthanks for your answer. \n\nI mostly work on a WebDAV server implementation (Jakarta Slide) and\ncurrently I am preparing a method/resource compatibility matrix. If you are\ninterested, I can post it soon.\n\nBest regards\n\nJuergen\n\nPS. I want to start working on the client side too starting next year.\n(http://www.jcp.org/jsr/detail/147.jsp).\n\n\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com]\nSent: Mittwoch, 5. Dezember 2001 15:01\nTo: 'ietf-dav-versioning@w3.org'\nSubject: RE: version resource and locking\n\n\nThe primary use cases requiring lock/unlock are for version-controlled\nresources.\n\nA server certainly could also support locking on a version resource,\nbut since a version resource is largely immutable (except for its\nlive properties, where whether or not they are immutable depends\non the characteristics of that live property), servers may not\nbother with supporting locks on them (unless they get that functionality\nfor free from their underlying implementation).\n\nJust for interests sake, did you have a client scenario in which\nversion locking was  interesting?\n\nSimilarly, it is unlikely that a \"lock\" on a version history resource\nwill be of much interest to a client, and servers may not support it.\n\nNote though that unlike LOCKing, which is only really interesting on\nversion-controlled resources, ACLs support is interesting and worthwhile\non all resource types, including versions (to control \"delete\" behavior)\nand version histories (to control who can add versions to that version\nhistory)\n\nCheers,\nGeoff\n\n\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Pill, Juergen [mailto:Juergen.Pill@softwareag.com]\nSent: Wednesday, December 05, 2001 7:45 AM\nTo: 'ietf-dav-versioning@w3.org'\nSubject: version resource and locking\n\n\nHello,\n\nThe Delta-V standard introduces the resource type \"version resource\". Would\nyou expect the webdav (un)lock command to work on a \"version resource\" too.\nA server may implement the delete method on a \"version resource\".\n\nAm I correct with the assumption, that (un)lock should work on a \"version\nhistory resource\" and a \"version controlled resource\" too.\n\nBest regards\n\nJuergen Pill\n\n\n\n", "id": "lists-006-15978319"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "I disagree that version history should be deleted if you delete the version\ncontrolled resource. Section 5 of the draft clearly states the version\nhistory resource exists in a server defined namespace and therefore is\nunaffected by any deletion or movement of a version controlled resource.\n\nIf you require the version history to be deleted you will cause serious\nproblems for a server that supports the workspace and working resource\nfeature.\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Tuesday, June 12, 2001 3:52 PM\nTo: 'Clemm, Geoff'; 'DeltaV'\nSubject: RE: Confusion: Removing a resource from version control \n\n\nIntro about me at bottom.\n\n\"In order to remove a resource at a given URL from version control, the\nclient can replace the resource under version control with a\nnon-version-controlled copy of that resource.  For example, a client can\nCOPY the version-controlled resource to a temporary location, DELETE the\nversion-controlled resource, and then MOVE the copy from the temporary\nlocation back to the original URL.  Note that the versions already\ncreated for the version-controlled resource will continue to exist at\ntheir server-defined locations.\"\n\nIs that clearer?\n\nCheers,\nGeoff\n\n=================================================================\n\nWhen you DELETE a version-controlled resource, I strongly believe that\nall information for that VCR and all versions already created should go\nto the great bit bucket in the sky.\n\nAs I understand your formulation, I would have severe problems in\nmodifying my DAV server (with versioning support) to support DELTAV\nusing this behavior.  \n\nI would prefer this formulation / behavior:\n\n\"In order to remove a resource at a given URL from version control, the\nclient can replace the resource under version control with a\nnon-version-controlled copy of that resource.  For example, a client can\nCOPY the version-controlled resource to a temporary location, DELETE the\nversion-controlled resource, and then MOVE the copy from the temporary\nlocation back to the original URL.  Note that the versions already\ncreated for the version-controlled resource will NO LONGER BE AVAILABLE.\nIf you wish to remove a resource at a given URL from version control\nwhile also retaining a previous revision history, then you should MOVE\nthe resource to a new save location and COPY the current version back to\nthe original URL.\"\n\n==========\n\nMy formulation is based explicitly on the idea that some implementations\nand some customers are not keeping track of legal documents and\ntherefore deleting old versions is highly desired if not required.  A\nserver shouldn't be forced to keep data that a client is willing to\nspecifically state that it doesn't want.\n\nI think a far better manner of achieving your goals is simply to allow\nthe VERSION-CONTROL method to turn version-control for a resource at a\ngiven URL off (if supported by the server).  That allows you to achieve\nyour above objectives (no new versions, but keep the old ones at the\nsame URLs) without changing the usefulness of the DELETE command.\n\n======================================================\n\nJohn Hall is an engineer working on the Xythos development team to\nmodify their DAV (with revision additions) server to support DELTAV as\nwell as other-party proprietary DAV versioning systems.\n\n\n\n", "id": "lists-006-1598500"}, {"subject": "XML elements in a respons", "content": "I've seen in this document : http://www.ietf.org/rfc/rfc2518.txt some exemples of DAV request and responses.\nBut there are still some things I'm not sure about...\n\nWhen you see that :\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <multistatus xmlns=\"DAV:\">\n     <response>\n         <href>http://www.foo.bar/container/</href>\n          <propstat>\n               <prop xmlns:R=\"http://www.foo.bar/boxschema/\">\n                    <R:bigbox/>\n                    <R:author/>\n                    <creationdate/>\n                    <displayname/>\n                    <resourcetype/>\n                    <supportedlock/>\n               </prop>\n              <status>HTTP/1.1 200 OK</status>\n          </propstat>\n    </response>\n\nWhat does \"multistatus\" mean ?\nThe line xmlns=\"DAV:\" means that DAV is the default namespace ?\nAnd since xmlns:R=... defines the URL of the resource, is R:bigbox a live property ?\n\nThanx in advance\n\n\n\n", "id": "lists-006-15989684"}, {"subject": "RE: XML elements in a respons", "content": "\"multistatus\" in the DAV: namespace is the top level XML node in the\nresponse body to PROPFIND (and various other methods).  It just groups the\n\"propstat\" elements, in case there are more than one resources affected by\nthe request).\n \nYes, the xmlns=\"DAV:\" makes \"DAV:\" the default namespace for the multistatus\nnode and its children.\n \nAnd no, the fact that there is a namespace declaration for the\nhttp://www.foo.bar/boxschema/ <http://www.foo.bar/boxschema/>  does not make\nit a live property.  The DeltaV extension to WebDAV defines a\n\"supported-live-property\" report, which tells you which properties are live.\nSeveral of us planning on making sure this report gets \"promoted\" into the\nnext rev of the WebDAV protocol.\n \nCheers,\nGeof\n \n \n\n-----Original Message-----\nFrom: Elodie Tasia [mailto:e.tasia@ever-team.com]\nSent: Thursday, December 06, 2001 4:36 AM\nTo: IETF DAV\nSubject: XML elements in a response\n\n\n\nI've seen in this document : http://www.ietf.org/rfc/rfc2518.txt\n<http://www.ietf.org/rfc/rfc2518.txt>  some exemples of DAV request and\nresponses.\nBut there are still some things I'm not sure about...\n \nWhen you see that :\n \n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <multistatus xmlns=\"DAV:\">\n     <response>\n         <href>http://www.foo.bar/container/</href>\n          <propstat>\n               <prop xmlns:R=\"http://www.foo.bar/boxschema/\">\n                    <R:bigbox/>\n                    <R:author/>\n                    <creationdate/>\n                    <displayname/>\n                    <resourcetype/>\n                    <supportedlock/>\n               </prop>\n              <status>HTTP/1.1 200 OK</status>\n          </propstat>\n    </response>\n \nWhat does \"multistatus\" mean ?\nThe line xmlns=\"DAV:\" means that DAV is the default namespace ?\nAnd since xmlns:R=... defines the URL of the resource, is R:bigbox a live\nproperty ?\n \nThanx in advance\n\n\n\n", "id": "lists-006-15997856"}, {"subject": "RE: XML elements in a respons", "content": "The URL of the resource is not \"http://www.foo.bar/boxschema/\" -- that's a\nnamespace for two of the properties.  Although namespaces can look like\nURLs, there may or may not be a document at the URL.  You can think of it as\na string of unique characters, no different than \"DAV:\", even though it\nlooks different.\n\nThe URL of the resource is in fact \"http://www.foo.bar/container/\".  The URL\nof the resource always appears in the <href></href> tags inside multistatus\nbodies.\n\nI think Geoff answered your other questions...\n\nLisa\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Elodie Tasia\nSent: Thursday, December 06, 2001 1:36 AM\nTo: IETF DAV\nSubject: XML elements in a response\n\n\nI've seen in this document : http://www.ietf.org/rfc/rfc2518.txt some\nexemples of DAV request and responses.\nBut there are still some things I'm not sure about...\n\nWhen you see that :\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <multistatus xmlns=\"DAV:\">\n     <response>\n         <href>http://www.foo.bar/container/</href>\n          <propstat>\n               <prop xmlns:R=\"http://www.foo.bar/boxschema/\">\n                    <R:bigbox/>\n                    <R:author/>\n                    <creationdate/>\n                    <displayname/>\n                    <resourcetype/>\n                    <supportedlock/>\n               </prop>\n              <status>HTTP/1.1 200 OK</status>\n          </propstat>\n    </response>\n\nWhat does \"multistatus\" mean ?\nThe line xmlns=\"DAV:\" means that DAV is the default namespace ?\nAnd since xmlns:R=... defines the URL of the resource, is R:bigbox a live\nproperty ?\n\nThanx in advance\n\n\n\n", "id": "lists-006-16007496"}, {"subject": "[daniel.kirmse&#64;sap.com: WebDAV/DeltaV: GET on Version Tree", "content": "This question is best directed to the DeltaV group for answering...\n\n----- Forwarded message from \"Kirmse, Daniel\" <daniel.kirmse@sap.com> -----\n\nFrom: \"Kirmse, Daniel\" <daniel.kirmse@sap.com>\nSubject: WebDAV/DeltaV: GET on Version Tree\nTo: \"'gstein@lyra.org'\" <gstein@lyra.org>\nDate: Mon, 10 Dec 2001 12:51:46 +0100\n\nHi Greg,\n\nI've a few problems not handled in the WebDAV-FAQ of webdav.org:\n\n1.Suppose you have a resource A.file with a version tree as follows:\n\n         A.file,1\n|\n   A.file,2\n/\\\n           /  \\\n          /    \\\n         /      \\\n  A.file,2.1   A.file,2.2\n ||\n A.file,2.1.1  A.file,2.2.1\n\nwhere the version number does not necessarily express the sequence of\ncreation of the versions. All versions are checked in.\n\nSuppose a client sends a GET A.file Request. Which version of A.file must be\nsent as response, A.file,2.1.1 or A.file,2.2.1?\n\n\n2.I'd like to use server workspace for emulating a development (DEV) and a\nconsolidation (CONS) source tree of a single source tree. \nSuppose I have a source tree. \n\n\"/\" (root)\n/\n     src\n           / \\\n          /   \\\n         a.c  b.c\n\nWhere a.c and b.c are version-controlled resources. In the beginning of my\ndevelopment I create a workspace DEV to contain all resources of a certain\ndevelopment.\n\n\"/\" (root)\n/        \\\n           /          \\\n          src         DEV\n          / \\          |\n         /   \\         |\n        a.c  b.c      src\n                      / \\\n                     /   \\\n                   a.c  b.c\n\nFiles a.c and b.c are part of the worksapce and after some time there are\nversion 4 of a.c and version 3 of b.c are candidates for delivery. So I set\nup a new workspace emulating my consolidation source tree (CONS) as a copy\nof the DEV workspace, copying the latest version of a.c and b.c to it. (Is\nit allowed so far?) In my oppinion now a checkin of a.c in DEV and in CONS\nwould produce a branch in the source tree of a.c (right?).\nNow suppose a user with a user worksapce /usr/dan who has to fix a bug in\na.c both in DEV and CONS. I think it is not allowed to have to versons of\na.c in the same workspace (right?), so user dan has to set up two workspace\nto get this done (right?). \nFinally the question is: Is it possible for user dan to copy /DEV/a.c into\nhis workspace or MUST he copy /src/a.c into his workspace? Or the other way\naround: Is it possible to have a workspace as a source of resources for\nanother workspace?\n\n\nMany thanks in advance,\nDaniel Kirmse\n\n----- End forwarded message -----\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-16017137"}, {"subject": "GET on version tree/Workspace", "content": "Hi,\n\nI've a few problems not handled in the WebDAV-FAQ of webdav.org:\n\n1.Suppose you have a resource A.file with a version tree as follows:\n\n         A.file,1\n|\n   A.file,2\n/\\\n           /  \\\n          /    \\\n         /      \\\n  A.file,2.1   A.file,2.2\n ||\n A.file,2.1.1  A.file,2.2.1\n\nwhere the version number does not necessarily express the sequence of\ncreation of the versions. All versions are checked in.\n\nSuppose a client sends a GET A.file Request. Which version of A.file must be\nsent as response, A.file,2.1.1 or A.file,2.2.1?\n\n\n2.I'd like to use server workspace for emulating a development (DEV) and a\nconsolidation (CONS) source tree of a single source tree. \nSuppose I have a source tree. \n\n\"/\" (root)\n/\n     src\n           / \\\n          /   \\\n         a.c  b.c\n\nWhere a.c and b.c are version-controlled resources. In the beginning of my\ndevelopment I create a workspace DEV to contain all resources of a certain\ndevelopment.\n\n\"/\" (root)\n/        \\\n           /          \\\n          src         DEV\n          / \\          |\n         /   \\         |\n        a.c  b.c      src\n                      / \\\n                     /   \\\n                   a.c  b.c\n\nFiles a.c and b.c are part of the worksapce and after some time there are\nversion 4 of a.c and version 3 of b.c are candidates for delivery. So I set\nup a new workspace emulating my consolidation source tree (CONS) as a copy\nof the DEV workspace, copying the latest version of a.c and b.c to it. (Is\nit allowed so far?) In my oppinion now a checkin of a.c in DEV and in CONS\nwould produce a branch in the source tree of a.c (right?).\nNow suppose a user with a user worksapce /usr/dan who has to fix a bug in\na.c both in DEV and CONS. I think it is not allowed to have to versons of\na.c in the same workspace (right?), so user dan has to set up two workspace\nto get this done (right?). \nFinally the question is: Is it possible for user dan to copy /DEV/a.c into\nhis workspace or MUST he copy /src/a.c into his workspace? Or the other way\naround: Is it possible to have a workspace as a source of resources for\nanother workspace?\n\n\nMany thanks in advance,\nDaniel Kirmse\n\n\n\n", "id": "lists-006-16028284"}, {"subject": "Workspaces and File&amp;Folder Hierarch", "content": "Hi,\n\nis it allowed to have a Workspace containing a File&Folder Hierarchy (i.e. a\ncopy of a subtree of the webdav resource tree) ?\n\nThnx,\nDaniel\n\n\n\n", "id": "lists-006-16037407"}, {"subject": "Re: [daniel.kirmse&#64;sap.com: WebDAV/DeltaV: GET on Version Tree", "content": "On Mon, Dec 10, 2001 at 04:29:49AM -0800, Greg Stein wrote:\n> This question is best directed to the DeltaV group for answering...\n\nWow, Greg did not instantly answer himself! Greg must be slipping! :-)\n(I remember well the many instant and informed responses Greg replied\nwith when I started asking questions.)\n\n> I've a few problems not handled in the WebDAV-FAQ of webdav.org:\n> \n> 1.Suppose you have a resource A.file with a version tree as follows:\n> \n>            A.file,1\n>               |\n>            A.file,2\n>               /\\\n>              /  \\\n>             /    \\\n>            /      \\\n>     A.file,2.1   A.file,2.2\n>          |              |\n>    A.file,2.1.1  A.file,2.2.1\n> \n> where the version number does not necessarily express the sequence of\n> creation of the versions. All versions are checked in.\n> \n> Suppose a client sends a GET A.file Request. Which version of A.file must be\n> sent as response, A.file,2.1.1 or A.file,2.2.1?\n\nMy understanding is you do not do a GET on A.file. You do a GET on\na URL. The URL must be bound to a particular version by the server.\nSo you get whatever version the URL has been bound to. There are DeltaV\ncommands for changing the version a URL is bound to.\n\n> 2.I'd like to use server workspace for emulating a development (DEV) and a\n> consolidation (CONS) source tree of a single source tree. \n> Suppose I have a source tree. \n> \n> \"/\" (root)\n> /\n>      src\n>            / \\\n>           /   \\\n>          a.c  b.c\n> \n> Where a.c and b.c are version-controlled resources. In the beginning of my\n> development I create a workspace DEV to contain all resources of a certain\n> development.\n> \n> \"/\" (root)\n> /        \\\n>            /          \\\n>           src         DEV\n>           / \\          |\n>          /   \\         |\n>         a.c  b.c      src\n>                       / \\\n>                      /   \\\n>                    a.c  b.c\n> \n> Files a.c and b.c are part of the worksapce and after some time there are\n> version 4 of a.c and version 3 of b.c are candidates for delivery. So I set\n> up a new workspace emulating my consolidation source tree (CONS) as a copy\n> of the DEV workspace, copying the latest version of a.c and b.c to it. (Is\n> it allowed so far?)\n\nSounds OK to me...\n\n> In my oppinion now a checkin of a.c in DEV and in CONS\n> would produce a branch in the source tree of a.c (right?).\n\nI think that is partially up to the implementation as to what the DetaV\nserver did. But it would be reasonable behaviour.\n\n> Now suppose a user with a user worksapce /usr/dan who has to fix a bug in\n> a.c both in DEV and CONS. I think it is not allowed to have to versons of\n> a.c in the same workspace (right?), so user dan has to set up two workspace\n> to get this done (right?). \n\nI think that is correct - or use the UPDATE command (I think it is\nfrom memory) to change the version a URL points at. But creating two\nworkspaces seems reasonable.\n\n> Finally the question is: Is it possible for user dan to copy /DEV/a.c into\n> his workspace or MUST he copy /src/a.c into his workspace? Or the other way\n> around: Is it possible to have a workspace as a source of resources for\n> another workspace?\n\nYou can certainly do a copy from one workspace to another.\nThere is no requirement for /src/a.c and /src/b.c to exist.\nIn our planned DeltaV implementation (ok, so its been planned\nfor a while now! :-) we would not have /src/a.c ever existing.\nWe plan to start with users creating workspaces and then adding\nfiles under there. Each user will get a home directory to use,\nand then we will let them create whatever directory structure\nthey like under that, including workspaces. The structure under\nthe workspace will then be version controlled (and so be the same\nbetween users - unless users change the directory structure\n(which is also versioned)).\n\n\nI hope the above helps (and is correct :-).\n\nAlan\n\n\n\n", "id": "lists-006-16045303"}, {"subject": "Re: Workspaces and File&amp;Folder Hierarch", "content": "On Mon, Dec 10, 2001 at 04:36:03PM +0100, Kirmse, Daniel wrote:\n> Hi,\n> \n> is it allowed to have a Workspace containing a File&Folder Hierarchy (i.e. a\n> copy of a subtree of the webdav resource tree) ?\n> \n> Thnx,\n> Daniel\n\nYes. I think a really nice thing about DeltaV is that it allows\nversioning of containers (directories). Its not mandatory, but\ncertainly is supported. I would suggest having a bit of a read.\n\nTo me the only special thing about a workspace is that it imposes\nadditional constraints on that you are only allowed to check out\none version of a resource under it. (Note, you could have multiple\nbindings of URLS to the same resource, but they would be the same\nversion of that resource).\n\nAlan\n\n\n\n", "id": "lists-006-16057008"}, {"subject": "RE: Creating new version-controlled bindings referencing existing  VHR'", "content": "I faced with the problem of placing existed version controlled\ncollection (with all members) in my workspace. Section 6.7 (Additional\nversion control semantic) says that VERSION-CONTROL method\n<DAV:version> element in body should be used in this case. But\n<DAV:version> elements specifies only version of the root collection\nto be placed in my workspace. And how can I determine versions of\nmembers of this collections? Version controlled collection contains\njust bindings to version histories of its members. It is not possible\nto select particular version from the version history without\nknowledge about workspace from which take this subtree. But workspace\nis not specified in VERSION-CONTROL method and there is no way to get\nit.\n  \nSo, in few words, I do not understand how to do the following\noperation:\n- I have some project (version-controlled-collection) in some workspace (for example /ws/his/project1)\n- I want to place this project (copy all its resources) in my workspace /ws/my\nHow it can be done?\n\n\n-- \nBest regards,\n Konstantin                          mailto:KKnizhnik@togetherlab.com\n\n\n\n", "id": "lists-006-16064983"}, {"subject": "RE: Workspaces and File&amp;Folder Hierarch", "content": "   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n\n   On Mon, Dec 10, 2001 at 04:36:03PM +0100, Kirmse, Daniel wrote:\n\n   > is it allowed to have a Workspace containing a File&Folder\n   > Hierarchy (i.e. a copy of a subtree of the webdav resource tree)?\n\n   Yes. I think a really nice thing about DeltaV is that it allows\n   versioning of containers (directories). Its not mandatory, but\n   certainly is supported. I would suggest having a bit of a read.\n\n   To me the only special thing about a workspace is that it imposes\n   additional constraints on that you are only allowed to check out\n   one version of a resource under it. (Note, you could have multiple\n   bindings of URLS to the same resource, but they would be the same\n   version of that resource).\n\nYes, as Alan says, a Workspace can have a File/Folder (WebDAV would\ncall it a Resource/Collection) hierarchy below it (a Workspace is\njust a special kind of collection).\n\nAnother special thing about a Workspace is that you can\nassociate a \"current-activity\" with that workspace, to simplify\nactivity-based checkouts.  Also, you have an easy way to identify\nall checkouts in a workspace (without doing a depth propfind),\nand you can tell whether a resource is a member of a workspace by\nlooking at its DAV:workspace property.\n\nBut I agree with Alan that the most important thing about a workspace\nis that it has at most one versioned-controlled resource for a given\nversion history.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-16073567"}, {"subject": "RE: [daniel.kirmse&#64;sap.com: WebDAV/DeltaV: GET on Version Tree", "content": "   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n\n   > From: Kirmse, Daniel [mailto:daniel.kirmse@sap.com]\n   > \n   > 1.Suppose you have a resource A.file with a version tree as follows:\n   > \n   >            A.file,1\n   >               |\n   >            A.file,2\n   >               /\\\n   >              /  \\\n   >             /    \\\n   >            /      \\\n   >     A.file,2.1   A.file,2.2\n   >          |              |\n   >    A.file,2.1.1  A.file,2.2.1\n   > \n\n   > where the version number does not necessarily express the\n   > sequence of creation of the versions. All versions are checked\n   > in.\n   > Suppose a client sends a GET A.file Request. Which version of\n   > A.file must be sent as response, A.file,2.1.1 or A.file,2.2.1?\n\n   My understanding is you do not do a GET on A.file. You do a GET on\n   a URL. The URL must be bound to a particular version by the server.\n   So you get whatever version the URL has been bound to. There are DeltaV\n   commands for changing the version a URL is bound to.\n\nI think Daniel just was using A.file as a shorthand for the URL that\nidentifies a version controlled resource (\"VCR\") whose version history\nis as described.  \n\nA GET on A.file will just return the content of A.file.  If A.file\nis checked in, then this content is required to be the same as\nthe content of the version identified by the DAV:checked-in property\nof A.file.  If A.file is checked out, then there may be no version\nthat has the same content as A.file.\n\n(Note: I'd avoid the term \"bound\" when talking about the relationship\nbetween a VCR and a version, since this might lead someone to infer\nthat the VCR is somehow a \"pointer\" to that version.)\n\n   > 2.I'd like to use server workspace for emulating a development (DEV)\nand a\n   > consolidation (CONS) source tree of a single source tree. \n   > Suppose I have a source tree. \n   > \n   > \"/\" (root)\n   > /\n   >      src\n   >            / \\\n   >           /   \\\n   >          a.c  b.c\n   > \n   > Where a.c and b.c are version-controlled resources.\n\nDoes \"/\" identify a workspace?  Or are /src, /src/a.c,\nand /src/b.c \"free-floating\" VCR's that are not in any workspace?\n(Commonly, a system that supports workspaces will have all VCR's\nappear in some workspace, but that is not required by the DeltaV\nprotocol).\n\n   > In the beginning of my development I create a workspace DEV to\n   > contain all resources of a certain development.\n   > \n   > \"/\" (root)\n   > /        \\\n   >            /          \\\n   >           src         DEV\n   >           / \\          |\n   >          /   \\         |\n   >         a.c  b.c      src\n   >                       / \\\n   >                      /   \\\n   >                    a.c  b.c\n\nNote that if \"/\" is a workspace, then you have the \"/DEV\" workspace\nnested inside the \"/\" worspace.  Many server implementations will not\nallow you to nest workspaces, but it is certainly allowed by the\nDeltaV spec.  Note that /DEV/src/a.c is in the /DEV workspace but\nis not in the \"/\" workspace, since a VCR can only be in one workspace.\n\n   > Files a.c and b.c are part of the worksapce and after some time\n   > there are version 4 of a.c and version 3 of b.c are candidates\n   > for delivery. So I set up a new workspace emulating my\n   > consolidation source tree (CONS) as a copy of the DEV workspace,\n   > copying the latest version of a.c and b.c to it. (Is it allowed\n   > so far?)\n\n   Sounds OK to me...\n\nWell, you need to be a bit careful about terminology.  If you use a\nWebDAV COPY to copy your DEV workspace to another workspace, you will\njust get a tree of non-version-controlled resources at the destination\nof the copy.  This is probably not what you want to do, because you\ncan't do merges or any other interesting versioning operation on these\nnon-version-controlled resources.  You probably want to use\nVERSION-CONTROL or BASELINE-CONTROL to create version-controlled\nresources in CONS corresponding to your version-controlled resources\nin DEV.  Note though that Dan's client might present this as a\n\"copy\" operation, even though under the hood, the client is issuing\na BASELINE-CONTROL request, or a sequence of VERSION-CONTROL requests.\n\n   > In my oppinion now a checkin of a.c in DEV and in CONS\n   > would produce a branch in the source tree of a.c (right?).\n\nIf you have a version-controlled resource in both DEV and CONS for the\nversion history of a.c, and they both identify the same version in\ntheir DAV:checked-in property, then it is true that if you issue a\nCHECKOUT/CHECKIN sequence against both VCRs, then you will create a\nfork in the source tree.\n\n   I think that is partially up to the implementation as to what the DetaV\n   server did. But it would be reasonable behaviour.\n\nIf you CHECKOUT/CHECKIN two VCRs that originally had the same version\nin their DAV:checked-in property, then your server would have to\ncreate a fork in the version history for that version.\n\n   > Now suppose a user with a user worksapce /usr/dan who has to fix\n   > a bug in a.c both in DEV and CONS. I think it is not allowed to\n   > have to versons of a.c in the same workspace (right?), so user\n   > dan has to set up two workspace to get this done (right?).\n\n   I think that is correct - or use the UPDATE command (I think it is\n   from memory) to change the version a URL points at. But creating two\n   workspaces seems reasonable.\n\nI'm not sure what you mean by \"set up two workspaces\".  You already\nhave two workspaces (DEV and CONS), so you would make a change in DEV\nif you wanted to change DEV and in CONS if you wanted to change CON.\nOr are you using DEV and CONS to now mean a \"line of descent\" (which \nin DeltaV we model as an \"activity\"), rather than a \"workspace\"?\nIt's important to be unambiguous here, since activities and\nworkspaces have different behaviors.\n\nBut as Alan says, you can make a change (create a new version) in DEV \nfor a.c, and then just update the VCR for a.c in CONS to see this\nnew version, if you want to have the bug fixed the same way in both\nworkspaces.\n\n   > Finally the question is: Is it possible for user dan to copy\n   > /DEV/a.c into his workspace or MUST he copy /src/a.c into his\n   > workspace? Or the other way around: Is it possible to have a\n   > workspace as a source of resources for another workspace?\n\nAs above, as long as Dan's client is converting Dan's \"copy\"\nrequest into the appropriate VERSION-CONTROL request, it doesn't\nmatter whether he \"copies\" from /src/a.c or /DEV/src/a.c \n(assuming both these VCRs identify the same version as their\nDAV:checked-in property).  In particular, the way Dan's client\nwill do the \"copy\" is to get the DAV:checked-in version from\nthe source of the copy, and then issue a VERSION-CONTROL request\n(specifying that version) to the destination of the \"copy\".\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-16082591"}, {"subject": "Re (2): Creating new version-controlled bindings referencing existing  VHR'", "content": "Konstantin Knizhnik <KKnizhnik@togetherlab.com> wrote:\n> So, in few words, I do not understand how to do the following\n> operation:\n> - I have some project (version-controlled-collection) in some workspace\n> (for example /ws/his/project1)\n> - I want to place this project (copy all its resources) in my workspace /ws/my\nIn short: have a look at BASELINE-CONTROL.\n- Do your work in /ws/his/project1.\n- Create a configuration by BASELINE-CONTROL\n- Check it in and you have a baseline (containing versions)\n- Then checkout the baseline at /ws/my\n\nCheers, Edgar\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-16097514"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "I was not planning on implementing a version-history feature.  I see\nabsolutely no problems with supporting the working resource feature with\nanything I've said.  I wasn't planning on supporting workspaces, but I\ndon't see any problems there that aren't inherent in being able to\ndelete individual versions.\n \nAlthough you can keep an object around that allows you to retrieve the\nversion history of a completely deleted resource, I don't understand how\nthat can be done without eventual name collisions.\n \nSay I create foo/bar.txt as a version controlled resource.  If I wanted\na separate version history object, I could put it in some place like\n/vhist/foo/bar.txt\nNow someone wants to delete foo/bar.txt -- OK, I delete it but not\n/vhist/foo/bar.txt\n \nThat works until someone tries to create a new foo/bar.txt that they\nwish to be a version controlled resource.  I have a collision with\n/vhist/foo/bar.txt and THIS foo/bar.txt is completely distinct from the\noriginal.\n \n \n \n \n \n \n\n-----Original Message-----\nFrom: Rick Rupp [mailto:Rick.Rupp@merant.com] \nSent: Tuesday, June 12, 2001 4:22 PM\nTo: 'John Hall'; 'ietf-dav-versioning@w3.org'\nSubject: RE: Confusion: Removing a resource from version control \n\n\n\nI disagree that version history should be deleted if you delete the\nversion controlled resource. Section 5 of the draft clearly states the\nversion history resource exists in a server defined namespace and\ntherefore is unaffected by any deletion or movement of a version\ncontrolled resource.\n\nIf you require the version history to be deleted you will cause serious\nproblems for a server that supports the workspace and working resource\nfeature.\n\n-----Original Message----- \nFrom: John Hall [mailto:johnhall@evergo.net] \nSent: Tuesday, June 12, 2001 3:52 PM \nTo: 'Clemm, Geoff'; 'DeltaV' \nSubject: RE: Confusion: Removing a resource from version control \n\n\nIntro about me at bottom. \n\n\"In order to remove a resource at a given URL from version control, the \nclient can replace the resource under version control with a \nnon-version-controlled copy of that resource.  For example, a client can\n\nCOPY the version-controlled resource to a temporary location, DELETE the\n\nversion-controlled resource, and then MOVE the copy from the temporary \nlocation back to the original URL.  Note that the versions already \ncreated for the version-controlled resource will continue to exist at \ntheir server-defined locations.\" \n\nIs that clearer? \n\nCheers, \nGeoff \n\n================================================================= \n\nWhen you DELETE a version-controlled resource, I strongly believe that \nall information for that VCR and all versions already created should go \nto the great bit bucket in the sky. \n\nAs I understand your formulation, I would have severe problems in \nmodifying my DAV server (with versioning support) to support DELTAV \nusing this behavior.  \n\nI would prefer this formulation / behavior: \n\n\"In order to remove a resource at a given URL from version control, the \nclient can replace the resource under version control with a \nnon-version-controlled copy of that resource.  For example, a client can\n\nCOPY the version-controlled resource to a temporary location, DELETE the\n\nversion-controlled resource, and then MOVE the copy from the temporary \nlocation back to the original URL.  Note that the versions already \ncreated for the version-controlled resource will NO LONGER BE AVAILABLE.\n\nIf you wish to remove a resource at a given URL from version control \nwhile also retaining a previous revision history, then you should MOVE \nthe resource to a new save location and COPY the current version back to\n\nthe original URL.\" \n\n========== \n\nMy formulation is based explicitly on the idea that some implementations\n\nand some customers are not keeping track of legal documents and \ntherefore deleting old versions is highly desired if not required.  A \nserver shouldn't be forced to keep data that a client is willing to \nspecifically state that it doesn't want. \n\nI think a far better manner of achieving your goals is simply to allow \nthe VERSION-CONTROL method to turn version-control for a resource at a \ngiven URL off (if supported by the server).  That allows you to achieve \nyour above objectives (no new versions, but keep the old ones at the \nsame URLs) without changing the usefulness of the DELETE command. \n\n====================================================== \n\nJohn Hall is an engineer working on the Xythos development team to \nmodify their DAV (with revision additions) server to support DELTAV as \nwell as other-party proprietary DAV versioning systems. \n\n\n\n", "id": "lists-006-1610563"}, {"subject": "Re: Re (2): Creating new version-controlled bindings referencing existing  VHR'", "content": "Hello Edgar,\n\nWednesday, December 12, 2001, 12:46:20 AM, you wrote:\n\nEEd> Konstantin Knizhnik <KKnizhnik@togetherlab.com> wrote:\n>> So, in few words, I do not understand how to do the following\n>> operation:\n>> - I have some project (version-controlled-collection) in some workspace\n>> (for example /ws/his/project1)\n>> - I want to place this project (copy all its resources) in my workspace /ws/my\nEEd> In short: have a look at BASELINE-CONTROL.\nEEd> - Do your work in /ws/his/project1.\nEEd> - Create a configuration by BASELINE-CONTROL\nEEd> - Check it in and you have a baseline (containing versions)\nEEd> - Then checkout the baseline at /ws/my\n\nSo the only way to do it - is to place source collection under\nbaseline control???\nBut what is the result of applying VERSION-CONTROL method with\n<DAV:version> refers to version-controlled-collection? It will create\nversion-controlled resource in the target workspace for this collection\niself but not for its members, right? What in this case is the result of PROPFIND\nwith Depth=infinite applied to such version-controled-resource?\nIs there any good motivation for restricting VERSION-CONTROL source to\nbe a version and not a version-controlled-resource, which capture\ninformation about the resource version and workspace to which it\nbelongs?\n\nIt seems to me that the current model of version-control method for\nexisted version history is contradicting and not clear...\nIf the only way of importing information in workspace from other\nworkspaces is baseline, then we should prohibit version-control method\nfor existed version history at all. Otherwise, version-control method\nshould be able to correctly place the whole specified subtree in the\ntarget workspace.\n\n\n\nEEd> Cheers, Edgar\n\n\n\n\n-- \nBest regards,\n Konstantin                            mailto:KKnizhnik@togetherlab.com\n\n\n\n", "id": "lists-006-16106340"}, {"subject": "RE: Creating new version-controlled bindings referencing existing   VHR'", "content": "To reconstruct a whole tree of version-controlled resources, \nyou would need a baseline (that is why the version-controlled\ncollection feature is always bundled with the baseline feature\nin all the defined packages).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\nSent: Tuesday, December 11, 2001 10:27 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Creating new version-controlled bindings referencing\nexisting VHR's\n\n\nI faced with the problem of placing existed version controlled\ncollection (with all members) in my workspace. Section 6.7 (Additional\nversion control semantic) says that VERSION-CONTROL method\n<DAV:version> element in body should be used in this case. But\n<DAV:version> elements specifies only version of the root collection\nto be placed in my workspace. And how can I determine versions of\nmembers of this collections? Version controlled collection contains\njust bindings to version histories of its members. It is not possible\nto select particular version from the version history without\nknowledge about workspace from which take this subtree. But workspace\nis not specified in VERSION-CONTROL method and there is no way to get\nit.\n  \nSo, in few words, I do not understand how to do the following\noperation:\n- I have some project (version-controlled-collection) in some workspace (for\nexample /ws/his/project1)\n- I want to place this project (copy all its resources) in my workspace\n/ws/my\nHow it can be done?\n\n\n-- \nBest regards,\n Konstantin                          mailto:KKnizhnik@togetherlab.com\n\n\n\n", "id": "lists-006-16116580"}, {"subject": "RE: Re (2): Creating new version-controlled bindings referencing  existing  VHR'", "content": "   From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\n\n   So the only way to do it - is to place source collection under\n   baseline control???\n\nIf you want to recreate a previous state of the source collection\nfrom history, yes.  A baseline is the \"deep-version\" of a collection\nthat captures the state of all members of the collection.  You can\nthink of it as a set of versions (i.e. one version of each\nversion-controlled\nresource in the collection, including each version-controlled collection).\n\n   But what is the result of applying VERSION-CONTROL method with\n   <DAV:version> refers to version-controlled-collection? It will create\n   version-controlled resource in the target workspace for this collection\n   iself but not for its members, right?\n\nIf there already is a version selected by that workspace for a given\nversion history, then that version is selected.  Otherwise, it is\nserver defined (e.g. a server could just pick the initial version,\nthe latest version, or some random version).\n\n   What in this case is the result of PROPFIND\n   with Depth=infinite applied to such version-controled-resource?\n\nDepends on what version the server selected.\n\n   Is there any good motivation for restricting VERSION-CONTROL source to\n   be a version and not a version-controlled-resource, which capture\n   information about the resource version and workspace to which it\n   belongs?  \n\nYes, the rationale is in the protocol document in the section on\nversion-controlled collections.  The collection version is used for\nactivity change set information, to capture the delta between a\nprevious version of that part of the namespace.  But the bottom line\nis that if you want a version of the whole tree, you use a baseline,\nand if you want incremental information about the namespace you use a\ncollection version.\n\n   It seems to me that the current model of version-control method for\n   existed version history is contradicting and not clear...\n   If the only way of importing information in workspace from other\n   workspaces is baseline, then we should prohibit version-control method\n   for existed version history at all. Otherwise, version-control method\n   should be able to correctly place the whole specified subtree in the\n   target workspace.\n\nA collection version and a baseline address different use cases.  It\nappears that your use cases are addressed by the baseline feature, and\nso that is the one you would use.  Why would you want another feature\n(version-controlled collections) to do the same thing?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-16126094"}, {"subject": "Re: Re (2): Creating new version-controlled bindings referencing  existing  VHR'", "content": "On Tue, Dec 11, 2001 at 08:09:30PM -0500, Clemm, Geoff wrote:\n>    From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\n> \n>    So the only way to do it - is to place source collection under\n>    baseline control???\n> \n> If you want to recreate a previous state of the source collection\n> from history, yes.\n\nWell, its not the *only* way to do it. We are not planning to support\nbaselines at this stage. We are planning to use other details such\nas a time point to find the appropriate version of every single\nthing we want to check out and then do an update to get the appropriate\nversion for each individual resource at that point in time.\n\nMind you, we might not be using the DeltaV protocol to do the check\nout initially. We might be doing it behind the scenes in a way compatible\nwith DeltaV to simplify DeltaV support later.\n\n> A collection version and a baseline address different use cases.  It\n> appears that your use cases are addressed by the baseline feature, and\n> so that is the one you would use.  Why would you want another feature\n> (version-controlled collections) to do the same thing?\n\nIt may be true that baselines may be more appropriate for your situation.\n\nAlan\n\n\n\n", "id": "lists-006-16136853"}, {"subject": "RE: Workspaces and File&amp;Folder Hierarch", "content": "Thanks so far! But what about this:\n\n>But I agree with Alan that the most important thing about a workspace\n>is that it has at most one versioned-controlled resource for a given\n>version history.\n\nBut it is still possible to have a version tree (not a single line of\ndescent of versions for the only VCR in the workspace)??? Well it would\nproduce a ambiguity, wouldn't it? And then there is no unambigious merge or\nbaselining can take place. So I would rather understand it that way, that\nyou should have a <checkin-fork><forbidden> behavior for the versions. With\nthat it would be possible that more than one developer checks out a given\nversion but at check in time they would be forced to do an explicit merge\nand the single line of descent and the unabiguity would be kept.\n\n(was that understandable???)\n\nregards\nDaniel\n\n>-----Original Message-----\n>From: Clemm, Geoff [mailto:gclemm@rational.com]\n>Sent: Dienstag, 11. Dezember 2001 16:53\n>To: Ietf-Dav-Versioning (E-mail)\n>Subject: RE: Workspaces and File&Folder Hierarchy\n>\n>\n>   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n>\n>   On Mon, Dec 10, 2001 at 04:36:03PM +0100, Kirmse, Daniel wrote:\n>\n>   > is it allowed to have a Workspace containing a File&Folder\n>   > Hierarchy (i.e. a copy of a subtree of the webdav resource tree)?\n>\n>   Yes. I think a really nice thing about DeltaV is that it allows\n>   versioning of containers (directories). Its not mandatory, but\n>   certainly is supported. I would suggest having a bit of a read.\n>\n>   To me the only special thing about a workspace is that it imposes\n>   additional constraints on that you are only allowed to check out\n>   one version of a resource under it. (Note, you could have multiple\n>   bindings of URLS to the same resource, but they would be the same\n>   version of that resource).\n>\n>Yes, as Alan says, a Workspace can have a File/Folder (WebDAV would\n>call it a Resource/Collection) hierarchy below it (a Workspace is\n>just a special kind of collection).\n>\n>Another special thing about a Workspace is that you can\n>associate a \"current-activity\" with that workspace, to simplify\n>activity-based checkouts.  Also, you have an easy way to identify\n>all checkouts in a workspace (without doing a depth propfind),\n>and you can tell whether a resource is a member of a workspace by\n>looking at its DAV:workspace property.\n>\n>But I agree with Alan that the most important thing about a workspace\n>is that it has at most one versioned-controlled resource for a given\n>version history.\n>\n>Cheers,\n>Geoff\n>\n\n\n\n", "id": "lists-006-16146047"}, {"subject": "VCR Fork and GE", "content": "Hi,\n\nanother question:\n\nSuppose a VCR with the history shown below. As DeltaV states in \"3.2.1\nDAV:checked-in (protected)\" a checked in VCR gots a property \"<!ELEMENT\nchecked-in\" (href)>\" assigned to it. In the example it would be the URL of\nversion V3 of the VCR that has to be stored with this property.\n\n\n         /foo.html (version-controlled resource)\n\n          +----+    \n          | S2 |    \n          +----+    \n       Checked-In=V2\n\n\n         /his/73 (version history for /foo.html)\n\n         +----+     \n         | S1 | V1  \n         +----+     \n            |       \n            |       \n         +----+     \n         | S2 | V2  \n         +----+     \n\n\nFurther suppose a user checks out the VCR. With that the URL stored in the\n\"Checked-in\" property has to be stored in a \"Checked-out\" property of that\nvery VCR. The \"Checked-in\" property vanishes to nothing. No damage done so\nfar.\n\n\n            ===checkout user 1==>\n\n\n         /foo.html (version-controlled resource)\n\n          +----+    |    +----+    \n          | S2 |    |    | S2 |    \n          +----+    |    +----+    \n       Checked-In=V2|Checked-Out=V2\n\n\n         /his/73 (version history for /foo.html)\n\n         +----+     |   +----+     \n         | S1 | V1  |   | S1 | V1  \n         +----+     |   +----+     \n            |       |      |       \n            |       |      |       \n         +----+     |   +----+     \n         | S2 | V2  |   | S2 | V2  \n         +----+     |   +----+     \n                    |              \n\nNow suppose another user that wants to check out the very same VCR. Checkout\nfork is allowed and/or fork-ok is sent with the request.\n\nNow (my) trouble starts:\n\n1. There is no \"checked-in\" property that could give me the version to check\nout. One Precondition for check out is:\n\n(DAV:must-be-checked-in): If a version-controlled resource\nis being checked out, it MUST have a DAV:checked-in property.\nIs this a condradiction? What is the solution?\n\nO.k., suppose the checkout of both of the users was successfull\n\n       ===checkout user 1==> ===checkout user 2==>\n\n\n         /foo.html (version-controlled resource)\n\n          +----+    |    +----+    |    +----+\n          | S2 |    |    | S2 |    |    | S2 |\n          +----+    |    +----+    |    +----+\n       Checked-In=V2|Checked-Out=V2|Checked-Out=V2\n\n\n         /his/73 (version history for /foo.html)\n\n         +----+     |   +----+     |    +----+\n         | S1 | V1  |   | S1 | V1  |    | S1 |\n         +----+     |   +----+     |    +----+\n            |       |      |       |       |________\n            |       |      |       |       |        |\n         +----+     |   +----+     |    +----+   +----+\n         | S2 | V2  |   | S2 | V2  |    | S2 |   | S3 |\n         +----+     |   +----+     |    +----+   +----+\n                    |              |       \nNow there are two checked out versions of the VCR. But there is only one\nChecked-Out property.\n\n2. Does a VCR got a checked-out property for every checked out version?  If\nnot, how a fork is handled correctly?\n\n3. After checkin of both versions without merging (fork-ok or checkin-fork\nnot forbidden) there are two checked in versions of the VCR now. There are\ntwo checked-in properties now  to?\n\nAs far as I know a not versioning aware client sends a GET request to the\nVCR itself to get the content of it. Asuming a single line of descent the\ncontent to deliver simply is the most current checked in version. (Same\napplies to a server that implements only basic versioning features (i.e. no\nversion histoty and with that no version resource URI)).\n\n4.If there is no single line of descent, the server has to provide a\nreasonable reply. What would it be?\n\n\nRegards,\nDaniel\n\n\n\n", "id": "lists-006-16156958"}, {"subject": "Some questions on Configuration", "content": "Hi, me again!\n\nThis time I have some questions concerning configurations.\n\n1.DeltaV differentiates a baseline-controlled collection and a\nversion-controlled configuration. My understanding is that a collection C\nput under baseline-control becomes the root of a version-controlled\nconfiguration (VCC). So puting a collection C under baseline-control means\nall resources subordinate to C will be part of the configuration rooted at C\nand theire last checked in version is captured in the baseline.\n\nThe pic below (taken from DeltaV draft 20) implies a 1:1 relationship of the\ntwo concepts.\n\n\n  +-------------------------------------+\n  |Baseline-Controlled Collection       |<------+\n  |/src                                 |       |\n  |-------------------------------------|       |\n  |DAV:version-controlled-configuration +---+   |\n  +-------------------------------------+   |   |\n                                            |   |\n                                            |   |\n  +-------------------------------------+   |   |\n  |Version-Controlled Configuration     |<--+   |\n  |/repo/vcc/128                        |       |\n  |-------------------------------------|       |\n  |DAV:baseline-controlled-collection   +-------+\n  |-------------------------------------|\n  |DAV:checked-in                       +-------+\n  +-------------------------------------+       |\n  |DAV:version-history                  +---+   |\n  +-------------------------------------+   |   |\n                                            |   |\n                                            |   |\n  +------------------------+                |   |\n  |Baseline History        |<---------------+   |\n  |/repo/blh/13            |                    |\n  |------------------------+                    |\n  |DAV:version-set         +----------------+   |\n  +------------------------+    |   |   |   |   |\n                                v   |   v   v   |\n                                    |           |\n  +------------------------+        |           |\n  |Baseline                |<-------+-----------+\n  |/repo/blh/13/ver/8      |\n  |------------------------+     +--------------+\n  |DAV:baseline-collection +---->|Collection    |\n  +------------------------+     |/repo/bc/15   |\n                                 +--------------+\n\n2. What about creating \"components\"/subbaselines/subconfigurations. Because\nof the definition of a Configuration given in DeltaV one would assume that\nthe components have to be created before the \"component container\" otherwise\nthere would be a problem with the definition:\n\nA \"configuration\" is a set of resources that consists of a root\ncollection and all members (not just internal members) of that root\ncollection that are not members of another configuration.  \n\nBut in my opinion the \"component\" baselines/configurations created that way\nwould be no subbaselines. Or would they be?\nThe only way of getting it straight (means creating components after the\nsuperior container was created) is that the container is created/put under\nbaseline control first and then subtrees of the configuration put under\nbaseline control on their own. But this would contradict with the definition\nas well.\nSo what is the way of creating subbaselines? My reading of the draft did not\nreveal this fact to me (unfortunately).\n\n\nRegards,\nDaniel\n\n\n\n", "id": "lists-006-16167694"}, {"subject": "Re: VCR Fork and GE", "content": "\"Kirmse, Daniel\" <daniel.kirmse@sap.com> wrote:\n\n> Hi,\n> \n> another question:\n> \n> Suppose a VCR with the history shown below. As DeltaV states\n> in \"3.2.1 DAV:checked-in (protected)\" a checked in VCR gots\n> a property \"<!ELEMENT checked-in\" (href)>\" assigned to it.\n> In the example it would be the URL of version V3 of the VCR\n> that has to be stored with this property.\n\nYes.  (You meant V2, not V3)\n\n>          /foo.html (version-controlled resource)\n> \n>           +----+\n>           | S2 |\n>           +----+\n>        Checked-In=V2\n> \n> \n>          /his/73 (version history for /foo.html)\n> \n>          +----+\n>          | S1 | V1\n>          +----+\n>             |\n>             |\n>          +----+\n>          | S2 | V2\n>          +----+\n> \n> \n> Further suppose a user checks out the VCR. With that the URL\n> stored in the \"Checked-in\" property has to be stored in a\n> \"Checked-out\" property of that very VCR. The \"Checked-in\"\n> property vanishes to nothing. No damage done so far.\n\nAgreed.  The DAV:checked-out property is removed.\n\n>             ===checkout user 1==>\n> \n> \n>          /foo.html (version-controlled resource)\n> \n>           +----+    |    +----+\n>           | S2 |    |    | S2 |\n>           +----+    |    +----+\n>        Checked-In=V2|Checked-Out=V2\n> \n> \n>          /his/73 (version history for /foo.html)\n> \n>          +----+     |   +----+\n>          | S1 | V1  |   | S1 | V1\n>          +----+     |   +----+\n>             |       |      |\n>             |       |      |\n>          +----+     |   +----+\n>          | S2 | V2  |   | S2 | V2\n>          +----+     |   +----+\n>                     |\n\nAgreed.  However, there is no guarantee that the state of the \nversion-controlled resource will remain at S2 as it is now mutable.\n\n> Now suppose another user that wants to check out the very\n> same VCR. Checkout fork is allowed and/or fork-ok is sent\n> with the request.\n\nOk, but that version-controlled resource is already checked-out, so the \nnew user would be unable to check it out again.  Remember that there is no \nconcept of 'user' or 'session' in DeltaV, so whether the request for \nanother check-out came from a new user or the original user the effect is \nthe same (i.e., the attempt would fail for the same reason, that the \nversion-controlled resource is already checked out).\n\n> Now (my) trouble starts:\n> \n> 1. There is no \"checked-in\" property that could give me the\n> version to check out. One Precondition for check out is:\n> \n>    (DAV:must-be-checked-in): If a version-controlled\n>    resource is being checked out, it MUST have a\n>    DAV:checked-in property.\n> Is this a condradiction? What is the solution?\n\nGiven what I wrote above, you can see that this precondition would cause \nthe second check-out to fail.\n\nThe solution is to create a second version-controlled resource (using \nVERSION-CONTROL) whose DAV:checked-in property refers to V2, or to \ncheck-out the version directly, thereby creating a working resource.\n\n> O.k., suppose the checkout of both of the users was\n> successfull\n\nIt won't be successful.\n\n>        ===checkout user 1==> ===checkout user 2==>\n> \n> \n>          /foo.html (version-controlled resource)\n> \n>           +----+    |    +----+    |    +----+\n>           | S2 |    |    | S2 |    |    | S2 |\n>           +----+    |    +----+    |    +----+\n>        Checked-In=V2|Checked-Out=V2|Checked-Out=V2\n> \n> \n>          /his/73 (version history for /foo.html)\n> \n>          +----+     |   +----+     |    +----+\n>          | S1 | V1  |   | S1 | V1  |    | S1 |\n>          +----+     |   +----+     |    +----+\n>             |       |      |       |       |________\n>             |       |      |       |       |        |\n>          +----+     |   +----+     |    +----+   +----+\n>          | S2 | V2  |   | S2 | V2  |    | S2 |   | S3 |\n>          +----+     |   +----+     |    +----+   +----+\n>                     |              |\n> Now there are two checked out versions of the VCR. But there\n> is only one Checked-Out property.\n\nThere is no such thing as a \"checked-out version\".  The situation you have \ndrawn can occur (again, by using another version-controlled resource on \nV1, or working resource of V1, then checking them in to create V3). So \nyour version history diagram is possible using a number of intermediate \nsteps.\n\n> 2. Does a VCR got a checked-out property for every checked out\n> version?  If not, how a fork is handled correctly?\n\nA checked-out version controlled resource only has a single (and \nsingle-valued) DAV:checked-out property.  To cause a fork in history \nrequires checking out a version twice.\n\n> 3. After checkin of both versions without merging (fork-ok or\n> checkin-fork not forbidden) there are two checked in versions\n> of the VCR now. There are two checked-in properties now  to?\n\nNope, there is a one-to-one between checked-in version-controlled \nresources and versions.\n\n> As far as I know a not versioning aware client sends a GET request\n> to the VCR itself to get the content of it.\n\nIndeed any client can send a GET to retrieve the content of a \nversion-controlled resource.\n\n> Asuming a single line of descent the content to deliver simply\n> is the most current checked in version.\n\nThat is true only if the server does not support UPDATE.\n\n> (Same applies to a server that implements only basic versioning\n> features (i.e. no version histoty and with that no version\n> resource URI)).\n\nEven if a server does not expose the version history resource, versions \nwill still have a (server generated) URL.\n\n> 4.If there is no single line of descent, the server has to provide\n> a reasonable reply. What would it be?\n\nThe version-controlled resource has its own content, so the server always \nanswers the content of the version-controlled resource.  When the \nversion-controlled resource is checked-in the content is identical to the \ncontent of the version identified by the DAV:checked-in property; when the \nversion-controlled resource is checked-out the content is initially the \nsame as when it was checked-in, but the content is mutable so it can \nbecome anything that the client PUTs there.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-16178290"}, {"subject": "Re: Some questions on Configuration", "content": "\"Kirmse, Daniel\" <daniel.kirmse@sap.com> wrote:\n\n> Hi, me again!\n> \n> This time I have some questions concerning configurations.\n> \n> 1.DeltaV differentiates a baseline-controlled collection and a\n> version-controlled configuration. My understanding is that a\n> collection C put under baseline-control becomes the root of a\n> version-controlled configuration (VCC).\n\nThis is true.\n\n> So puting a collection C under baseline-control means all\n> resources subordinate to C will be part of the configuration\n> rooted at C and theire last checked in version is captured\n> in the baseline.\n\nThe baseline captures all version-controlled resources 'reachable' from C.\n\n> The pic below (taken from DeltaV draft 20) implies a 1:1 relationship of \nthe\n> two concepts.\n\n<<snip>>\n\n> 2. What about creating \"components\"/subbaselines/subconfigurations.\n> Because of the definition of a Configuration given in DeltaV\n> one would assume that the components have to be created before\n> the \"component container\" otherwise there would be a problem with\n> the definition:\n> \n>    A \"configuration\" is a set of resources that consists of a root\n>    collection and all members (not just internal members) of that\n>    root collection that are not members of another configuration.\n\nAgreed.\n\n> But in my opinion the \"component\" baselines/configurations created\n> that way would be no subbaselines. Or would they be?\n\nYes.  Furthermore, the subbaselines are not constrained to capture parts \nof the namespace rooted by C, they can be disjoint.\n\n> The only way of getting it straight (means creating components after\n> the superior container was created) is that the container is created/put\n> under baseline control first and then subtrees of the configuration\n> put under baseline control on their own. But this would contradict\n> with the definition as well.\n\nNo, the subbaselines have to be created first, and can be added to the \nDAV:subbaseline-set property of a checked-out version-controlled \nconfiguration.\n\n> So what is the way of creating subbaselines? My reading of the draft did\n> not reveal this fact to me (unfortunately).\n\nThe baseline is created using BASELINE-CONTROL, and they become \nsubbaselines by virtue of being added to the DAV:subbaseline-set.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-16191860"}, {"subject": "RE: Some questions on Configuration", "content": "><<snip>>\n>\n>> 2. What about creating \"components\"/subbaselines/subconfigurations.\n>> Because of the definition of a Configuration given in DeltaV\n>> one would assume that the components have to be created before\n>> the \"component container\" otherwise there would be a problem with\n>> the definition:\n>> \n>>    A \"configuration\" is a set of resources that consists of a root\n>>    collection and all members (not just internal members) of that\n>>    root collection that are not members of another configuration.\n>\n>Agreed.\n>\n>> But in my opinion the \"component\" baselines/configurations created\n>> that way would be no subbaselines. Or would they be?\n>\n>Yes.  Furthermore, the subbaselines are not constrained to \n>capture parts \n>of the namespace rooted by C, they can be disjoint.\n>\n\nThis means you could have a baseline /.../B/C/... rooted at /.../B/C\nPossible subbaselines could be:  /.../B/C/A/... rooted at /.../B/C/A\nor /.../B/... rooted at /.../B\nor even /.../D/E/... rooted at /.../D/E\n\nright?\n\n><<snip>>\n\n\n\n", "id": "lists-006-16201740"}, {"subject": "RE: Some questions on Configuration", "content": "> This means you could have a baseline /.../B/C/... rooted at /.../B/C\n> Possible subbaselines could be:  /.../B/C/A/... rooted at /.../B/C/A\n> or /.../B/... rooted at /.../B\n> or even /.../D/E/... rooted at /.../D/E\n> \n> right?\n\nright.\n\nTim\n\n\n\n", "id": "lists-006-16210370"}, {"subject": "Re: Workspaces and File&amp;Folder Hierarch", "content": "On Wed, Dec 12, 2001 at 09:26:29AM +0100, Kirmse, Daniel wrote:\n> Thanks so far! But what about this:\n> \n> >But I agree with Alan that the most important thing about a workspace\n> >is that it has at most one versioned-controlled resource for a given\n> >version history.\n> \n> But it is still possible to have a version tree (not a single line of\n> descent of versions for the only VCR in the workspace)???\n\nA version controlled resource can have a tree of version resources.\nBut I am not sure I understand what you mean by 'for the only VCR\nin the workspace' - I am missing something from a previous post maybe?\n\n> Well it would\n> produce a ambiguity, wouldn't it? And then there is no unambigious merge or\n> baselining can take place.\n\nSorry, you have lost me here. Are you proposing something above then?\n\n> ...\n> (was that understandable???)\n\nUmmmm. Sorry, not to me (so I probably should not be replying! :-)\n\n> regards\n> Daniel\n\nAlan\n\n\n\n", "id": "lists-006-16217347"}, {"subject": "RE: Workspaces and File&amp;Folder Hierarch", "content": "   From: Kirmse, Daniel [mailto:daniel.kirmse@sap.com]\n\n   But it is still possible to have a version tree (not a single line of\n   descent of versions for the only VCR in the workspace)???\n\nRemember that a workspace contains version-controlled resources,\nnot versions or version histories.  So I'm not sure what you mean\nby \"having a version tree\" in the workspace.\n\n   Well it would\n   produce a ambiguity, wouldn't it? And then there is no unambigious merge\nor\n   baselining can take place. \n\nRemember that each version-controlled resource refers to exactly one\nversion in its dav:checked-in or dav:checked-out property.  So there\nis no ambiguity about what version is associated with a given\nversion-controlled resource.\n\n   So I would rather understand it that way, that\n   you should have a <checkin-fork><forbidden> behavior for the versions.\nWith\n   that it would be possible that more than one developer checks out a given\n   version but at check in time they would be forced to do an explicit merge\n   and the single line of descent and the unabiguity would be kept.\n\nPerhaps you are thinking that a version-controlled resource always\nrefers to the \"latest\" version in a version history?  This is definitely\nnot the case.  It refers to the last version checked-in to that working\nresource, or to an arbitrary version (of that version history)\nspecified in an UPDATE request.\n\nSo there is no ambiguity if there are forks and multiple lines of \ndescent.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-16225469"}, {"subject": "Parallel Developmen", "content": "HI,\n\nits getting complicated! First of all many thanks to everyone anwsering my\nquestions so far! It helped me a lot.\n\nSo next question:\n\nScenario: \nSuppose a development environment where the development codeline is kept in\na workspace. Within this Workspace there is a VCR /DEV/a.c the checked-in\nproperty points to version  V1. Now there is a checkout of the checked-in\nversion of /DEV/a.c into a working-resource WR1. In my understanding of\nDeltaV the checked-in property of the VCR is not changed by this action. Now\nanother checkout of the checked-in version into a working-resource WR2 is\ndone (i.e. two developer working parallel on the same source). Rigth so far?\nIf not, is there a way in DeltaV to get done the behavior described below?\n\nNow WR1 is checked in. WR1 disappears the version history (VH) of /DEV/a.c\ncontains a new version V2 that is a descendant of V1. In my understanding\nthe checked-in property of the VCR is set to V2 during this checkin. Still\nright?\n\nNow WR2 is checked in. Checkin fork is forbidden. Because there is a\ndescendent to V1 allready and the checkin fork is forbidden. So a merge must\nbe forced (how?). After that done the checked-in property of the VCR points\nto the merged version of V2 and the checked in version of WR2. Right?\n\n\nBackground:\nI have a development codeline. A file to edit is a VCR. I want the\npossibility of two (or more) developers working parallel with this file. But\nI want them to do a merge of their work at the second checkin (the checkin\nof the first developer causes no problems). And I want the VCR point to the\nmost current checked-in version of its VH automatically. Is this\nachieveable? I think it must be, since this is what can be done using\nPerforce.\n\n\nRegards,\nDaniel\n\n\n\n", "id": "lists-006-16234172"}, {"subject": "RE: Question on support for in-place editin", "content": "From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n\n   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n\n   By \"in-place editing\" I mean that when the VCR is checked out,\nclients can\n   do any number of PUT, PROPPATCH and other write operations, before\nfinally\n   checking in.  In the meantime, this work-in-progress is available for\nother\n   users to see if they have permission to read the resource.\n\n   First question: Does anybody plan to implement DeltaV this way?\n\nI would strongly consider this an option, if a default GET and PROPFIND\ndid not reference the work in progress but instead referenced the\nlast-checked-in-version.\n\nImagine this:\nAfter checkout, GET/PROPFIND from users that don't have the resource\nchecked out refer to the last checked in copy.  PUT/PROPPATCH are\nillegal.\n\nFor the user with the resource checked out, all operations apply to the\ncheckout-in-place copy.\n\nThat gives you most of the functionality of the working resource model,\navoids things like UPDATE/MERGE interactions with working resources, and\navoids placing extra demands on the client.\n\nIf we weren't trying to be compatible with a 3rd party DAV + revision\nbut not DeltaV server, I'd propose that we do it this way.  The 3rd\nparty server puts the working resource in an independent namespace.\n\n[Lest no one confuse us, I do work for Lisa at Xythos.  But she works in\nCA and I work in WA where it is cheaper to live.  We have independent\nopinions.]\n\n\n\n", "id": "lists-006-1623584"}, {"subject": "Re: Parallel Developmen", "content": "\"Kirmse, Daniel\" <daniel.kirmse@sap.com> wrote:\n> HI,\n> \n> its getting complicated! First of all many thanks to everyone\n> anwsering my questions so far! It helped me a lot.\n> \n> So next question:\n> \n> Scenario:\n> Suppose a development environment where the development\n> codeline is kept in a workspace. Within this Workspace\n> there is a VCR /DEV/a.c the checked-in property points\n> to version  V1.\n\nOk, so there are two distinct resources, a version-controlled resource at\n    /DAV/a.c\n\nand a version resource at some server-generated URL, let's say,\n    /versions/vh1/r23\n\nThe checked-in property of the version-controlled resource has a value \nthat is the URL of the version.  This means, \"the version-controlled \nresource is checked-in (i.e. `immutable`) and it has identical (i.e. a \ntrue copy of) content and dead properties as the version whose URL is in \nthe DAV:checked-in property\"  Note that the version-controlled resource \nmay have different live properties to the version resource.\n\n> Now there is a checkout of the checked-in version of /DEV/a.c\n> into a working-resource WR1.\n\nJust to be pedantic, a version is not checked-in (or checked-out for that \nmatter), but applying CHECKOUT to a version creates a new working resource \nwith the same content and dead properties as the version.\n\n> In my understanding of DeltaV the checked-in property of the\n> VCR is not changed by this action.\n\nCorrect, the version-controlled resource is unaffected by the creation of \nthe working resource.  It remains a checked-in version-controlled \nresource.\n\n> Now another checkout of the checked-in version into a working-\n> resource WR2 is done (i.e. two developer working parallel on\n> the same source). Rigth so far?\n\nSure (assuming liberal fork control) you can create more working resources \nby applying CHECKOUT to the version resource.\n\n> If not, is there a way in DeltaV to get done the behavior\n> described below?\n\n> Now WR1 is checked in. WR1 disappears the version history\n> (VH) of /DEV/a.c contains a new version V2 that is a descendant\n> of V1.\n\nCorrect.\n\n> In my understanding the checked-in property of the\n> VCR is set to V2 during this checkin. Still right?\n\nNope (we were doing so well up to this point :-)\n\nThe version-controlled resource is not updated since there is no tie \nbetween the working resource created by checking out the version, and the \nversion-controlled resource.  So in this scenario, the version-controlled \nresource would still have the same content and dead properties as the \nversion V1.\n\nIf you did want to update the version-controlled resource there are two \nways to do this.\n\n(1) Rather than check-out the version to create a working resource you \ncould have just checked-out the version-controlled resource 'in-place'. \nYou would then modify the version-controlled resource (PUT, PROPPATCH, \netc.) and check-in the version-controlled resource to create a new \nversion.  However, modifying the resource in-place obviously means that \nother clients would see your work in progress.  In the trivial case this \nis state that you didn't want to version because it was incomplete; but \nmore seriously it could be a state that is inconsistent because there is \nno way to modify the properties and content simultaneously (imagine a \n\"FOOBAR:last-modified-by\" property).  So the alternative way is...\n(2) send CHECKOUT to the version-controlled resource _with_ a \nDAV:apply-to-version flag.  Now you have a (hidden) working resource that \nis coupled to the version-controlled resource, as evidenced by it's \nDAV:auto-update property.  Since the working resource is effectively \nhidden from other clients, you can modify the content and properties, \nnumerous times, and finally CHECKIN the working resource.  This check-in \nwill create the new version, delete the working resource, *and* update the \nversion-controlled resource identified by the DAV:auto-update property.\n\n> Now WR2 is checked in. Checkin fork is forbidden. Because there\n> is a descendent to V1 allready and the checkin fork is forbidden.\n> So a merge must be forced (how?). After that done the checked-in\n> property of the VCR points to the merged version of V2 and the\n> checked in version of WR2. Right?\n\nSo now, hopefully, you see that you can't get into this mess<g>.\n\n> Background:\n> I have a development codeline. A file to edit is a VCR. I want\n> the possibility of two (or more) developers working parallel\n> with this file. But I want them to do a merge of their work at\n> the second checkin (the checkin of the first developer causes\n> no problems).\n\nSo you would have the DAV:checkin-fork property set to DAV:forbidden for \neach version to force the second checking to fail, and force a merge.\n\n> And I want the VCR point to the most current checked-in version\n> of its VH automatically. Is this achieveable?\n> I think it must be, since this is what can be done using\n> Perforce.\n\nAgain, by checking out the version 'through' the version-controlled \nresource, i.e. by using <DAV:apply-to-version/> you can get the \nDAV:auto-update behaviour described above.\n\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-16243308"}, {"subject": "baselines &amp; namespace", "content": "I've got a question to do with preserving the location in a namespace of\nthe root of a baseline.\n\nSection 12 has the following discussion of subbaselines and components:\n\n         As a configuration gets large, it is often useful to break it\nup\n         into a set of smaller configurations that form the logical\n         \"components\" of that configuration.  In order to capture the\nfact\n         that a baseline of a configuration is logically extended by a\n         component configuration baseline, the component configuration\n         baseline is captured as a \"subbaseline\" of the baseline.\n\n         The root collection of a configuration is unconstrained with\n         respect to its relationship to the root collection of any ofits\n\n         components.  In particular, the root collection of a\nconfiguration\n         can have a member that is the root collection of one of its\n         components (e.g. configuration /sys/x can have a component\n         /sys/x/foo), can be a member of the root collection of one of\nits\n         components (e.g. configuration /sys/y/z can have a component\n         /sys/y), or neither (e.g. configuration /sys/x can have a\ncomponent\n         /comp/bar).\n\n\nMy understanding of the protocol is that a baseline does not record\nwhere in a namespace the root of the baseline should be located. The\nbaseline records the versions and relative names of members of the\nbaseline, i.e. it preserves a namespace where the baseline-collection is\nthe root of the namespace.\n\nI also thought that while a baseline can have subbaselines, this set of\nbaselines does not define where in a namespace each baseline should be\nplaced.\n\nGiven the DAV:baseline-controlled-collection-set property of a\nworkspace, I had assumed that the workspace acted as a namespace that\npreserved the relative name of the root of each baseline.\n\nSo, for example, to populate a new workspace from a workspace that\npublishes a set of baselines, the client would issue MKCOL and\nBASELINE_CONTROL requests to populate the new workspace with baselines\nchosen from, & as named in, the publishing workspace.\n\nHave I understood this right? Or is there something in the structure of\na baseline itself, that preserves the relative name of another baseline?\n\nI wondered if it was expected that a baseline implementation should\nrecord a \"baseline-binding\", where a baseline-binding is a (name,\nbaseline-history) pair. The baseline-collection, or any collection which\nis a member of the baseline-collection, would retain a baseline-binding\nif at the time the baseline was created the collection had an internal\nmember which was baseline-controlled.\n\nThen, on BASELINE-CONTROL of a collection in the new workspace from a\nbaseline, the server could restore a subbaseline  if the baseline\ncontains a baseline-binding for the baseline-history of the subbaseline.\nThe BASELINE-CONTROL method does not include a postcondition for\nsubbaselines, so I'm not sure if this would be compliant behaviour or\nnot.\n\nFinally, the cases where a subbaseline is located outside of the\nnamespace of the baseline (examples /sys/y/z +/sys/y and /sys/x +\n/comp/bar from above), would seem to rely on baseline-bindings being\npreserved in some other baseline (if the intention is to automate this),\nand being present in the target namespace of the operation.\n\nThanks,\nAlison.\n--\n -------------------------------------------------------------\n The statements and opinions expressed here are my own\n and do not necessarily represent those of Oracle Corporation.\n -------------------------------------------------------------\n\n\n\n", "id": "lists-006-16255825"}, {"subject": "RE: baselines &amp; namespace", "content": "   From: Alison Macmillan [mailto:alison.macmillan@oracle.com]\n\n   I've got a question to do with preserving the location in a\n   namespace of the root of a baseline.\n\n   Section 12 has the following discussion of subbaselines and components:\n\n     As a configuration gets large, it is often useful to break it up\n     into a set of smaller configurations that form the logical\n     \"components\" of that configuration.  In order to capture the fact\n     that a baseline of a configuration is logically extended by a\n     component configuration baseline, the component configuration\n     baseline is captured as a \"subbaseline\" of the baseline.\n\n     The root collection of a configuration is unconstrained with\n     respect to its relationship to the root collection of any of its\n     components.  In particular, the root collection of a\n     configuration can have a member that is the root collection of\n     one of its components (e.g. configuration /sys/x can have a\n     component /sys/x/foo), can be a member of the root collection of\n     one of its components (e.g. configuration /sys/y/z can have a\n     component /sys/y), or neither (e.g. configuration /sys/x can have\n     a component /comp/bar).\n\n   My understanding of the protocol is that a baseline does not record\n   where in a namespace the root of the baseline should be located.\n\nCorrect.\n\n   The baseline records the versions and relative names of members of\n   the baseline, i.e. it preserves a namespace where the\n   baseline-collection is the root of the namespace.\n\nCorrect.\n\n   I also thought that while a baseline can have subbaselines, this set of\n   baselines does not define where in a namespace each baseline should be\n   placed.\n\nCorrect.\n\n   Given the DAV:baseline-controlled-collection-set property of a\n   workspace, I had assumed that the workspace acted as a namespace that\n   preserved the relative name of the root of each baseline.\n   So, for example, to populate a new workspace from a workspace that\n   publishes a set of baselines, the client would issue MKCOL and\n   BASELINE_CONTROL requests to populate the new workspace with baselines\n   chosen from, & as named in, the publishing workspace.\n   Have I understood this right? Or is there something in the structure of\n   a baseline itself, that preserves the relative name of another baseline?\n\nIf a server supports version-controlled collections, and if\na version-controlled collection gave a name to a\nversion history, and that version history is the root of a \nsubbaseline, then that subbaseline is restored at that location.\nBut otherwise, no, the protocol does not require a server to\npreserve anything about the relative locations of subbaselines.\n\n   I wondered if it was expected that a baseline implementation should\n   record a \"baseline-binding\", where a baseline-binding is a (name,\n   baseline-history) pair. The baseline-collection, or any collection which\n   is a member of the baseline-collection, would retain a baseline-binding\n   if at the time the baseline was created the collection had an internal\n   member which was baseline-controlled.\n\nThis is automatically captured by version-controlled collections, but\nit certainly would be reasonable (although not required) for a server\nto support this even if it does not support version-controlled\ncollections (clients that expect version-controlled collections will\nexpect this kind of behavior).\n\n   Then, on BASELINE-CONTROL of a collection in the new workspace from a\n   baseline, the server could restore a subbaseline  if the baseline\n   contains a baseline-binding for the baseline-history of the subbaseline.\n   The BASELINE-CONTROL method does not include a postcondition for\n   subbaselines, so I'm not sure if this would be compliant behaviour or\n   not.\n\nIt is not required behavior unless the server supports version-controlled\ncollections, but it is certainly legal for a server to do so.\n\n   Finally, the cases where a subbaseline is located outside of the\n   namespace of the baseline (examples /sys/y/z +/sys/y and /sys/x +\n   /comp/bar from above), would seem to rely on baseline-bindings being\n   preserved in some other baseline (if the intention is to automate this),\n   and being present in the target namespace of the operation.\n\nYes.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-16266536"}, {"subject": "RE: Parallel Developmen", "content": "   From: Kirmse, Daniel [mailto:daniel.kirmse@sap.com]\n\n   Suppose a development environment where the development codeline is\n   kept in a workspace. Within this Workspace there is a VCR /DEV/a.c\n   the checked-in property points to version V1. Now there is a\n   checkout of the checked-in version of /DEV/a.c into a\n   working-resource WR1.\n\nI will assume this CHECKOUT was done by applying a CHECKOUT to\n/DEV/a.c, with the DAV:apply-to-version flag.  (As Tim points out,\nthis has slightly different behavior from explicitly applying the\nCHECKOUT to a version resource).\n\n   In my understanding of DeltaV the checked-in property of the VCR is\n   not changed by this action.\n\nCorrect.\n\n   Now another checkout of the checked-in version into a\n   working-resource WR2 is done (i.e. two developer working parallel\n   on the same source). Rigth so far?\n\nYes.  Again, I will assume that this was a CHECKOUT of /DEV/a.c with\nthe DAV:apply-to-version flag.\n\n   Now WR1 is checked in. WR1 disappears the version history (VH) of\n/DEV/a.c\n   contains a new version V2 that is a descendant of V1. In my understanding\n   the checked-in property of the VCR is set to V2 during this checkin.\nStill\n   right?\n\nYes, if WR1 resulted from checking out /DEV/a.c with the\nDAV:apply-to-version flag.\n\n   Now WR2 is checked in. Checkin fork is forbidden. Because there is a\n   descendent to V1 allready and the checkin fork is forbidden.\n\nActually, there is no need to have Checkin-fork to be forbidden\n(although it doesn't hurt to have it set to be that).  The\nDAV:no-overwrite-by-auto-update postcondition of CHECKIN will\nforce the CHECKIN to fail.\n\n   So a merge must be forced (how?).\n\nI'm not sure if you are asking \"how is it forced\" or \"how do you do\nthe merge\"?  It is forced, because every time you try to CHECKIN, it\nwill fail with the postcondition identified above.  The client does\nthe merge by downloading the current content of /DEV/a.c, merging that\ninto the content of WR2, and then adding the DAV:checked-in version to\nthe DAV:predecessor set of WR2.  Then the CHECKIN will succeed,\nbecause the DAV:overwrite-by-auto-update condition is no longer true.\n\n   After that done the checked-in property of the VCR points\n   to the merged version of V2 and the checked in version of WR2. Right?\n\nActually, the checked-in property of the VCR points to the version\nthat resulted from checking in WR2, where the content of WR2 is the\nmerge of the previous state of WR2 with the state of the checked-in\nversion of /DEV/a.c.\n\n\n   Background:\n   I have a development codeline. A file to edit is a VCR. I want the\n   possibility of two (or more) developers working parallel with this\n   file. But I want them to do a merge of their work at the second\n   checkin (the checkin of the first developer causes no\n   problems). And I want the VCR point to the most current checked-in\n   version of its VH automatically. Is this achieveable? I think it\n   must be, since this is what can be done using Perforce.\n\nYes, it is.  Just have the developers client apply CHECKOUT with\nDAV:apply-to-version to a version-controlled resource.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-16278202"}, {"subject": "REPORT metho", "content": "Hi !\n\nI'm reading some drafts about the Access Control Protocol and I've just discovered there was a REPORT method. Is it the same that the REPORT defined in DeltaV ? Why is this method present both in WebDAV and DeltaV documentations ?\n\nThanx\n\n\n\n", "id": "lists-006-16288476"}, {"subject": "Re: REPORT metho", "content": "\"Elodie Tasia\" <e.tasia@ever-team.com> wrote:\n\n> I'm reading some drafts about the Access Control  Protocol and I've\n> just discovered there was a REPORT method. Is it the same that  the\n> REPORT defined in DeltaV ? Why is this method present both in\n> WebDAV  and DeltaV documentations ?\n \nWell, it's got the same name, so I guess it is the same method<g>.\n\nIt is defined in both places because both specs were at the stage where, \ntechnically, could not be referenced from one another.  Rather than wait \nfor one to advance along the standards track and delay the other, it makes \nsense to include this duplication.\ni.e., just consider it the same method.\n\nTim.\n\n\n\n", "id": "lists-006-16295828"}, {"subject": "RE: Parallel Developmen", "content": "Hi,\n\ni've got this (at least I think so ;o) ). Now we advance a step further:\n\nSuppose this situation:\n\n\n    +--------+               +-------+               +--------+\n    |  VCR1  |               |  VH1  |               |  VCR2  |\n    +--------+               +-------+               +--------+\n    | CIN V2-+------+        |  V1   |      +--------+-CIN V2 |\n    +--------+      |        |   |   |      |        +--------+\n                    +--------+->V2 <-+------+           \n                             +-------+\n\nThe checked-in (CIN) versions of VCR1 and VCR2 are located in the very same\nVH and they are even the same version.\n\nNow same problem to checkouts on the same version via the VCR's. To be\nprecise there is a checkout on VCR1 with DAV:apply-to-version flag which\ncreates WR1 with DAV:auto-update = VCR1. And there is a checkout on VCR2\nwith DAV:apply-to-version flag which creates WR2 with DAV:auto-update =\nVCR2. Performing a checkin on both WR's would cause no failed checkin but\nproduces this situation:\n\n    +--------+               +-------+               +--------+\n    |  VCR1  |               |  VH1  |               |  VCR2  |\n    +--------+               +-------+               +--------+\n    | CIN V3-+------+        |  V1   |      +--------+-CIN V4 |\n    +--------+      |        |   |   |      |        +--------+\n                    |        |  V2   |      |            \n                    |        |  / \\  |      |\n                    +--------+>V3 V4<+------+\n                             +-------+\n\nAm I right with this? Please let me be! Otherwise I should give up trying to\nunderstand this (at least for this week) ! ;o)\n\nP.S.: Obviously there MUST NOT be any DAV:checkin-fork forbidden property at\nV2.\n\nRegards,\nDaniel\n>-----Original Message-----\n>From: Clemm, Geoff [mailto:gclemm@rational.com]\n>Sent: Freitag, 14. Dezember 2001 05:56\n>To: Ietf-Dav-Versioning (E-mail)\n>Subject: RE: Parallel Development\n>\n>\n>   From: Kirmse, Daniel [mailto:daniel.kirmse@sap.com]\n>\n>   Suppose a development environment where the development codeline is\n>   kept in a workspace. Within this Workspace there is a VCR /DEV/a.c\n>   the checked-in property points to version V1. Now there is a\n>   checkout of the checked-in version of /DEV/a.c into a\n>   working-resource WR1.\n>\n>I will assume this CHECKOUT was done by applying a CHECKOUT to\n>/DEV/a.c, with the DAV:apply-to-version flag.  (As Tim points out,\n>this has slightly different behavior from explicitly applying the\n>CHECKOUT to a version resource).\n>\n>   In my understanding of DeltaV the checked-in property of the VCR is\n>   not changed by this action.\n>\n>Correct.\n>\n>   Now another checkout of the checked-in version into a\n>   working-resource WR2 is done (i.e. two developer working parallel\n>   on the same source). Rigth so far?\n>\n>Yes.  Again, I will assume that this was a CHECKOUT of /DEV/a.c with\n>the DAV:apply-to-version flag.\n>\n>   Now WR1 is checked in. WR1 disappears the version history (VH) of\n>/DEV/a.c\n>   contains a new version V2 that is a descendant of V1. In my \n>understanding\n>   the checked-in property of the VCR is set to V2 during this checkin.\n>Still\n>   right?\n>\n>Yes, if WR1 resulted from checking out /DEV/a.c with the\n>DAV:apply-to-version flag.\n>\n>   Now WR2 is checked in. Checkin fork is forbidden. Because there is a\n>   descendent to V1 allready and the checkin fork is forbidden.\n>\n>Actually, there is no need to have Checkin-fork to be forbidden\n>(although it doesn't hurt to have it set to be that).  The\n>DAV:no-overwrite-by-auto-update postcondition of CHECKIN will\n>force the CHECKIN to fail.\n>\n>   So a merge must be forced (how?).\n>\n>I'm not sure if you are asking \"how is it forced\" or \"how do you do\n>the merge\"?  It is forced, because every time you try to CHECKIN, it\n>will fail with the postcondition identified above.  The client does\n>the merge by downloading the current content of /DEV/a.c, merging that\n>into the content of WR2, and then adding the DAV:checked-in version to\n>the DAV:predecessor set of WR2.  Then the CHECKIN will succeed,\n>because the DAV:overwrite-by-auto-update condition is no longer true.\n>\n>   After that done the checked-in property of the VCR points\n>   to the merged version of V2 and the checked in version of \n>WR2. Right?\n>\n>Actually, the checked-in property of the VCR points to the version\n>that resulted from checking in WR2, where the content of WR2 is the\n>merge of the previous state of WR2 with the state of the checked-in\n>version of /DEV/a.c.\n>\n>\n>   Background:\n>   I have a development codeline. A file to edit is a VCR. I want the\n>   possibility of two (or more) developers working parallel with this\n>   file. But I want them to do a merge of their work at the second\n>   checkin (the checkin of the first developer causes no\n>   problems). And I want the VCR point to the most current checked-in\n>   version of its VH automatically. Is this achieveable? I think it\n>   must be, since this is what can be done using Perforce.\n>\n>Yes, it is.  Just have the developers client apply CHECKOUT with\n>DAV:apply-to-version to a version-controlled resource.\n>\n>Cheers,\n>Geoff\n>\n\n\n\n", "id": "lists-006-16304308"}, {"subject": "RE: Parallel Developmen", "content": "Right on!\nYour description is correct.\n\nRegards,\nTim\n\n\n\n\n\"Kirmse, Daniel\" <daniel.kirmse@sap.com>\nSent by: ietf-dav-versioning-request@w3.org\n2001-12-14 11:39 AM\n\n \n        To:     \"Ietf-Dav-Versioning (E-mail)\" <ietf-dav-versioning@w3.org>\n        cc: \n        Subject:        RE: Parallel Development\n\n \n\n\nHi,\n\ni've got this (at least I think so ;o) ). Now we advance a step further:\n\nSuppose this situation:\n\n\n    +--------+               +-------+               +--------+\n    |  VCR1  |               |  VH1  |               |  VCR2  |\n    +--------+               +-------+               +--------+\n    | CIN V2-+------+        |  V1   |      +--------+-CIN V2 |\n    +--------+      |        |   |   |      |        +--------+\n                    +--------+->V2 <-+------+\n                             +-------+\n\nThe checked-in (CIN) versions of VCR1 and VCR2 are located in the very \nsame\nVH and they are even the same version.\n\nNow same problem to checkouts on the same version via the VCR's. To be\nprecise there is a checkout on VCR1 with DAV:apply-to-version flag which\ncreates WR1 with DAV:auto-update = VCR1. And there is a checkout on VCR2\nwith DAV:apply-to-version flag which creates WR2 with DAV:auto-update =\nVCR2. Performing a checkin on both WR's would cause no failed checkin but\nproduces this situation:\n\n    +--------+               +-------+               +--------+\n    |  VCR1  |               |  VH1  |               |  VCR2  |\n    +--------+               +-------+               +--------+\n    | CIN V3-+------+        |  V1   |      +--------+-CIN V4 |\n    +--------+      |        |   |   |      |        +--------+\n                    |        |  V2   |      |\n                    |        |  / \\  |      |\n                    +--------+>V3 V4<+------+\n                             +-------+\n\nAm I right with this? Please let me be! Otherwise I should give up trying \nto\nunderstand this (at least for this week) ! ;o)\n\nP.S.: Obviously there MUST NOT be any DAV:checkin-fork forbidden property \nat\nV2.\n\nRegards,\nDaniel\n>-----Original Message-----\n>From: Clemm, Geoff [mailto:gclemm@rational.com]\n>Sent: Freitag, 14. Dezember 2001 05:56\n>To: Ietf-Dav-Versioning (E-mail)\n>Subject: RE: Parallel Development\n>\n>\n>   From: Kirmse, Daniel [mailto:daniel.kirmse@sap.com]\n>\n>   Suppose a development environment where the development codeline is\n>   kept in a workspace. Within this Workspace there is a VCR /DEV/a.c\n>   the checked-in property points to version V1. Now there is a\n>   checkout of the checked-in version of /DEV/a.c into a\n>   working-resource WR1.\n>\n>I will assume this CHECKOUT was done by applying a CHECKOUT to\n>/DEV/a.c, with the DAV:apply-to-version flag.  (As Tim points out,\n>this has slightly different behavior from explicitly applying the\n>CHECKOUT to a version resource).\n>\n>   In my understanding of DeltaV the checked-in property of the VCR is\n>   not changed by this action.\n>\n>Correct.\n>\n>   Now another checkout of the checked-in version into a\n>   working-resource WR2 is done (i.e. two developer working parallel\n>   on the same source). Rigth so far?\n>\n>Yes.  Again, I will assume that this was a CHECKOUT of /DEV/a.c with\n>the DAV:apply-to-version flag.\n>\n>   Now WR1 is checked in. WR1 disappears the version history (VH) of\n>/DEV/a.c\n>   contains a new version V2 that is a descendant of V1. In my\n>understanding\n>   the checked-in property of the VCR is set to V2 during this checkin.\n>Still\n>   right?\n>\n>Yes, if WR1 resulted from checking out /DEV/a.c with the\n>DAV:apply-to-version flag.\n>\n>   Now WR2 is checked in. Checkin fork is forbidden. Because there is a\n>   descendent to V1 allready and the checkin fork is forbidden.\n>\n>Actually, there is no need to have Checkin-fork to be forbidden\n>(although it doesn't hurt to have it set to be that).  The\n>DAV:no-overwrite-by-auto-update postcondition of CHECKIN will\n>force the CHECKIN to fail.\n>\n>   So a merge must be forced (how?).\n>\n>I'm not sure if you are asking \"how is it forced\" or \"how do you do\n>the merge\"?  It is forced, because every time you try to CHECKIN, it\n>will fail with the postcondition identified above.  The client does\n>the merge by downloading the current content of /DEV/a.c, merging that\n>into the content of WR2, and then adding the DAV:checked-in version to\n>the DAV:predecessor set of WR2.  Then the CHECKIN will succeed,\n>because the DAV:overwrite-by-auto-update condition is no longer true.\n>\n>   After that done the checked-in property of the VCR points\n>   to the merged version of V2 and the checked in version of\n>WR2. Right?\n>\n>Actually, the checked-in property of the VCR points to the version\n>that resulted from checking in WR2, where the content of WR2 is the\n>merge of the previous state of WR2 with the state of the checked-in\n>version of /DEV/a.c.\n>\n>\n>   Background:\n>   I have a development codeline. A file to edit is a VCR. I want the\n>   possibility of two (or more) developers working parallel with this\n>   file. But I want them to do a merge of their work at the second\n>   checkin (the checkin of the first developer causes no\n>   problems). And I want the VCR point to the most current checked-in\n>   version of its VH automatically. Is this achieveable? I think it\n>   must be, since this is what can be done using Perforce.\n>\n>Yes, it is.  Just have the developers client apply CHECKOUT with\n>DAV:apply-to-version to a version-controlled resource.\n>\n>Cheers,\n>Geoff\n>\n\n\n\n", "id": "lists-006-16317282"}, {"subject": "BASELINE-CONTRO", "content": "HI,\n\nnext topic (looks like after I'm done with all my questions we could write a\nbook called \"DeltaV for Dummies - A virtual reality dialogue\" :o)), anyway.\n\nSituation:\n\n     +----------------+                        +-------------------+\n     | WS /DEV        |<-------------------+   | VCC1  /repo/vcc/1 |\n     +----------------+                    |   +-------------------+\n     |                |       +-------+    +---+DAV:bline-cntrl-col|\n     |   +--------+   |       |  VH1  |        +-------------------+\n     |   |  VCR1  |   |       +-------+        |DAV:checked-in     +------+\n     |   +--------+   |       |   V1 <+-----+  +-------------------+      |\n     |   | CIN V2-+---+---+   |   |   |     |  |DAV:version-history+--+   |\n     |   +--------+   |   +---+-> V2 <+--+  |  +-------------------+  |   |\n     |                |       +-------+  |  |                         |   |\n     +----------------+                  |  |  +-------------------+  |   |\n                                         |  |  | BLH /repo/blh/1   |<-+   |\n                                         |  |  +-------------------+      |\n                                         |  |  |DAV:version-set    +--+-+ |\n                                         |  |  +-------------------+  | | |\n                                         |  |                         | | |\n                                         |  |  +-------------------+  | | |\n                                         |  +--+ BL /repo/blh/1/v1 |<-+ | |\n                                         |     +-------------------+    | |\n                                         |                              | |\n                                         |     +-------------------+    | |\n                                         +-----+ BL /repo/blh/1/v2 |<---+-+\n                                               +-------------------+    \n                                               \n\n\nThe Worksapce precise /DEV is under BASELINE-CONTROL. V2 of VCR1 is captured\nin V2 of the VCC1 (Baseline /repo/blh/1/v2). Now a new workspace /CONS is\ncreated and put under BASELINE-CONTROL that way:\n\nMKWORKSPACE /CONS\n\nBASELINE-CONTROL /src HTTP/1.1 \nHost: www.webdav.org\nContent-Type: text/xml; charset=\"utf-8\"\nContent-Length: xxxx\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:baseline-control xmlns:D=\"DAV:\">\n  <D:href>http://.../repo/blh/1/V2</D:href>\n</D:baseline-control>\n\n(see DeltaV 12.6.1)\n\nWell what happens to /CONS is explained in 12.6.1 of DeltaV. But take a look\nat VCR1. Am I right that the copy of VCR1 in /CONS (VCR2) points to V2 of\nVCR1 in VH1 to? Or is there a new VH for VCR2 and there is no connection\nbetween VCR1 and VCR2. My understanding would be that VCR1 and VCR2 sharing\nthe same VH. (At least this is what suits me and my application best)\n\nBAckground:\nI have a software project under development. The Sourcetree is originally\nlocated in workspace /DEV. /DEV is under baseline-control. At some time in\nfuture I will close development and set up a consolidation codeline. This\nconsolidation codeline is placed into workspace /CONS using the reference to\na baseline of /DEV to populate it with the then closed development codeline.\nAs far as I understand this /DEV and /CONS are VCC's on their own and have\ndistinct baseline-histories. \nWhat I want to achieve is, that the changes applied to my sources via the\nVCR's in /CONS should be a branch/fork of the version-tree/history of the\ncorresponding VCR in /DEV.\n\n\nRegards,\nDaniel\n\n\n\n", "id": "lists-006-16331101"}, {"subject": "RE: [ACL] RE: lock and access control lists on (working) version", "content": "I think he wants a version-independent ACL to be the 'real' ACL but he\nwants a historical record of the ACL.\n\nI would not like to retain historical ACL lists.  Let alone create new\nversions because the ACL list kept changing.\n\nIt seems that Yaron's scenario would be better served by a historical\nlog of who had accessed a particular item, stored in a manner that was\npermanent.  After all, you want to know if the spy read it, not if he\ncould have read it.\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Eric Sedlar\nSent: Tuesday, June 12, 2001 3:45 PM\nTo: Yaron Goland; Clemm, Geoff; ietf-dav-versioning@w3.org\nCc: acl@webdav.org\nSubject: RE: [ACL] RE: lock and access control lists on (working)\nversions\n\n\nIsn't \"the ACL list it currently uses to decide who gets to see the\nversion\" the ACL on the version history resource, or is what you want a\nversion- independent ACL that applies to all versions of a resource,\nthat can override the ACL on that particular version?\n\n> -----Original Message-----\n> From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of \n> Yaron Goland\n> Sent: Tuesday, June 12, 2001 2:29 PM\n> To: Clemm, Geoff; ietf-dav-versioning@w3.org\n> Cc: acl@webdav.org\n> Subject: RE: [ACL] RE: lock and access control lists on (working) \n> versions\n>\n>\n> When I version a resource I will also likely want to version the \n> access control list it had when I 'froze' it. This is very important \n> for things like security checks. Imagine that an employee who was \n> fired a year ago turned out to be a corporate spy, you are going to \n> want to check what resources he had access to back then. This means \n> that a version really needs two sets of ACLs. One if the ACL list it \n> had when it was frozen. The other is the ACL list it currently uses to\n\n> decide who gets to see the version.\n>\n> > -----Original Message-----\n> > From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n\n> > Clemm, Geoff\n> > Sent: Saturday, May 26, 2001 8:27 AM\n> > To: ietf-dav-versioning@w3.org\n> > Cc: acl@webdav.org\n> > Subject: [ACL] RE: lock and access control lists on (working) \n> > versions\n> >\n> >\n> > As Tim surmised, the answer to (1) is in fact \"yes\".\n> > Each version is a separate resource, and each resource\n> > can have its own distinct access control list.\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n> > Sent: Wednesday, May 16, 2001 5:42 AM\n> > To: ietf-dav-versioning@w3.org\n> > Cc: acl@webdav.org\n> > Subject: Re: lock and access control lists on (working) versions\n> >\n> >\n> >\n> >\n> > \"Pill, Juergen\" <Juergen.Pill@softwareag.com>\n> > > Hello,\n> > >\n> > > 1) Would it be possible with DETA-V to have different access\n> > control list\n> > > for different versions of a resource, e.g. V1 of resource /foo\n> > will allow\n> > > user A to modify and read, but V2 of resource /foo will allow\n> user A to\n> > read\n> > > read only?\n> >\n> > You'd have to ask the ACL-folk that question, but I would sincerely \n> > hope the answer is 'yes'.\n> >\n> > > 2) Would it be possible to have two distinct locks on two \n> > > different\n> > > (working) resources?\n> >\n> > Yes.  Working resources have distinct server-defined URLs.  They can\n\n> > be locked using their URLs just like any other resource.\n> >\n> > > Does that make sense at all?\n> >\n> > Yep.\n> >\n> > Tim\n> >\n> >\n> > _______________________________________________\n> > acl mailing list\n> > acl@webdav.org http://mailman.webdav.org/mailman/listinfo/acl\n> >\n>\n>\n>\n>\n> _______________________________________________\n> acl mailing list\n> acl@webdav.org\n> http://mailman.webdav.org/mailman/listinfo/acl\n>\n\n\n\n", "id": "lists-006-1633393"}, {"subject": "Re: BASELINE-CONTRO", "content": "\"Kirmse, Daniel\" <daniel.kirmse@sap.com> wrote:\n\n> next topic (looks like after I'm done with all my\n> questions we could write a book called \"DeltaV for\n> Dummies - A virtual reality dialogue\" :o)), anyway.\n\nI appreciate you taking time to raise these questions.  They're far from \n'dummy' questions, too.  I'd encourage you to contribute to the FAQ \n(http://www.webdav.org/deltav/faq) all that you have learned that you felt \nwas not well described by the specification.\n\n> Situation:\n> \n>   +----------------+                        +-------------------+\n>   | WS /DEV        |<-------------------+   | VCC1  /repo/vcc/1 |\n>   +----------------+                    |   +-------------------+\n>   |                |       +-------+    +---+DAV:bline-cntrl-col|\n>   |   +--------+   |       |  VH1  |        +-------------------+\n>   |   |  VCR1  |   |       +-------+        |DAV:checked-in     +------+\n>   |   +--------+   |       |   V1 <+-----+  +-------------------+      |\n>   |   | CIN V2-+---+---+   |   |   |     |  |DAV:version-history+--+   |\n>   |   +--------+   |   +---+-> V2 <+--+  |  +-------------------+  |   |\n>   |                |       +-------+  |  |                         |   |\n>   +----------------+                  |  |  +-------------------+  |   |\n>                                       |  |  | BLH /repo/blh/1   |<-+   |\n>                                       |  |  +-------------------+      |\n>                                       |  |  |DAV:version-set    +--+-+ |\n>                                       |  |  +-------------------+  | | |\n>                                       |  |                         | | |\n>                                       |  |  +-------------------+  | | |\n>                                       |  +--+ BL /repo/blh/1/v1 |<-+ | |\n>                                       |     +-------------------+    | |\n>                                       |                              | |\n>                                       |     +-------------------+    | |\n>                                       +-----+ BL /repo/blh/1/v2 |<---+-+\n>                                             +-------------------+\n> \n\nI'm confused by this diagram, what are the arrows that are going from the \nbaseline(s) to the version(s)?  You did not give then a property name so I \ncannot guess what they are.  Maybe you are thinking of the \nDAV:baseline-collection? In which case this is not in the version history \nas you depict.\n\nFurthermore, I don't see what the relationship is between /DEV and VCR1? \nSo let's assume that VCR1 is called /DEV/foo\n\n> The Worksapce precise /DEV is under BASELINE-CONTROL. V2 of\n> VCR1 is captured in V2 of the VCC1 (Baseline /repo/blh/1/v2).\n> Now a new workspace /CONS is created and put under\n> BASELINE-CONTROL that way:\n> \n>         MKWORKSPACE /CONS\n> \n>                 BASELINE-CONTROL /src HTTP/1.1\n>                 Host: www.webdav.org\n>                 Content-Type: text/xml; charset=\"utf-8\"\n>                 Content-Length: xxxx\n> \n>                 <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n>                 <D:baseline-control xmlns:D=\"DAV:\">\n>                   <D:href>http://.../repo/blh/1/V2</D:href>\n>                 </D:baseline-control>\n> \n>         (see DeltaV 12.6.1)\n> \n> Well what happens to /CONS is explained in 12.6.1 of DeltaV.\n> But take a look at VCR1. Am I right that the copy of VCR1\n> in /CONS (VCR2) points to V2 of VCR1 in VH1 to? Or is there\n> a new VH for VCR2 and there is no connection between VCR1\n> and VCR2. My understanding would be that VCR1 and VCR2\n> sharing the same VH. (At least this is what suits me and\n> my application best)\n\nI'm confused.  Perhaps you can restate the problem, answering my questions \nabove, and I'll try again.\n\n> BAckground:\n> I have a software project under development. The Sourcetree\n> is originally located in workspace /DEV. /DEV is under\n> baseline-control. At some time in future I will close\n> development and set up a consolidation codeline. This\n> consolidation codeline is placed into workspace /CONS using\n> the reference to a baseline of /DEV to populate it with\n> the then closed development codeline.  As far as I\n> understand this /DEV and /CONS are VCC's on their own and\n> have distinct baseline-histories.\n> What I want to achieve is, that the changes applied to my\n> sources via the VCR's in /CONS should be a branch/fork of\n> the version-tree/history of the corresponding VCR in /DEV.\n\nOne way to do this is to create the consolidation workspace and bring it \nunder baseline control.  Then create /DEV, /DEV1, etc as required and \nbring them under baseline control specifying an existing baseline of /DAV \nin the body of the reuest (as you showed above).  This will initialize the \n/DAV workspace to contain version-controlled members whose DAV:checked-in \nversions and relative names are as captured in the baseline of /CONS.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-16341893"}, {"subject": "RE: BASELINE-CONTRO", "content": "Yes, VCR2 would have the same DAV:checked-in version and the\nsame DAV:version-history as VCR1.  You are using this feature\nexactly the way it was intended to be used.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Kirmse, Daniel [mailto:daniel.kirmse@sap.com]\nSent: Friday, December 14, 2001 9:32 AM\nTo: Ietf-Dav-Versioning (E-mail)\nSubject: BASELINE-CONTROL\n\n\nHI,\n\nnext topic (looks like after I'm done with all my questions we could write a\nbook called \"DeltaV for Dummies - A virtual reality dialogue\" :o)), anyway.\n\nSituation:\n\n     +----------------+                        +-------------------+\n     | WS /DEV        |<-------------------+   | VCC1  /repo/vcc/1 |\n     +----------------+                    |   +-------------------+\n     |                |       +-------+    +---+DAV:bline-cntrl-col|\n     |   +--------+   |       |  VH1  |        +-------------------+\n     |   |  VCR1  |   |       +-------+        |DAV:checked-in     +------+\n     |   +--------+   |       |   V1 <+-----+  +-------------------+      |\n     |   | CIN V2-+---+---+   |   |   |     |  |DAV:version-history+--+   |\n     |   +--------+   |   +---+-> V2 <+--+  |  +-------------------+  |   |\n     |                |       +-------+  |  |                         |   |\n     +----------------+                  |  |  +-------------------+  |   |\n                                         |  |  | BLH /repo/blh/1   |<-+   |\n                                         |  |  +-------------------+      |\n                                         |  |  |DAV:version-set    +--+-+ |\n                                         |  |  +-------------------+  | | |\n                                         |  |                         | | |\n                                         |  |  +-------------------+  | | |\n                                         |  +--+ BL /repo/blh/1/v1 |<-+ | |\n                                         |     +-------------------+    | |\n                                         |                              | |\n                                         |     +-------------------+    | |\n                                         +-----+ BL /repo/blh/1/v2 |<---+-+\n                                               +-------------------+    \n                                               \n\n\nThe Worksapce precise /DEV is under BASELINE-CONTROL. V2 of VCR1 is captured\nin V2 of the VCC1 (Baseline /repo/blh/1/v2). Now a new workspace /CONS is\ncreated and put under BASELINE-CONTROL that way:\n\nMKWORKSPACE /CONS\n\nBASELINE-CONTROL /src HTTP/1.1 \nHost: www.webdav.org\nContent-Type: text/xml; charset=\"utf-8\"\nContent-Length: xxxx\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:baseline-control xmlns:D=\"DAV:\">\n  <D:href>http://.../repo/blh/1/V2</D:href>\n</D:baseline-control>\n\n(see DeltaV 12.6.1)\n\nWell what happens to /CONS is explained in 12.6.1 of DeltaV. But take a look\nat VCR1. Am I right that the copy of VCR1 in /CONS (VCR2) points to V2 of\nVCR1 in VH1 to? Or is there a new VH for VCR2 and there is no connection\nbetween VCR1 and VCR2. My understanding would be that VCR1 and VCR2 sharing\nthe same VH. (At least this is what suits me and my application best)\n\nBAckground:\nI have a software project under development. The Sourcetree is originally\nlocated in workspace /DEV. /DEV is under baseline-control. At some time in\nfuture I will close development and set up a consolidation codeline. This\nconsolidation codeline is placed into workspace /CONS using the reference to\na baseline of /DEV to populate it with the then closed development codeline.\nAs far as I understand this /DEV and /CONS are VCC's on their own and have\ndistinct baseline-histories. \nWhat I want to achieve is, that the changes applied to my sources via the\nVCR's in /CONS should be a branch/fork of the version-tree/history of the\ncorresponding VCR in /DEV.\n\n\nRegards,\nDaniel\n\n\n\n", "id": "lists-006-16354387"}, {"subject": "Re[2]: Re (2): Creating new version-controlled bindings referencing   existing  VHR'", "content": "Sorry, I have one more question about this topic:\nIf I do UPDATE on version-controlled-collection in some workspace,\nwhat should I do with version-controlled resource - members of this\ncollection. Version of version-controlled-collection contains bindings\n<name, version-history>. Workspace provides binding of version-history\nto versioned-resource. If version of version-controlled-collections\nis changed by UPDATE, what should I do with versioned-resources, which\nvresion-histories are no more members of this collection? Delete?\n\nMore interesting - what should I do with new members, i.e. version\nhistories of which were not in bindings of previous version of\ncollection. Should I create versioned-resource to provide\n<workspace,version-history> -> versioned-resource binding?\nBut which version should this versioned-resource select by\ncheckedIn/checkedOut property? Once again, UPDATE source is version\nand there is no information about source workspace.\n\nLooks like it is once again up to the server which version to choose?\nWell, for me it means that UPDATE should not be used at all for\nversion-controlled collections because result is unspecified.\nBut UPDATE is is special case of MERGE (if MERGE target is successor\nof MERGE source). Does it mean that I also can not use MERGE to\ncorrectly merge two versions of version-controlled-collection\n(belonging to the same version history)?\nIn any case I think that answer for these questions should be included\nin specification, because it is not behavior of\nMERGE/UPDATE/VERSION-CONTROL methods\napplied to version-controlled-collection in a workspace is not\nobvious (at least for me).\n\n\n\nWednesday, December 12, 2001, 4:09:30 AM, you wrote:\n\nCG>    From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\n\nCG>    So the only way to do it - is to place source collection under\nCG>    baseline control???\n\nCG> If you want to recreate a previous state of the source collection\nCG> from history, yes.  A baseline is the \"deep-version\" of a collection\nCG> that captures the state of all members of the collection.  You can\nCG> think of it as a set of versions (i.e. one version of each\nCG> version-controlled\nCG> resource in the collection, including each version-controlled collection).\n\nCG>    But what is the result of applying VERSION-CONTROL method with\nCG>    <DAV:version> refers to version-controlled-collection? It will create\nCG>    version-controlled resource in the target workspace for this collection\nCG>    iself but not for its members, right?\n\nCG> If there already is a version selected by that workspace for a given\nCG> version history, then that version is selected.  Otherwise, it is\nCG> server defined (e.g. a server could just pick the initial version,\nCG> the latest version, or some random version).\n\nCG>    What in this case is the result of PROPFIND\nCG>    with Depth=infinite applied to such version-controled-resource?\n\nCG> Depends on what version the server selected.\n\nCG>    Is there any good motivation for restricting VERSION-CONTROL source to\nCG>    be a version and not a version-controlled-resource, which capture\nCG>    information about the resource version and workspace to which it\nCG>    belongs?  \n\nCG> Yes, the rationale is in the protocol document in the section on\nCG> version-controlled collections.  The collection version is used for\nCG> activity change set information, to capture the delta between a\nCG> previous version of that part of the namespace.  But the bottom line\nCG> is that if you want a version of the whole tree, you use a baseline,\nCG> and if you want incremental information about the namespace you use a\nCG> collection version.\n\nCG>    It seems to me that the current model of version-control method for\nCG>    existed version history is contradicting and not clear...\nCG>    If the only way of importing information in workspace from other\nCG>    workspaces is baseline, then we should prohibit version-control method\nCG>    for existed version history at all. Otherwise, version-control method\nCG>    should be able to correctly place the whole specified subtree in the\nCG>    target workspace.\n\nCG> A collection version and a baseline address different use cases.  It\nCG> appears that your use cases are addressed by the baseline feature, and\nCG> so that is the one you would use.  Why would you want another feature\nCG> (version-controlled collections) to do the same thing?\n\nCG> Cheers,\nCG> Geoff\n\n\n\n-- \nBest regards,\n Konstantin                            mailto:KKnizhnik@togetherlab.com\n\n\n\n", "id": "lists-006-16365828"}, {"subject": "RE: Re[4]: Re (2): Creating new version-controlled bindings refer  encing   existing  VHR'", "content": "No, creating no VCR is not legal (i.e. you must create the VCR).\nIf there is a VCR there, the client can update it to see a better\nversion than the one the server picked for it, but if no VCR was\ncreated, the client is stuck with a \"bad\" namespace.\n\nI hope it's OK that I posted this back to the deltav mailing list -\nit is a good question.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\nSent: Friday, December 14, 2001 1:08 PM\nTo: Clemm, Geoff\nSubject: Re[4]: Re (2): Creating new version-controlled bindings refer\nencing existing VHR's\n\n\n\nIs it a valid \"server-defined behavior\" to select no version at all?\nI.e. not create version-controlled resource for collection member in\nMERGE/UPDATE/VERSION-CONTROL methods when member version is not\nspecified? (and it can not be specified in UPDATE/VERSION-CONTROL\nmethods according to specification)\nBecause other policies (choosing initial, random or most recent\nversion seems to be no more useful). If version selected in such case\nis not defined by specification, it means that client should not make an\nassumption about which version will be chosen. So, is there any sense in\ncreating versioned-resource for such ember?\n\n\nFriday, December 14, 2001, 8:47:40 PM, you wrote:\n\nCG>    From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\n\nCG>    If I do UPDATE on version-controlled-collection in some workspace,\nCG>    what should I do with version-controlled resource - members of this\nCG>    collection. Version of version-controlled-collection contains\nCG>    bindings <name, version-history>. Workspace provides binding of\nCG>    version-history to versioned-resource. If version of\nCG>    version-controlled-collections is changed by UPDATE, what should I\nCG>    do with versioned-resources, which vresion-histories are no more\nCG>    members of this collection? Delete?\n\nCG> Yes.  This is defined in the\nCG> DAV:update-version-controlled-collection-members postcondition from\nCG> section 14.11 (Additional MERGE and UPDATE semantics for\nCG> version-controlled collections).\n\nCG>    More interesting - what should I do with new members, i.e. version\nCG>    histories of which were not in bindings of previous version of\nCG>    collection. Should I create versioned-resource to provide\nCG>    <workspace,version-history> -> versioned-resource binding?\n\nCG> Yes.\n\nCG>    But which version should this versioned-resource select by\nCG>    checkedIn/checkedOut property? Once again, UPDATE source is version\nCG>    and there is no information about source workspace.\nCG>    Looks like it is once again up to the server which version to choose?\n\nCG> Yes.\n\nCG>    Well, for me it means that UPDATE should not be used at all for\nCG>    version-controlled collections because result is unspecified.\n\nCG> UPDATE is much less common than MERGE, and even less common in the\nCG> case of version-controlled collections - you would much more likely be\nCG> updating a baseline controlled collection with a new baseline, rather\nCG> than updating an individual version-controlled collection.\n\nCG>    But UPDATE is is special case of MERGE (if MERGE target is successor\nCG>    of MERGE source).\n\nCG> No, MERGE is much more flexible than UPDATE.  In particular, you\nCG> commonly MERGE a collection of version controlled resources (as\nCG> opposed to an individual collection version), or you MERGE an\nCG> activity.  In the first case, the MERGE of a collection merges all of\nCG> the members of the collection as well.  In the case of MERGE of an\nCG> activity, if the activity created a new version of collection that has\nCG> a new version history in it, the activity probably also has the\nCG> initial version of that version history in it as well.\n\nCG>    Does it mean that I also can not use MERGE to\nCG>    correctly merge two versions of version-controlled-collection\nCG>    (belonging to the same version history)?\n\nCG> You can, but it probably will be occurring in the context of\nCG> a more general activity or VCR collection merge.\n\nCG>    In any case I think that answer for these questions should be\nincluded\nCG>    in specification, because it is not behavior of\nCG>    MERGE/UPDATE/VERSION-CONTROL methods\nCG>    applied to version-controlled-collection in a workspace is not\nCG>    obvious (at least for me).\n\nCG> I believe it is \"well-defined\" in the spec, but I agree that it is\nCG> not \"obvious\".  Unfortunately, it is not always clear how to make\nCG> something obvious (since it is so reader-dependent), but we need to\nCG> get appropriate entries into the FAQ to address this.\n\nCG> Cheers,\nCG> Geoff\n\n\n\n-- \nBest regards,\n Konstantin                            mailto:KKnizhnik@togetherlab.com\n\n\n\n", "id": "lists-006-16378916"}, {"subject": "BASELINE-COLLECTION Propert", "content": "Hi,\n\nanother question I'll add to the faq soon:\n\nI don't think I've got an understanding of what this means:\n\n12.3.1 DAV:baseline-collection (protected)\nThis property contains a server-defined URL for a collection, where\neach member of this collection MUST either be a version-controlled resource\nwith the same DAV:checked-in version and relative name as a\nversion-controlled member of the baseline-controlled collection at the time\nthe baseline was created, or be a collection needed to provide the relative\nname for a version-controlled resource.\n<!ELEMENT baseline-collection (href)>\n\nSuppose a collection /DEV under basline-control. This collection has a\nmember collection /src and the latter has a member source.c. Is it right to\nundersatnd it that way that the baseline-collection property of a baseline\nof the VCC tracking /DEV contains a copy of the tree rooted of /DEV (except\nfor those memebers tracked by another VCC) at the moment the snapshot was\ndone? \nWell was this sentence really more understandable than the definition above?\n\nRegards,\nDaniel\n\n\n\n", "id": "lists-006-16392001"}, {"subject": "Re: BASELINE-COLLECTION Propert", "content": "\"Kirmse, Daniel\" <daniel.kirmse@sap.com> wrote:\n\n> I don't think I've got an understanding of what this means:\n> \n> 12.3.1 DAV:baseline-collection (protected)\n>         This property contains a server-defined URL for a\n> collection, where each member of this collection MUST\n> either be a version-controlled resource with the same\n> DAV:checked-in version and relative name as a version-\n> controlled member of the baseline-controlled collection\n> at the time the baseline was created, or be a collection\n> needed to provide the relative name for a version-\n> controlled resource.\n>         <!ELEMENT baseline-collection (href)>\n\nThe DAV:baseline-collection is a mechanism for 'viewing' the contents of a \nbaseline without 'restoring' it.\n\nA baseline resource is not a collection, it is a blob that captures the \nstate of version-controlled resources in a configuration.  However, it is \nuseful to be able to see which (version-controlled) resources were \ncaptured by the baseline, and that is provided by the \nDAV:baseline-collection.\n\nThe DAV:baseline-collection will appear exactly the same as the \n(version-controlled resources in the) configuration that was baselined. \nSince there may be collections that are not version-controlled, whose \nmembers _are_ version-controlled, it may be necessary to include \n'place-holder' collections in the DAV:baseline-collection to ensure that \nall the version-controlled resources appear at the correct relative name.\n\n> Suppose a collection /DEV under basline-control. This\n> collection has a member collection /src and the latter\n> has a member source.c.\n\nOk, /DAV/src/source.c\n\n> Is it right to undersatnd it that\n> way that the baseline-collection property of a baseline\n> of the VCC tracking /DEV contains a copy of the tree\n> rooted of /DEV (except for those memebers tracked by\n> another VCC) at the moment the snapshot was done?\n\nYes, again, provided they are themselves version-controlled.\n\nSo if\n/DAV/ is baseline controlled but not version-controlled,\n/DAV/src/ is not version-controlled,\n/DAV/src/source.c _is_ version-controlled.\n\nThen a baseline of /DAV/ will have a baseline-collection with two \ncollections only there to make up the namespace (i.e., their members only \nincludes resources that are version-controlled, or have version-controlled \nmembers).\n/DAV/\n/DAV/src/\n\nand a version-controlled resource\n/DAV/src/source.c\n\nwhich as you can see is at the 'right' point in the namespace.  Its \ncontent and dead properties are those as captured by th baseline (and it \ncannot be modified).\n\n> Well was this sentence really more understandable than\n> the definition above?\n\n<g>\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-16400834"}, {"subject": "RE: BASELINE-COLLECTION Propert", "content": "   From: Kirmse, Daniel [mailto:daniel.kirmse@sap.com]\n\n   I don't think I've got an understanding of what this means:\n\n    12.3.1 DAV:baseline-collection (protected)\n    This property contains a server-defined URL for a collection, where\n    each member of this collection MUST either be a version-controlled\n    resource with the same DAV:checked-in version and relative name as\n    a version-controlled member of the baseline-controlled collection\n    at the time the baseline was created, or be a collection needed to\n    provide the relative name for a version-controlled resource.\n\n   Suppose a collection /DEV under basline-control. This collection\n   has a member collection /src and the latter has a member\n   source.c. Is it right to undersatnd it that way that the\n   baseline-collection property of a baseline of the VCC tracking /DEV\n   contains a copy of the tree rooted of /DEV (except for those\n   memebers tracked by another VCC) at the moment the snapshot was\n   done?\n\n   Well was this sentence really more understandable than the definition\nabove?\n\nThe problem with that sentence is that the only definition we have of\nthe term \"copy\" is \"the result of a COPY request\", and this would not\ncorrectly characterize the baseline-collection.  A \"copy\" of a\nbaseline-controlled collection (as produced by a COPY request) does\nnot necessarily create a tree of version-controlled resources, but\ndoes whatever a PUT/MKCOL would do at that destination, which usually\nis to create non-version-controlled resources.  In addition, a COPY\nwould copy both the version-controlled and non-version-controlled\nmembers of the baseline-controlled collection, while a\nbaseline-collection only contains the version-controlled members, as\nwell as any collections needed to identify version-controlled members.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-16410959"}, {"subject": "RE: BASELINE-COLLECTION Propert", "content": "\"copy\" wasn't ment as COPY but as \"structured equally\". Well I understand\nthat there are only VCR and collections needed to identify VCR's. Any other\nstuff is not under version-control and therefore irrelevant for baselining.\n\nO.k., using my example again the baseline-collection contains members:\n\n/src (Collection)\n/src/source.c (VCR)\n\nThe prefix /DEV must be left out because the uri must be relative to the VCC\nroot and that is /DEV. right?\n\n\n>-----Original Message-----\n>From: Clemm, Geoff [mailto:gclemm@rational.com]\n>Sent: Montag, 17. Dezember 2001 14:05\n>To: Ietf-Dav-Versioning (E-mail)\n>Subject: RE: BASELINE-COLLECTION Property\n>\n>\n>   From: Kirmse, Daniel [mailto:daniel.kirmse@sap.com]\n>\n>   I don't think I've got an understanding of what this means:\n>\n>    12.3.1 DAV:baseline-collection (protected)\n>    This property contains a server-defined URL for a collection, where\n>    each member of this collection MUST either be a version-controlled\n>    resource with the same DAV:checked-in version and relative name as\n>    a version-controlled member of the baseline-controlled collection\n>    at the time the baseline was created, or be a collection needed to\n>    provide the relative name for a version-controlled resource.\n>\n>   Suppose a collection /DEV under basline-control. This collection\n>   has a member collection /src and the latter has a member\n>   source.c. Is it right to undersatnd it that way that the\n>   baseline-collection property of a baseline of the VCC tracking /DEV\n>   contains a copy of the tree rooted of /DEV (except for those\n>   memebers tracked by another VCC) at the moment the snapshot was\n>   done?\n>\n>   Well was this sentence really more understandable than the \n>definition\n>above?\n>\n>The problem with that sentence is that the only definition we have of\n>the term \"copy\" is \"the result of a COPY request\", and this would not\n>correctly characterize the baseline-collection.  A \"copy\" of a\n>baseline-controlled collection (as produced by a COPY request) does\n>not necessarily create a tree of version-controlled resources, but\n>does whatever a PUT/MKCOL would do at that destination, which usually\n>is to create non-version-controlled resources.  In addition, a COPY\n>would copy both the version-controlled and non-version-controlled\n>members of the baseline-controlled collection, while a\n>baseline-collection only contains the version-controlled members, as\n>well as any collections needed to identify version-controlled members.\n>\n>Cheers,\n>Geoff\n>\n\n\n\n", "id": "lists-006-16420092"}, {"subject": "RE: BASELINE-COLLECTION Propert", "content": "Yes, that is right.\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Kirmse, Daniel [mailto:daniel.kirmse@sap.com]\nSent: Monday, December 17, 2001 9:59 AM\nTo: Ietf-Dav-Versioning (E-mail)\nSubject: RE: BASELINE-COLLECTION Property\n\n\n\"copy\" wasn't ment as COPY but as \"structured equally\". Well I understand\nthat there are only VCR and collections needed to identify VCR's. Any other\nstuff is not under version-control and therefore irrelevant for baselining.\n\nO.k., using my example again the baseline-collection contains members:\n\n/src (Collection)\n/src/source.c (VCR)\n\nThe prefix /DEV must be left out because the uri must be relative to the VCC\nroot and that is /DEV. right?\n\n\n>-----Original Message-----\n>From: Clemm, Geoff [mailto:gclemm@rational.com]\n>Sent: Montag, 17. Dezember 2001 14:05\n>To: Ietf-Dav-Versioning (E-mail)\n>Subject: RE: BASELINE-COLLECTION Property\n>\n>\n>   From: Kirmse, Daniel [mailto:daniel.kirmse@sap.com]\n>\n>   I don't think I've got an understanding of what this means:\n>\n>    12.3.1 DAV:baseline-collection (protected)\n>    This property contains a server-defined URL for a collection, where\n>    each member of this collection MUST either be a version-controlled\n>    resource with the same DAV:checked-in version and relative name as\n>    a version-controlled member of the baseline-controlled collection\n>    at the time the baseline was created, or be a collection needed to\n>    provide the relative name for a version-controlled resource.\n>\n>   Suppose a collection /DEV under basline-control. This collection\n>   has a member collection /src and the latter has a member\n>   source.c. Is it right to undersatnd it that way that the\n>   baseline-collection property of a baseline of the VCC tracking /DEV\n>   contains a copy of the tree rooted of /DEV (except for those\n>   memebers tracked by another VCC) at the moment the snapshot was\n>   done?\n>\n>   Well was this sentence really more understandable than the \n>definition\n>above?\n>\n>The problem with that sentence is that the only definition we have of\n>the term \"copy\" is \"the result of a COPY request\", and this would not\n>correctly characterize the baseline-collection.  A \"copy\" of a\n>baseline-controlled collection (as produced by a COPY request) does\n>not necessarily create a tree of version-controlled resources, but\n>does whatever a PUT/MKCOL would do at that destination, which usually\n>is to create non-version-controlled resources.  In addition, a COPY\n>would copy both the version-controlled and non-version-controlled\n>members of the baseline-controlled collection, while a\n>baseline-collection only contains the version-controlled members, as\n>well as any collections needed to identify version-controlled members.\n>\n>Cheers,\n>Geoff\n>\n\n\n\n", "id": "lists-006-16430484"}, {"subject": "RE: BASELINE-COLLECTION Propert", "content": "\"Kirmse, Daniel\" <daniel.kirmse@sap.com> wrote:\n\n> O.k., using my example again the baseline-collection\n> contains members:\n> \n> /src (Collection)\n> /src/source.c (VCR)\n> \n> The prefix /DEV must be left out because the uri must\n> be relative to the VCC root and that is /DEV. right?\n\noops, right, (not as I wrote previously).\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-16441193"}, {"subject": "Re: baselines &amp; namespace", "content": "\"Clemm, Geoff\" wrote:\n\n>\n> If a server supports version-controlled collections, and if\n> a version-controlled collection gave a name to a\n> version history, and that version history is the root of a\n> subbaseline, then that subbaseline is restored at that location.\n> But otherwise, no, the protocol does not require a server to\n> preserve anything about the relative locations of subbaselines.\n>\n\nThanks for the reply.\n\nI hadn't understood from the spec that the (collection) version-history should\nimply a baseline, and so had not seen how the version-controlled-binding could\nbehave as a \"baseline-binding\".\n\nSo,  is the model that there is an association between a baseline and a\nversion-history, or between a baseline-history and a version-history, or\nsomething else?\n\nIf there is an association between a baseline-history and a version-history, is\nit constrained to be 1:1 (i.e. the baseline-history and version-history are two\naspects of the same collection - a collection that is both versioned, and the\nroot of a configuration)?\n\nDo any additional pre- or post- conditions arise from the association?\n\nFor example, if /ws/col1 is a non-empty version-controlled collection, that is\nbaseline-controlled to create baseline /bl/1. Is it illegal to\nbaseline-control  /ws/col2, an _empty_ version-controlled collection, from\nbaseline /bl/1? Or does /ws/col2 simply become another name for /ws/col1?\n\nThanks,\nAlison\n--\n -------------------------------------------------------------\n The statements and opinions expressed here are my own\n and do not necessarily represent those of Oracle Corporation.\n -------------------------------------------------------------\n\n\n\n", "id": "lists-006-16448697"}, {"subject": "RE: baselines &amp; namespace", "content": "   From: Alison Macmillan [mailto:alison.macmillan@oracle.com]\n\n   \"Clemm, Geoff\" wrote:\n\n   > If a server supports version-controlled collections, and if\n   > a version-controlled collection gave a name to a\n   > version history, and that version history is the root of a\n   > subbaseline, then that subbaseline is restored at that location.\n   > But otherwise, no, the protocol does not require a server to\n   > preserve anything about the relative locations of subbaselines.\n\n   I hadn't understood from the spec that the (collection)\n   version-history should imply a baseline, and so had not seen how\n   the version-controlled-binding could behave as a\n   \"baseline-binding\".\n\nA collection version history definitely does not imply a baseline.\nBut if a server supports both version-controlled collections and\nbaselines, then if a baseline B1 selects collection version CV2 (say\nwith name \"x/y\" relative to the root of B1), and if CV2 has a\nversion-controlled binding named \"z\" to the collection version history\nCVH3, and if B1 has a subbaseline B2, and if the root of B2 is a\nversion of CVH3, then subbaseline B2 will be located at \"x/y/z\"\nrelative to the root of B1.\n\n   So, is the model that there is an association between a baseline\n   and a version-history, or between a baseline-history and a\n   version-history, or something else?\n\nThere is an association, but it is the:\nbaseline (selects) collection version (has binding to)\ncollection version history (has version)\ncollection version (root of) subbaseline\n \n   If there is an association between a baseline-history and a\n   version-history, is it constrained to be 1:1 (i.e. the\n   baseline-history and version-history are two aspects of the same\n   collection - a collection that is both versioned, and the root of a\n   configuration)?\n\nThis is not required by the protocol.\n\n   Do any additional pre- or post- conditions arise from the\n   association?  For example, if /ws/col1 is a non-empty\n   version-controlled collection, that is baseline-controlled to\n   create baseline /bl/1. Is it illegal to baseline-control /ws/col2,\n   an _empty_ version-controlled collection, from baseline /bl/1? Or\n   does /ws/col2 simply become another name for /ws/col1?\n\nYour server could do it either way.  We could constrain it to be\none way or the other, but I think that might intrude on issues\nthat might conflict with alternative implementation techniques.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-16457466"}, {"subject": "RE: BASELINE-CONTRO", "content": "Some more questions about baselines and subbaselines. Sorry, if there\nare already answers for this question in the archive, but search is\nnot available, so I failed to find them.\n\nAssume that I have some project /project1 (version-controlled-collection) placed under\nbaseline control. I have some baseline with subbaselines. Subbaseline\nrefer to some components in the project - some collections which are members of\nthe /project1 collection.\nNow I want to place project in my workspace. I create directory\n/ws/my/project1 and place it under version control, right?\nBut what how subbaselines will be handled? The expected behavior is\nthat subbaselines will be extracted to the correspondent\nsubdirectories of /ws/my/project1 which will be placed under baseline\ncontrol? But I didn't find confirmation in the specification.\n\nAlso specification doesn't require that baseline-controlled-collection of\nthe subbaseline is member of baseline-controlled-collection of the\nsuper-baseline. In this case I will not be able to create collections\nfor subbaselines when I place /ws/my/project under baseline control.\nSo while behavior explained in the previous section seems to be\nnatural and obvious, I afraid that it is not what intended for\nsubbaselines by specification. Unfortunately there is almost nothing in\nspecification about subbaselines, except brief explanation of\nsubbaseline property.\n\nNow when I am going to prepare new baseline, I will have to\nexplicitly setup subbaselines property for this baseline.  Why the is\nno notion of \"subconfiguration\". It seems to very convenient and\nnatural: I have version-controlled-collection /project1, I have\ncomponent /project1/gui, project1/db and project1/core.\nI place them under baseline control and declare that configuration of\n/project1 has three subconfigurations. Now when I checkin this\nconfiguration and produce new baseline for /project1, this baseline\nwill automatically be assigned subbaseline property, referred to the\ncheckedIn baselines selected by subconfigurations. Does it make sense?\n\n\nAnd one more question about baselines: it is said in specification that\n\"the root collection of a configuration is unconstrained with respect\nto its relationship to the root collection of its components\".\nFirst of all,  the notion \"root collection of configuration\", been\nintroduced in the first abstract of section 12 (Baseline\nfeature), is never more used. So it is not clear what is it and how it\ncan be used.\n\nBASELINE-CONTROL method creates new configuration and either create new baseline bounded\nwith specified version-controlled collection either initialize specified version-control-collection\nwith existed baseline. This version-controlled-collection is stored in\n<DAV:baseline-controlled-collection/> of the configuration. It is\n\"root collection of configuration\"? If so, how it is possible that\ncomponents of this collection are not members of this collections?\n\n\n\n", "id": "lists-006-16467320"}, {"subject": "Re: baselines &amp; namespace", "content": "\"Clemm, Geoff\" wrote:\n\n>    From: Alison Macmillan [mailto:alison.macmillan@oracle.com]\n>\n>    \"Clemm, Geoff\" wrote:\n>\n>    > If a server supports version-controlled collections, and if\n>    > a version-controlled collection gave a name to a\n>    > version history, and that version history is the root of a\n>    > subbaseline, then that subbaseline is restored at that location.\n>    > But otherwise, no, the protocol does not require a server to\n>    > preserve anything about the relative locations of subbaselines.\n>\n>    I hadn't understood from the spec that the (collection)\n>    version-history should imply a baseline, and so had not seen how\n>    the version-controlled-binding could behave as a\n>    \"baseline-binding\".\n>\n> A collection version history definitely does not imply a baseline.\n> But if a server supports both version-controlled collections and\n> baselines, then if a baseline B1 selects collection version CV2 (say\n> with name \"x/y\" relative to the root of B1), and if CV2 has a\n> version-controlled binding named \"z\" to the collection version history\n> CVH3, and if B1 has a subbaseline B2, and if the root of B2 is a\n> version of CVH3, then subbaseline B2 will be located at \"x/y/z\"\n> relative to the root of B1.\n>\n\nSo, is it right  that the DAV:baseline-collection can _itself_ be a VCR\n(for the above example, with DAV:checked-in a version of CVH3)?\n\nThanks,\nAlison.\n--\n -------------------------------------------------------------\n The statements and opinions expressed here are my own\n and do not necessarily represent those of Oracle Corporation.\n -------------------------------------------------------------\n\n\n\n", "id": "lists-006-16477084"}, {"subject": "RE: BASELINE-CONTRO", "content": "   From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\n\n   Assume that I have some project /project1\n   (version-controlled-collection) placed under baseline control. I\n   have some baseline with subbaselines. Subbaseline refer to some\n   components in the project - some collections which are members of\n   the /project1 collection.  Now I want to place project in my\n   workspace. I create directory /ws/my/project1 and place it under\n   version control, right?\n\nActually, you create directory /ws/my/project1 by using the \nBASELINE-CONTROL method, specifying the baseline from /project1\nthat you want to initialize /ws/my/project1 with.\n\n   But what how subbaselines will be handled? The expected behavior is\n   that subbaselines will be extracted to the correspondent\n   subdirectories of /ws/my/project1 which will be placed under\n   baseline control? But I didn't find confirmation in the\n   specification.\n\nSee the recent thread on \"baselines & namespaces\" (starting last\nweek).\n\n   Also specification doesn't require that baseline-controlled-collection of\n   the subbaseline is member of baseline-controlled-collection of the\n   super-baseline.\n\nThat is correct.\n\n   In this case I will not be able to create collections\n   for subbaselines when I place /ws/my/project under baseline control.\n\nIf the subbaselines are not under /ws/my/project1, they must be\nindependent projects, e.g. project2 and project3.  You would therefore\nhave to initialize your workspace with those other projects as\nwell, by using additional BASELINE-CONTROL requests (i.e. creating\n/ws/my/project2 and /ws/my/project3).  It obviously is easier if\nall the sub-projects are nested under a common \"namespace\", because\nthen a single BASELINE-CONTROL request is sufficient.\n\n   So while behavior explained in the previous section seems to be\n   natural and obvious, I afraid that it is not what intended for\n   subbaselines by specification. Unfortunately there is almost\n   nothing in specification about subbaselines, except brief\n   explanation of subbaseline property.\n\nWe need to add this kind of info to the FAQ.  Hopefully this thread\nprovides the material we will need for this.\n\n   Now when I am going to prepare new baseline, I will have to\n   explicitly setup subbaselines property for this baseline.  Why the is\n   no notion of \"subconfiguration\". It seems to very convenient and\n   natural: I have version-controlled-collection /project1, I have\n   component /project1/gui, project1/db and project1/core.\n   I place them under baseline control and declare that configuration of\n   /project1 has three subconfigurations. Now when I checkin this\n   configuration and produce new baseline for /project1, this baseline\n   will automatically be assigned subbaseline property, referred to the\n   checkedIn baselines selected by subconfigurations. Does it make sense?\n\nYes, I think that is exactly right.  Until now, there were only a few\nfolks interested in advanced baselining functionality, so we just\nended up defined the basic machinery and left the elaboration for a\nfuture draft (there are some interesting issues that arise when that\nkind of machinery is defined).  But now that we have several folks\ninterested in sub-baselining, we should go ahead and iterate on some\nsemantics, and get it posted to the deltav web site.\n\n   And one more question about baselines: it is said in specification that\n   \"the root collection of a configuration is unconstrained with respect\n   to its relationship to the root collection of its components\".\n   First of all,  the notion \"root collection of configuration\", been\n   introduced in the first abstract of section 12 (Baseline\n   feature), is never more used. So it is not clear what is it and how it\n   can be used.\n\nThe concept of a \"root collection\" appears is explicitly used in a\nvariety of the method postconditions in the baseline feature (just\nsearch for the string \"root\" in the protocol text).\n\n   BASELINE-CONTROL method creates new configuration \n\nto be precise, it creates a new version-controlled configuration.\n\n   and either create\n   new baseline bounded with specified version-controlled collection\n   either initialize specified version-control-collection with existed\n   baseline.\n\nIt does not need to be a version-controlled collection ... whether\nor not a collection is under version-control or baseline-control\nare two orthogonal issues (it can be neither, either, or both).\n\n   This version-controlled-collection is stored in\n   <DAV:baseline-controlled-collection/> of the configuration.\n\nMore precisely, the location of the baseline-controlled collection\nis stored in the DAV:baseline-controlled-collection property\nof the version-controlled configuration.\n\n   It is \"root collection of configuration\"?\n\nMore precisely, it is the root collection of the configuration whose\nstate is being tracked by the version-controlled configuration.\n\n   If so, how it is possible that components of this collection are\n   not members of this collections?\n\nA version-controlled configuration is not itself a configuration (it's\nnot even a collection), but rather is a mechanism for tracking the\nhistory of a configuration (in particular, the configuration whose\nroot is identified by the DAV:baseline-controlled-collection property\nof the version-controlled configuration).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-16486163"}, {"subject": "RE: baselines &amp; namespace", "content": "   From: Alison Macmillan [mailto:alison.macmillan@oracle.com]\n\n   \"Clemm, Geoff\" wrote:\n\n   >    From: Alison Macmillan [mailto:alison.macmillan@oracle.com]\n   >\n   >    I hadn't understood from the spec that the (collection)\n   >    version-history should imply a baseline, and so had not seen\n   >    how the version-controlled-binding could behave as a\n   >    \"baseline-binding\".\n   >\n   > A collection version history definitely does not imply a\n   > baseline.  But if a server supports both version-controlled\n   > collections and baselines, then if a baseline B1 selects\n   > collection version CV2 (say with name \"x/y\" relative to the root\n   > of B1), and if CV2 has a version-controlled binding named \"z\" to\n   > the collection version history CVH3, and if B1 has a subbaseline\n   > B2, and if the root of B2 is a version of CVH3, then subbaseline\n   > B2 will be located at \"x/y/z\" relative to the root of B1.\n   >\n\n   So, is it right that the DAV:baseline-collection can _itself_ be a\n   VCR (for the above example, with DAV:checked-in a version of CVH3)?\n\nThat's correct.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-16498306"}, {"subject": "AW: baselines &amp; namespace", "content": "Hi,\n\nI tried to get the Web Versioning Model from the deltaV web server\nat http://www.webdav.org/deltav/\nI can access it in the browser version only, \nbut I don't get the permission to download the corresponding mdl file.\nIs there a way to get a copy of this model ?\n\nthanks and regards\nMatthias\n\n\n\n", "id": "lists-006-16507126"}, {"subject": "RE: baselines &amp; namespace", "content": "Please try it again (the link was pointing to the collection instead\nof to the .mdl file).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Sohn, Matthias [mailto:matthias.sohn@sap.com]\nSent: Wednesday, December 19, 2001 7:22 AM\nTo: ietf-dav-versioning@w3.org\nSubject: AW: baselines & namespaces\n\n\nHi,\n\nI tried to get the Web Versioning Model from the deltaV web server\nat http://www.webdav.org/deltav/\nI can access it in the browser version only, \nbut I don't get the permission to download the corresponding mdl file.\nIs there a way to get a copy of this model ?\n\nthanks and regards\nMatthias\n\n\n\n", "id": "lists-006-16514010"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "A version-controlled resource is really just a handle to a version resource\ncontained within a version-history resource. There could be many\nversion-controlled resource pointing to the same version. Deleting a version\nwhen deleting a version-controlled resource does not make any sense.\n\nWhat is not clear is how a client can delete a version or version-history\nresource when the server only supports the version-control feature. Maybe\nwhat needs to be stated is a version-history resource MUST be deleted when\nthe version-controlled resource is deleted if the server only supports the\nversion-control feature.\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Tuesday, June 12, 2001 4:54 PM\nTo: 'Rick Rupp'; ietf-dav-versioning@w3.org\nSubject: RE: Confusion: Removing a resource from version control \n\n\nI was not planning on implementing a version-history feature.  I see\nabsolutely no problems with supporting the working resource feature with\nanything I've said.  I wasn't planning on supporting workspaces, but I don't\nsee any problems there that aren't inherent in being able to delete\nindividual versions.\n\nAlthough you can keep an object around that allows you to retrieve the\nversion history of a completely deleted resource, I don't understand how\nthat can be done without eventual name collisions.\n\nSay I create foo/bar.txt as a version controlled resource.  If I wanted a\nseparate version history object, I could put it in some place like\n/vhist/foo/bar.txt\nNow someone wants to delete foo/bar.txt -- OK, I delete it but not\n/vhist/foo/bar.txt\n\nThat works until someone tries to create a new foo/bar.txt that they wish to\nbe a version controlled resource.  I have a collision with\n/vhist/foo/bar.txt and THIS foo/bar.txt is completely distinct from the\noriginal.\n\n\n\n\n\n\n-----Original Message-----\nFrom: Rick Rupp [mailto:Rick.Rupp@merant.com] \nSent: Tuesday, June 12, 2001 4:22 PM\nTo: 'John Hall'; 'ietf-dav-versioning@w3.org'\nSubject: RE: Confusion: Removing a resource from version control \n\n\nI disagree that version history should be deleted if you delete the version\ncontrolled resource. Section 5 of the draft clearly states the version\nhistory resource exists in a server defined namespace and therefore is\nunaffected by any deletion or movement of a version controlled resource.\nIf you require the version history to be deleted you will cause serious\nproblems for a server that supports the workspace and working resource\nfeature.\n-----Original Message----- \nFrom: John Hall [mailto:johnhall@evergo.net] \nSent: Tuesday, June 12, 2001 3:52 PM \nTo: 'Clemm, Geoff'; 'DeltaV' \nSubject: RE: Confusion: Removing a resource from version control \n\n\nIntro about me at bottom. \n\"In order to remove a resource at a given URL from version control, the \nclient can replace the resource under version control with a \nnon-version-controlled copy of that resource.  For example, a client can \nCOPY the version-controlled resource to a temporary location, DELETE the \nversion-controlled resource, and then MOVE the copy from the temporary \nlocation back to the original URL.  Note that the versions already \ncreated for the version-controlled resource will continue to exist at \ntheir server-defined locations.\" \nIs that clearer? \nCheers, \nGeoff \n================================================================= \nWhen you DELETE a version-controlled resource, I strongly believe that \nall information for that VCR and all versions already created should go \nto the great bit bucket in the sky. \nAs I understand your formulation, I would have severe problems in \nmodifying my DAV server (with versioning support) to support DELTAV \nusing this behavior.  \nI would prefer this formulation / behavior: \n\"In order to remove a resource at a given URL from version control, the \nclient can replace the resource under version control with a \nnon-version-controlled copy of that resource.  For example, a client can \nCOPY the version-controlled resource to a temporary location, DELETE the \nversion-controlled resource, and then MOVE the copy from the temporary \nlocation back to the original URL.  Note that the versions already \ncreated for the version-controlled resource will NO LONGER BE AVAILABLE. \nIf you wish to remove a resource at a given URL from version control \nwhile also retaining a previous revision history, then you should MOVE \nthe resource to a new save location and COPY the current version back to \nthe original URL.\" \n========== \nMy formulation is based explicitly on the idea that some implementations \nand some customers are not keeping track of legal documents and \ntherefore deleting old versions is highly desired if not required.  A \nserver shouldn't be forced to keep data that a client is willing to \nspecifically state that it doesn't want. \nI think a far better manner of achieving your goals is simply to allow \nthe VERSION-CONTROL method to turn version-control for a resource at a \ngiven URL off (if supported by the server).  That allows you to achieve \nyour above objectives (no new versions, but keep the old ones at the \nsame URLs) without changing the usefulness of the DELETE command. \n====================================================== \nJohn Hall is an engineer working on the Xythos development team to \nmodify their DAV (with revision additions) server to support DELTAV as \nwell as other-party proprietary DAV versioning systems. \n\n\n\n", "id": "lists-006-1651764"}, {"subject": "Re[2]: baselines &amp; namespace", "content": "Consider the following situation: we have version-controlled-directory\n/x placed under baseline control and version-controlled-directory /x/y\nbelonging to the different configuration. Now if we extract baseline\n(without subbaselines) from version-controlled-configuration for /x in some workspace,\nhow we should handle /x/y belonging to the other configuration and all it's\nmembers ?\n\nShould created version-controlled-resource /x contain binding to \"y\"?\n\nShould we create version-controlled-resource for /x/y?\nIf so, which version should it select? Server dependent (initial,\nlatest, random,...) Should it also be done for members of /x/y?\n\n\nThanks in advance\nKonstantin\n\n\n\n", "id": "lists-006-16521904"}, {"subject": "RE: Re[2]: baselines &amp; namespace", "content": "   From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\n\n   Consider the following situation: we have\n   version-controlled-directory /x placed under baseline control and\n   version-controlled-directory /x/y belonging to the different\n   configuration. Now if we extract baseline (without subbaselines)\n   from version-controlled-configuration for /x in some workspace, how\n   we should handle /x/y belonging to the other configuration and all\n   it's members ?\n\nTo make this more concrete: let's assume that \"some workspace\" is\n/ws/kk, and that /ws/kk/x is under baseline control, and\nversion-controlled configuration associated with /ws/kk/x selects a\nbaseline from the baseline history /repo/bh/8.  Now a new baseline\n(/repo/bl/22) for /repo/bh/8 is created in some other workspace, and\nwe decide to MERGE /repo/bl/22 into /ws/kk.\n\n   Should created version-controlled-resource /x contain binding to \"y\"?\n\nYes.  Although it is not a binding \"to\" y, but rather a binding \"named\" y.\n\n   Should we create version-controlled-resource for /x/y?\n\nIt depends.  Let /repo/vh/12 be the version-history that is identified\nby the version-controlled binding named \"y\" in the version of /x\nselected by /repo/bl/22.  If before the MERGE, there was a VCR that\nselected a version of /repo/vh/12, then /ws/kk/x/y is just a binding\nto that VCR.  If there was no such VCR, then the server creates a new\nVCR at /ws/kk/x/y.\n\n   If so, which version should it select? Server dependent (initial,\n   latest, random,...) \n\nIf a new VCR was created, the DAV:checked-in version of that VCR is an\narbitrary version of /repo/vh/12.  I tried to require that it select\nthe root version in this case, but a couple members of the design team\ninsisted this this choice had to be left up to the server.\n\n\n   Should it also be done for members of /x/y?\n\nYes.  One of the advantages of picking the \"root\" version is that if\nit is a collection, it is common for the \"root\" version to be empty,\nso you don't have to traverse down the tree picking random versions\nall the way down.\n\nCheers,\nGeoff\nh\n\n\n\n", "id": "lists-006-16530135"}, {"subject": "Re (2): Re[2]: baselines &amp; namespace", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n>    From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\n> \n>    Consider the following situation: we have\n>    version-controlled-directory /x placed under baseline control and\n>    version-controlled-directory /x/y belonging to the different\n>    configuration. Now if we extract baseline (without subbaselines)\n>    from version-controlled-configuration for /x in some workspace, how\n>    we should handle /x/y belonging to the other configuration and all\n>    it's members ?\n> \n> To make this more concrete: let's assume that \"some workspace\" is\n> /ws/kk, and that /ws/kk/x is under baseline control, and\n> version-controlled configuration associated with /ws/kk/x selects a\n> baseline from the baseline history /repo/bh/8.  Now a new baseline\n> (/repo/bl/22) for /repo/bh/8 is created in some other workspace, and\n> we decide to MERGE /repo/bl/22 into /ws/kk.\n> \n>    Should created version-controlled-resource /x contain binding to \"y\"?\n> \n> Yes.  Although it is not a binding \"to\" y, but rather a binding \"named\" y.\nHi Geoff, my interpretation of Konstantins question is different.\nIf /x/y is the root collection of another configuration it doesn't belong to /x\nand if it also isn't a subbaseline of /x it must not be created when /x is\nextracted in a new workspace.\nJust as a reminder: In my understanding the BASELINE-CONTROL feature can\nexist without the VERSION-CONTROLLED-COLLECTION feature.\n\nCheers, Edgar\n\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-16539806"}, {"subject": "Re[4]: baselines &amp; namespace", "content": "Postcondition for DELETE in section 5.6 DAV:delete-version-set says\nthat it is possible to delete version-history. By what should I do\nwith bindings to this version-history from parent versions? There is\nnothing about it in specification. Is it possible for server to\nprohibit DELETE of VERSION-HISTORY? (as it is allowed for VERSION)\n\n\n\n", "id": "lists-006-16549386"}, {"subject": "RE: Re (2): Re[2]: baselines &amp; namespace", "content": "   From: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n\n   \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n   >    From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\n   > \n   >    Consider the following situation: we have\n   >    version-controlled-directory /x placed under baseline control\n   >    and version-controlled-directory /x/y belonging to the\n   >    different configuration. Now if we extract baseline (without\n   >    subbaselines) from version-controlled-configuration for /x in\n   >    some workspace, how we should handle /x/y belonging to the\n   >    other configuration and all it's members ?\n   > \n   > To make this more concrete: let's assume that \"some workspace\" is\n   > /ws/kk, and that /ws/kk/x is under baseline control, and\n   > version-controlled configuration associated with /ws/kk/x selects\n   > a baseline from the baseline history /repo/bh/8.  Now a new\n   > baseline (/repo/bl/22) for /repo/bh/8 is created in some other\n   > workspace, and we decide to MERGE /repo/bl/22 into /ws/kk.\n   > \n   >    Should created version-controlled-resource /x contain binding\n   >    to \"y\"?\n   > \n   > Yes.  Although it is not a binding \"to\" y, but rather a binding\n   > \"named\" y.\n\n   If /x/y is the root collection of another configuration it doesn't\n   belong to /x and if it also isn't a subbaseline of /x it must not\n   be created when /x is extracted in a new workspace.\n\nIt is important to distinguish between what the protocol does not\nrequire the server to do, and what it requires the server not to do.\nIf your server supports baselines but not versioned collections, then\nit is not required to create /ws/kk/x/y when /repo/bl/22 is merged\ninto /ws/kk, but it may do so.  If your server supports baselines\nand versioned collectios, then it MUST create /ws/kk/x/y when\n/repo/bl/22 is merged into /ws/kk.\n\n   Just as a reminder: In my understanding the BASELINE-CONTROL\n   feature can exist without the VERSION-CONTROLLED-COLLECTION\n   feature.\n\nThat is correct.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-16557014"}, {"subject": "RE: Re[4]: baselines &amp; namespace", "content": "Yes, a server is allowed to prohibit DELETE of a version history.\n\nIf a server does support DELETE of a version history, it is faced\nwith two unpleasant alternatives: either delete all references to\nthat version history from collection versions, or to leave those\nreferences dangling, with undefined results when that collection\nversion is selected as the DAV:checked-in version of a version\ncontrolled collection.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]\nSent: Monday, December 24, 2001 9:37 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Re[4]: baselines & namespaces\n\n\nPostcondition for DELETE in section 5.6 DAV:delete-version-set says\nthat it is possible to delete version-history. By what should I do\nwith bindings to this version-history from parent versions? There is\nnothing about it in specification. Is it possible for server to\nprohibit DELETE of VERSION-HISTORY? (as it is allowed for VERSION)\n\n\n\n", "id": "lists-006-16567103"}, {"subject": "Re (3): Re[2]: baselines &amp; namespace", "content": "As an introduction, what I want to be able to do with DeltaV.\n\nStructuring Software with Components and it's Implementation in DeltaV\n----------------------------------------------------------------------\nAt first there is the model:\nA Software project is a component (To take the term which is used in Chapter 12\non BASELINE-CONTROL) consisting of resources.\nFor big Software projects it makes sense to break up the set of resources into\na set of smaller components (This also allows reuse of components in other\nprojects). The whole project now consists of a (possibly empty) set of resources and\na (possibly empty) set of subcomponents.\nThe resources of a component also can be structured in groups belonging together\nlogically.\nThat's in short what I had in my mind in the past when I was argueing for\nsubbaselines. \n\nThen comes the view provided by DeltaV:\nA component is mapped to a baseline-controlled collection and called 'Configuration'.\nIt's resources are mapped to members of this collection. Component internal member\nstructuring is mapped to additional collections contained in the baseline-controlled\ncollection. A component version is called a 'Baseline'.\nSubcomponents are also mapped to baseline-controlled collections (configurations)\nof this view. Subcomponent property is implemented by adding the configuration\nto the subbaseline-set property of it's 'master' configuration.\nBTW, I expect subbaselines to be restored to the same relative path concerning\nthe baseline like when the baseline was created. There should be the necessary\nproperties to guarantee this.\n\n\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n>Edgar@edgarschwarz.de schrieb:\n>    If /x/y is the root collection of another configuration it doesn't\n>    belong to /x and if it also isn't a subbaseline of /x it must not\n>    be created when /x is extracted in a new workspace.\n> \n> It is important to distinguish between what the protocol does not\n> require the server to do, and what it requires the server not to do.\nRight.\n> If your server supports baselines but not versioned collections, then\n> it is not required to create /ws/kk/x/y when /repo/bl/22 is merged\n> into /ws/kk, but it may do so.\nWhy should this be allowed ? A baseline \"... captures the state of each version\ncontrolled member of a configuration.\". So /ws/kk/x/y isn't captured in the\nbaseline and I see no reason to restore it. \n\n> If your server supports baselines and versioned collectios, then it MUST create\n> /ws/kk/x/y when /repo/bl/22 is merged into /ws/kk.\nAgain ! Why should this be required  ? /ws/kk/x/y wasn't captured in the baseline,\nso there is no information how to restore it.\nIn your agenda BASELINE-CONTROL is giving different results depending on another\n'competing' feature being supported or not. This shouldn't be.\nDo you see why I have problems ? Perhaps you have a different model than me :-)\nthen please explain it.\n\nCheers, Edgar.\n\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-16575638"}, {"subject": "RE: Re (3): Re[2]: baselines &amp; namespace", "content": "   From: Edgar@edgarschwarz.de [mailto:Edgar@edgarschwarz.de]\n\n   >Edgar@edgarschwarz.de schrieb:\n   >    If /x/y is the root collection of another configuration it\n   >    doesn't belong to /x and if it also isn't a subbaseline of /x\n   >    it must not be created when /x is extracted in a new\n   >    workspace.\n\n   \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n   > If your server supports baselines but not versioned collections,\n   > then it is not required to create /ws/kk/x/y when /repo/bl/22 is\n   > merged into /ws/kk, but it may do so.\n\n   Why should this be allowed ? A baseline \"... captures the state of\n   each version controlled member of a configuration.\". So /ws/kk/x/y\n   isn't captured in the baseline and I see no reason to restore it.\n\nThis is allowed to provide consistent semantics in the presence of\nversioned collections.  A version of a collection captures a set of\nversion-controlled bindings, and an appropriately named binding to a\nVCR must exist when that collection version is restored\n(i.e. specified in the DAV:checked-in property of a version-controlled\ncollection).\n\n   > If your server supports baselines and versioned collectios, then\n   > it MUST create /ws/kk/x/y when /repo/bl/22 is merged into /ws/kk.\n\n   Why should this be required ? /ws/kk/x/y wasn't captured in the\n   baseline, so there is no information how to restore it.\n\nThe baseline /repo/bl/22 contains a collection version for \"./x/y\",\nand this collection version has a version-controlled binding named\n\"y\".  This means that after /repo/bl/22 is merged into /ws/kk, there\nmust be a VCR named \"y\" in the version-controlled collection\nidentified by /ws/kk/x.\n\n   In your agenda BASELINE-CONTROL is giving different results\n   depending on another 'competing' feature being supported or\n   not. This shouldn't be.\n\nThat's why the server is given the \"choice\" of what to do.  If it does\nnot support version-controlled collections, it doesn't make sense to\nrequire it create a VCR named /ws/kk/x/y.  But if it does support\nversion-controlled collections, then it doesn't make sense *not* to\ncreate a VCR named /ws/kk/x/y.  So we leave this particular choice up\nto the server.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-16586460"}, {"subject": "Re (4): Re[2]: baselines &amp; namespace", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n>    > If your server supports baselines and versioned collectios, then\n>    > it MUST create /ws/kk/x/y when /repo/bl/22 is merged into /ws/kk.\n> \n>    Why should this be required ? /ws/kk/x/y wasn't captured in the\n>    baseline, so there is no information how to restore it.\n> \n> The baseline /repo/bl/22 contains a collection version for \"./x/y\",\nThat's already the point I don't understand.\nMy reasoning goes like that:\n0. It doesn't matter whether the server also has versioned collections because\n   baselines and versioned collections are independent features.\n1. /repo/bl/22 is a baseline of the configuration rooted at \"./x\".\n2. It was explicitly stated in the original question that \"./x/y\" is the root of\n   another configuration which isn't a subbaseline of \"./x\".\n3. A baseline is a set of versions of version-controlled-resources with the exception\n   of resources which belong to another configuration.\n=> Baseline /repo/bl/22 doesn't contain a collection version for \"./x/y\",\nSo where's my error ?\n\n\n> This is allowed to provide consistent semantics in the presence of\n> versioned collections.  A version of a collection captures a set of\n> version-controlled bindings, and an appropriately named binding to a\n> VCR must exist when that collection version is restored\n> (i.e. specified in the DAV:checked-in property of a version-controlled\n> collection).\nAfter thinking about my points above I guess that you probably already disagree\nwith point 0. Right ?\nIn this case I think I can stop argueing with you. Because as long as there aren't\nversioned collections I think we agree.\n\nNow suppose there are only baselines. In an earlier post you granted that it would\nmake sense for the server to save the relative position of the subbaseline somehow.\nSo it knows where to restore it later.\nDo we already have a property to do that ? If not I think we should create it.\nOr is there another mechanism using existing features ?\nAt least is should be guaranteed that subbaselines are restored to the same relative\nposition like when the baseline was created.\n\nCheers, Edgar\n  \n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-16596738"}, {"subject": "RE: Re (4): Re[2]: baselines &amp; namespace", "content": "   From: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n\n   \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n   >    > If your server supports baselines and versioned collectios, then\n   >    > it MUST create /ws/kk/x/y when /repo/bl/22 is merged into /ws/kk.\n   > \n   >    Why should this be required ? /ws/kk/x/y wasn't captured in the\n   >    baseline, so there is no information how to restore it.\n   > \n   > The baseline /repo/bl/22 contains a collection version for \"./x/y\",\n   > and this collection version has a version-controlled binding named\n   > \"y\".\n\nNote: I meant to say \"the baseline /repo/bl/22 contains a collection\nversion for ./x\".  Sorry about the typo.\n\n   That's already the point I don't understand.\n   My reasoning goes like that:\n\n   0. It doesn't matter whether the server also has versioned\n      collections because baselines and versioned collections are\n      independent features.\n\nDepends how you define \"matters\".\n\n   1. /repo/bl/22 is a baseline of the configuration rooted at \"./x\".\n\nYes.\n\n   2. It was explicitly stated in the original question that \"./x/y\"\n      is the root of another configuration which isn't a subbaseline\n      of \"./x\".\n\nYes.\n\n   3. A baseline is a set of versions of version-controlled-resources\n      with the exception of resources which belong to another\n      configuration.\n\n   => Baseline /repo/bl/22 doesn't contain a collection version for \"./x/y\",\n   So where's my error ?\n\nThat was my typo.  It contains a collection version for \"./x\", not\nfor \"./x/y\".  BUT, the collection version for \"./x\" contains a\nversion-controlled binding named \"y\", and that is what forces the\ncreation of a VCR named \"/ws/kk/x/y\" (although it does not specify\nwhat version of /ws/kk/x/y is to be selected).\n\n   > This is allowed to provide consistent semantics in the presence of\n   > versioned collections.  A version of a collection captures a set of\n   > version-controlled bindings, and an appropriately named binding to a\n   > VCR must exist when that collection version is restored\n   > (i.e. specified in the DAV:checked-in property of a version-controlled\n   > collection).\n\n   After thinking about my points above I guess that you probably\n   already disagree with point 0. Right ?\n\nWell, it depends how you define \"matters\".  One clear way in which\nthey interact, is that if your server supports version-controlled\ncollections, then a baseline will contain versions of collections,\nwhile if it doesn't, a baseline will not.  And it is the version of\na collection which introduces the behavior we are discussing.\n\n   In this case I think I can stop argueing with you. Because as long\n   as there aren't versioned collections I think we agree.\n\nYes, if a server does not support version-controlled collections, then\nit can chose to not create a VCR named /ws/kk/x/y.  But note that a\nclient must be prepared for /ws/kk/x/y being created, since that is\nwhat it will see on a server that supports version-controlled\ncollections.\n\n   Now suppose there are only baselines. In an earlier post you\n   granted that it would make sense for the server to save the\n   relative position of the subbaseline somehow.  So it knows where to\n   restore it later.\n\nI agree that for \"immediately nested\" sub-components, it makes sense,\nbut for non-nested sub-components, it probably does not.\nSuppose you have a baseline for /ws/gmc/xx that has a subbaseline\nnamed /ws/gmc/yy.  And you have a baseline for /ws/es/zz that has\na subbaseline named /ws/es/yy.  Then you \"merge\" the baseline for\n/ws/es/zz into /ws/gmc.  You get a name collision for /ws/gmc/yy.\n\n   Do we already have a property to do that ? If not I think we should\n   create it.  Or is there another mechanism using existing features ?\n   At least is should be guaranteed that subbaselines are restored to\n   the same relative position like when the baseline was created.\n\nThe purpose of a baseline is to allow you to MERGE (or UPDATE) that\nbaseline into a workspace.  You don't need a property to achieve\nthose semantics, but just have to specify the semantics that are\nrequired following the MERGE (or UPDATE).  The main reason we didn't\nspecify this as an independent postcondition is that in the\ndefined packages, version-controlled collections always appear\nwhenever baselines appear, so this postcondition follows from the\nexisting postconditions of those two packages.\n\nI expect that adding the postcondition that nested subbaselines are\nrestored in their same relative location will be acceptable to\neveryone, so the best approach here is probably to get this written up\nand posted to the deltav web site, so that deltav implementors are\naware of it as a likely addition in the next rev of the deltav spec.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-16606601"}, {"subject": "Re (5): Re[2]: baselines &amp; namespace", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n>    \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n>    >    > If your server supports baselines and versioned collectios, then\n>    >    > it MUST create /ws/kk/x/y when /repo/bl/22 is merged into /ws/kk.\n>    > \n>    >    Why should this be required ? /ws/kk/x/y wasn't captured in the\n>    >    baseline, so there is no information how to restore it.\n>    > \n>    > The baseline /repo/bl/22 contains a collection version for \"./x/y\",\n>    > and this collection version has a version-controlled binding named\n>    > \"y\".\n> \n> Note: I meant to say \"the baseline /repo/bl/22 contains a collection\n> version for ./x\".  Sorry about the typo.\nNow I think I finally understand what you are getting at.\nAs a baseline can't catch a collection version without VERSION-CONTROLLED-COLLECTIONS\nI also didn't expect that with this feature available.\nI'm not sure whether this is really necessary. Something to ponder on the weekend.\nBut I guess it looks obvious to sombody having experience with e.g. Clearcase\nVERSION-CONTROLLED-COLLECTIONS. OTOH I had my view centered on BASELINES and just\nwanted to avoid more complexity.\n\n>    In this case I think I can stop argueing with you. Because as long\n>    as there aren't versioned collections I think we agree.\n> \n> Yes, if a server does not support version-controlled collections, then\n> it can chose to not create a VCR named /ws/kk/x/y.  But note that a\n> client must be prepared for /ws/kk/x/y being created, since that is\n> what it will see on a server that supports version-controlled\n> collections.\nAgreed.\n\n>    Now suppose there are only baselines. In an earlier post you\n>    granted that it would make sense for the server to save the\n>    relative position of the subbaseline somehow.  So it knows where to\n>    restore it later.\n> I agree that for \"immediately nested\" sub-components, it makes sense,\nFine.\n\n> but for non-nested sub-components, it probably does not.\n> Suppose you have a baseline for /ws/gmc/xx that has a subbaseline\n> named /ws/gmc/yy.  And you have a baseline for /ws/es/zz that has\n> a subbaseline named /ws/es/yy.  Then you \"merge\" the baseline for\n> /ws/es/zz into /ws/gmc.  You get a name collision for /ws/gmc/yy.\nThen it could be the users job to remove the collision e.g. by moving\nthe already existing /ws/gmc/yy out of the way. In any case he has\nto do some restructuring if this happens. But I guess that's outside\nof the spec.\n\n> The main reason we didn't\n> specify this as an independent postcondition is that in the\n> defined packages, version-controlled collections always appear\n> whenever baselines appear, so this postcondition follows from the\n> existing postconditions of those two packages.\n> I expect that adding the postcondition that nested subbaselines are\n> restored in their same relative location will be acceptable to\n> everyone, so the best approach here is probably to get this written up\n> and posted to the deltav web site, so that deltav implementors are\n> aware of it as a likely addition in the next rev of the deltav spec.\nGood. Then would it be clear also in case of BASELINES without\nVERSION-CONTROLLED-COLLECTIONS. It's just that I still think that I can\ndo with BASELINES all what I want. So even if it's the obvious solution\nI think it's useful to have it written down somewhere.\nIt's just my fear that these two features will lead to complex\ninteractions and also confusion if they are both implemented. They are\ndifferent solutions for similar problems so I want them to be as standalone\nas possible. \n\nCheers, Edgar\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-16619275"}, {"subject": "RE: [ACL] RE: lock and access control lists on (working) version", "content": "I believe Yaron was just saying he both wanted \"what the ACL was at\nthe time it was checked in\" (i.e. a historical record, that\npresumably could be re-instated with you \"update\" a VCR to select\nthat version), as well as an ACL that actually affects who\ncan access the version.\n\nMy response is that in practice, nobody does anything like what\nYaron describes, and so we can leave it as a \"server value add\"\nfor now.  Realistically, you won't get all that much interoperability\nfrom ACL's anyway (although they are a lot better than nothing),\nso the chances of any significant interoperability benefit from\ndefining a standard way to access historical access values is\nvanishingly small.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\nSent: Tuesday, June 12, 2001 6:45 PM\nTo: Yaron Goland; Clemm, Geoff; ietf-dav-versioning@w3.org\nCc: acl@webdav.org\nSubject: RE: [ACL] RE: lock and access control lists on (working)\nversions\n\n\nIsn't \"the ACL list it currently uses to decide who gets to see the version\"\nthe ACL on the version history resource, or is what you want a version-\nindependent ACL that applies to all versions of a resource, that can\noverride the ACL on that particular version?\n\n> -----Original Message-----\n> From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> Yaron Goland\n> Sent: Tuesday, June 12, 2001 2:29 PM\n> To: Clemm, Geoff; ietf-dav-versioning@w3.org\n> Cc: acl@webdav.org\n> Subject: RE: [ACL] RE: lock and access control lists on (working)\n> versions\n>\n>\n> When I version a resource I will also likely want to version the access\n> control list it had when I 'froze' it. This is very important for things\n> like security checks. Imagine that an employee who was fired a year ago\n> turned out to be a corporate spy, you are going to want to check what\n> resources he had access to back then. This means that a version\n> really needs\n> two sets of ACLs. One if the ACL list it had when it was frozen. The other\n> is the ACL list it currently uses to decide who gets to see the version.\n>\n> > -----Original Message-----\n> > From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> > Clemm, Geoff\n> > Sent: Saturday, May 26, 2001 8:27 AM\n> > To: ietf-dav-versioning@w3.org\n> > Cc: acl@webdav.org\n> > Subject: [ACL] RE: lock and access control lists on (working) versions\n> >\n> >\n> > As Tim surmised, the answer to (1) is in fact \"yes\".\n> > Each version is a separate resource, and each resource\n> > can have its own distinct access control list.\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n> > Sent: Wednesday, May 16, 2001 5:42 AM\n> > To: ietf-dav-versioning@w3.org\n> > Cc: acl@webdav.org\n> > Subject: Re: lock and access control lists on (working) versions\n> >\n> >\n> >\n> >\n> > \"Pill, Juergen\" <Juergen.Pill@softwareag.com>\n> > > Hello,\n> > >\n> > > 1) Would it be possible with DETA-V to have different access\n> > control list\n> > > for different versions of a resource, e.g. V1 of resource /foo\n> > will allow\n> > > user A to modify and read, but V2 of resource /foo will allow\n> user A to\n> > read\n> > > read only?\n> >\n> > You'd have to ask the ACL-folk that question, but I would sincerely hope\n> > the answer is 'yes'.\n> >\n> > > 2) Would it be possible to have two distinct locks on two different\n> > > (working) resources?\n> >\n> > Yes.  Working resources have distinct server-defined URLs.  They can be\n> > locked using their URLs just like any other resource.\n> >\n> > > Does that make sense at all?\n> >\n> > Yep.\n> >\n> > Tim\n> >\n> >\n> > _______________________________________________\n> > acl mailing list\n> > acl@webdav.org\n> > http://mailman.webdav.org/mailman/listinfo/acl\n> >\n>\n>\n>\n>\n> _______________________________________________\n> acl mailing list\n> acl@webdav.org\n> http://mailman.webdav.org/mailman/listinfo/acl\n>\n\n\n_______________________________________________\nacl mailing list\nacl@webdav.org\nhttp://mailman.webdav.org/mailman/listinfo/acl\n\n\n\n", "id": "lists-006-1666544"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   I was not planning on implementing a version-history feature.  I\n   see absolutely no problems with supporting the working resource\n   feature with anything I've said.\n\nRick's point was that if you are also supporting the workspace\nfeature, since you will have many version-controlled resources for the\nsame version history, you need to decouple the lifetime of a version\nhistory (and version) resource from the lifetime of any of the\nversion-controlled resources that might refer to it.\n\nThe protocol has to be consistent in how it acts under any combination\nof features, so you cannot have a DELETE of a version-controlled\nresource do incompatible things depending on what feature set is\nsupported by the server.  (Well, you could, but then writing an\ninteroperable client becomes infeasible).\n\n   I wasn't planning on supporting\n   workspaces, but I don't see any problems there that aren't inherent\n   in being able to delete individual versions.\n\nIf a client explicitly deletes a version resource, it knows what\nit is doing.  In the case of your client that wants to destroy\nall old versions, it can certainly do so (and in fact, if your\nserver supports version history resources, it can do so by issuing\na single delete against the version history resource).\n\nBut a versioning *unaware* clients will also be issuing a DELETE\nagainst a version-controlled resource on a versioning server that\nsupports workspaces, and reasonable behavior must result.  Blowing\naway all versions of that resources from all other workspaces is not a\nreasonable result.\n\n   Although you can keep an object around that allows you to retrieve\n   the version history of a completely deleted resource, I don't\n   understand how that can be done without eventual name collisions.\n\nKeep a counter, or any other kind of GUID generator.  According to the\nprotocol, each new version MUST be given its own unique URL.  A long\nemail thread about 3 months ago let to this consensus, although not\nunanimous, decision.\n\n   Say I create foo/bar.txt as a version controlled resource.  If I\n   wanted a separate version history object, I could put it in some\n   place like /vhist/foo/bar.txt Now someone wants to delete\n   foo/bar.txt -- OK, I delete it but not /vhist/foo/bar.txt\n\n   That works until someone tries to create a new foo/bar.txt that\n   they wish to be a version controlled resource.  I have a collision\n   with /vhist/foo/bar.txt and THIS foo/bar.txt is completely distinct\n   from the original.\n\nThis just means you have to add some GUID to the version history\nresource (and the version resource) URL's.  So you'd keep a counter\nat /vhist, bumping it each time you create a new version history\nresource.  So the version history for foo/bar.txt would be\nsomething like /vhist/foo/bar.txt;3456 while the later version\nhistory for foo/bar.txt would be something like /vhist/foo/bar.txt;8322\n\nAll the details are in the old email thread, but the basic reason\nis that the ability to have reliable URL's to old versions outweighed\nthe additional implementation cost of requiring that GUID's be\nadded to version history and version URL's.\n\nCheers,\nGeoff\n\n\n   From: Rick Rupp [mailto:Rick.Rupp@merant.com] \n\n   I disagree that version history should be deleted if you delete the\n   version controlled resource. Section 5 of the draft clearly states\n   the version history resource exists in a server defined namespace\n   and therefore is unaffected by any deletion or movement of a\n   version controlled resource.  If you require the version history to\n   be deleted you will cause serious problems for a server that\n   supports the workspace and working resource feature.\n\n\n   From: John Hall [mailto:johnhall@evergo.net] \n\n   When you DELETE a version-controlled resource, I strongly believe\n   that all information for that VCR and all versions already created\n   should go to the great bit bucket in the sky.  As I understand your\n   formulation, I would have severe problems in modifying my DAV\n   server (with versioning support) to support DELTAV using this\n   behavior.  I would prefer this formulation / behavior:\n\n   \"In order to remove a resource at a given URL from version control,\n   the client can replace the resource under version control with a\n   non-version-controlled copy of that resource.  For example, a\n   client can COPY the version-controlled resource to a temporary\n   location, DELETE the version-controlled resource, and then MOVE the\n   copy from the temporary location back to the original URL.  Note\n   that the versions already created for the version-controlled\n   resource will NO LONGER BE AVAILABLE.  If you wish to remove a\n   resource at a given URL from version control while also retaining a\n   previous revision history, then you should MOVE the resource to a\n   new save location and COPY the current version back to the original\n   URL.\"\n\n   ========== \n\n   My formulation is based explicitly on the idea that some\n   implementations and some customers are not keeping track of legal\n   documents and therefore deleting old versions is highly desired if\n   not required.  A server shouldn't be forced to keep data that a\n   client is willing to specifically state that it doesn't want.  I\n   think a far better manner of achieving your goals is simply to\n   allow the VERSION-CONTROL method to turn version-control for a\n   resource at a given URL off (if supported by the server).  That\n   allows you to achieve your above objectives (no new versions, but\n   keep the old ones at the same URLs) without changing the usefulness\n   of the DELETE command.\n\n\n\n", "id": "lists-006-1684893"}, {"subject": "RE: Question on support for in-place editin", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n      From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n      By \"in-place editing\" I mean that when the VCR is checked out,\n      clients can do any number of PUT, PROPPATCH and other write\n      operations, before finally checking in.  In the meantime, this\n      work-in-progress is available for other users to see if they have\n      permission to read the resource.\n\n      First question: Does anybody plan to implement DeltaV this way?\n\n   I would strongly consider this an option, if a default GET and PROPFIND\n   did not reference the work in progress but instead referenced the\n   last-checked-in-version.\n\nThat is how working resources work.  The\nversion-controlled resource URL is a copy of the state of some\nchecked-in version (but not the last checked-in version,\nbut rather the last version specified in an UPDATE).\n\nThe working resource has its own URL, and that is what the client\nthat \"checked it out\" works with.\n\nIn-place editing is precisely for those cases where you want the\nall clients to see \"work in progress\" at that URL (to see a\nchecked in version, you look at a URL in a different workspace).\n\n   Imagine this:\n   After checkout, GET/PROPFIND from users that don't have the resource\n   checked out refer to the last checked in copy.  PUT/PROPPATCH are\n   illegal.\n\nThe easiest way to determine \"which user has it checked out\" is to\ngive the \"checked out version\" its own URL.  And PUT/PROPPATCH are\nillegal (unless your server has auto-versioning turned on).\n\n   For the user with the resource checked out, all operations apply to the\n   checkout-in-place copy.\n\n   That gives you most of the functionality of the working resource model,\n   avoids things like UPDATE/MERGE interactions with working resources, and\n   avoids placing extra demands on the client.\n\nAnd how does a client indicate which checked out state it wants to\naccess?  Why make a client remember two strings (the checked-out \"token\"\nand the URL), which it only needs one string (the working-resource URL).\n(We need to support parallel checkouts, so a \"the checked-out one\"\nheader does not suffice).\n\n   If we weren't trying to be compatible with a 3rd party DAV + revision\n   but not DeltaV server, I'd propose that we do it this way.  The 3rd\n   party server puts the working resource in an independent namespace.\n\nSo you actually don't propose we do it this other way?  Then we agree (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1698893"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "   From: Rick Rupp [mailto:Rick.Rupp@merant.com]\n\n   A version-controlled resource is really just a handle to a version\n   resource contained within a version-history resource.\n\nIt's best to think of them as three totally separate and distinct\nresources.  A checked-in version-controlled resource does display the\nsame content and dead properties of another totally separate resource\n(the version resource identified by the DAV:checked-in property),\nbut it is not a \"handle\" or \"pointer\" or \"reference\" to that resource\nin any significant way.\n\n   There could\n   be many version-controlled resource pointing to the same\n   version.\n\nYes.\n\n   Deleting a version when deleting a version-controlled\n   resource does not make any sense.\n\nYes, in the context of many version-controlled resources\nassociated with the same version history, this deletion\ndoes not make sense (just because one workspace is no longer\ninterested in it, does not mean other workspaces aren't).\n\n   What is not clear is how a client can delete a version or\n   version-history resource when the server only supports the\n   version-control feature.\n\nA version resource has a URL assigned to it when it is created.\nIf you issue a DELETE request against that URL, that version is\ndeleted (assuming you have permission to do so).  The URL for\nversions can be obtained from the DAV:checked-in property,\nthe DAV:version-tree report, and the DAV:predecessor-set and\nDAV:successor-set properties of another version resource.\n\n   Maybe what needs to be stated is a\n   version-history resource MUST be deleted when the\n   version-controlled resource is deleted if the server only supports\n   the version-control feature.\n\nIf the server only supports the version control feature, then there\nis no version history resource visible in the URL namespace, so a\nclient wouldn't know if it was deleted or not (:-).  The key here\nis that the behavior of DELETE has to be consistent, whatever\nfeature set is supported by the server, so you can't have \nDELETE do incompatible things depending on what versioning features\nare supported (not if you want to make it feasible to write\ninteroperable clients).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1709114"}, {"subject": "AW: Question on support for in-place editin", "content": "> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Lisa Dusseault\n>\n> DeltaV supports an in-place editing model for situations where the server\n> does not support the Working Resource option, and where the\n> client does not\n> do all their edits on their local copy.\n>\n> By \"in-place editing\" I mean that when the VCR is checked out, clients can\n> do any number of PUT, PROPPATCH and other write operations, before finally\n> checking in.  In the meantime, this work-in-progress is available\n> for other\n> users to see if they have permission to read the resource.\n>\n> First question: Does anybody plan to implement DeltaV this way?\n> [...]\n\nYes.\n\n> Second question:  Is there a way for clients to view working resources and\n> only see the latest checked-in versions?  E.g. I may be uninterested in\n> seeing \"works in progress\" affected by in-place editing.  Can I do a\n> PROPFIND depth-1 against the latest checked-in versions in a collection,\n> rather than the works-in-progress?\n\nI think that's what working resources are made for. Anyway, how should your\nfeature work with anonymous access?\n\nStefan\n\n\n\n", "id": "lists-006-1719191"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "One additional note:\n\nThe key relationship between a checked-in version-controlled resource\nand a version resource is that the DAV:checked-in property of a VCR\ncontains the URL of a version resource.\n\nSome of the options open to a server when an explicit request to\nDELETE a version identified by a DAV:checked-in property include:\n\n- fail the DELETE\n- allow the DELETE, and return a 404 when a client later attempts\n  to perform some operation on the URL from the DAV:checked-in property\n  of the VCR\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@Rational.Com]\nSent: Tuesday, June 12, 2001 10:15 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Confusion: Removing a resource from version control \n\n\n\n   From: Rick Rupp [mailto:Rick.Rupp@merant.com]\n\n   A version-controlled resource is really just a handle to a version\n   resource contained within a version-history resource.\n\nIt's best to think of them as three totally separate and distinct\nresources.  A checked-in version-controlled resource does display the\nsame content and dead properties of another totally separate resource\n(the version resource identified by the DAV:checked-in property),\nbut it is not a \"handle\" or \"pointer\" or \"reference\" to that resource\nin any significant way.\n\n   There could\n   be many version-controlled resource pointing to the same\n   version.\n\nYes.\n\n   Deleting a version when deleting a version-controlled\n   resource does not make any sense.\n\nYes, in the context of many version-controlled resources\nassociated with the same version history, this deletion\ndoes not make sense (just because one workspace is no longer\ninterested in it, does not mean other workspaces aren't).\n\n   What is not clear is how a client can delete a version or\n   version-history resource when the server only supports the\n   version-control feature.\n\nA version resource has a URL assigned to it when it is created.\nIf you issue a DELETE request against that URL, that version is\ndeleted (assuming you have permission to do so).  The URL for\nversions can be obtained from the DAV:checked-in property,\nthe DAV:version-tree report, and the DAV:predecessor-set and\nDAV:successor-set properties of another version resource.\n\n   Maybe what needs to be stated is a\n   version-history resource MUST be deleted when the\n   version-controlled resource is deleted if the server only supports\n   the version-control feature.\n\nIf the server only supports the version control feature, then there\nis no version history resource visible in the URL namespace, so a\nclient wouldn't know if it was deleted or not (:-).  The key here\nis that the behavior of DELETE has to be consistent, whatever\nfeature set is supported by the server, so you can't have \nDELETE do incompatible things depending on what versioning features\nare supported (not if you want to make it feasible to write\ninteroperable clients).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1728977"}, {"subject": "RE: [ACL] RE: lock and access control lists on (working) version", "content": "When I version a resource I will also likely want to version the access\ncontrol list it had when I 'froze' it. This is very important for things\nlike security checks. Imagine that an employee who was fired a year ago\nturned out to be a corporate spy, you are going to want to check what\nresources he had access to back then. This means that a version really needs\ntwo sets of ACLs. One if the ACL list it had when it was frozen. The other\nis the ACL list it currently uses to decide who gets to see the version.\n\n> -----Original Message-----\n> From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> Clemm, Geoff\n> Sent: Saturday, May 26, 2001 8:27 AM\n> To: ietf-dav-versioning@w3.org\n> Cc: acl@webdav.org\n> Subject: [ACL] RE: lock and access control lists on (working) versions\n>\n>\n> As Tim surmised, the answer to (1) is in fact \"yes\".\n> Each version is a separate resource, and each resource\n> can have its own distinct access control list.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n> Sent: Wednesday, May 16, 2001 5:42 AM\n> To: ietf-dav-versioning@w3.org\n> Cc: acl@webdav.org\n> Subject: Re: lock and access control lists on (working) versions\n>\n>\n>\n>\n> \"Pill, Juergen\" <Juergen.Pill@softwareag.com>\n> > Hello,\n> >\n> > 1) Would it be possible with DETA-V to have different access\n> control list\n> > for different versions of a resource, e.g. V1 of resource /foo\n> will allow\n> > user A to modify and read, but V2 of resource /foo will allow user A to\n> read\n> > read only?\n>\n> You'd have to ask the ACL-folk that question, but I would sincerely hope\n> the answer is 'yes'.\n>\n> > 2) Would it be possible to have two distinct locks on two different\n> > (working) resources?\n>\n> Yes.  Working resources have distinct server-defined URLs.  They can be\n> locked using their URLs just like any other resource.\n>\n> > Does that make sense at all?\n>\n> Yep.\n>\n> Tim\n>\n>\n> _______________________________________________\n> acl mailing list\n> acl@webdav.org\n> http://mailman.webdav.org/mailman/listinfo/acl\n>\n\n\n\n", "id": "lists-006-1740156"}, {"subject": "RE: [ACL] RE: lock and access control lists on (working) version", "content": "When is a resource frozen?  Can you translate that into DeltaV terms?\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Yaron Goland\n> Sent: Tuesday, June 12, 2001 2:30 PM\n> To: Clemm, Geoff; ietf-dav-versioning@w3.org\n> Cc: acl@webdav.org\n> Subject: RE: [ACL] RE: lock and access control lists on (working)\n> versions\n>\n>\n> When I version a resource I will also likely want to version the access\n> control list it had when I 'froze' it. This is very important for things\n> like security checks. Imagine that an employee who was fired a year ago\n> turned out to be a corporate spy, you are going to want to check what\n> resources he had access to back then. This means that a version\n> really needs\n> two sets of ACLs. One if the ACL list it had when it was frozen. The other\n> is the ACL list it currently uses to decide who gets to see the version.\n>\n> > -----Original Message-----\n> > From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> > Clemm, Geoff\n> > Sent: Saturday, May 26, 2001 8:27 AM\n> > To: ietf-dav-versioning@w3.org\n> > Cc: acl@webdav.org\n> > Subject: [ACL] RE: lock and access control lists on (working) versions\n> >\n> >\n> > As Tim surmised, the answer to (1) is in fact \"yes\".\n> > Each version is a separate resource, and each resource\n> > can have its own distinct access control list.\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n> > Sent: Wednesday, May 16, 2001 5:42 AM\n> > To: ietf-dav-versioning@w3.org\n> > Cc: acl@webdav.org\n> > Subject: Re: lock and access control lists on (working) versions\n> >\n> >\n> >\n> >\n> > \"Pill, Juergen\" <Juergen.Pill@softwareag.com>\n> > > Hello,\n> > >\n> > > 1) Would it be possible with DETA-V to have different access\n> > control list\n> > > for different versions of a resource, e.g. V1 of resource /foo\n> > will allow\n> > > user A to modify and read, but V2 of resource /foo will allow\n> user A to\n> > read\n> > > read only?\n> >\n> > You'd have to ask the ACL-folk that question, but I would sincerely hope\n> > the answer is 'yes'.\n> >\n> > > 2) Would it be possible to have two distinct locks on two different\n> > > (working) resources?\n> >\n> > Yes.  Working resources have distinct server-defined URLs.  They can be\n> > locked using their URLs just like any other resource.\n> >\n> > > Does that make sense at all?\n> >\n> > Yep.\n> >\n> > Tim\n> >\n> >\n> > _______________________________________________\n> > acl mailing list\n> > acl@webdav.org\n> > http://mailman.webdav.org/mailman/listinfo/acl\n> >\n>\n>\n>\n>\n\n\n\n", "id": "lists-006-1754324"}, {"subject": "RE: [ACL] RE: lock and access control lists on (working) version", "content": "\"frozen\" == \"checked in\".\n\n-----Original Message-----\nFrom: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\n\nWhen is a resource frozen?  Can you translate that into DeltaV terms?\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Yaron Goland\n>\n> When I version a resource I will also likely want to version the access\n> control list it had when I 'froze' it. This is very important for things\n> like security checks. Imagine that an employee who was fired a year ago\n> turned out to be a corporate spy, you are going to want to check what\n> resources he had access to back then. This means that a version\n> really needs\n> two sets of ACLs. One if the ACL list it had when it was frozen. The other\n> is the ACL list it currently uses to decide who gets to see the version.\n>\n> > -----Original Message-----\n> > From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> > Clemm, Geoff\n> >\n> > As Tim surmised, the answer to (1) is in fact \"yes\".\n> > Each version is a separate resource, and each resource\n> > can have its own distinct access control list.\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n> >\n> > \"Pill, Juergen\" <Juergen.Pill@softwareag.com>\n> > > Hello,\n> > >\n> > > 1) Would it be possible with DETA-V to have different access\n> > control list\n> > > for different versions of a resource, e.g. V1 of resource /foo\n> > will allow\n> > > user A to modify and read, but V2 of resource /foo will allow\n> user A to\n> > read\n> > > read only?\n> >\n> > You'd have to ask the ACL-folk that question, but I would sincerely hope\n> > the answer is 'yes'.\n> >\n> > > 2) Would it be possible to have two distinct locks on two different\n> > > (working) resources?\n> >\n> > Yes.  Working resources have distinct server-defined URLs.  They can be\n> > locked using their URLs just like any other resource.\n> >\n\n\n\n", "id": "lists-006-1769314"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "> If the server only supports the version control feature, then there\n> is no version history resource visible in the URL namespace, so a\n> client wouldn't know if it was deleted or not (:-).  The key here\n> is that the behavior of DELETE has to be consistent, whatever\n> feature set is supported by the server, so you can't have\n> DELETE do incompatible things depending on what versioning features\n> are supported (not if you want to make it feasible to write\n> interoperable clients).\n\nThen you need to explain in the draft what the interoperable behaviour is\nthat allows our implementation to clean out version histories automatically,\nbecause that is what our customers want.\n\nlisa\n\n\n\n", "id": "lists-006-1782214"}, {"subject": "RE: Question on support for in-place editin", "content": "> > Second question:  Is there a way for clients to view working\n> resources and\n> > only see the latest checked-in versions?  E.g. I may be uninterested in\n> > seeing \"works in progress\" affected by in-place editing.  Can I do a\n> > PROPFIND depth-1 against the latest checked-in versions in a collection,\n> > rather than the works-in-progress?\n>\n> I think that's what working resources are made for. Anyway, how\n> should your\n> feature work with anonymous access?\n\nOops, I meant \"view a bunch of version-controlled resources and only see\nlatest checked-in versions\".  I can see that's what working resources are\nmade for, only unfortunately existing clients don't support working\nresources.  I'm trying to make our implementation work as much as possible\nwith existing WebDAV clients and still have the desired behaviour.  If we\ndidn't have to be compatible with DeltaV, it would be easy.  ;)\n\nWhy wouldn't viewing checked-in versions work with anonymous access, as long\nas the 'anonymous' principal is granted read privilege on the resources?\n\nlisa\n\n\n\n", "id": "lists-006-1790551"}, {"subject": "RE: [ACL] RE: lock and access control lists on (working) version", "content": "If \"frozen\" == \"checked in\" then you have no way of knowing what\nresources an employee used to have, since they may have selected\nan older version with a particular workspace.\n\nI guess the basic question is whether or not ACLs are versioned like\na dead property.  In other words, does changing the ACL create a new\nversion?  I think that if you do create a new version when you change\nthe ACL, you will get what you want, since by correlating the\ncreation date of each version with the ACL on each, you can figure\nout what versions of the resource a particular user had access to\nduring a particular period of time.\n\n> -----Original Message-----\n> From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> Clemm, Geoff\n> Sent: Wednesday, June 13, 2001 9:47 AM\n> To: ietf-dav-versioning@w3.org\n> Cc: acl@webdav.org\n> Subject: RE: [ACL] RE: lock and access control lists on (working)\n> versions\n>\n>\n> \"frozen\" == \"checked in\".\n>\n> -----Original Message-----\n> From: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\n>\n> When is a resource frozen?  Can you translate that into DeltaV terms?\n>\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Yaron Goland\n> >\n> > When I version a resource I will also likely want to version the access\n> > control list it had when I 'froze' it. This is very important for things\n> > like security checks. Imagine that an employee who was fired a year ago\n> > turned out to be a corporate spy, you are going to want to check what\n> > resources he had access to back then. This means that a version\n> > really needs\n> > two sets of ACLs. One if the ACL list it had when it was\n> frozen. The other\n> > is the ACL list it currently uses to decide who gets to see the version.\n> >\n> > > -----Original Message-----\n> > > From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> > > Clemm, Geoff\n> > >\n> > > As Tim surmised, the answer to (1) is in fact \"yes\".\n> > > Each version is a separate resource, and each resource\n> > > can have its own distinct access control list.\n> > >\n> > > Cheers,\n> > > Geoff\n> > >\n> > > -----Original Message-----\n> > > From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n> > >\n> > > \"Pill, Juergen\" <Juergen.Pill@softwareag.com>\n> > > > Hello,\n> > > >\n> > > > 1) Would it be possible with DETA-V to have different access\n> > > control list\n> > > > for different versions of a resource, e.g. V1 of resource /foo\n> > > will allow\n> > > > user A to modify and read, but V2 of resource /foo will allow\n> > user A to\n> > > read\n> > > > read only?\n> > >\n> > > You'd have to ask the ACL-folk that question, but I would\n> sincerely hope\n> > > the answer is 'yes'.\n> > >\n> > > > 2) Would it be possible to have two distinct locks on two different\n> > > > (working) resources?\n> > >\n> > > Yes.  Working resources have distinct server-defined URLs.\n> They can be\n> > > locked using their URLs just like any other resource.\n> > >\n>\n> _______________________________________________\n> acl mailing list\n> acl@webdav.org\n> http://mailman.webdav.org/mailman/listinfo/acl\n>\n\n\n\n", "id": "lists-006-1798920"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "Interoperability is achieved by making server behavior\npredictable.  If there are two different \"reasonable\"\nbehaviors, one needs to chose one behavior as the defined\nbehavior and ensure that the other behavior can be achieved\nby explicit client action.  In this case, the two behaviors are:\n\n- automatically delete all versions from a version history\nwhen a version-controlled resource for that version history \nis deleted.\n\n- keep all versions when a version-controlled resource is deleted.\n\nIf the defined behavior is to keep all versions, then the other\nbehavior can be achieved by the client explicitly deleting\nthe versions when deleting the version-controlled resource.\nBut if the defined behavior is to delete all versions, the other\nbehavior cannot be achieved by any explicit client action\n(the versions are deleted and cannot be brought back).\n\nNote that \"explicit client action\" does not mean \"explicit user\naction\".  A client can expose a user to whatever default behavior\nit wishes (e.g. delete all versions), and can achieve that\nbehavior interoperably against all (compliant) servers.\n\nAlternatively, one can just define every possible server default\nas a \"server option\", and leave it up to the client writer to\ndiscover what kind of server it is running against, and to\nmodify every action it performs based upon \"what kind of server\"\nit is running against.  But the result of this approach is\nthat it is too hard to write an interoperable client, so you\njust write clients to run against a specific set of server\noptions, and thus interoperability is not achieved.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Wednesday, June 13, 2001 1:03 PM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: RE: Confusion: Removing a resource from version control \n\n\n> If the server only supports the version control feature, then there\n> is no version history resource visible in the URL namespace, so a\n> client wouldn't know if it was deleted or not (:-).  The key here\n> is that the behavior of DELETE has to be consistent, whatever\n> feature set is supported by the server, so you can't have\n> DELETE do incompatible things depending on what versioning features\n> are supported (not if you want to make it feasible to write\n> interoperable clients).\n\nThen you need to explain in the draft what the interoperable behaviour is\nthat allows our implementation to clean out version histories automatically,\nbecause that is what our customers want.\n\nlisa\n\n\n\n", "id": "lists-006-1814823"}, {"subject": "RE: [ACL] RE: lock and access control lists on (working) version", "content": "I don't think anyone was suggesting \"either/or\" here.\nThe ACL on a version resource will always be the ACL\nthat control access to that version resource (and can\nbe changed, when you change your mind about who can\naccess that version resource).\n\nYaron was just suggesting that we add *another* property\nthat captures the ACL of the version-controlled resource\nat the time of check-in.  This would not be the DAV:acl\nproperty, but would be something like the DAV:checkin-acl\nproperty.\n\nIn an earlier message, I indicated that I believed there\nis not sufficient value or interest in a DAV:checkin-acl\nproperty to merit its inclusion in either\nthe versioning or the acl protocol.\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\nSent: Wednesday, June 13, 2001 2:00 PM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nCc: acl@webdav.org\nSubject: RE: [ACL] RE: lock and access control lists on (working)\nversions\n\n\nIf \"frozen\" == \"checked in\" then you have no way of knowing what\nresources an employee used to have, since they may have selected\nan older version with a particular workspace.\n\nI guess the basic question is whether or not ACLs are versioned like\na dead property.  In other words, does changing the ACL create a new\nversion?  I think that if you do create a new version when you change\nthe ACL, you will get what you want, since by correlating the\ncreation date of each version with the ACL on each, you can figure\nout what versions of the resource a particular user had access to\nduring a particular period of time.\n\n> -----Original Message-----\n> From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> Clemm, Geoff\n> Sent: Wednesday, June 13, 2001 9:47 AM\n> To: ietf-dav-versioning@w3.org\n> Cc: acl@webdav.org\n> Subject: RE: [ACL] RE: lock and access control lists on (working)\n> versions\n>\n>\n> \"frozen\" == \"checked in\".\n>\n> -----Original Message-----\n> From: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\n>\n> When is a resource frozen?  Can you translate that into DeltaV terms?\n>\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Yaron Goland\n> >\n> > When I version a resource I will also likely want to version the access\n> > control list it had when I 'froze' it. This is very important for things\n> > like security checks. Imagine that an employee who was fired a year ago\n> > turned out to be a corporate spy, you are going to want to check what\n> > resources he had access to back then. This means that a version\n> > really needs\n> > two sets of ACLs. One if the ACL list it had when it was\n> frozen. The other\n> > is the ACL list it currently uses to decide who gets to see the version.\n> >\n> > > -----Original Message-----\n> > > From: acl-admin@webdav.org [mailto:acl-admin@webdav.org]On Behalf Of\n> > > Clemm, Geoff\n> > >\n> > > As Tim surmised, the answer to (1) is in fact \"yes\".\n> > > Each version is a separate resource, and each resource\n> > > can have its own distinct access control list.\n> > >\n> > > Cheers,\n> > > Geoff\n> > >\n> > > -----Original Message-----\n> > > From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n> > >\n> > > \"Pill, Juergen\" <Juergen.Pill@softwareag.com>\n> > > > Hello,\n> > > >\n> > > > 1) Would it be possible with DETA-V to have different access\n> > > control list\n> > > > for different versions of a resource, e.g. V1 of resource /foo\n> > > will allow\n> > > > user A to modify and read, but V2 of resource /foo will allow\n> > user A to\n> > > read\n> > > > read only?\n> > >\n> > > You'd have to ask the ACL-folk that question, but I would\n> sincerely hope\n> > > the answer is 'yes'.\n> > >\n> > > > 2) Would it be possible to have two distinct locks on two different\n> > > > (working) resources?\n> > >\n> > > Yes.  Working resources have distinct server-defined URLs.\n> They can be\n> > > locked using their URLs just like any other resource.\n> > >\n>\n> _______________________________________________\n> acl mailing list\n> acl@webdav.org\n> http://mailman.webdav.org/mailman/listinfo/acl\n>\n\n\n\n", "id": "lists-006-1825652"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "> If the defined behavior is to keep all versions, then the other\n> behavior can be achieved by the client explicitly deleting\n> the versions when deleting the version-controlled resource.\n> But if the defined behavior is to delete all versions, the other\n> behavior cannot be achieved by any explicit client action\n> (the versions are deleted and cannot be brought back).\n\nNormally I'd agree with what you're saying, but cleaning up old versions can\nbe server policy.  Server administrators can't force clients to do that, so\nit must be a possible server behaviour.\n\nI understand it can also be server policy to keep around all old versions\nand NEVER delete them.  That's why DeltaV MUST support both.\n\nlisa\n\n\n\n", "id": "lists-006-1843117"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "If you were to use the model of an RDBMS;\n\nIf a version is related to anything then you must archive everything at that\npoint of time before removing the relation and the version.\n\nIf something in the version control system depends on or is a child of the\nversion that is to be deleted then that version can not be deleted.\n\nDo not allow the versioning standard to allow defined corruption...\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\nSent: Wednesday, June 13, 2001 12:37 PM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: RE: Confusion: Removing a resource from version control\n\n\n\n> If the defined behavior is to keep all versions, then the other\n> behavior can be achieved by the client explicitly deleting\n> the versions when deleting the version-controlled resource.\n> But if the defined behavior is to delete all versions, the other\n> behavior cannot be achieved by any explicit client action\n> (the versions are deleted and cannot be brought back).\n\nNormally I'd agree with what you're saying, but cleaning up old versions can\nbe server policy.  Server administrators can't force clients to do that, so\nit must be a possible server behaviour.\n\nI understand it can also be server policy to keep around all old versions\nand NEVER delete them.  That's why DeltaV MUST support both.\n\nlisa\n\n\n\n", "id": "lists-006-1851725"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "A server can of course delete old versions.  It can delete\nany resource that it wants to (anything older than 6 months,\nanything named \"core\", anything authored by \"geoff\" (:-),\nwhatever).  The question is what kind of expectation should\na client have for persistency of data.  If servers delete\nversions as soon as a version-controlled resource is deleted,\na client would have to \"save\" any versions it cares about in\nsome other location before it deletes the version-controlled\nresource.  If servers do not delete versions as soon as\na version-controlled resource is deleted, the client would\nhave to explicitly delete the versions it wanted deleted.\nThe more such \"server options\" are supported, the harder\nit is to write an interoperable client, and the less likely it\nis that anyone will be able to do so.\n\nSo I disagree that \"DeltaV MUST support both\" (i.e. leave this\nas a server option).  To the contrary, if we care about\nbuiding interoperable clients, it should specify one behavior\nor the other.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Wednesday, June 13, 2001 2:37 PM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: RE: Confusion: Removing a resource from version control \n\n\n\n> If the defined behavior is to keep all versions, then the other\n> behavior can be achieved by the client explicitly deleting\n> the versions when deleting the version-controlled resource.\n> But if the defined behavior is to delete all versions, the other\n> behavior cannot be achieved by any explicit client action\n> (the versions are deleted and cannot be brought back).\n\nNormally I'd agree with what you're saying, but cleaning up old versions can\nbe server policy.  Server administrators can't force clients to do that, so\nit must be a possible server behaviour.\n\nI understand it can also be server policy to keep around all old versions\nand NEVER delete them.  That's why DeltaV MUST support both.\n\nlisa\n\n\n\n", "id": "lists-006-1861537"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "I'm not dissing the RDBMS-model or any other model that says \"keep around\nversions that are referenced\". In fact, what I'm proposing may be compatible\nwith that model -- we weren't planning to delete versions that were still\nreferenced by an existing VCR.\n\nI'm also not dissing the model that says \"keep around all versions forever\".\nThat's fine.\n\nBut there is also a model that requires servers to delete stuff.  To\nconserve space, to enforce policy on not archiving stuff (e.g. like email\nservers), or for whatever reason.  The rule might be to delete ANYTHING over\n2 yrs old.  The rule might be to cleanse (bitmask wipe) anything that's\ndeleted in case your archives are requested for material in a trial.  The\nspec needs to accomodate these models as well.\n\nOr consider the model on www.sharemation.com, where we support versioning\nthrough a Web UI (try it out) but we also have quota.  A user is limited to\n20 MB.  THey reach that and clean out old files.  How can they possibly\nreduce the amount of space used in their system?  Remember, this person may\nbe using current Web Folders or other existing clients.\n\nTo rebut the earlier argument that clients need predictable behaviour --\nwell sometimes that goes by the wayside.  After all, that's what 404 Not\nFound was invented for.  Things disappear.\n\nlisa\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Kevin Angus\n> Sent: Wednesday, June 13, 2001 12:03 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Confusion: Removing a resource from version control\n>\n>\n> If you were to use the model of an RDBMS;\n>\n> If a version is related to anything then you must archive\n> everything at that\n> point of time before removing the relation and the version.\n>\n> If something in the version control system depends on or is a child of the\n> version that is to be deleted then that version can not be deleted.\n>\n> Do not allow the versioning standard to allow defined corruption...\n>\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: Wednesday, June 13, 2001 12:37 PM\n> To: Clemm, Geoff; ietf-dav-versioning@w3.org\n> Subject: RE: Confusion: Removing a resource from version control\n>\n>\n>\n> > If the defined behavior is to keep all versions, then the other\n> > behavior can be achieved by the client explicitly deleting\n> > the versions when deleting the version-controlled resource.\n> > But if the defined behavior is to delete all versions, the other\n> > behavior cannot be achieved by any explicit client action\n> > (the versions are deleted and cannot be brought back).\n>\n> Normally I'd agree with what you're saying, but cleaning up old\n> versions can\n> be server policy.  Server administrators can't force clients to\n> do that, so\n> it must be a possible server behaviour.\n>\n> I understand it can also be server policy to keep around all old versions\n> and NEVER delete them.  That's why DeltaV MUST support both.\n>\n> lisa\n>\n\n\n\n", "id": "lists-006-1871522"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   To rebut the earlier argument that clients need predictable\n   behaviour -- well sometimes that goes by the wayside.  After all,\n   that's what 404 Not Found was invented for.  Things disappear.\n\nHaving the server provide predictable behavior for a versioning\nunaware client (and for that matter, a versioning unaware user) is\nnecessary but far from sufficient.  The hard part is to also support\nan interoperable versioning-aware client for versioning aware\nusers.\n\nA versioning aware user knows (and cares) whether old versions are\nkept or not.  A versioning aware client needs to do what the\nversioning aware user wants (not just some random behavior selected by\na versioning server implementer).  So that means if the versioning\naware user wants the versions to be deleted, the versioning aware\nclient needs to somehow delete those versions.  Similarly, if the\nversioning aware user wants the versions to be kept, the versioning\naware client needs to somehow save those versions.\n\nIf the protocol defines the deletion behavior, an interoperable\nversioning aware client can be written to produce whatever versioning\nbehavior the user expects.  If the protocol leaves deletion behavior\nup to the server, then an interoperable versioning client would need\nto determine what behavior the server has chosen to implement, and\nthen have separate code paths to deal with each of those behaviors\n(in order to produce the effect expected by the versioning aware\nuser).\n\nNote: If you primarily care about producing a specific behavior for\nversioning *unaware* clients, and you don't care much about\ninteroperability with versioning *aware* clients, then you can just\nsupport HTTP or 2518 WebDAV, and implement whatever versioning\nbehavior you want.  But if you want to support interoperability\nbetween versioning aware clients, then you only get that by defining\nexplicit behavior for the server that versioning aware clients can\ncount on when they are implementing versioning behavior for a\nversioning aware user. \n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1884052"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\nSent: Tuesday, June 12, 2001 6:08 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Confusion: Removing a resource from version control \n\n\n> But a versioning *unaware* clients will also be issuing a DELETE\nagainst a version-controlled resource on a versioning \n> server that supports workspaces, and reasonable behavior must result.\nBlowing away all versions of that resources \n> from all other workspaces is not a reasonable result.\n\nI fail to see what this is not a reasonable result, either in the\npresence of workspaces or not.\n\nWithout workspaces, it is the normally expected behavior.  It is the\nbehavior a user is used to when they say \"del foo.txt\"  oops \"rm\nfoo.txt\".  It is the expected behavior they get when they issue a DELETE\non a DAV server.  It is the expectation of customers building simple\nclients.\n\n\"Least Surprise\".  If you don't know anything about a server\nimplementation, they only thing safe to assume is that DELETE means\nDESTROY.\n\n\"Greater Burden\".  The more sophisticated client should have a greater\nburden than the less sophisticated client.  A simple non-workspace\nclient should not have to jump through hoops to make it easier to write\na more complex client that uses workspaces.  If necessary, add a XML\nitem to the DELETE VCR that would say <!ELEMENT retain-old-versions\nEMPTY>, again keeping the burden on the new clients and the more\nsophisticated clients not the older and less sophisticated ones.  If you\nchange the spec so that the default MAY blow away all old versions when\nyou delete the VCR I'd be happy to say that such behavior MUST also\nsupport retain-old-versions.\n\nNow, the workspace element \"workspace-checkout-set\" name seems to imply\nthat a workspace only references checked out versions.  So what would be\nthe problem?  A DELETE should fail on an item that is in a checked-out\nstate, so the fact that a workspace has references to checked out\nversions isn't a problem.  Perhaps you should define a 'checkout-count'\non a VCR when operating in the presence of workspaces.\n\nIf the workspace refers to non-checked out versions, then there is\nalways the \"404 Not Found\" error code.  I see no reason why a client\nshouldn't handle, and be prepared to handle, that case.  It matches a\nclient that is storing its state on local disk, like most source control\nsystems.  A 'sync' will note that a resouce is no longer found and\ndelete it from the local copy.\n\nThis does not prevent your implmentation from keeping around all old\nversions.  It does mean we don't have to ask our customers to increase\ntheir complexity in order to get simple functionality.\n\n=====================\n\nIn summary, I think it is unreasonable not to allow a server to blow\naway all versions when the VCR is deleted.  It is a natural\nimplementation which satisfies customer desires and expectations.  Nor\ndo I think the implementation of this behavior in my server precludes\nyour server implementation, or makes it difficult for your more\nsophisticated client to be interoperable.\n\nPeace\n \n\n\n\n", "id": "lists-006-1894310"}, {"subject": "Removing a resource: A compromise that satisfies", "content": "Ok, then have the versioning aware client specify exactly the behavior\nit expects.\n\nDELETE /foo.txt\n\nIs issued by version unaware clients and version aware clients that wish\nto delete a resource completely.\n\nDELETE /foo.txt\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<DAV:retain-old-versions/>\n\nIs issued by version aware clients that wish to see the VCR removed but\nnot old versions die.\n\nDoing this seems to satisfy both of our requirements.  We want to make\nsure that there is a small burden on simple clients, and you wish to\nretain consistency, predictability, and flexibility in more\nsophisticated clients.\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\nSent: Wednesday, June 13, 2001 1:54 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Confusion: Removing a resource from version control \n\n\n   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   To rebut the earlier argument that clients need predictable\n   behaviour -- well sometimes that goes by the wayside.  After all,\n   that's what 404 Not Found was invented for.  Things disappear.\n\nHaving the server provide predictable behavior for a versioning unaware\nclient (and for that matter, a versioning unaware user) is necessary but\nfar from sufficient.  The hard part is to also support an interoperable\nversioning-aware client for versioning aware users.\n\nA versioning aware user knows (and cares) whether old versions are kept\nor not.  A versioning aware client needs to do what the versioning aware\nuser wants (not just some random behavior selected by a versioning\nserver implementer).  So that means if the versioning aware user wants\nthe versions to be deleted, the versioning aware client needs to somehow\ndelete those versions.  Similarly, if the versioning aware user wants\nthe versions to be kept, the versioning aware client needs to somehow\nsave those versions.\n\nIf the protocol defines the deletion behavior, an interoperable\nversioning aware client can be written to produce whatever versioning\nbehavior the user expects.  If the protocol leaves deletion behavior up\nto the server, then an interoperable versioning client would need to\ndetermine what behavior the server has chosen to implement, and then\nhave separate code paths to deal with each of those behaviors (in order\nto produce the effect expected by the versioning aware user).\n\nNote: If you primarily care about producing a specific behavior for\nversioning *unaware* clients, and you don't care much about\ninteroperability with versioning *aware* clients, then you can just\nsupport HTTP or 2518 WebDAV, and implement whatever versioning behavior\nyou want.  But if you want to support interoperability between\nversioning aware clients, then you only get that by defining explicit\nbehavior for the server that versioning aware clients can count on when\nthey are implementing versioning behavior for a versioning aware user. \n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1905957"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "> A versioning aware client needs to do what the\n> versioning aware user wants (not just some random behavior selected by\n> a versioning server implementer).  So that means if the versioning\n> aware user wants the versions to be deleted, the versioning aware\n> client needs to somehow delete those versions.  Similarly, if the\n> versioning aware user wants the versions to be kept, the versioning\n> aware client needs to somehow save those versions.\n\nIt seems to me that this is an inconsistent position with respect to other\nimplementor-dependent behaviour already allowed by DeltaV.\n\nYou might also say \"A versioning aware client needs to do what the\nversioning aware user wants (not just some random behaviour selected by a\nversioning server implementer).  So that means if the versioning aware user\nwants the resource to be created as a regular resource, the versioning aware\nclient needs to somehow be able to create the resource as a regular\nresource.  Similarly, if the versioning aware user wants the resource to be\ncreated as a version-controlled resource, the versioning aware client needs\nto somehow be able to achieve that.\"\n\nYet, the deltaV specification allows implementations to create resources\nthat are versioned in response to a PUT to a non-existent, or to create\nresources that are not versioned.  That's \"some random behavior selected by\na versioning server implementer.\"\n\nI could probably come up with some more examples!\n\nlisa\n\n\n\n", "id": "lists-006-1919454"}, {"subject": "Re: Removing a resource: A compromise that satisfies", "content": "This is a bad solution. It does not consider a server where version history \nis important.\n\nAt 6/13/2001 02:35 PM, John Hall wrote:\n>Ok, then have the versioning aware client specify exactly the behavior\n>it expects.\n>\n>DELETE /foo.txt\n>\n>Is issued by version unaware clients and version aware clients that wish\n>to delete a resource completely.\n>\n>DELETE /foo.txt\n><?xml version=\"1.0\" encoding=\"utf-8\" ?>\n><DAV:retain-old-versions/>\n>\n>Is issued by version aware clients that wish to see the VCR removed but\n>not old versions die.\n>\n>Doing this seems to satisfy both of our requirements.  We want to make\n>sure that there is a small burden on simple clients, and you wish to\n>retain consistency, predictability, and flexibility in more\n>sophisticated clients.\n>\n>-----Original Message-----\n>From: ietf-dav-versioning-request@w3.org\n>[mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n>Sent: Wednesday, June 13, 2001 1:54 PM\n>To: ietf-dav-versioning@w3.org\n>Subject: RE: Confusion: Removing a resource from version control\n>\n>\n>    From: Lisa Dusseault [mailto:lisa@xythos.com]\n>\n>    To rebut the earlier argument that clients need predictable\n>    behaviour -- well sometimes that goes by the wayside.  After all,\n>    that's what 404 Not Found was invented for.  Things disappear.\n>\n>Having the server provide predictable behavior for a versioning unaware\n>client (and for that matter, a versioning unaware user) is necessary but\n>far from sufficient.  The hard part is to also support an interoperable\n>versioning-aware client for versioning aware users.\n>\n>A versioning aware user knows (and cares) whether old versions are kept\n>or not.  A versioning aware client needs to do what the versioning aware\n>user wants (not just some random behavior selected by a versioning\n>server implementer).  So that means if the versioning aware user wants\n>the versions to be deleted, the versioning aware client needs to somehow\n>delete those versions.  Similarly, if the versioning aware user wants\n>the versions to be kept, the versioning aware client needs to somehow\n>save those versions.\n>\n>If the protocol defines the deletion behavior, an interoperable\n>versioning aware client can be written to produce whatever versioning\n>behavior the user expects.  If the protocol leaves deletion behavior up\n>to the server, then an interoperable versioning client would need to\n>determine what behavior the server has chosen to implement, and then\n>have separate code paths to deal with each of those behaviors (in order\n>to produce the effect expected by the versioning aware user).\n>\n>Note: If you primarily care about producing a specific behavior for\n>versioning *unaware* clients, and you don't care much about\n>interoperability with versioning *aware* clients, then you can just\n>support HTTP or 2518 WebDAV, and implement whatever versioning behavior\n>you want.  But if you want to support interoperability between\n>versioning aware clients, then you only get that by defining explicit\n>behavior for the server that versioning aware clients can count on when\n>they are implementing versioning behavior for a versioning aware user.\n>\n>Cheers,\n>Geoff\n\n\n\n", "id": "lists-006-1928471"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "Why is it a bad solution?\n\nIs it still a bad solution if an implementation MAY retain versions if\nretain-old-versions is not specified but MUST retain them if it is?\n\nWhy wouldn't that consider a server where version history is important?\n\n\n-----Original Message-----\nFrom: Rick Rupp [mailto:rick.rupp@merant.com] \nSent: Wednesday, June 13, 2001 3:14 PM\nTo: John Hall; ietf-dav-versioning@w3.org\nSubject: Re: Removing a resource: A compromise that satisfies?\n\n\nThis is a bad solution. It does not consider a server where version\nhistory \nis important.\n\nAt 6/13/2001 02:35 PM, John Hall wrote:\n>Ok, then have the versioning aware client specify exactly the behavior \n>it expects.\n>\n>DELETE /foo.txt\n>\n>Is issued by version unaware clients and version aware clients that \n>wish to delete a resource completely.\n>\n>DELETE /foo.txt\n><?xml version=\"1.0\" encoding=\"utf-8\" ?> <DAV:retain-old-versions/>\n>\n>Is issued by version aware clients that wish to see the VCR removed but\n\n>not old versions die.\n>\n>Doing this seems to satisfy both of our requirements.  We want to make \n>sure that there is a small burden on simple clients, and you wish to \n>retain consistency, predictability, and flexibility in more \n>sophisticated clients.\n>\n>-----Original Message-----\n>From: ietf-dav-versioning-request@w3.org\n>[mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n>Sent: Wednesday, June 13, 2001 1:54 PM\n>To: ietf-dav-versioning@w3.org\n>Subject: RE: Confusion: Removing a resource from version control\n>\n>\n>    From: Lisa Dusseault [mailto:lisa@xythos.com]\n>\n>    To rebut the earlier argument that clients need predictable\n>    behaviour -- well sometimes that goes by the wayside.  After all,\n>    that's what 404 Not Found was invented for.  Things disappear.\n>\n>Having the server provide predictable behavior for a versioning unaware\n\n>client (and for that matter, a versioning unaware user) is necessary \n>but far from sufficient.  The hard part is to also support an \n>interoperable versioning-aware client for versioning aware users.\n>\n>A versioning aware user knows (and cares) whether old versions are kept\n\n>or not.  A versioning aware client needs to do what the versioning \n>aware user wants (not just some random behavior selected by a \n>versioning server implementer).  So that means if the versioning aware \n>user wants the versions to be deleted, the versioning aware client \n>needs to somehow delete those versions.  Similarly, if the versioning \n>aware user wants the versions to be kept, the versioning aware client \n>needs to somehow save those versions.\n>\n>If the protocol defines the deletion behavior, an interoperable \n>versioning aware client can be written to produce whatever versioning \n>behavior the user expects.  If the protocol leaves deletion behavior up\n\n>to the server, then an interoperable versioning client would need to \n>determine what behavior the server has chosen to implement, and then \n>have separate code paths to deal with each of those behaviors (in order\n\n>to produce the effect expected by the versioning aware user).\n>\n>Note: If you primarily care about producing a specific behavior for \n>versioning *unaware* clients, and you don't care much about \n>interoperability with versioning *aware* clients, then you can just \n>support HTTP or 2518 WebDAV, and implement whatever versioning behavior\n\n>you want.  But if you want to support interoperability between \n>versioning aware clients, then you only get that by defining explicit \n>behavior for the server that versioning aware clients can count on when\n\n>they are implementing versioning behavior for a versioning aware user.\n>\n>Cheers,\n>Geoff\n\n\n\n", "id": "lists-006-1940818"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "When I read your first message I interpreted it to mean a server MUST \ndelete the version history unless a DAV:retain-old-versions property is \nincluded. How does a server that doesn't want version history deleted \nprotect itself from the current clients who don't know about this new property?\n\nI like the wording MAY retain versions however that still does not provide \nexplicit server behavior. The client really isn't aware what the server has \ndone with the versions in the version history.\n\nIf a server only supports version-control, how does a client delete \nversion-history if that is what it wants to do? When the version-controlled \nresource is deleted the version-history associated with it is in effect \nlost on the server isn't it?\n\nAt 6/13/2001 03:32 PM, John Hall wrote:\n>Why is it a bad solution?\n>\n>Is it still a bad solution if an implementation MAY retain versions if\n>retain-old-versions is not specified but MUST retain them if it is?\n>\n>Why wouldn't that consider a server where version history is important?\n>\n>\n>-----Original Message-----\n>From: Rick Rupp [mailto:rick.rupp@merant.com]\n>Sent: Wednesday, June 13, 2001 3:14 PM\n>To: John Hall; ietf-dav-versioning@w3.org\n>Subject: Re: Removing a resource: A compromise that satisfies?\n>\n>\n>This is a bad solution. It does not consider a server where version\n>history\n>is important.\n>\n>At 6/13/2001 02:35 PM, John Hall wrote:\n> >Ok, then have the versioning aware client specify exactly the behavior\n> >it expects.\n> >\n> >DELETE /foo.txt\n> >\n> >Is issued by version unaware clients and version aware clients that\n> >wish to delete a resource completely.\n> >\n> >DELETE /foo.txt\n> ><?xml version=\"1.0\" encoding=\"utf-8\" ?> <DAV:retain-old-versions/>\n> >\n> >Is issued by version aware clients that wish to see the VCR removed but\n>\n> >not old versions die.\n> >\n> >Doing this seems to satisfy both of our requirements.  We want to make\n> >sure that there is a small burden on simple clients, and you wish to\n> >retain consistency, predictability, and flexibility in more\n> >sophisticated clients.\n> >\n> >-----Original Message-----\n> >From: ietf-dav-versioning-request@w3.org\n> >[mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> >Sent: Wednesday, June 13, 2001 1:54 PM\n> >To: ietf-dav-versioning@w3.org\n> >Subject: RE: Confusion: Removing a resource from version control\n> >\n> >\n> >    From: Lisa Dusseault [mailto:lisa@xythos.com]\n> >\n> >    To rebut the earlier argument that clients need predictable\n> >    behaviour -- well sometimes that goes by the wayside.  After all,\n> >    that's what 404 Not Found was invented for.  Things disappear.\n> >\n> >Having the server provide predictable behavior for a versioning unaware\n>\n> >client (and for that matter, a versioning unaware user) is necessary\n> >but far from sufficient.  The hard part is to also support an\n> >interoperable versioning-aware client for versioning aware users.\n> >\n> >A versioning aware user knows (and cares) whether old versions are kept\n>\n> >or not.  A versioning aware client needs to do what the versioning\n> >aware user wants (not just some random behavior selected by a\n> >versioning server implementer).  So that means if the versioning aware\n> >user wants the versions to be deleted, the versioning aware client\n> >needs to somehow delete those versions.  Similarly, if the versioning\n> >aware user wants the versions to be kept, the versioning aware client\n> >needs to somehow save those versions.\n> >\n> >If the protocol defines the deletion behavior, an interoperable\n> >versioning aware client can be written to produce whatever versioning\n> >behavior the user expects.  If the protocol leaves deletion behavior up\n>\n> >to the server, then an interoperable versioning client would need to\n> >determine what behavior the server has chosen to implement, and then\n> >have separate code paths to deal with each of those behaviors (in order\n>\n> >to produce the effect expected by the versioning aware user).\n> >\n> >Note: If you primarily care about producing a specific behavior for\n> >versioning *unaware* clients, and you don't care much about\n> >interoperability with versioning *aware* clients, then you can just\n> >support HTTP or 2518 WebDAV, and implement whatever versioning behavior\n>\n> >you want.  But if you want to support interoperability between\n> >versioning aware clients, then you only get that by defining explicit\n> >behavior for the server that versioning aware clients can count on when\n>\n> >they are implementing versioning behavior for a versioning aware user.\n> >\n> >Cheers,\n> >Geoff\n\n\n\n", "id": "lists-006-1954151"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "A server doesn't have to let a client delete version history.  Even if a\nclient wants that behavior, a server doesn't have to provide it.\n\nWhat I have proposed is that the default simple client wants its\nresources freed and things like version-history deleted when it issues a\ndelete on a VCR.\n\nBut I've protected your right to build a server that keeps old versions,\nand the ability to develop smart clients that can tell you they don't\nwant versions deleted and make it stick, or *suggest* that they delete\nold versions and let the server decide.\n\nThose proposals seemed to satisfy my goals and Geoff Clemm's.\n\nI have no objections to a DAV:delete-old-versions element that is\nignorable.\n\nI have no objections to a server returning its decision\n(DAV:old-versions-retained, DAV:old-versions-deleted).\n\nIf we added those, would it satisfy your objections?\n\n\n\n-----Original Message-----\nFrom: Rick Rupp [mailto:rick.rupp@merant.com] \nSent: Wednesday, June 13, 2001 5:42 PM\nTo: John Hall; ietf-dav-versioning@w3.org\nSubject: RE: Removing a resource: A compromise that satisfies?\n\n\nWhen I read your first message I interpreted it to mean a server MUST \ndelete the version history unless a DAV:retain-old-versions property is \nincluded. How does a server that doesn't want version history deleted \nprotect itself from the current clients who don't know about this new\nproperty?\n\nI like the wording MAY retain versions however that still does not\nprovide \nexplicit server behavior. The client really isn't aware what the server\nhas \ndone with the versions in the version history.\n\nIf a server only supports version-control, how does a client delete \nversion-history if that is what it wants to do? When the\nversion-controlled \nresource is deleted the version-history associated with it is in effect \nlost on the server isn't it?\n\nAt 6/13/2001 03:32 PM, John Hall wrote:\n>Why is it a bad solution?\n>\n>Is it still a bad solution if an implementation MAY retain versions if \n>retain-old-versions is not specified but MUST retain them if it is?\n>\n>Why wouldn't that consider a server where version history is important?\n>\n>\n>-----Original Message-----\n>From: Rick Rupp [mailto:rick.rupp@merant.com]\n>Sent: Wednesday, June 13, 2001 3:14 PM\n>To: John Hall; ietf-dav-versioning@w3.org\n>Subject: Re: Removing a resource: A compromise that satisfies?\n>\n>\n>This is a bad solution. It does not consider a server where version \n>history is important.\n>\n>At 6/13/2001 02:35 PM, John Hall wrote:\n> >Ok, then have the versioning aware client specify exactly the \n> >behavior it expects.\n> >\n> >DELETE /foo.txt\n> >\n> >Is issued by version unaware clients and version aware clients that \n> >wish to delete a resource completely.\n> >\n> >DELETE /foo.txt\n> ><?xml version=\"1.0\" encoding=\"utf-8\" ?> <DAV:retain-old-versions/>\n> >\n> >Is issued by version aware clients that wish to see the VCR removed \n> >but\n>\n> >not old versions die.\n> >\n> >Doing this seems to satisfy both of our requirements.  We want to \n> >make sure that there is a small burden on simple clients, and you \n> >wish to retain consistency, predictability, and flexibility in more \n> >sophisticated clients.\n> >\n> >-----Original Message-----\n> >From: ietf-dav-versioning-request@w3.org\n> >[mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> >Sent: Wednesday, June 13, 2001 1:54 PM\n> >To: ietf-dav-versioning@w3.org\n> >Subject: RE: Confusion: Removing a resource from version control\n> >\n> >\n> >    From: Lisa Dusseault [mailto:lisa@xythos.com]\n> >\n> >    To rebut the earlier argument that clients need predictable\n> >    behaviour -- well sometimes that goes by the wayside.  After all,\n> >    that's what 404 Not Found was invented for.  Things disappear.\n> >\n> >Having the server provide predictable behavior for a versioning \n> >unaware\n>\n> >client (and for that matter, a versioning unaware user) is necessary \n> >but far from sufficient.  The hard part is to also support an \n> >interoperable versioning-aware client for versioning aware users.\n> >\n> >A versioning aware user knows (and cares) whether old versions are \n> >kept\n>\n> >or not.  A versioning aware client needs to do what the versioning \n> >aware user wants (not just some random behavior selected by a \n> >versioning server implementer).  So that means if the versioning \n> >aware user wants the versions to be deleted, the versioning aware \n> >client needs to somehow delete those versions.  Similarly, if the \n> >versioning aware user wants the versions to be kept, the versioning \n> >aware client needs to somehow save those versions.\n> >\n> >If the protocol defines the deletion behavior, an interoperable \n> >versioning aware client can be written to produce whatever versioning\n\n> >behavior the user expects.  If the protocol leaves deletion behavior \n> >up\n>\n> >to the server, then an interoperable versioning client would need to \n> >determine what behavior the server has chosen to implement, and then \n> >have separate code paths to deal with each of those behaviors (in \n> >order\n>\n> >to produce the effect expected by the versioning aware user).\n> >\n> >Note: If you primarily care about producing a specific behavior for \n> >versioning *unaware* clients, and you don't care much about \n> >interoperability with versioning *aware* clients, then you can just \n> >support HTTP or 2518 WebDAV, and implement whatever versioning \n> >behavior\n>\n> >you want.  But if you want to support interoperability between \n> >versioning aware clients, then you only get that by defining explicit\n\n> >behavior for the server that versioning aware clients can count on \n> >when\n>\n> >they are implementing versioning behavior for a versioning aware \n> >user.\n> >\n> >Cheers,\n> >Geoff\n\n\n\n", "id": "lists-006-1968731"}, {"subject": "Basic Property Behavio", "content": "My goals are in providing basic versioning for customers that do not\nneed elaborate features, but not getting in the way of more\nsophisticated clients envisioned in the full DeltaV spec.\n\nThis is probably a land mine, but I thought I'd try.\n\nI do not like the idea of versioning properties.  My customers are\ninterested in versioning content, not properties.  Mutable global\nproperties are just fine, beyond those properties specifically defined\nin DeltaV as per-version (like comment and label).\n\nSo my first suggestion would be to modify the VERSION-CONTROL feature so\nthat someone could turn versioning for content on seperately from\nversioning of properties.  Your sophisticated clients would know up\nfront if they hit our server and we didn't support property versioning.\nThey could then warn their version-aware users.\n\nI've thought of some other expedients, most of which Lisa shot down for\na variety of reasons.  But why can't we make it optional?  If your\nclients want to get huffy and not deal with a lowly server that doesn't\nversion properties then so be it.\n\n\n\n", "id": "lists-006-1984698"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "How about an alternative approach:\n\nAdd a new postcondition to DELETE that says:\n\n\"If a server does not support the version-history feature,\nthen it MAY automatically delete a version resource if that\nversion no longer appears in the DAV:version-tree report\nof any version-controlled resource.\"\n\nI believe this allows John and Lisa to do what they want,\nwithout violating the concern of several of us that\na client should be able to count on a version being\npreserved by a server while it is still being referenced\nby another resource visible on the server.\n\nI believe this approach is better than adding a body\nto DELETE, because it does not require adding additional\nprotocol elements.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-1992951"}, {"subject": "RE: Deleting histor", "content": "Whether or not a server supports the version-history feature,\na client that wants ensure that all versions associated with a\nversion-controlled resource are deleted should get a version-tree report\n(or get the version history URL) before deleting the version-controlled\nresource.  Otherwise, once the version-controlled resource is gone, the\nclient will no longer have a good way to find either the \nversions or the version-controlled resource.  (Actually, if the\nserver supports the workspace option, it may be able to find\nthat version history by finding the \"corresponding\" version \ncontrolled resource in another workspace, but there is no\nguarantee that there is such a corresponding version controlled\nresource.)\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Rick Rupp [mailto:rick.rupp@merant.com]\n\nIf a server only supports version-control, how does a client delete \nversion-history if that is what it wants to do? When the version-controlled \nresource is deleted the version-history associated with it is in effect \nlost on the server isn't it?\n\n\n\n", "id": "lists-006-2001345"}, {"subject": "RE: Confusion: Removing a resource from version contro", "content": "I believe we actually have a reasonable compromise on this particular\nissue, but Lisa does raise some interesting points below that I\nthought were worth following up.\n\n   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   > A versioning aware client needs to do what the versioning aware\n   > user wants (not just some random behavior selected by a\n   > versioning server implementer).\n\n   It seems to me that this is an inconsistent position with respect to\nother\n   implementor-dependent behaviour already allowed by DeltaV.\n\nYes, DeltaV does allow the server implementer some choices,\nbut only after a great deal of effort to find an acceptable\ncommon semantics.  So this does appear, but only as a last\nresort after all reasonable effort has been expended to determine\nan alternative.  A key factor in allowing such choices is how\nsignificant the impact of this choice is on the user.\n\n   You might also say \"A versioning aware client needs to do what the\n   versioning aware user wants (not just some random behaviour\n   selected by a versioning server implementer).\n\nActually, that is what I said (:-).\n\n   So that means if the versioning aware user wants the resource to be\n   created as a regular resource, the versioning aware client needs to\n   somehow be able to create the resource as a regular resource.\n\nYes, this was one of those choices.  In this case, the consensus was\nthat the impact on the user of automatically putting something under\nversion control was minor, compared for example, to the impact of the\nserver automatically deleting a resource the user wanted to preserve.\n\n   Similarly, if the versioning aware user wants the resource to be\n   created as a version-controlled resource, the versioning aware\n   client needs to somehow be able to achieve that.\"\n\n   Yet, the deltaV specification allows implementations to create\n   resources that are versioned in response to a PUT to a\n   non-existent, or to create resources that are not versioned.\n   That's \"some random behavior selected by a versioning server\n   implementer.\"\n\nHaving the server \"not support\" something is inevitable.  The issue\nis whether a method that is supported has consistent semantics from\nserver to server.\n\n   I could probably come up with some more examples!\n\nAll such examples should be highlighted in the protocol with the\npresence of the MAY keyword.  I believe we have debated at great\nlength over all such MAY semantics but if there is one that you feel\nshould be eliminated, please feel free to raise it as an issue.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2008948"}, {"subject": "RE: Basic Property Behavio", "content": "Yes, this issue was raised and debated a couple of IETF's ago,\nand the consensus was that the implementation burden on a server\nto support versioned dead properties was not sufficient to\nintroduce a major source of\ninteroperability problems (i.e. clients that expected to be\nable to version properties would not interoperate effectively\nwith servers that did not, and vica versa).\n\nNote that the server defines the versioning behavior of any\nserver defined (and therefore, live) properties, so a server is\ncertainly free to make all of its server defined properties\nnon-versioned.\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\n\nMy goals are in providing basic versioning for customers that do not\nneed elaborate features, but not getting in the way of more\nsophisticated clients envisioned in the full DeltaV spec.\n\nThis is probably a land mine, but I thought I'd try.\n\nI do not like the idea of versioning properties.  My customers are\ninterested in versioning content, not properties.  Mutable global\nproperties are just fine, beyond those properties specifically defined\nin DeltaV as per-version (like comment and label).\n\nSo my first suggestion would be to modify the VERSION-CONTROL feature so\nthat someone could turn versioning for content on seperately from\nversioning of properties.  Your sophisticated clients would know up\nfront if they hit our server and we didn't support property versioning.\nThey could then warn their version-aware users.\n\nI've thought of some other expedients, most of which Lisa shot down for\na variety of reasons.  But why can't we make it optional?  If your\nclients want to get huffy and not deal with a lowly server that doesn't\nversion properties then so be it.\n\n\n\n", "id": "lists-006-2018756"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "That's OK by me, as far as cleaning out versions goes!\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, June 13, 2001 8:04 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Removing a resource: A compromise that satisfies?\n> \n> \n> How about an alternative approach:\n> \n> Add a new postcondition to DELETE that says:\n> \n> \"If a server does not support the version-history feature,\n> then it MAY automatically delete a version resource if that\n> version no longer appears in the DAV:version-tree report\n> of any version-controlled resource.\"\n> \n> I believe this allows John and Lisa to do what they want,\n> without violating the concern of several of us that\n> a client should be able to count on a version being\n> preserved by a server while it is still being referenced\n> by another resource visible on the server.\n> \n> I believe this approach is better than adding a body\n> to DELETE, because it does not require adding additional\n> protocol elements.\n> \n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-2028188"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "As I read the spec, this simply amounts to our original request.\nNamely, the server is free to delete versions -- at least if it doesn't\nsupport the version-history feature.  Because I see no way a version\nwould be listed in a version-tree report other than its 'own'.\n\nSo while that might be acceptable to me and Lisa, I don't think it will\nbe acceptable to others.  Further, our acceptance is somewhat\nconditional on being able to not implement the version-history feature.\nApparently, it was suggested that a client which would prefer to use\nglobal properties would have to use the version-history URL.  Thus\nforcing us to implement this object just to get global properties.\n\nI think Rick Rupp raised some valid points.\n\nSo I feel at this point that it is better to A) add new protocol\nelements and B) make sure that a version-aware client can specify either\nbehavior and tell which behavior was implemented.  As elements go they\nare relatively simple flags.  Since I haven't been involved in a\ndiscussion like this before I may not understand the true impact of\nprotocol elements.  But it looks pretty easy from my code base.\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\nSent: Wednesday, June 13, 2001 8:04 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Removing a resource: A compromise that satisfies?\n\n\nHow about an alternative approach:\n\nAdd a new postcondition to DELETE that says:\n\n\"If a server does not support the version-history feature,\nthen it MAY automatically delete a version resource if that version no\nlonger appears in the DAV:version-tree report of any version-controlled\nresource.\"\n\nI believe this allows John and Lisa to do what they want, without\nviolating the concern of several of us that a client should be able to\ncount on a version being preserved by a server while it is still being\nreferenced by another resource visible on the server.\n\nI believe this approach is better than adding a body\nto DELETE, because it does not require adding additional protocol\nelements.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2037741"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n\n> Add a new postcondition to DELETE that says:\n>\n> \"If a server does not support the version-history feature,\n> then it MAY automatically delete a version resource if that\n> version no longer appears in the DAV:version-tree report\n> of any version-controlled resource.\"\n\nI can support this postcondition, and encourage John and Lisa to read it\ncarefully to ensure it satisfies their requirements.\n\n> I believe this allows John and Lisa to do what they want,\n> without violating the concern of several of us that\n> a client should be able to count on a version being\n> preserved by a server while it is still being referenced\n> by another resource visible on the server.\n\nI turned my back for one day...and there was a flood of messages to the\nlist!  After following the arguments (any my blood pressure rising and\nfalling numerous times) this is a reasonable outcome.\n\n> I believe this approach is better than adding a body\n> to DELETE, because it does not require adding additional\n> protocol elements.\n\nAgreed.\n\nTim\n\n\n\n", "id": "lists-006-2048320"}, {"subject": "Re (2): Removing a resource: A compromise that satisfies", "content": "Tim_Ellison@uk.ibm.com wrote:\n> ..and there was a flood of messages to the list.\n> After following the arguments (any my blood pressure rising and\n> falling numerous times)\nMe too :-).\nMy understanding is that a versioning unaware client should NEVER\nhave the side effect of deleting version resources it doesn't know\nabout. The server side concerns Lisa raises are another matter I don't\nhave the time to discuss at the moment.\n\nNow to Geoffs proposal. \nClemm, Geoff wrote:\n> How about an alternative approach:\n> \n> Add a new postcondition to DELETE that says:\n> \n> \"If a server does not support the version-history feature,\n> then it MAY automatically delete a version resource if that\n> version no longer appears in the DAV:version-tree report\n> of any version-controlled resource.\"\nHere you draw a fine line between explicitly having a version\nhistory ('support the version-history feature') or implicitly\nhaving it ('appears in the DAV:version-tree report') because\nthe version tree is the fundamental data of a version history.\nOr isn't it ?\nTo me it seems that VERSION-CONTROL is providing a version-history\nlight in the form of the version-tree report. Does that make sense ?\n\nCheers, Edgar\n\nP.S. I would like to write more but I'm leaving for a birthday\nparty just now. \n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-2057110"}, {"subject": "Re: Re (2): Removing a resource: A compromise that satisfies", "content": "Edgar@EdgarSchwarz.de wrote:\n> Tim_Ellison@uk.ibm.com wrote:\n> > ..and there was a flood of messages to the list.\n> > After following the arguments (any my blood pressure rising and\n> > falling numerous times)\n> Me too :-).\n> My understanding is that a versioning unaware client should NEVER\n> have the side effect of deleting version resources it doesn't know\n> about. The server side concerns Lisa raises are another matter I don't\n> have the time to discuss at the moment.\n\nI also find it surprising that people would want that.  But Geoff has\ncleverly worded the postcondition so that only 'branches' of version\nhistory can be deleted upon a version-controlled resource deletion until\nthe final version-controlled resource departs, the postcondition is\noptional (\"MAY\"), and the clearly misguided version deletion behavior <g>\nis forbidden for those servers that implement version history.\n\n> Now to Geoffs proposal.\n> Clemm, Geoff wrote:\n> > How about an alternative approach:\n> >\n> > Add a new postcondition to DELETE that says:\n> >\n> > \"If a server does not support the version-history feature,\n> > then it MAY automatically delete a version resource if that\n> > version no longer appears in the DAV:version-tree report\n> > of any version-controlled resource.\"\n> Here you draw a fine line between explicitly having a version\n> history ('support the version-history feature') or implicitly\n> having it ('appears in the DAV:version-tree report') because\n> the version tree is the fundamental data of a version history.\n> Or isn't it ?\n> To me it seems that VERSION-CONTROL is providing a version-history\n> light in the form of the version-tree report. Does that make sense ?\n\nSure, even where the version history resource does not exist, the versions\nstill do so.  That is why I'm a bit surprised that people won't implement\nversion history since the overhead is only a few simple live properties\nexposing data that will be maintained anyway -- it's only an exercise in\nparsing the history URL.  But whatever.\n\nTim\n\n\n\n", "id": "lists-006-2066905"}, {"subject": "RE: Re (2): Removing a resource: A compromise that satisfies", "content": ">> My understanding is that a versioning unaware client should NEVER\nhave the side effect of deleting version resources it doesn't know\nabout. The server side concerns Lisa raises are another matter I don't\nhave the time to discuss at the moment.\n\n=============================\n\nYou mistake where I am coming from, because you have probably eliminated\na key middle ground from consideration.\n\nI'm not fighting for clients/customers/users that are BLIND to the fact\nthat things are being versioned.\n\nI'm fighting for clients/customers/users that have tacked on the concept\nand simple usefulness of versioned content.  The only thing they care\nabout, or want to care about, is CHECKIN/CHECKOUT/UNCHECKOUT and \"oops,\ncan I see version 5 please?\".\n\nSo yes, they know about versions.  And they expect them to get blown\naway when they issue a DELETE.  But they are profoundly uninterested in\neverything else.\n\nA similar issue arises when I bring up the topic of properties.  The\nissue isn't the 'burden on the server' from implementing versioned\nproperties.  The issue is customers and users that say \"but why on earth\nwould anyone want to do that?\".  From my personal perspective, as\nsomeone who has been using code source control for a decade, I'm close\nto that position myself.  Not fully, since I understand that you folks\nwant that behavior.  But with the exception of narrowly defined sets of\nproperites (which ought to be declared) it isn't something I want / need\n/ would use and I'd rather not have my server resoruces devoted to it.\nAnd even if I have a system that wants to version properties, I would\n*really* object to creating a new version just because a property\nchanged.\n\nSurely I'm not the only user in the universe that feels that way.\nPerhaps someone can come up with a way that you don't have to support\nwhich would make the current-checked-in-properties mutable.  <!ELEMENT\nproperties-mutable EMPTY> within auto-checkout would do it.\n\nConsider the following language:\n\nAn implementation MAY support properties-mutable as a default within\nauto-checkout.  It is DISCOURAGED.  If present, an implementation MUST\nsupport removing the element so that clients who do not wish any\nproperties to be mutable may protect themselves against this server\noption.  An implementation MAY NOT allow the element to be set.\n\nIF the element is present then the currently checked in versions\nproperties are mutable and may be changed by a PROPPATCH without\ncreating a new version.  If the VCR is in an unlocked state, a PROPPATCH\nwill mutably change properties if unlocked-update AND properties-mutable\nare present.  In the locked state, a PROPPATCH will mutably change\nproperties if locked-update AND properties-mutable are present.\n\n\n\n", "id": "lists-006-2077185"}, {"subject": "A non-forking server, precussor revisited", "content": "In my first reading of the specification, I remind myself that I\nprobably don't fully understand the spec or how people envision that it\nbe implemented.\n\nI note that there is support for both a forking and a non-forking\nserver. A server does not have to implement features that allow people\nto 'fork' version controlled resources. I appreciate that. Some\nsituations and clients do require that capacity, but many other systems\nwould like to do a 'simple' versioning system and don't require this.\n\nBut it seems that the separation isn't clean. If I don't support\nforking, UPDATE, or MERGE, then I see no reason at all to keep track of\nprecursor-set. \n\nGeoff said precursor-set was only one href, but I thought it was each\nand every href that had ever been copied on top of a versioned resource\n-- so it is an unlimited set of href's.\n\nSo I would strongly prefer that precursor-set be optional.  An\nalternative would be that an implementation MAY not track precursor-set\nand MAY set it equal to predecessor-set IF it doesn't support MERGE or\nUPDATE.\n \n\n\n\n\n\n", "id": "lists-006-2087640"}, {"subject": "Question on Checking (of Working Resource vs. VCR): is this right", "content": "My user performs a CHECKOUT, PUT, and CHECKIN.  He wants the contents to\nchange, and he wants a new version.\n\nI'm using working resources.\n\nTo get this behavior, the user must:\n1) CHECKOUT the VCR.\n2) PUT on the working copy identified by the Location URL in the\nCHECKOUT response.\n3) CHECKIN the VCR.\n\nIt appears that if they do a CHECKIN on the working copy, they will not\nget what they expect.  9.4 indicates that they create a 'version' but\nthat the VCR doesn't know about it.\n\nSince I don't support UPDATE or MERGE I seem to have two options.  Fail\nthe CHECKIN on a working copy or treat it as a CHECKIN on the VCR\nsilently.\n\n\n\n", "id": "lists-006-2097086"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "Great!\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Thursday, June 14, 2001 12:33 AM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: RE: Removing a resource: A compromise that satisfies?\n\n\nThat's OK by me, as far as cleaning out versions goes!\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, June 13, 2001 8:04 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Removing a resource: A compromise that satisfies?\n> \n> \n> How about an alternative approach:\n> \n> Add a new postcondition to DELETE that says:\n> \n> \"If a server does not support the version-history feature,\n> then it MAY automatically delete a version resource if that\n> version no longer appears in the DAV:version-tree report\n> of any version-controlled resource.\"\n> \n> I believe this allows John and Lisa to do what they want,\n> without violating the concern of several of us that\n> a client should be able to count on a version being\n> preserved by a server while it is still being referenced\n> by another resource visible on the server.\n> \n> I believe this approach is better than adding a body\n> to DELETE, because it does not require adding additional\n> protocol elements.\n> \n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-2105357"}, {"subject": "RE: Re (2): Removing a resource: A compromise that satisfies", "content": "   From: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\n\n   Clemm, Geoff wrote:\n\n   > How about an alternative approach:\n   > \n   > Add a new postcondition to DELETE that says:\n   > \n   > \"If a server does not support the version-history feature,\n   > then it MAY automatically delete a version resource if that\n   > version no longer appears in the DAV:version-tree report\n   > of any version-controlled resource.\"\n\n   Here you draw a fine line between explicitly having a version\n   history ('support the version-history feature') or implicitly\n   having it ('appears in the DAV:version-tree report') because the\n   version tree is the fundamental data of a version history.  Or\n   isn't it ?  To me it seems that VERSION-CONTROL is providing a\n   version-history light in the form of the version-tree report. Does\n   that make sense ?\n\nYes, there is always a version history for a version-controlled\nresource, but the version history is only exposed in the URL namespace\nif the server supports the version-history feature.\n\nThe reason why I worded the postcondition this way is that if\nthere is no version history resource, then the versions are\nscattered randomly around the URL namespace, and there is no\nstandard way for a client to find them again.\n\nIn contrast, if a server supports the version-history feature,\na client can use OPTION to request the version-history-collection-set,\nand then find old version histories in that collection.\n\nWith all that said, we are still damaging interoperability for\nversioning aware clients, because URL's to versions can be stored in a\nvariety of places, and allowing a server to blow away a version just\nbecause the version-controlled resource was deleted makes it hard to\nwrite a versioning-aware client with predictable behavior (blowing\naway data has too much of an impact on the user to have it be\nunpredictable from server to server).  So if anyone wants to reject\nthis compromise on the grounds that we should *never* allow a \nserver to blow away versions because of a VCR deletion, please\ndo so (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2116290"}, {"subject": "RE: Re (2): Removing a resource: A compromise that satisfies", "content": ">>The reason why I worded the postcondition this way is that if there is\nno version history resource, then the versions are scattered randomly\naround the URL namespace, and there is no standard way for a client to\nfind them again.\n\nWhat is wrong with:\nREPORT VCR\n<version-tree><prop><version-name>/</prop></version-tree>\n\nOr\n\nPROPFIND VCR\n<propfind><prop><predecessor-set/></prop></propfind>\n\n====================================\n\n>> So if anyone wants to reject this compromise on the grounds that we\nshould *never* allow a \nserver to blow away versions because of a VCR deletion, please do so\n(:-).\n\nOur customers needs are directly opposed to that, and materially damaged\nby that position.  It has nothing to do with my ability to code the\nbehavior (not blowing them away is easier, in fact).\n\nIf consistency is this important, we should *require* versions to be\nblown away, unless the client specifically specifies something else.\nThat solves the consistency problem without preventing my ability to\nserve my customer base.\n\n\n\n", "id": "lists-006-2126764"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "Before we got much further with this thread, let's examine the\nunderlying premise that \"deleting the versions when the VCR is\ndeleted\" is an important use case.\n\nThis is the web, so everybody and their grandmother (and for sure,\nwww.google.com) will have cached copies of anything you put up on the\nweb, so an argument that blowing away old versions at server defined\nURL's will somehow make that data go away is rather unrealistic, isn't\nit?  And if it doesn't really go away, why do we care that there\nare also a few obscure server-defined URL's that contain a copy\nof a version of this data?\n\nSo perhaps we should reach agreement that this is a compelling use\ncase before we consider supporting it by introducing either additional\nprotocol\nelements or making server behavior less consistent and predictable.\n\nSo my revised position is that we defer any action on this proposal\nuntil the group reaches consensus that this is in fact a compelling use\ncase.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2135538"}, {"subject": "Should CHECKOUT support a TIMEOUT", "content": "... And if not, is there a provision for someone other than the person\nwho did the checkout performing an UNCHECKOUT?\n\n\n\n", "id": "lists-006-2143743"}, {"subject": "RE: Re (2): Removing a resource: A compromise that satisfies", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   A similar issue arises when I bring up the topic of properties.\n   The issue isn't the 'burden on the server' from implementing\n   versioned properties.  The issue is customers and users that say\n   \"but why on earth would anyone want to do that?\".  From my personal\n   perspective, as someone who has been using code source control for\n   a decade, I'm close to that position myself.  Not fully, since I\n   understand that you folks want that behavior.  But with the\n   exception of narrowly defined sets of properites (which ought to be\n   declared) it isn't something I want / need / would use and I'd\n   rather not have my server resoruces devoted to it.\n\nFrom a historical perspective, you only had content (and a few\nsystem defined live properties), not dead properties, so you can't\nuse that as an indication one way or another that if you had dead\nproperties, whether you would want them under version control or not.\n\n   And even if I\n   have a system that wants to version properties, I would *really*\n   object to creating a new version just because a property changed.\n\nBased on what usage of dead properties?  I'm sure one can imagine\nsome, but they would need to be compelling to complicate the\nprotocol in this way.\n\n   Surely I'm not the only user in the universe that feels that way.\n   Perhaps someone can come up with a way that you don't have to support\n   which would make the current-checked-in-properties mutable.  <!ELEMENT\n   properties-mutable EMPTY> within auto-checkout would do it.\n\nThere are a variety of interesting meta-information that you would\nlike to say about properties ... mutable version specific dead\nproperties is just one of them.  But the consensus of\nthe working group the last time this was discussed was that this\nneeded to be worked out in the context of a general property metadata\nproposal, and not as a special one-off case for this particular\nproperty behavior for the versioning protocol.\n\n   Consider the following language:\n\n   An implementation MAY support properties-mutable as a default within\n   auto-checkout.  It is DISCOURAGED.\n\nUsually you deprecate old functionality that turns out not to have\nbeen a good idea, not new functionality (unless you knew from the\nbeginning wasn't a good idea, but then why add it :-).\n\n   If present, an implementation MUST\n   support removing the element so that clients who do not wish any\n   properties to be mutable may protect themselves against this server\n   option.  An implementation MAY NOT allow the element to be set.\n   IF the element is present then the currently checked in versions\n   properties are mutable and may be changed by a PROPPATCH without\n   creating a new version.  If the VCR is in an unlocked state, a PROPPATCH\n   will mutably change properties if unlocked-update AND properties-mutable\n   are present.  In the locked state, a PROPPATCH will mutably change\n   properties if locked-update AND properties-mutable are present.\n\nThe auto-version stuff is bad enough without this ... we don't want to\nmake it any worse unless there is a really compelling use case for it.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2151832"}, {"subject": "RE: Should CHECKOUT support a TIMEOUT", "content": "The versioning protocol places no restriction on who can\ndo an UNCHECKOUT (if there were, you would see it specified\nas a precondition for the UNCHECKOUT method).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Thursday, June 14, 2001 5:24 PM\nTo: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\nSubject: Should CHECKOUT support a TIMEOUT?\n\n\n\n... And if not, is there a provision for someone other than the person\nwho did the checkout performing an UNCHECKOUT?\n\n\n\n", "id": "lists-006-2162285"}, {"subject": "RE: A non-forking server, precussor revisited", "content": "The intent for \"precursor-set\" was that it capture the last \"copy\",\nnot that it accumulate all the copies.  But I agree that this is\nnot at all clear from the semantics of the COPY operation, so this\nneeds to be clarified.  The reason it is a set is to allow a \nclient to add additional values if there has been a logical \"merge\"\nto that resource.  But a COPY just sets it to be a single value.\n\nA more general question:  I personally am not attached to the\n\"precursor\" property.  Does anyone want to argue for keeping it in\nthe spec?  If not, I propose we get rid of it, since it seems to\nbe a source of confusion.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Thursday, June 14, 2001 3:06 PM\nTo: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\nSubject: A non-forking server, precussor revisited.\n\n\n\n\nIn my first reading of the specification, I remind myself that I\nprobably don't fully understand the spec or how people envision that it\nbe implemented.\n\nI note that there is support for both a forking and a non-forking\nserver. A server does not have to implement features that allow people\nto 'fork' version controlled resources. I appreciate that. Some\nsituations and clients do require that capacity, but many other systems\nwould like to do a 'simple' versioning system and don't require this.\n\nBut it seems that the separation isn't clean. If I don't support\nforking, UPDATE, or MERGE, then I see no reason at all to keep track of\nprecursor-set. \n\nGeoff said precursor-set was only one href, but I thought it was each\nand every href that had ever been copied on top of a versioned resource\n-- so it is an unlimited set of href's.\n\nSo I would strongly prefer that precursor-set be optional.  An\nalternative would be that an implementation MAY not track precursor-set\nand MAY set it equal to predecessor-set IF it doesn't support MERGE or\nUPDATE.\n \n\n\n\n\n\n", "id": "lists-006-2170575"}, {"subject": "RE: Question on Checking (of Working Resource vs. VCR): is this r ight", "content": "A working resource can be created by checking out\nan arbitrary version, so in general, it is not\nassociated with any VCR.\n\nSo you do need to support either the update feature\nor the merge feature if you support the working resource\nfeature (that is why\nthe client-side workspace package contains the\nupdate feature. \n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Thursday, June 14, 2001 3:15 PM\nTo: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\nSubject: Question on Checking (of Working Resource vs. VCR): is this\nright?\n\n\n\nMy user performs a CHECKOUT, PUT, and CHECKIN.  He wants the contents to\nchange, and he wants a new version.\n\nI'm using working resources.\n\nTo get this behavior, the user must:\n1) CHECKOUT the VCR.\n2) PUT on the working copy identified by the Location URL in the\nCHECKOUT response.\n3) CHECKIN the VCR.\n\nIt appears that if they do a CHECKIN on the working copy, they will not\nget what they expect.  9.4 indicates that they create a 'version' but\nthat the VCR doesn't know about it.\n\nSince I don't support UPDATE or MERGE I seem to have two options.  Fail\nthe CHECKIN on a working copy or treat it as a CHECKIN on the VCR\nsilently.\n\n\n\n", "id": "lists-006-2180219"}, {"subject": "RE: Question on Checking (of Working Resource vs. VCR): is this r ight", "content": "I have a non-forking server and I will not allow people to check out a\nprior version, which seems to be allowed in the spec.\n\nI'm willing to refuse to allow a CHECKIN on the working copy and require\nit be issued on the VCR.  But a CHECKIN that doesn't 'check the file in'\nviolates the expectations of every user of every source control system\nI've ever seen.\n\n\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n\n\nA working resource can be created by checking out\nan arbitrary version, so in general, it is not\nassociated with any VCR.\n\nSo you do need to support either the update feature\nor the merge feature if you support the working resource feature (that\nis why the client-side workspace package contains the update feature. \n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Thursday, June 14, 2001 3:15 PM\nTo: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\nSubject: Question on Checking (of Working Resource vs. VCR): is this\nright?\n\n\n\nMy user performs a CHECKOUT, PUT, and CHECKIN.  He wants the contents to\nchange, and he wants a new version.\n\nI'm using working resources.\n\nTo get this behavior, the user must:\n1) CHECKOUT the VCR.\n2) PUT on the working copy identified by the Location URL in the\nCHECKOUT response.\n3) CHECKIN the VCR.\n\nIt appears that if they do a CHECKIN on the working copy, they will not\nget what they expect.  9.4 indicates that they create a 'version' but\nthat the VCR doesn't know about it.\n\nSince I don't support UPDATE or MERGE I seem to have two options.  Fail\nthe CHECKIN on a working copy or treat it as a CHECKIN on the VCR\nsilently.\n\n\n\n", "id": "lists-006-2189884"}, {"subject": "RE: Question on Checking (of Working Resource vs. VCR): is this r  ight", "content": "It's not your user which needs to do the CHECKIN/UPDATE\nsequence, but rather your client (hopefully you will not\nbe exposing your user to the working resource URL either).\n\nSo your user just issues a \"checkin\" (or \"freeze\" or whatever\nyou want them to call it) operation, and to implement it,\nyour client issues a CHECKIN (which returns the URL of the\nnewly created version), and then an UPDATE (which makes then\nmakes the content and dead properties of the specified URL\nbe those of the new version.\n\nA CHECKIN against a checked-in URL will just fail (you can\nonly issue a CHECKIN against something that is checked-out,\nsuch as an in-place checked-out vcr, or a working resource.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Thursday, June 14, 2001 6:56 PM\nTo: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\nSubject: RE: Question on Checking (of Working Resource vs. VCR): is this\nr ight?\n\n\nI have a non-forking server and I will not allow people to check out a\nprior version, which seems to be allowed in the spec.\n\nI'm willing to refuse to allow a CHECKIN on the working copy and require\nit be issued on the VCR.  But a CHECKIN that doesn't 'check the file in'\nviolates the expectations of every user of every source control system\nI've ever seen.\n\n\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n\n\nA working resource can be created by checking out\nan arbitrary version, so in general, it is not\nassociated with any VCR.\n\nSo you do need to support either the update feature\nor the merge feature if you support the working resource feature (that\nis why the client-side workspace package contains the update feature. \n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Thursday, June 14, 2001 3:15 PM\nTo: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\nSubject: Question on Checking (of Working Resource vs. VCR): is this\nright?\n\n\n\nMy user performs a CHECKOUT, PUT, and CHECKIN.  He wants the contents to\nchange, and he wants a new version.\n\nI'm using working resources.\n\nTo get this behavior, the user must:\n1) CHECKOUT the VCR.\n2) PUT on the working copy identified by the Location URL in the\nCHECKOUT response.\n3) CHECKIN the VCR.\n\nIt appears that if they do a CHECKIN on the working copy, they will not\nget what they expect.  9.4 indicates that they create a 'version' but\nthat the VCR doesn't know about it.\n\nSince I don't support UPDATE or MERGE I seem to have two options.  Fail\nthe CHECKIN on a working copy or treat it as a CHECKIN on the VCR\nsilently.\n\n\n\n", "id": "lists-006-2200783"}, {"subject": "RE: Question on Checking (of Working Resource vs. VCR): is this r  ight", "content": "So does this mean that support for working resources effectively has a\ndependency on the UPDATE feature?  It's at least consistent that both are\nincluded in the \"basic client workspace\" package.\n\nSection 9.4 does state that UPDATE or MERGE are required after a checkin\nfrom a working resource, but this is misleading.  Merge can only be done if\nthere are a couple things that can be merged.  That's not always the case;\nnor is the server always capable of doing a merge.  Imagine I check out an\nimage in my repository, I get a working-resource URL, and I PUT the new\nimage to the working-resource.  Now you can see that UPDATE is absolutely\nrequired ror the version-controlled resource to ever have its contents and\ndead properties change.\n\nThis dependency should at least be made clear.  We might also consider\ntrying to remove the dependency, since one would think that in a non-forking\nserver, a CHECKIN would 99% of the time be followed by a UPDATE to push the\nlatest content to the VCR.  Rolling those two actions into one request\n(unless specified otherwise) would save a round-trip, because the CHECKIN\nand UPDATE can't be pipelined if you have to wait for the successful\nresponse to the CHECKIN before knowing how to send the UPDATE.\n\nlisa\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Thursday, June 14, 2001 7:38 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Question on Checking (of Working Resource vs. VCR): is this\n> r ight?\n>\n>\n> It's not your user which needs to do the CHECKIN/UPDATE\n> sequence, but rather your client (hopefully you will not\n> be exposing your user to the working resource URL either).\n>\n> So your user just issues a \"checkin\" (or \"freeze\" or whatever\n> you want them to call it) operation, and to implement it,\n> your client issues a CHECKIN (which returns the URL of the\n> newly created version), and then an UPDATE (which makes then\n> makes the content and dead properties of the specified URL\n> be those of the new version.\n>\n> A CHECKIN against a checked-in URL will just fail (you can\n> only issue a CHECKIN against something that is checked-out,\n> such as an in-place checked-out vcr, or a working resource.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net]\n> Sent: Thursday, June 14, 2001 6:56 PM\n> To: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\n> Subject: RE: Question on Checking (of Working Resource vs. VCR): is this\n> r ight?\n>\n>\n> I have a non-forking server and I will not allow people to check out a\n> prior version, which seems to be allowed in the spec.\n>\n> I'm willing to refuse to allow a CHECKIN on the working copy and require\n> it be issued on the VCR.  But a CHECKIN that doesn't 'check the file in'\n> violates the expectations of every user of every source control system\n> I've ever seen.\n>\n>\n>\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n>\n>\n> A working resource can be created by checking out\n> an arbitrary version, so in general, it is not\n> associated with any VCR.\n>\n> So you do need to support either the update feature\n> or the merge feature if you support the working resource feature (that\n> is why the client-side workspace package contains the update feature.\n>\n> Cheers,\n> Geoff\n>\n>\n> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net]\n> Sent: Thursday, June 14, 2001 3:15 PM\n> To: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\n> Subject: Question on Checking (of Working Resource vs. VCR): is this\n> right?\n>\n>\n>\n> My user performs a CHECKOUT, PUT, and CHECKIN.  He wants the contents to\n> change, and he wants a new version.\n>\n> I'm using working resources.\n>\n> To get this behavior, the user must:\n> 1) CHECKOUT the VCR.\n> 2) PUT on the working copy identified by the Location URL in the\n> CHECKOUT response.\n> 3) CHECKIN the VCR.\n>\n> It appears that if they do a CHECKIN on the working copy, they will not\n> get what they expect.  9.4 indicates that they create a 'version' but\n> that the VCR doesn't know about it.\n>\n> Since I don't support UPDATE or MERGE I seem to have two options.  Fail\n> the CHECKIN on a working copy or treat it as a CHECKIN on the VCR\n> silently.\n\n\n\n", "id": "lists-006-2212936"}, {"subject": "RE: A non-forking server, precussor revisited", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n\n> A more general question:  I personally am not attached\n> to the \"precursor\" property.  Does anyone want to argue\n> for keeping it in the spec?  If not, I propose we get\n> rid of it, since it seems to be a source of confusion.\n\nIt can go as far as I am concerned -- as I recall JimA. was keen on this\ndistinction.\n\nTim\n\n\n\n", "id": "lists-006-2227954"}, {"subject": "RE: Question on Checking (of Working Resource vs. VCR): is this r   ight", "content": "\"Lisa Dusseault\" <lisa@xythos.com> wrote:\n> So does this mean that support for working resources\n> effectively has a dependency on the UPDATE feature?\n> It's at least consistent that both are included in\n> the \"basic client workspace\" package.\n\nGiven that it is likely that users would want to make a version available\nat a user-defined URL (i.e. as a version-controlled resource) then yes,\nthey would require UPDATE.\nHowever, we have cases where we are creating versions that are only\naccessed via their version URL and so UPDATE is not required there.\n\n> Section 9.4 does state that UPDATE or MERGE are required\n> after a checkin from a working resource, but this is\n> misleading.\n\nWhat it actually says is:\n   \"Note that checking in a working resource does not change\n    the content or dead properties of any version-controlled\n    resource, therefore an UPDATE or MERGE request must be\n    used to update a version-controlled resource with the\n    content and dead properties of a version created by\n    checking in a working resource\"\n\nSo yes, to clarify, that \"must be used\" should be changed to \"may be used\"\n(i.e. if you don't want to update a version-controlled resource, then don't\nbother with an UPDATE or MERGE.)\n\n> Merge can only be done if there are a couple things that can\n> be merged.  That's not always the case; nor is the server\n> always capable of doing a merge.  Imagine I check out an\n> image in my repository, I get a working-resource URL, and I\n> PUT the new image to the working-resource.  Now you can see\n> that UPDATE is absolutely required ror the version-controlled\n> resource to ever have its contents and dead properties change.\n\nThe MERGE is merging version history, not resource content(*).\n\nTo merge means to update this version-controlled resource with the latest\n(in the version history) version given two versions to choose from, or\ncomplain if one version is not the predecessor of the other.  That is, if\nthe versions are on different branches then it is ambiguous as to which\nversion represents the 'latest' state of the resource and the merge must\nfail.\nObviously there is more to it than that, and the definitive description is\ngiven in the document.\n\n(*) the spec does give a server the right to merge content if it is capable\nof doing so, and the server must give an indication of what it has done so\nthat it can be verified.\nThis is only going to be available on super-advanced servers (with initals\nCC <g>)\n\n> This dependency should at least be made clear.  We might also\n> consider trying to remove the dependency, since one would think\n> that in a non-forking server, a CHECKIN would 99% of the time\n> be followed by a UPDATE to push the latest content to the VCR.\n> Rolling those two actions into one request (unless specified\n> otherwise) would save a round-trip, because the CHECKIN and\n> UPDATE can't be pipelined if you have to wait for the successful\n> response to the CHECKIN before knowing how to send the UPDATE.\n\nThese non-forking servers may use in-place-checkout to keep a\nversion-controlled resource up to date.\n\nTim\n\n\n\n", "id": "lists-006-2236009"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> Before we got much further with this thread, let's\n> examine the underlying premise that \"deleting the\n> versions when the VCR is deleted\" is an important\n> use case.\n\nWhether it is an important use case or not, the proposal that you made so\nfar seems relatively harmless since it permits a server to delete versions\nin a fashion that retains the 'referential integrity' that people wanted.\nClearly there will be servers that do not allow version deletion at all,\nand they are free to retain that policy; but for servers that do allow\nversion deletion I do not see significant difference to the server\nimplementing the proposal and a client implementing the same deletion as a\npolicy.  Either way the versions will have gone.\n\n> This is the web, so everybody and their grandmother\n> (and for sure, www.google.com) will have cached copies\n> of anything you put up on the web, so an argument\n> that blowing away old versions at server defined\n> URL's will somehow make that data go away is rather\n> unrealistic, isn't it?\n\nI don't buy this argument at all -- the argument for DELETE is not 'erase'\nthe data but rather to make it unaccesible (it is a namespace operation)?\n\n> And if it doesn't really go\n> away, why do we care that there are also a few obscure\n> server-defined URL's that contain a copy of a\n> version of this data?\n\nThe server admin sure cares that there are copies of the version data left\non the server.\n\n> So perhaps we should reach agreement that this is a\n> compelling use case before we consider supporting it\n> by introducing either additional protocol elements\n> or making server behavior less consistent and predictable.\n\nThis is always a good idea.\n\n> So my revised position is that we defer any action\n> on this proposal until the group reaches consensus\n> that this is in fact a compelling use case.\n\nAgreed.\n\nTim\n\n\n\n", "id": "lists-006-2246570"}, {"subject": "Re: A non-forking server, precussor revisited", "content": "\"John Hall\" <johnhall@evergo.net> wrote:\n\n> In my first reading of the specification, I remind myself\n> that I probably don't fully understand the spec or how\n> people envision that it be implemented.\n\nIt is undoubtably a 'deep' read, but it is very useful for people like\nyourself to read it without the baggage of previous iterations and give\nyour impression and opinion.\n\n> I note that there is support for both a forking and a\n> non-forking server. A server does not have to implement\n> features that allow people to 'fork' version controlled\n> resources. I appreciate that. Some situations and clients\n> do require that capacity, but many other systems would\n> like to do a 'simple' versioning system and don't require\n> this.\n\nJust a nit; version-controlled resources have no history, so it is\n_versions_ that are forked (or not as the case may be).\n\n> But it seems that the separation isn't clean. If I don't\n> support forking, UPDATE, or MERGE, then I see no reason at\n> all to keep track of precursor-set.\n\nI'm a bit confused here -- the separation between what is unclean?\nThe precursor-set is the 'logical predecessors' of the resource either by\ncopying an existing resource from another version history, or maybe by\nmanually merging a significant amount of content, or even a significant\nconcept, from another resource.  It is simply a means of identifying a\nhistorical relationship between two resources that was not directly based\non CHECKOUT/CHECKIN.\n\n> Geoff said precursor-set was only one href, but I thought\n> it was each and every href that had ever been copied on\n> top of a versioned resource -- so it is an unlimited set\n> of href's.\n\nIt is a set of any number of resource URLs that form part of the resource's\nlogical history.\n\n> So I would strongly prefer that precursor-set be optional.\n> An alternative would be that an implementation MAY not track\n> precursor-set and MAY set it equal to predecessor-set IF\n> it doesn't support MERGE or UPDATE.\n\nI see no point in making it equal to the predecessor set, but I'm also\nhappy with making it optional.\n\nTim\n\n\n\n", "id": "lists-006-2256255"}, {"subject": "RE: Question on Checking (of Working Resource vs. VCR): is this r ight", "content": "   From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n\n   \"Lisa Dusseault\" <lisa@xythos.com> wrote:\n   > Section 9.4 does state that UPDATE or MERGE are required\n   > after a checkin from a working resource, but this is\n   > misleading.\n\n   What it actually says is:\n      \"Note that checking in a working resource does not change\n       the content or dead properties of any version-controlled\n       resource, therefore an UPDATE or MERGE request must be\n       used to update a version-controlled resource with the\n       content and dead properties of a version created by\n       checking in a working resource\"\n\n   So yes, to clarify, that \"must be used\" should be changed to \"may\n   be used\" (i.e. if you don't want to update a version-controlled\n   resource, then don't bother with an UPDATE or MERGE.)\n\nThis sentence was intended to be parsed as \"in order to update a\nversion-controlled resource with the content and dead properties\nof a version created by checking in a working resource, an UPDATE\nor MERGE request must be used\".  This was an attempt (clearly\nunsuccessful :-) to preemptively address the question above.\nI'll try to reword this so that it is clearer.\n\n   > Merge can only be done if there are a couple things that can\n   > be merged.\n\nThere is always at least one other version (the initial version).\n\n   > That's not always the case; nor is the server\n   > always capable of doing a merge.\n\nNote that if your server does not support branching, a MERGE will\nalways just set the content and dead properties to whatever\nversion is later ... no client or server defined content\nmodification is required.\n\n   > Imagine I check out an\n   > image in my repository, I get a working-resource URL, and I\n   > PUT the new image to the working-resource.  Now you can see\n   > that UPDATE is absolutely required or the version-controlled\n   > resource to ever have its contents and dead properties change.\n\n   The MERGE is merging version history, not resource content(*).\n\n   To merge means to update this version-controlled resource with the\n   latest (in the version history) version given two versions to\n   choose from, or complain if one version is not the predecessor of\n   the other.  That is, if the versions are on different branches then\n   it is ambiguous as to which version represents the 'latest' state\n   of the resource and the merge must fail.  Obviously there is more\n   to it than that, and the definitive description is given in the\n   document.\n\nYes.\n\n   (*) the spec does give a server the right to merge content if it is\n   capable of doing so, and the server must give an indication of what\n   it has done so that it can be verified.  This is only going to be\n   available on super-advanced servers (with initals CC <g>)\n\nActually we only do the simple automatable merges (i.e. merging\ntwo directory versions).  For content merges, we leave that to the\nuser (although we do provide a super-duper n-way merge GUI to\nhelp out :-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2265992"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "   From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n\n   \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n   > Before we got much further with this thread, let's\n   > examine the underlying premise that \"deleting the\n   > versions when the VCR is deleted\" is an important\n   > use case.\n\n   Whether it is an important use case or not, the proposal that you\n   made so far seems relatively harmless since it permits a server to\n   delete versions in a fashion that retains the 'referential\n   integrity' that people wanted.\n\nThe problem with the \"referential integrity\" argument was that it\nassumed that the only version references that mattered were a few\nspecific ones (e.g. the DAV:checked-in or DAV:checked-out properties\nof version-controlled resources).  In fact, there might be references\nto those versions stored in a variety of dead properties, or in\nHTML documents, and those references would be broken if the \nversion was deleted.\n\n   Clearly there will be servers that do not allow version deletion at all,\n   and they are free to retain that policy; but for servers that do allow\n   version deletion I do not see significant difference to the server\n   implementing the proposal and a client implementing the same deletion as\na\n   policy.  Either way the versions will have gone.\n\nThe difference is critical for a versioning aware client that wants to\nprovide predictable behavior to a versioning aware user.  If that user\nwants \"all traces of those versions removed from this site\", then it\nis the clients job to do so.  If that user wants \"all references to\nthose versions to remain valid\", then it is also the clients job to do\nthat.  If the versioning protocol defines predictable version deletion\nbehavior, the client has a reasonable chance of doing this against a\nwide range of versioning servers.  If it does not define predictable\nversion deletion behavior, then for users that don't want version\nreferences to be broken, the client would have to create its own\ncopies of all the versions (in some non-versioning space), and then\nfix up all the references (not an easy job!) to those versions to\npoint to those new copies.\n\n   > This is the web, so everybody and their grandmother\n   > (and for sure, www.google.com) will have cached copies\n   > of anything you put up on the web, so an argument\n   > that blowing away old versions at server defined\n   > URL's will somehow make that data go away is rather\n   > unrealistic, isn't it?\n\n   I don't buy this argument at all -- the argument for DELETE is not\n   'erase' the data but rather to make it unaccesible (it is a\n   namespace operation)?\n\nWhich argument don't you buy?  The one that says that it is important\nfor DELETE to erase the data?  Or the one that says that it is\nunrealistic to expect to be able to erase all instances of \"related\ninformation at other URL's\" (e.g. old versions) with a DELETE request.\n(The first argument was the argument made by the proponents of the\nauto-delete behavior.  The second argument is a counter-argument to\nthis first argument.)\n\n   > And if it doesn't really go away, why do we care that there are\n   > also a few obscure server-defined URL's that contain a copy of a\n   > version of this data?\n\n   The server admin sure cares that there are copies of the version data\nleft\n   on the server.\n\nThis is a separate issue.  Yes, the server admin does have to have\nspace conservation policies, but I believe that should be provided\nin a general WebDAV context, based on issues like \"last time referenced\", \n\"size\", and \"reproducibility\".\n\n   > So my revised position is that we defer any action on this\n   > proposal until the group reaches consensus that this is in fact a\n   > compelling use case.\n\n   Agreed.\n\nDoes your agreement imply that you feel no such compelling use\ncase has been brought forward?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2277559"}, {"subject": "RE: Question on Checking (of Working Resource vs. VCR): is this r ight", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   We might also consider trying to remove the dependency [of the\n   working-resource option on the update option], since one would\n   think that in a non-forking server, a CHECKIN would 99% of the time\n   be followed by a UPDATE to push the latest content to the VCR.\n   Rolling those two actions into one request (unless specified\n   otherwise) would save a round-trip, because the CHECKIN and UPDATE\n   can't be pipelined if you have to wait for the successful response\n   to the CHECKIN before knowing how to send the UPDATE.\n\nIf folks agree that this is worth making an addition to the\nprotocol to support, I'd suggest the fillowing:\n\nAdd a property to a working resource like \"DAV:checked-out-VCR\".  Set\nthis property on the working resource created when a CHECKOUT is\napplied to a VCR with the DAV:apply-to-version option.  A client is of\ncourse free to add/delete/change this property.  Then add a\npostcondition to \"CHECKIN\" that says that if there is a\nDAV:checked-out-VCR on the working resource being checked in,\nthe specified VCR will automatically be updated to reflect the\ncontent and dead properties of that version.\n\nAnd I will also point out that we would then have a live property\nthat would distinguish a working resource from a checked-out\nversion-controlled resource ... (and thus remove one of the\nobjections of using DAV:supported-live-property-set to classify\nversioning resources ... I can sense Tim either smiling widely,\nor groaning loudly, or both :-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2290017"}, {"subject": "RE: A non-forking server, precussor revisited", "content": "   From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n\n   \"John Hall\" <johnhall@evergo.net> wrote:\n\n   > In my first reading of the specification, I remind myself\n   > that I probably don't fully understand the spec or how\n   > people envision that it be implemented.\n\n   It is undoubtably a 'deep' read, but it is very useful for people\n   like yourself to read it without the baggage of previous iterations\n   and give your impression and opinion.\n\nTotally agree!  Any resulting \"vigorous debate\" (:-) just means that\nyou've raised an interesting point.\n\n   > Geoff said precursor-set was only one href, but I thought\n   > it was each and every href that had ever been copied on\n   > top of a versioned resource -- so it is an unlimited set\n   > of href's.\n\n   It is a set of any number of resource URLs that form part of the\n   resource's logical history.\n\nBut note that my intent for the postcondition of the COPY was\nfor the COPY to *replace* the existing DAV:precursor-set\nwith a singe URL for the new version, not to add it to the\nlist of URL's that are currently the value of that property.\nThe idea here was that if you did a \"merge\", you would be\ndoing a PUT to the resource (which does not modify the DAV:precursor-set)\nand that the client could explicitly add multiple members to\ncapture any logical \"merge\" that preceded that PUT.\n\nPerhaps it would be clearer to just ignore the \"merge\" case,\nand just say there is one href there, and it is always the\nresult of the COPY?\n\n   > So I would strongly prefer that precursor-set be optional.\n   > An alternative would be that an implementation MAY not track\n   > precursor-set and MAY set it equal to predecessor-set IF\n   > it doesn't support MERGE or UPDATE.\n\n   I see no point in making it equal to the predecessor set, but I'm also\n   happy with making it optional.\n\nThe predecessor set is for versions in the same version history, and\nthe precursor set is for versions in a different version history, so\nyou definitely don't want to make the precursor-set equal to the\npredecessor-set.\n\nSo how about the following.  Just change the postcondition of COPY\nto say that the COPY \"MAY\" update the precursor set.  Is this\nOK with everyone?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2299662"}, {"subject": "RE: Basic Property Behavio", "content": "I agree with this decision as well.\n\nAt present, DeltaV *already* has too many options. It is my opinion that the\nbenefit to be gained by adding another option concerning versioning of\nproperties is swamped by the interoperability problems it would raise.\n\nIf a server needed to maintain property whose semantics required it to be\nthe same across all revisions, then this could be made into a live property\nwith that behavior. But, a client should have the expectation that arbitrary\ndead properties are versioned along with the resource contents.\n\n- Jim\n\n> Yes, this issue was raised and debated a couple of IETF's ago,\n> and the consensus was that the implementation burden on a server\n> to support versioned dead properties was not sufficient to\n> introduce a major source of\n> interoperability problems (i.e. clients that expected to be\n> able to version properties would not interoperate effectively\n> with servers that did not, and vica versa).\n>\n> Note that the server defines the versioning behavior of any\n> server defined (and therefore, live) properties, so a server is\n> certainly free to make all of its server defined properties\n> non-versioned.\n\n\n\n", "id": "lists-006-2309937"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "A few comments.\n\nIt is important to keep a clean separation between the issues of content\ndisposition and delete semantics. Content disposition is concerned with\npolicies about when documents should automatically be deleted, or archived\nin some way. For example, one such policy might be to \"archive on tape all\nrevisions older than 1 year then delete them from online storage\", or\n\"delete any email older than 6 months\". This is distinct from the semantics\nof the client-initiated DELETE command when invoked on a resource.\n\nA content disposition solution involves the definition of predicates, stored\nin properties on a resource, for when certain actions are automatically\nperformed by the server. The semantics of DELETE are concerned with a server\nreaction to a client request.\n\nAs well, it is useful to separate issues of persistence of revisions on the\nauthoring server, vs. persistence of revisions across the Web. It should be\nclear that, if a resource is ever world-readable, then there is no way to\nensure that it hasn't been archived somewhere <http://www.archive.org/>.\nHowever, it is possible to control persistence of revisions on the authoring\nserver.\n\nGeoff Clemm writes:\n> Add a new postcondition to DELETE that says:\n>\n> \"If a server does not support the version-history feature,\n> then it MAY automatically delete a version resource if that\n> version no longer appears in the DAV:version-tree report\n> of any version-controlled resource.\"\n\nI support this approach.\n\nJohn, Lisa: Let me note that one of the foundations of your argument in\nfavor of this capability is an indirect appeal to authority, namely the\nauthority of your users/customers. Now, you almost certainly cannot (or\ndon't want to) reveal the market research that led to your position. But,\nlet me note that when you (or anyone else on the list) make this kind of\nargument, you have a responsibility to ensure that you have, in fact done\ndue diligence when reflecting your customer's requirements.\n\nI am not asserting that you have, or that you have not done this due\ndiligence. I am merely noting that it should be done.\n\nJohn Hall writes:\n> allow the VERSION-CONTROL method to turn version-control for a\n> resource at a given URL off\n\nI think this is also a good idea. The current approach is problematic for a\nclient, since it requires the client to know a safe location on the server\nto perform the intermediate copy (if one exists). It is not inconceivable\nthat a client may only have one URL on a server where it is allowed to\nwrite. As well, by dividing the operation up into several steps, it prevents\nus from adding any operation-specific semantics to the \"remove from version\ncontrol\" operation.\n\n- Jim\n\n\n\n", "id": "lists-006-2318111"}, {"subject": "CHECKIN / CHECKOUT proposal from Geof", "content": "I think something like this would be highly desireable.  It removes the\ndependency on UPDATE/MERGE, it makes the meaning of CHECKIN on a working\nresource with this flag the same as a CHECKIN on a edit-in-place\nresource, and it simplifies the life of simple clients / servers\ngreatly.  \n\nNot supporting working copies and instead giving people\n'checkout-in-place' introduced the unwanted side effect of exposing\nusers to works in progress.\n\nAs I understand it then, the language goes something like this:\nDAV:apply-to-version  -- If this property is present, a CHECKOUT of a\nWORKING COPY on the VCR will set the property checked-out-VCR on the\nworking copy.  An implementation MAY support this feature.  An\nimplementation MAY allow this property to be changed.  An implementation\nthat supports this property, the feature WORKING COPY, but not the\nfeatures UPDATE or MERGE, SHOULD prevent this property from being\nmodified.\n\n<!ELEMENT apply-to-version EMPTY>\n\nDAV:checked-out-VCR\n\nIf this optional property exists on a working copy, then a CHECKIN will\nalso update the VCR listed.  An implementation MUST support this\nproperty if it supports WORKING COPY but not one of (UPDATE, MERGE).\n\n<!ELEMENT checked-out-VCR (href)>\n\nCHECKIN postcondition:\n\nIf the property checked-out-VCR is present, then a CHECKIN will\nautomatically update the VCR to reflect the content and dead properties\nof this version.\n\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> Sent: Friday, June 15, 2001 7:51 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Question on Checking (of Working Resource vs. \n> VCR): is this r ight?\n> \n> \n>    From: Lisa Dusseault [mailto:lisa@xythos.com]\n> \n>    We might also consider trying to remove the dependency [of the\n>    working-resource option on the update option], since one would\n>    think that in a non-forking server, a CHECKIN would 99% of the time\n>    be followed by a UPDATE to push the latest content to the VCR.\n>    Rolling those two actions into one request (unless specified\n>    otherwise) would save a round-trip, because the CHECKIN and UPDATE\n>    can't be pipelined if you have to wait for the successful response\n>    to the CHECKIN before knowing how to send the UPDATE.\n> \n> If folks agree that this is worth making an addition to the \n> protocol to support, I'd suggest the fillowing:\n> \n> Add a property to a working resource like \n> \"DAV:checked-out-VCR\".  Set this property on the working \n> resource created when a CHECKOUT is applied to a VCR with the \n> DAV:apply-to-version option.  A client is of course free to \n> add/delete/change this property.  Then add a postcondition to \n> \"CHECKIN\" that says that if there is a DAV:checked-out-VCR on \n> the working resource being checked in, the specified VCR will \n> automatically be updated to reflect the content and dead \n> properties of that version.\n> \n> And I will also point out that we would then have a live \n> property that would distinguish a working resource from a \n> checked-out version-controlled resource ... (and thus remove \n> one of the objections of using \n> DAV:supported-live-property-set to classify versioning \n> resources ... I can sense Tim either smiling widely, or \n> groaning loudly, or both :-).\n> \n> Cheers,\n> Geoff\n> \n> \n\n\n\n", "id": "lists-006-2328353"}, {"subject": "A compelling use case ..", "content": "Geoff Wrote:\nWhich argument don't you buy?  The one that says that it is important\nfor DELETE to erase the data?  Or the one that says that it is\nunrealistic to expect to be able to erase all instances of \"related\ninformation at other URL's\" (e.g. old versions) with a DELETE request.\n(The first argument was the argument made by the proponents of the\nauto-delete behavior.  The second argument is a counter-argument to this\nfirst argument.)\n\n====================================\n\nNo, that is not our position / concern.  That you believe it is may have\neffected your response.\n\nTo me the issues are:\n1) Freeing the resources occupied by the data.\n2) Default behavior of DELETE.\n3) Where should the burden properly fall.\n\nIt simply isn't relevant to any of my concerns that other people may\nhave cached the data, or have links to it.  They can cache it if they\nwant too on THEIR systems.  And if they link to it they have NO\nexpectation it will remain in existence unless they hold a lock on it.\nThat applies to your version-aware clients / customers / users, too.\n\nTim Ellison wrote:\n   Clearly there will be servers that do not allow version deletion at\nall,\n   and they are free to retain that policy; but for servers that do\nallow\n   version deletion I do not see significant difference to the server\n   implementing the proposal and a client implementing the same deletion\nas a\n   policy.  Either way the versions will have gone.\n\nAnd Geoff responded:\nThe difference is critical for a versioning aware client that wants to\nprovide predictable behavior to a versioning aware user.  If that user\nwants \"all traces of those versions removed from this site\", then it is\nthe clients job to do so.  If that user wants \"all references to those\nversions to remain valid\", then it is also the clients job to do that.\nIf the versioning protocol defines predictable version deletion\nbehavior, the client has a reasonable chance of doing this against a\nwide range of versioning servers.  If it does not define predictable\nversion deletion behavior, then for users that don't want version\nreferences to be broken, the client would have to create its own copies\nof all the versions (in some non-versioning space), and then fix up all\nthe references (not an easy job!) to those versions to point to those\nnew copies.\n\nMy Position:\nI'm 100% with Tim Ellison, which is why I offered additional protocol\nelements on the DELETE if necessary to resolve the predictability\nproblem.\n\nWhy should it be my clients obligation to jump through hoops to make\n\"all traces of those versions removed from this site\" rather than your\nclients obligation to tell the server \"keep them around\"?  Since a\nDELETE on a non-VCR reclaims server space, I think I have the stronger\nargument that reclaiming space is the natural default.  And it seems\nsafe to assume that your server and clients are more sophisticated than\nmine, which implies they have a greater burden in being explicit about\nwhat they want to happen.\n\nAnd as for the users that don't want version references to be broken,\nthe ONLY recourse they have to set permissions and locks that prevent\ndelete.  Or restrict themselves to your server implementation.\n\nI don't see your position as protecting these clients, or the ability to\nwrite interoperable clients at all.  It is only protecting them from\nhaving to add the flag \"keep-versions\" when they do a DELETE.\n\nJim W:\nJohn, Lisa: Let me note that one of the foundations of your argument in\nfavor of this capability is an indirect appeal to authority, namely the\nauthority of your users/customers.\n\nMe:\nGranted, and we are going back to those customers to check as we speak.\n\n=================================================\nThe comments below were created earlier, and I sat on them for awhile.\nThey may be a good key to my thinking, attitudes, biases, etc. that are\ndriving my comments on this.  They cover many of the points above, but\nwith more exposition around them.\n\n=================================================\n\n\nWhat is a compelling use case?  To me it is a paying customer with a\nreasonable request.\n\nWell, I'm an almost 40 year old engineer with a grad degree.  I may be\nwrong, but I've rarely been accused of being an idiot.  And my reaction\nis *of course* a DELETE of this versioned file deletes all the old\nversions, too.  Why the bloody else would I ask for a DELETE?  Why would\nan old version have any life after the file it was an old version of\nceased to be?  Gimme back my server space.\n\nNow if I react that way, how am I supposed to explain the idea that\nDELETE doesn't mean DELETE to my typing pool?\n\nTo my typing pool, these versions aren't completely separate items.\nThey are intimately tied to the file in question and they are\nmeaningless without it. I don't mind your attempts to satisfy a market\nwhere they are viewed differently, but this *is* my market, it isn't an\nunreasonable one, and I'd lay bets that it is the larger market.\n\nLook; disk space costs money.  It is a limited resource.  Companies\nassign quotas to users.  Most companies DO NOT view adding revisioning\nas a dramatically new sophisticated way of looking at things, but as a\nsmall incremental advance.  As such, the default behavior experienced by\nusers and simple clients that know about versioning should be as close\nas possible to a straight DAV server.  If anyone has to stand on their\nhead to make something work, it should be the more complex clients with\nthe more complex users, not the members of my typing pool.\n\nAnd it is particularly bad to say that a DELETE of item A renders items\nB through Z effectively undeleteable.  (If I can't find them, I can't\ndelete them.  Besides, my users thought they already did delete them.).\n\nNo client should expect a resource to remain in existence unless it\nspecifically locks the resource or takes some other action to make sure\nthe resource is not deleteable.  If my customer tells me that he wants a\nsystem that deletes versions that are 6+ months old and have at least 2\nsubsequent versions then he should be able to buy software that\nimplements that decision.  The idea that some other company in Angola\ndoesn't think information once collected should ever be lost won't\nimpress him -- the company in Angola isn't paying for his disk drives.\n\nI keep reading that your clients need to 'know' that those versions\nhaven't been deleted.  Why?  I'm certainly going to allow a user to zap\nthem one at a time.  Since your client can't know those resources have\nnot been deleted, we are only arguing about the default behavior -- and\nthe simplest 'least surprise' 'least burden' response is to make\ndestroying the old versions the default.\n\nI fail to see the point about Google, and I don't think my grandmother\nuses a PC.  If google caches a document, so be it.  They can do whatever\nthey want when they are paying for the server space.  If they have a\nlink, ok.  They just might get a 'NOT FOUND' response.  They have NO\nguarantee the resource is still there, only that if they do find\nsomething on the unique URL that it is what they thought it was.  The\npoint about DELETE isn't to destroy the information, it is to free the\nresources.\n\n\n\n", "id": "lists-006-2340702"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: 15 June 2001 15:51\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Removing a resource: A compromise that satisfies?\n>\n>    From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n>\n>    \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n>    > Before we got much further with this thread, let's\n>    > examine the underlying premise that \"deleting the\n>    > versions when the VCR is deleted\" is an important\n>    > use case.\n>\n>    Whether it is an important use case or not, the proposal that you\n>    made so far seems relatively harmless since it permits a server to\n>    delete versions in a fashion that retains the 'referential\n>    integrity' that people wanted.\n>\n> The problem with the \"referential integrity\" argument was that it\n> assumed that the only version references that mattered were a few\n> specific ones (e.g. the DAV:checked-in or DAV:checked-out properties\n> of version-controlled resources).  In fact, there might be references\n> to those versions stored in a variety of dead properties, or in\n> HTML documents, and those references would be broken if the\n> version was deleted.\n\nThere is always the potential for these references to be broken whenever a\nserver allows a version to be deleted.  *If* the use case (automatically\ncleaning out versions) is proven useful then retaining \"referential\nintegrity\" of existing version-controlled resources is useful.\n\n>    Clearly there will be servers that do not allow version\n>    deletion at all,\n>    and they are free to retain that policy; but for servers that do allow\n>    version deletion I do not see significant difference to the server\n>    implementing the proposal and a client implementing the same\n>    deletion as a policy.  Either way the versions will have gone.\n>\n> The difference is critical for a versioning aware client that wants to\n> provide predictable behavior to a versioning aware user.  If that user\n> wants \"all traces of those versions removed from this site\", then it\n> is the clients job to do so.  If that user wants \"all references to\n> those versions to remain valid\", then it is also the clients job to do\n> that.\n\nWhere a server allows version deletion the client cannot do that job.  It\ncannot prevent the client in the next room deleting versions that it\nconsiders important.\n\n> If the versioning protocol defines predictable version deletion\n> behavior, the client has a reasonable chance of doing this against a\n> wide range of versioning servers.  If it does not define predictable\n> version deletion behavior, then for users that don't want version\n> references to be broken, the client would have to create its own\n> copies of all the versions (in some non-versioning space), and then\n> fix up all the references (not an easy job!) to those versions to\n> point to those new copies.\n\nAgreed -- I was only stating that, where servers allow version deletion, the\nproposed condition could be implemented client-side with existing methods --\nand since this is the case there is no good argument against it.  It does\nhave to be predictable however.\n\n>    > This is the web, so everybody and their grandmother\n>    > (and for sure, www.google.com) will have cached copies\n>    > of anything you put up on the web, so an argument\n>    > that blowing away old versions at server defined\n>    > URL's will somehow make that data go away is rather\n>    > unrealistic, isn't it?\n>\n>    I don't buy this argument at all -- the argument for DELETE is not\n>    'erase' the data but rather to make it unaccesible (it is a\n>    namespace operation)?\n>\n> Which argument don't you buy?  The one that says that it is important\n> for DELETE to erase the data?  Or the one that says that it is\n> unrealistic to expect to be able to erase all instances of \"related\n> information at other URL's\" (e.g. old versions) with a DELETE request.\n> (The first argument was the argument made by the proponents of the\n> auto-delete behavior.  The second argument is a counter-argument to\n> this first argument.)\n\nThe one that says that it is important for DELETE to erase the data.\n\"Erasing the data\" is not the correct answer in the face of BINDs etc.\n\n>    > And if it doesn't really go away, why do we care that there are\n>    > also a few obscure server-defined URL's that contain a copy of a\n>    > version of this data?\n>\n>    The server admin sure cares that there are copies of the version data\n>    left on the server.\n>\n> This is a separate issue.  Yes, the server admin does have to have\n> space conservation policies, but I believe that should be provided\n> in a general WebDAV context, based on issues like \"last time referenced\",\n> \"size\", and \"reproducibility\".\n>\n>    > So my revised position is that we defer any action on this\n>    > proposal until the group reaches consensus that this is in fact a\n>    > compelling use case.\n>\n>    Agreed.\n>\n> Does your agreement imply that you feel no such compelling use\n> case has been brought forward?\n\nYes.\n\nTim\n\n\n\n", "id": "lists-006-2355405"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Tim Ellison\n> \n> There is always the potential for these references to be \n> broken whenever a server allows a version to be deleted.  \n> Where a server allows version deletion the client cannot do \n> that job.  It cannot prevent the client in the next room \n> deleting versions that it considers important.\n> \n> Agreed -- I was only stating that, where servers allow \n> version deletion, the proposed condition could be implemented \n> client-side with existing methods -- and since this is the \n> case there is no good argument against it.  It does have to \n> be predictable however.\n> \n\nEnthusiastic clapping from the audience.\n\nMy server WILL allow version delete.\n\nI believe it is unreasonable to ask a client that wishes to reclaim\nspace on the server to do a REPORT version-tree, loop through the\nversions, issue separate DELETE's on each version, and then delete the\nVCR.\n\nI believe it is unreasonable for DeltaV to assume that no\nclient/user/customer would ever want to do that.\n\nAt this point I'd prefer that a DELETE of a VCR *fail* if the client\ndoesn't specify <keep-versions> or <destroy-versions>.    I'd rather not\nhave a default action at all.  \n\nIf we do have a default I think it should be <destroy-versions>, because\nthat is what I think a version-unaware client/user will expect.  But I\ncould live with the default being <keep-versions>.\n\n\n\n", "id": "lists-006-2369907"}, {"subject": "RE: CHECKIN / CHECKOUT proposal from Geof", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   > From Geoff Clemm\n   > \n   > Add a property to a working resource like \n   > \"DAV:checked-out-VCR\".  Set this property on the working \n   > resource created when a CHECKOUT is applied to a VCR with the \n   > DAV:apply-to-version option.  A client is of course free to \n   > add/delete/change this property.  Then add a postcondition to \n   > \"CHECKIN\" that says that if there is a DAV:checked-out-VCR on \n   > the working resource being checked in, the specified VCR will \n   > automatically be updated to reflect the content and dead \n   > properties of that version.\n\n   I think something like this would be highly desireable.  ...\n\n   As I understand it then, the language goes something like this:\n   DAV:apply-to-version  -- If this property is present, a CHECKOUT of a\n   WORKING COPY on the VCR will set the property checked-out-VCR on the\n   working copy.\n\nProbably more like: \"If DAV:apply-to-version is specified in the\nrequest body, then the DAV:checked-out-VCR property of the working\nresource created by the request MUST contain a DAV:href that contains\nthe request-URL.\n\n   An implementation MAY support this feature.\n\nI'd make it a MUST, unless someone can make a convincing argument\nfor why it is prohibitively difficult for some servers to support this\nwhen they support the working resource feature.\n\n   An\n   implementation MAY allow this property to be changed.\n\nI'd make that a MUST as well.  Every MAY in the spec indicates\na failure to reach agreement, and represents an increase in the\ncomplexity of writing an interoperable client.\n\n   An implementation\n   that supports this property, the feature WORKING COPY, but not the\n   features UPDATE or MERGE, SHOULD prevent this property from being\n   modified.\n\nI see no reason for this constraint (SHOULD's are only slightly\nbetter than MAY's).\n\n   <!ELEMENT apply-to-version EMPTY>\n\nYes (this is already a defined element in the protocol).\n\n   DAV:checked-out-VCR\n\n   If this optional property exists on a working copy, then a CHECKIN will\n   also update the VCR listed.  An implementation MUST support this\n   property if it supports WORKING COPY but not one of (UPDATE, MERGE).\n\nAs above, I'd make it a required part of the working resource\nfeature, not conditional on the non-support of some other feature.\n\n   <!ELEMENT checked-out-VCR (href)>\n\n   CHECKIN postcondition:\n\n   If the property checked-out-VCR is present, then a CHECKIN will\n   automatically update the VCR to reflect the content and dead properties\n   of this version.\n\nYes.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2379213"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "   > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Tim Ellison\n   > \n   > There is always the potential for these references to be \n   > broken whenever a server allows a version to be deleted.  \n   > Where a server allows version deletion the client cannot do \n   > that job.  It cannot prevent the client in the next room \n   > deleting versions that it considers important.\n\nYes, I of course agree.  My argument here was not that references to\nversions can't dangle (obviously they can, if the server allows you to\napply DELETE to the URL of a version.  My argument was just that\n\"deleting all the versions when you delete the VCR\" can be a very\ndamaging thing, so that it is not behavior that you should leave as\n\"server defined\".  So I'm guessing we've been violently agreeing\nhere (:-).\n\n   > Agreed -- I was only stating that, where servers allow \n   > version deletion, the proposed condition could be implemented \n   > client-side with existing methods -- and since this is the \n   > case there is no good argument against it.  It does have to \n   > be predictable however.\n\n   From: John Hall [mailto:johnhall@evergo.net]\n\n   Enthusiastic clapping from the audience.\n\nYou may have misinterpreted Tim's message here (or at least, one\nof us has :-).  When he refers to \"version deletion\", I believe\nhe is referring to the application of a DELETE to a version URL,\nnot the deletion of versions as a side effect of deleting a VCR.\nAnd he is inferring from this that a client needs to be prepared\nfor references to versions to dangle (which I agree with).\nThe key sentence is the last one: \"It does have to be predictable\nhowever\".  I believe this means the protocol has to state what are\nthe resource deletion properties of a method, and should not\nleave it up to the server to decide what deletion semantics it\nwants to provide.\n\n   My server WILL allow version delete.\n\nAllowing a DELETE to be applied to a version URL, no argument.\nHaving a delete of a VCR automatically delete all versions on\none server while having it not delete any versions on another\nserver, that I would argue against being supported by the protocol\n(your server can of course do whatever it wants ... we're just\ntalking about what behavior the protocol tells clients to expect).\n\n   I believe it is unreasonable to ask a client that wishes to reclaim\n   space on the server to do a REPORT version-tree, loop through the\n   versions, issue separate DELETE's on each version, and then delete the\n   VCR.\n\nSurely computer programs are really good at implementing loops? (:-)\nJust take the loop that you are using to display the version history,\nand replace the display routine with a DELETE request.  And if you end\nup supporting version history resources (which I believe Lisa was\nleaning towards, to get \"global\" properties on all versions of a VCR),\nthen you can just delete the version history resource, and no loops\nare required.\n\n   I believe it is unreasonable for DeltaV to assume that no\n   client/user/customer would ever want to do that.\n\nI agree.  Which is why explicit version deletion is supported.\n\n   At this point I'd prefer that a DELETE of a VCR *fail* if the client\n   doesn't specify <keep-versions> or <destroy-versions>.    I'd rather not\n   have a default action at all.  \n\nThat I believe is an unreasonable constraint on interoperability with\nversioning unaware clients.\n\n   If we do have a default I think it should be <destroy-versions>, because\n   that is what I think a version-unaware client/user will expect.  But I\n   could live with the default being <keep-versions>.\n\nOK, if you can live with the default being <keep-versions>, we are\npretty close (I can *only* live with the default being <keep-versions> :-).\nSo the remaining question is: Is that loop through the version history\nlist really so prohibitively complex,  that we need an additional protocol\nelement to optimize it (especially since we already have the\noptimization that has the DELETE on a version history also delete\nall the versions in that version history.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2389431"}, {"subject": "RE: CHECKIN / CHECKOUT proposal from Geof", "content": "My 'MAY' values are only trying to keep the client from getting into an\nimpossible state.  Namely, no UPDATE/MERGE available but the CHECKIN\n'apply-to-version' isn't specified.\n\nNow, I thought 'apply-to-version' was a flag on the working resource,\nbut you are putting it in the CHECKIN body.  OK.\n\nSo can you just let me fail the CHECKIN if 'apply-to-version' isn't\nspecified and neither is UPDATE/MERGE?\n\nAnd another reason for 'MAY' is that different companies might wish to\nconfigure a given server in different ways.  Although my server will\nallow versions to be deleted, I'll also provide an admin flag\n(proprietary) to prohibit it.\n\n======================\n\nSO:\nCHECKOUT (of working copy) postcondition:\n<!ELEMENT checked-out-VCR (href)> MAY be set on the working copy with\nthe href of the VCR when the current version is checked out.  This is\nset when the server supports apply-to-version.\n\nCHECKIN (of working copy) marshalling:\nIf <!ELEMENT apply-to-version EMPTY> is present and <!ELEMENT\nchecked-out-VCR (href)> exists the server performs a CHECKIN (of working\ncopy) and then automatically updates the VCR to reflect the content and\ndead properties of this version.\n\n[I need an error condition here if the UPDATE wasn't successful.  That\ncould happen if checked-out-VCR was invalid.]\n\n\n\n", "id": "lists-006-2401613"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n>    > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of \n>    Enthusiastic clapping from the audience.\n> \n> You may have misinterpreted Tim's message here (or at least, \n> one of us has :-).  When he refers to \"version deletion\", I \n> believe he is referring to the application of a DELETE to a \n> version URL, not the deletion of versions as a side effect of \n> deleting a VCR. \n\nWe both understood it.\n\n\n>    My server WILL allow version delete.\n> \n> Allowing a DELETE to be applied to a version URL, no \n> argument. \n\nThat is what I meant here.\n\n> Surely computer programs are really good at implementing \n> loops? (:-) \n\nWith versioned properties, there might be a LOT of versions.  No, I do\nnot want to entertain the thought of all those separate requests.  Not\nwhen it would be simple to allow a flag in the request body.\n\n> And if you end up supporting version history \n> resources (which I believe Lisa was leaning towards, to get \n> \"global\" properties on all versions of a VCR), then you can \n> just delete the version history resource, and no loops are required.\n\nI'd rather do without global properties than support a VHR, and I\nwouldn't want the implementation tied to it.  The problem with global\nproperties on the VHR is it looks like a proprietary implementation to\nme.  (Setting global properties on the VHR wouldn't be, but I would want\nto retrieve those properties on any PROPFIND on the VCR or any version.)\n\n> OK, if you can live with the default being <keep-versions>, \n> we are pretty close (I can *only* live with the default being \n> <keep-versions> :-). So the remaining question is: Is that \n> loop through the version history list really so prohibitively \n> complex,  that we need an additional protocol element to \n> optimize it (especially since we already have the \n> optimization that has the DELETE on a version history also \n> delete all the versions in that version history.\n\nIt isn't prohibitively complex for the client, it is prohibitively\nexpensive.  \n\nWithout it, I might indeed get forced into supporting a VHR and telling\nclients that they have to do a PROPFIND (for VHR) and two DELETE's\ninstead of just one.  \n\nMy other option would be to support the unofficial flag and let my\nclients make their own decision about the importance of compatibility.\nBut a decision like that is above my pay grade.\n\nIn fact, I'd probably recommend we do both.\n\n\n\n", "id": "lists-006-2410358"}, {"subject": "RE: Should CHECKOUT support a TIMEOUT", "content": "I would like to see this pointed out explicitly in the spec (does not need\nto be normative though), rather than have the behaviour left to be induced.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Thursday, June 14, 2001 2:51 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Should CHECKOUT support a TIMEOUT?\n>\n>\n> The versioning protocol places no restriction on who can\n> do an UNCHECKOUT (if there were, you would see it specified\n> as a precondition for the UNCHECKOUT method).\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net]\n> Sent: Thursday, June 14, 2001 5:24 PM\n> To: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\n> Subject: Should CHECKOUT support a TIMEOUT?\n>\n>\n>\n> ... And if not, is there a provision for someone other than the person\n> who did the checkout performing an UNCHECKOUT?\n>\n>\n\n\n\n", "id": "lists-006-2421046"}, {"subject": "RE: Should CHECKOUT support a TIMEOUT", "content": "I don't know how you could add this to the spec, since it would require\nusing language about 'client identity' that we don't have.  I think this is\na clear case for _not_ stating something that we _don't_ do.\n\nTim\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: 16 June 2001 17:24\n> To: Clemm, Geoff; ietf-dav-versioning@w3.org\n> Subject: RE: Should CHECKOUT support a TIMEOUT?\n>\n>\n> I would like to see this pointed out explicitly in the spec (does not need\n> to be normative though), rather than have the behaviour left to\n> be induced.\n>\n> lisa\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> > Sent: Thursday, June 14, 2001 2:51 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: RE: Should CHECKOUT support a TIMEOUT?\n> >\n> >\n> > The versioning protocol places no restriction on who can\n> > do an UNCHECKOUT (if there were, you would see it specified\n> > as a precondition for the UNCHECKOUT method).\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: John Hall [mailto:johnhall@evergo.net]\n> > Sent: Thursday, June 14, 2001 5:24 PM\n> > To: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\n> > Subject: Should CHECKOUT support a TIMEOUT?\n> >\n> >\n> >\n> > ... And if not, is there a provision for someone other than the person\n> > who did the checkout performing an UNCHECKOUT?\n> >\n> >\n>\n\n\n\n", "id": "lists-006-2430926"}, {"subject": "RE: Should CHECKOUT support a TIMEOUT", "content": "It seems pretty easy to add \"Note: any client can issue an UNCHECKOUT\".\n\nThe spec says that deleting the working resource results in an implicit\nUNCHECKOUT.\n\nBut what happens to the working resource if you do an UNCHECKOUT?\nShould it be deleted?\n\nDoes a WRITE-LOCK prevent an UNCHECKOUT from succeeding unless you hold\nthe LOCK?  That would be a round about way of adding a timeout to a\nCHECKOUT request.\n\nIf a WRITE-LOCK prevents an UNCHECKOUT unless the Locks is held and\nspecified, then someone with a working resource could lock the VCR\nfirst.  In that case, perhaps the VCR and the working resource should\nshare the lock?\n\nI could imagine an argument to CHECKOUT that requested a WRITE-LOCK\n(shared or exclusive, for those who allow multiple checkouts) that\napplied to both the VCR and the working resource.  Then you would have\nto deal with the issue of how to release the LOCK (on checkin, or with a\ndifferent UNLOCK command).  I sort of like that but I've got the feeling\nnobody else will.\n\nSo how about adding this tidbit on the CHECKOUT command: if the VCR is\nlocked, the lock token must be specified for the CHECKOUT to succeed.\nIf the CHECKOUT results in a working resource, the LOCK associated with\nthe lock token specified will be applied to the working copy as well.\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Tim Ellison\n> Sent: Sunday, June 17, 2001 10:21 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Should CHECKOUT support a TIMEOUT?\n> \n> \n> I don't know how you could add this to the spec, since it \n> would require using language about 'client identity' that we \n> don't have.  I think this is a clear case for _not_ stating \n> something that we _don't_ do.\n> \n> Tim\n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of \n> Lisa Dusseault\n> > Sent: 16 June 2001 17:24\n> > To: Clemm, Geoff; ietf-dav-versioning@w3.org\n> > Subject: RE: Should CHECKOUT support a TIMEOUT?\n> >\n> >\n> > I would like to see this pointed out explicitly in the spec \n> (does not \n> > need to be normative though), rather than have the \n> behaviour left to \n> > be induced.\n> >\n> > lisa\n> >\n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of \n> Clemm, Geoff\n> > > Sent: Thursday, June 14, 2001 2:51 PM\n> > > To: ietf-dav-versioning@w3.org\n> > > Subject: RE: Should CHECKOUT support a TIMEOUT?\n> > >\n> > >\n> > > The versioning protocol places no restriction on who can\n> > > do an UNCHECKOUT (if there were, you would see it specified as a \n> > > precondition for the UNCHECKOUT method).\n> > >\n> > > Cheers,\n> > > Geoff\n> > >\n> > > -----Original Message-----\n> > > From: John Hall [mailto:johnhall@evergo.net]\n> > > Sent: Thursday, June 14, 2001 5:24 PM\n> > > To: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\n> > > Subject: Should CHECKOUT support a TIMEOUT?\n> > >\n> > >\n> > >\n> > > ... And if not, is there a provision for someone other than the \n> > > person who did the checkout performing an UNCHECKOUT?\n> > >\n> > >\n> >\n> \n> \n\n\n\n", "id": "lists-006-2441826"}, {"subject": "RE: Should CHECKOUT support a TIMEOUT", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   It seems pretty easy to add \"Note: any client can issue an UNCHECKOUT\".\n\nAny client can issue any request.  I assume that you meant something\nmore significant than that?\n\n   The spec says that deleting the working resource results in an implicit\n   UNCHECKOUT.\n\nNo, it says that a CHECKOUT that created a working resource is cancelled\nby deleting that working resource.  An UNCHECKOUT request is only defined\nfor a version-controlled resource, not a working resource, because the\nkey semantic of UNCHECKOUT is that it returns the version-controlled\nresource back to the state it had before the CHECKOUT.  This makes no\nsense for a working resource.\n\n   But what happens to the working resource if you do an UNCHECKOUT?\n   Should it be deleted?\n\nIt is undefined.\n\n   Does a WRITE-LOCK prevent an UNCHECKOUT from succeeding unless you hold\n   the LOCK?  That would be a round about way of adding a timeout to a\n   CHECKOUT request.\n\nA write-lock on a version-controlled resource prevents an UNCHECKOUT\nfrom succeeding if that UNCHECKOUT would change the content or dead\nproperties of that VCR.  The only connection between a lock timeout\nand a checkout is if the checkout was an automatic checkout resulting\nfrom updating a write-locked checked-in VCR.  In this case, the result\nof the lock expiration would be an automatic checkin, not an automatic\nUNCHECKOUT.\n\n   If a WRITE-LOCK prevents an UNCHECKOUT unless the Locks is held and\n   specified, then someone with a working resource could lock the VCR\n   first.  In that case, perhaps the VCR and the working resource should\n   share the lock?\n\nThe VCR and the working resource are two separate resources, with two\nseparate URL's, with their own set of locks.  It would have to be\nan incredibly compelling use case to cause us to \"link\" the locks of\ntwo distinct resources.  The versioning protocol and the locking\nprotocol have been carefully kept as orthogonal as possible so that\nthey can evolve independently.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2455573"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   > ... we already have the \n   > optimization that has the DELETE on a version history also \n   > delete all the versions in that version history.\n\n   ... I might indeed get forced into supporting a VHR and telling\n   clients that they have to do a PROPFIND (for VHR) and two DELETE's\n   instead of just one.  \n\nThat sounds like the right thing to do.  An extra PROPFIND and DELETE\nseems like a reasonable amount of overhead for deleting the entire\nversion history of a resource.\n\n   My other option would be to support the unofficial flag and let my\n   clients make their own decision about the importance of compatibility.\n   But a decision like that is above my pay grade.\n\nAdding in optimizations that make your clients work better with your\nservers is always a reasonable thing to do ... it does not harm\ninteroperability, but does give customers a motivation to purchase\nyour clients and servers (assuming you have picked a good set of\noptimizations and added features).\n\n   In fact, I'd probably recommend we do both.\n\nSounds right to me.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2465089"}, {"subject": "RE: Should CHECKOUT support a TIMEOUT", "content": ">    The spec says that deleting the working resource results \n> in an implicit\n>    UNCHECKOUT.\n> \n> No, it says that a CHECKOUT that created a working resource \n> is cancelled by deleting that working resource.  \n\nDo you say this because an UNCHECKOUT will kill multiple checkout's (if\nthose are allowed) while deleting the working resource will only cancel\nthat particular checkout, returning the VCR to the uncheckedout state if\nand only if that was the only checkout?\n\n\n\n", "id": "lists-006-2473660"}, {"subject": "RE: A non-forking server, precussor revisited", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> So how about the following.  Just change the postcondition\n> of COPY to say that the COPY \"MAY\" update the precursor set.\n> Is this OK with everyone?\n\nNo.  I think we should either make it mandatory or scrap it altogether.\nUnless you have at least one 'compelling' use case for each option offered\nby \"MAY\" (i.e. COPY should update the DAV:precursor-set property, and COPY\nshould not update the DAV:precursor-set property) then we are doing a\ndisservice to clients by stating that servers can choose.\nIn this case, unless someone can defend the property I suggest we remove\nit.\n\nTim\n\n\n\n", "id": "lists-006-2481534"}, {"subject": "Last call on the DAV:precursor-set propert", "content": "Tim is of course correct ... only the most compelling implementation\nissue or use case should cause one to insert a MAY in the protocol.\n\nSo unless I hear from a defender of the DAV:precursor-set property,\nI will delete it from the next draft of the protocol.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Monday, June 18, 2001 5:15 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: A non-forking server, precussor revisited.\n\n\n\n\n\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> So how about the following.  Just change the postcondition\n> of COPY to say that the COPY \"MAY\" update the precursor set.\n> Is this OK with everyone?\n\nNo.  I think we should either make it mandatory or scrap it altogether.\nUnless you have at least one 'compelling' use case for each option offered\nby \"MAY\" (i.e. COPY should update the DAV:precursor-set property, and COPY\nshould not update the DAV:precursor-set property) then we are doing a\ndisservice to clients by stating that servers can choose.\nIn this case, unless someone can defend the property I suggest we remove\nit.\n\nTim\n\n\n\n", "id": "lists-006-2489705"}, {"subject": "RE: Should CHECKOUT support a TIMEOUT", "content": "UNCHECKOUT cancels exactly one checkout, namely the in-place\ncheckout on the VCR.  More significantly, it reverts the content\nand dead properties of that VCR back to the state of its\nDAV:checked-out version.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Monday, June 18, 2001 12:41 AM\nTo: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\nSubject: RE: Should CHECKOUT support a TIMEOUT?\n\n\n>    The spec says that deleting the working resource results \n> in an implicit\n>    UNCHECKOUT.\n> \n> No, it says that a CHECKOUT that created a working resource \n> is cancelled by deleting that working resource.  \n\nDo you say this because an UNCHECKOUT will kill multiple checkout's (if\nthose are allowed) while deleting the working resource will only cancel\nthat particular checkout, returning the VCR to the uncheckedout state if\nand only if that was the only checkout?\n\n\n\n", "id": "lists-006-2498438"}, {"subject": "RE: CHECKIN / CHECKOUT proposal from Geof", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n\n   My 'MAY' values are only trying to keep the client from getting into an\n   impossible state.  Namely, no UPDATE/MERGE available but the CHECKIN\n   'apply-to-version' isn't specified.\n\nThat is not an impossible state.  A server may wish to allow versions\nto be created that will never be used to update the state of a VCR.\nOr a server may have some other non-standard method of using a version\nto update the state of a VCR.\n\n   Now, I thought 'apply-to-version' was a flag on the working resource,\n   but you are putting it in the CHECKIN body.  OK.\n\nThe DAV:apply-to-version flag is already defined in the protocol\n(in the CHECKOUT body).\n\n   So can you just let me fail the CHECKIN if 'apply-to-version' isn't\n   specified and neither is UPDATE/MERGE?\n\nA server is of course free to do so, but an interoperable client will\nnot expect that behavior.  An interoperable client will expect that\nyou do support UPDATE, since that is part of the client workspace \npackage.\n\n   And another reason for 'MAY' is that different companies might wish to\n   configure a given server in different ways.  Although my server will\n   allow versions to be deleted, I'll also provide an admin flag\n   (proprietary) to prohibit it.\n\nEvery MAY is an interoperability problem, only added as a last resort.\nThe \"MAY\" for version deletion represents an inherent tension between\nthe desire of a user to preserve history, and the desire of a user to\npreserve space.  Any other \"MAY\" needs a correspondingly compelling\nargument.\n\n   ======================\n\n   SO:\n   CHECKOUT (of working copy) postcondition:\n   <!ELEMENT checked-out-VCR (href)> MAY be set on the working copy with\n   the href of the VCR when the current version is checked out.  This is\n   set when the server supports apply-to-version.\n\nA server that supports the working-resource option MUST support the\nDAV:apply-to-version, and if we add this protocol element, it similarly\nMUST add DAV:checked-out-VCR when DAV:apply-to-version is used.\nOtherwise clients would have to inspect the working resource to\ndetermine if DAV:checked-out-VCR was inserted, and then have\nseparate code paths for if it does, or if it doesn't.\n\n   CHECKIN (of working copy) marshalling:\n   If <!ELEMENT apply-to-version EMPTY> is present and <!ELEMENT\n   checked-out-VCR (href)> exists the server performs a CHECKIN (of working\n   copy) and then automatically updates the VCR to reflect the content and\n   dead properties of this version.\n\nDAV:apply-to-version only appears in CHECKOUT, not CHECKIN.\n\n   [I need an error condition here if the UPDATE wasn't successful.  That\n   could happen if checked-out-VCR was invalid.]\n\nGood point!\n\nThat raises two issues:\n- why did I propose that a client be able to modify the DAV:checked-out-VCR?\n  A client could have checked out a particular version if it didn't want\n  a DAV:checked-out-VCR to be set.\n- should a server be required to update the DAV:checked-out-VCR property\n  of a working resource if the VCR is moved?  I think the answer is yes\n  (only the server can do this correctly).  This goes along with the\n  previous constraint that the DAV:checked-out-VCR property is protected.\n\nSo the modified proposal is:\n\n-----------------\nAdd a protected DAV:checked-out-vcr property for a working resource.\nSet this property on the working resource created when a CHECKOUT with\nthe DAV:apply-to-version flag is applied to a VCR.  Add a\npostcondition to \"CHECKIN\" of a working resource that says that if\nthere is a DAV:checked-out-VCR on the working resource, the specified\nVCR will automatically be updated to reflect the content and dead\nproperties of the new version.  Add a postcondition to \"MOVE\" of a VCR\nthat says that if there is a DAV:checked-out-VCR that identifies that\nVCR, that property is updated to reflect the new location of the VCR.\n------------------\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2506918"}, {"subject": "[ietf-dav-versioning] &lt;none&gt", "content": "The precursor-set property seems to be an important concept of a versions \nhistory. Without it there is no indication that a version has a \nrelationship to another version history.\n\nI don't think it will be unusual for a client to create a new version by \ncopying from a different version history. Will it be important to know the \nnew version came from a different version history? I think the answer is \nyes and the precursor-set facilitates this.\n\n\n\n", "id": "lists-006-2517872"}, {"subject": "RE: [ietf-dav-versioning] &lt;none&gt", "content": "I disagree.\n\nI see no difference between creating a new version from scratch and\ncopying data from somewhere else to create a new version from scratch.\nIf I open file1 and then do a save-as on file2, the server doesn't know\nand precussor isn't set in any case.  So why is it so important to know\nthat someone grabbed a copy of file1's current version and copied it to\nfile2 without editing it first?  If you really want the version history,\nuse MOVE not COPY.\n\nDo you have a 'for example' use case where that origin information is\nvaluable?  And would it still remain valuable after a few more edits\nwere done?\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Rick Rupp\n> Sent: Monday, June 18, 2001 5:39 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: [ietf-dav-versioning] <none>\n> \n> \n> The precursor-set property seems to be an important concept \n> of a versions \n> history. Without it there is no indication that a version has a \n> relationship to another version history.\n> \n> I don't think it will be unusual for a client to create a new \n> version by \n> copying from a different version history. Will it be \n> important to know the \n> new version came from a different version history? I think \n> the answer is \n> yes and the precursor-set facilitates this.\n> \n> \n> \n\n\n\n", "id": "lists-006-2525277"}, {"subject": "RE: DAV:precursor-set propert", "content": "I just wanted to verify that there still was somebody out there\nwho was willing to stand up for it.  There actually was consensus\nreached a while back that this property merited inclusion in the\nprotocol.  So now that one of the supporters has spoken up,\nonce it is clarified that COPY sets the DAV:precursor-set \nproperty to be the URL of the version (as opposed to, appending\nthat URL to the existing contents of the DAV:precursor-set),\nare there any implementation objections to making this a\nrequired property?  As Tim pointed out, we only make something\noptional if it truly presents an implementation barrier, not\njust because a particular client isn't planning on using it.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Rick Rupp [mailto:rick.rupp@merant.com]\nSent: Monday, June 18, 2001 8:39 PM\nTo: ietf-dav-versioning@w3.org\nSubject: [ietf-dav-versioning] <none>\n\n\nThe precursor-set property seems to be an important concept of a versions \nhistory. Without it there is no indication that a version has a \nrelationship to another version history.\n\nI don't think it will be unusual for a client to create a new version by \ncopying from a different version history. Will it be important to know the \nnew version came from a different version history? I think the answer is \nyes and the precursor-set facilitates this.\n\n\n\n", "id": "lists-006-2535117"}, {"subject": "RE: [ietf-dav-versioning] &lt;none&gt", "content": "OK, I officially recuse myself from this issue.  Every time I read\na post from one side or the other, I find myself agreeing with\nwhoever posted last (which means I currently agree with John, but\nI'm sure it won't take much to switch me back again :-).\n\nSo the only thing I am against is \"MAY\".  Either we keep it in the\nprotocol as a MUST (i.e. MUST be set on COPY), or we delete it.\nOther than that, just tell me which side won (:-).\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Monday, June 18, 2001 11:30 PM\nTo: 'Rick Rupp'; ietf-dav-versioning@w3.org\nSubject: RE: [ietf-dav-versioning] <none>\n\n\nI disagree.\n\nI see no difference between creating a new version from scratch and\ncopying data from somewhere else to create a new version from scratch.\nIf I open file1 and then do a save-as on file2, the server doesn't know\nand precussor isn't set in any case.  So why is it so important to know\nthat someone grabbed a copy of file1's current version and copied it to\nfile2 without editing it first?  If you really want the version history,\nuse MOVE not COPY.\n\nDo you have a 'for example' use case where that origin information is\nvaluable?  And would it still remain valuable after a few more edits\nwere done?\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Rick Rupp\n> Sent: Monday, June 18, 2001 5:39 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: [ietf-dav-versioning] <none>\n> \n> \n> The precursor-set property seems to be an important concept \n> of a versions \n> history. Without it there is no indication that a version has a \n> relationship to another version history.\n> \n> I don't think it will be unusual for a client to create a new \n> version by \n> copying from a different version history. Will it be \n> important to know the \n> new version came from a different version history? I think \n> the answer is \n> yes and the precursor-set facilitates this.\n> \n> \n> \n\n\n\n", "id": "lists-006-2543270"}, {"subject": "Actually, you don't need COPY or MOVE, what you really seem to want is CLONE", "content": "I still can't see where it is useful to know about two different version\nhistories, one that you have poor information on (the source of the\nCOPY) and an old version history that is no longer relevent to the\nactual content (since you overlayed it).\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of John Hall\n> Sent: Monday, June 18, 2001 8:30 PM\n> To: 'Rick Rupp'; ietf-dav-versioning@w3.org\n> Subject: RE: [ietf-dav-versioning] <none>\n> \n> \n> I disagree.\n> \n> I see no difference between creating a new version from \n> scratch and copying data from somewhere else to create a new \n> version from scratch. If I open file1 and then do a save-as \n> on file2, the server doesn't know and precussor isn't set in \n> any case.  So why is it so important to know that someone \n> grabbed a copy of file1's current version and copied it to \n> file2 without editing it first?  If you really want the \n> version history, use MOVE not COPY.\n> \n> Do you have a 'for example' use case where that origin \n> information is valuable?  And would it still remain valuable \n> after a few more edits were done?\n> \n> \n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Rick Rupp\n> > Sent: Monday, June 18, 2001 5:39 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: [ietf-dav-versioning] <none>\n> > \n> > \n> > The precursor-set property seems to be an important concept\n> > of a versions \n> > history. Without it there is no indication that a version has a \n> > relationship to another version history.\n> > \n> > I don't think it will be unusual for a client to create a new\n> > version by \n> > copying from a different version history. Will it be \n> > important to know the \n> > new version came from a different version history? I think \n> > the answer is \n> > yes and the precursor-set facilitates this.\n> > \n> > \n> > \n> \n> \n> \n\n\n\n", "id": "lists-006-2553771"}, {"subject": "RE: Actually, you don't need COPY or MOVE, what you really seem t o want is CLONE", "content": "I went thumbing through the archives (which I should have done\nin the first place ...), and found another motivation for\nthe DAV:precursor-set property.\n\nA workspace is only allowed to have one VCR for a given version\nhistory, to ensure that baselining and merging is unambiguous\n(baselining and merging in a workspace is based on finding the\nversion history that corresponds to the version being merged),\nso if you want to create a \"variant\" of a resource in the same\nworkspace, this requires two different version histories.\nIn order to track the relationship between these two variants\n(i.e. when the diverged, and from what common version), the\nDAV:precursor-set property was introduced.\n\nIt was then decided by the working group that this \"history of\na COPY\" was something of general utility (using arguments similar\nto those that Rick posted), and since it provides utility with\nminimal server implementation cost, it was made part of the base\nprotocol.\n\nWith respect to John's argument that a resource created by COPY\nhas its content \"overlaid\" by later changes, that's the case for\nany new version in a version history as well, so I don't see this\nas an argument against tracking this relationship.\n\nSo in conclusion, although it is fair to ask the working group\nto defend any element of the protocol (and desireable to remove\nanything that has no such defense), I believe the case for the\nDAV:precursor-set has been resurrected, so an implementation\ndifficulty would need to be identified in order to remove this\nprotocol element.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Tuesday, June 19, 2001 1:45 AM\nTo: 'John Hall'; 'Rick Rupp'; ietf-dav-versioning@w3.org\nSubject: Actually, you don't need COPY or MOVE, what you really seem to\nwant is CLONE.\n\n\nI still can't see where it is useful to know about two different version\nhistories, one that you have poor information on (the source of the\nCOPY) and an old version history that is no longer relevent to the\nactual content (since you overlayed it).\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of John Hall\n> Sent: Monday, June 18, 2001 8:30 PM\n> To: 'Rick Rupp'; ietf-dav-versioning@w3.org\n> Subject: RE: [ietf-dav-versioning] <none>\n> \n> \n> I disagree.\n> \n> I see no difference between creating a new version from \n> scratch and copying data from somewhere else to create a new \n> version from scratch. If I open file1 and then do a save-as \n> on file2, the server doesn't know and precussor isn't set in \n> any case.  So why is it so important to know that someone \n> grabbed a copy of file1's current version and copied it to \n> file2 without editing it first?  If you really want the \n> version history, use MOVE not COPY.\n> \n> Do you have a 'for example' use case where that origin \n> information is valuable?  And would it still remain valuable \n> after a few more edits were done?\n> \n> \n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Rick Rupp\n> > Sent: Monday, June 18, 2001 5:39 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: [ietf-dav-versioning] <none>\n> > \n> > \n> > The precursor-set property seems to be an important concept\n> > of a versions \n> > history. Without it there is no indication that a version has a \n> > relationship to another version history.\n> > \n> > I don't think it will be unusual for a client to create a new\n> > version by \n> > copying from a different version history. Will it be \n> > important to know the \n> > new version came from a different version history? I think \n> > the answer is \n> > yes and the precursor-set facilitates this.\n> > \n> > \n> > \n> \n> \n> \n\n\n\n", "id": "lists-006-2565887"}, {"subject": "versioning lock null resource", "content": "Lisa says:\n\n>>A direct read of this paragraph combined with deltaV draft 15 (and your\nimplication) would indicate that you can't issue a VERSION-CONTROL method \non\na lock-null resource.  That's bogus.  A \"write locked null resource\" is\nthere so that the creator can do all the write operations and state \nchanges\nthey need before making the resource visible to everybody.\n\nSo, I suggest that VERSION-CONTROL (and perhaps other methods like \nCHECKOUT,\nMKWORKSPACE...) should be explicitly allowed by DeltaV to be done on write\nlocked null resources, and that the spec define a precondition that can be\nreturned if the server decides not to allow operations on write-lock\nresources.<<\n\nThe purpose of lock null resources was to provide an atomic operation for \ncreating and locking a new resource. It was not to control visibility of a \nresource until the creator is ready to \"release\" it to the community. Lock \nnull resources do appear in PROPFIND of collections with dept 1 or \ninfinity, and do respond to PROPFIND themselves. This is a hack solving a \nspecific instance of a problem without coming up with a general solution \n(which would probably require Web transactions). What problem would be \nsolved by allowing versioning of lock null resources? What would it mean? \nWhat would be the contents of the root revision? These are all questions \nthat will be difficult and arbitrary to answer resulting in the current \napproach to handling lock null resources.\n\n\n\n", "id": "lists-006-2580271"}, {"subject": "Re: Removing the DAV:activity and DAV:version-history and DAV:baselin e  resource type value", "content": "The reason we can't introduce new resource types for all of the versioning \nresources is because we have to support down-level clients that only know \nabout DAV:collection. For new resources that down-level clients couldn't \npossibly know about, workspaces, activities, baselines, etc., we don't \nhave this restriction. I agree with Greg and Tim. We should be as specific \nas we can about declared type and only compromise when required by \ninteroperability considerations.\n\n\n\nThis doesn't feel right. Tim's point about supersets worries me. And \nclients\nthat don't look at enough scope to be able to differentiate future/private\ntypes.\n\nWe have specific types of resources in the spec. Semantic/conceptual types\nof resources. It seems better to state \"this resource is of <THIS> type\"\nthan to let it be inferred by the property set.\n\nThat inference step is rather brittle over time.\n\nCheers,\n-g\n\nOn Sat, Jun 02, 2001 at 04:50:44PM -0400, Clemm, Geoff wrote:\n> Currently, the versioning spec defines a few special values for\n> DAV:resourcetype.\n> \n> It has been pointed out in a current thread that this is only done in a \nfew\n> cases,\n> whereas in most cases, the type of a resource is inferred from the\n> DAV:supported-live-property-set.\n> \n> To make this more consistent, I propose that we remove those redundant\n> resource\n> types, which means that you will be able to tell whether or not \nsomething is\n> an\n> activity, version history, or baseline, by looking at its\n> DAV:supported-live-property-set,\n> as is done for the other versioning resources.\n> \n> This follows the Goland \"you are done when you can't delete anything\"\n> protocol principle.\n> \n> Cheers,\n> Geoff\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-2588882"}, {"subject": "RE: A compelling use case ..", "content": "First, I'd like to emphasize that I agree with the following \nstatements:\n- the protocol should support the explicit deletion of versions\n(although a server may refuse the deletion request)\n- servers will provide some mechanism for reclaiming space\n(possibly involving auto-archiving, and maybe even auto-deletion).\n\nThere appear to be three questions in this thread:\n\n- Should we define two different behaviors that a server can\nperform in response to a \"plain\" (i.e. no request body or\nadditional headers) DELETE does when applied to a VCR?\n\n- If the answer to question 1 is \"no\", then should the defined\nbehavior be \"keep all versions\" or \"delete all versions\".\n\n- Should we extend the DELETE request with a body that says either\n\"delete all versions of the VCR\" and \"keep all versions of the VCR\".\n\nMy responses to these questions would be as follows:\n\nFor question (1):\n\nIn designing an interoperable protocol, what matters is not what your\nusers have in mind, since different users will have many different\n(incompatible) things in mind, but rather what client writers have in\nmind when they have written a client using the protocol.\n\nThe job of a client writer is to map the (many different) things a\nuser might want into the (single shared) semantics defined by the\nprotocol.  The more \"server-selected\" alternatives defined by the\nprotocol, the harder it is for a client writer to do this mapping\nin a way to works against a wide range of servers.  We've worked very\nhard to narrow these alternatives down to 5 \"packages\".  To introduce\nvariant server-selected delete semantics would be a step backward.\n\nFor question (2):\n\n- The \"delete all versions\" behavior is inconsistent with the server\nworkspace feature, while the \"keep all versions\" behavior is not\ninconsistent\nwith any other versioning feature (to emphasize, this is talking about\nfeature consistency, not user wishes, which are always inconsistent\nfrom one community of users to another).\n\nFor question (3):\n\n- We already have a way for a server to support efficient\ndeletion of all versions, by supporting the version-history feature,\nso we do not need another way (additional features, even minor ones,\nin a complex protocol, further increase the complexity).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Friday, June 15, 2001 3:44 PM\nTo: 'Clemm, Geoff'; ietf-dav-versioning@w3.org\nSubject: A compelling use case ...\n\n\nGeoff Wrote:\nWhich argument don't you buy?  The one that says that it is important\nfor DELETE to erase the data?  Or the one that says that it is\nunrealistic to expect to be able to erase all instances of \"related\ninformation at other URL's\" (e.g. old versions) with a DELETE request.\n(The first argument was the argument made by the proponents of the\nauto-delete behavior.  The second argument is a counter-argument to this\nfirst argument.)\n\n====================================\n\nNo, that is not our position / concern.  That you believe it is may have\neffected your response.\n\nTo me the issues are:\n1) Freeing the resources occupied by the data.\n2) Default behavior of DELETE.\n3) Where should the burden properly fall.\n\nIt simply isn't relevant to any of my concerns that other people may\nhave cached the data, or have links to it.  They can cache it if they\nwant too on THEIR systems.  And if they link to it they have NO\nexpectation it will remain in existence unless they hold a lock on it.\nThat applies to your version-aware clients / customers / users, too.\n\nTim Ellison wrote:\n   Clearly there will be servers that do not allow version deletion at\nall,\n   and they are free to retain that policy; but for servers that do\nallow\n   version deletion I do not see significant difference to the server\n   implementing the proposal and a client implementing the same deletion\nas a\n   policy.  Either way the versions will have gone.\n\nAnd Geoff responded:\nThe difference is critical for a versioning aware client that wants to\nprovide predictable behavior to a versioning aware user.  If that user\nwants \"all traces of those versions removed from this site\", then it is\nthe clients job to do so.  If that user wants \"all references to those\nversions to remain valid\", then it is also the clients job to do that.\nIf the versioning protocol defines predictable version deletion\nbehavior, the client has a reasonable chance of doing this against a\nwide range of versioning servers.  If it does not define predictable\nversion deletion behavior, then for users that don't want version\nreferences to be broken, the client would have to create its own copies\nof all the versions (in some non-versioning space), and then fix up all\nthe references (not an easy job!) to those versions to point to those\nnew copies.\n\nMy Position:\nI'm 100% with Tim Ellison, which is why I offered additional protocol\nelements on the DELETE if necessary to resolve the predictability\nproblem.\n\nWhy should it be my clients obligation to jump through hoops to make\n\"all traces of those versions removed from this site\" rather than your\nclients obligation to tell the server \"keep them around\"?  Since a\nDELETE on a non-VCR reclaims server space, I think I have the stronger\nargument that reclaiming space is the natural default.  And it seems\nsafe to assume that your server and clients are more sophisticated than\nmine, which implies they have a greater burden in being explicit about\nwhat they want to happen.\n\nAnd as for the users that don't want version references to be broken,\nthe ONLY recourse they have to set permissions and locks that prevent\ndelete.  Or restrict themselves to your server implementation.\n\nI don't see your position as protecting these clients, or the ability to\nwrite interoperable clients at all.  It is only protecting them from\nhaving to add the flag \"keep-versions\" when they do a DELETE.\n\nJim W:\nJohn, Lisa: Let me note that one of the foundations of your argument in\nfavor of this capability is an indirect appeal to authority, namely the\nauthority of your users/customers.\n\nMe:\nGranted, and we are going back to those customers to check as we speak.\n\n=================================================\nThe comments below were created earlier, and I sat on them for awhile.\nThey may be a good key to my thinking, attitudes, biases, etc. that are\ndriving my comments on this.  They cover many of the points above, but\nwith more exposition around them.\n\n=================================================\n\n\nWhat is a compelling use case?  To me it is a paying customer with a\nreasonable request.\n\nWell, I'm an almost 40 year old engineer with a grad degree.  I may be\nwrong, but I've rarely been accused of being an idiot.  And my reaction\nis *of course* a DELETE of this versioned file deletes all the old\nversions, too.  Why the bloody else would I ask for a DELETE?  Why would\nan old version have any life after the file it was an old version of\nceased to be?  Gimme back my server space.\n\nNow if I react that way, how am I supposed to explain the idea that\nDELETE doesn't mean DELETE to my typing pool?\n\nTo my typing pool, these versions aren't completely separate items.\nThey are intimately tied to the file in question and they are\nmeaningless without it. I don't mind your attempts to satisfy a market\nwhere they are viewed differently, but this *is* my market, it isn't an\nunreasonable one, and I'd lay bets that it is the larger market.\n\nLook; disk space costs money.  It is a limited resource.  Companies\nassign quotas to users.  Most companies DO NOT view adding revisioning\nas a dramatically new sophisticated way of looking at things, but as a\nsmall incremental advance.  As such, the default behavior experienced by\nusers and simple clients that know about versioning should be as close\nas possible to a straight DAV server.  If anyone has to stand on their\nhead to make something work, it should be the more complex clients with\nthe more complex users, not the members of my typing pool.\n\nAnd it is particularly bad to say that a DELETE of item A renders items\nB through Z effectively undeleteable.  (If I can't find them, I can't\ndelete them.  Besides, my users thought they already did delete them.).\n\nNo client should expect a resource to remain in existence unless it\nspecifically locks the resource or takes some other action to make sure\nthe resource is not deleteable.  If my customer tells me that he wants a\nsystem that deletes versions that are 6+ months old and have at least 2\nsubsequent versions then he should be able to buy software that\nimplements that decision.  The idea that some other company in Angola\ndoesn't think information once collected should ever be lost won't\nimpress him -- the company in Angola isn't paying for his disk drives.\n\nI keep reading that your clients need to 'know' that those versions\nhaven't been deleted.  Why?  I'm certainly going to allow a user to zap\nthem one at a time.  Since your client can't know those resources have\nnot been deleted, we are only arguing about the default behavior -- and\nthe simplest 'least surprise' 'least burden' response is to make\ndestroying the old versions the default.\n\nI fail to see the point about Google, and I don't think my grandmother\nuses a PC.  If google caches a document, so be it.  They can do whatever\nthey want when they are paying for the server space.  If they have a\nlink, ok.  They just might get a 'NOT FOUND' response.  They have NO\nguarantee the resource is still there, only that if they do find\nsomething on the unique URL that it is what they thought it was.  The\npoint about DELETE isn't to destroy the information, it is to free the\nresources.\n\n\n\n", "id": "lists-006-2598449"}, {"subject": "AW: Actually, you don't need COPY or MOVE, what you really seem t o want is CLONE", "content": "I think this thread calls for the definition of a \"Quantum Property\"\nwhich is spontaneously created and annihilated and exists in a\nprobabilistic state as long as nobody looks into the mailing list\narchives.\n\nClients and servers implemented during this time, will share the\nprobabilistic state. It will be unknown if they are brilliant\nor rather a piece of junk until \"Geoff starts thumbing\".\n\nNotice that a collapsed quantum property can be made probabilistic\nagain when\na) someone asks a questions about it on the list\nb) enough time has gone by that Geoff did last \"thumb\".\nc) it is not mentioned in the spec what happened last time\n\nI therefore propose to document the result of \"thumbing\" in\nthe Spec.\n\nRegards, Stefan\n\n> -----Urspr?ngliche Nachricht-----\n> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n> Gesendet: Dienstag, 19. Juni 2001 13:35\n> An: ietf-dav-versioning@w3.org\n> Betreff: RE: Actually, you don't need COPY or MOVE, what you really seem\n> t o want is CLONE.\n>\n>\n> I went thumbing through the archives (which I should have done\n> in the first place ...), and found another motivation for\n> the DAV:precursor-set property.\n>\n> A workspace is only allowed to have one VCR for a given version\n> history, to ensure that baselining and merging is unambiguous\n> (baselining and merging in a workspace is based on finding the\n> version history that corresponds to the version being merged),\n> so if you want to create a \"variant\" of a resource in the same\n> workspace, this requires two different version histories.\n> In order to track the relationship between these two variants\n> (i.e. when the diverged, and from what common version), the\n> DAV:precursor-set property was introduced.\n>\n> It was then decided by the working group that this \"history of\n> a COPY\" was something of general utility (using arguments similar\n> to those that Rick posted), and since it provides utility with\n> minimal server implementation cost, it was made part of the base\n> protocol.\n>\n> With respect to John's argument that a resource created by COPY\n> has its content \"overlaid\" by later changes, that's the case for\n> any new version in a version history as well, so I don't see this\n> as an argument against tracking this relationship.\n>\n> So in conclusion, although it is fair to ask the working group\n> to defend any element of the protocol (and desireable to remove\n> anything that has no such defense), I believe the case for the\n> DAV:precursor-set has been resurrected, so an implementation\n> difficulty would need to be identified in order to remove this\n> protocol element.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net]\n> Sent: Tuesday, June 19, 2001 1:45 AM\n> To: 'John Hall'; 'Rick Rupp'; ietf-dav-versioning@w3.org\n> Subject: Actually, you don't need COPY or MOVE, what you really seem to\n> want is CLONE.\n>\n>\n> I still can't see where it is useful to know about two different version\n> histories, one that you have poor information on (the source of the\n> COPY) and an old version history that is no longer relevent to the\n> actual content (since you overlayed it).\n>\n>\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of John Hall\n> > Sent: Monday, June 18, 2001 8:30 PM\n> > To: 'Rick Rupp'; ietf-dav-versioning@w3.org\n> > Subject: RE: [ietf-dav-versioning] <none>\n> >\n> >\n> > I disagree.\n> >\n> > I see no difference between creating a new version from\n> > scratch and copying data from somewhere else to create a new\n> > version from scratch. If I open file1 and then do a save-as\n> > on file2, the server doesn't know and precussor isn't set in\n> > any case.  So why is it so important to know that someone\n> > grabbed a copy of file1's current version and copied it to\n> > file2 without editing it first?  If you really want the\n> > version history, use MOVE not COPY.\n> >\n> > Do you have a 'for example' use case where that origin\n> > information is valuable?  And would it still remain valuable\n> > after a few more edits were done?\n> >\n> >\n> >\n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Rick Rupp\n> > > Sent: Monday, June 18, 2001 5:39 PM\n> > > To: ietf-dav-versioning@w3.org\n> > > Subject: [ietf-dav-versioning] <none>\n> > >\n> > >\n> > > The precursor-set property seems to be an important concept\n> > > of a versions\n> > > history. Without it there is no indication that a version has a\n> > > relationship to another version history.\n> > >\n> > > I don't think it will be unusual for a client to create a new\n> > > version by\n> > > copying from a different version history. Will it be\n> > > important to know the\n> > > new version came from a different version history? I think\n> > > the answer is\n> > > yes and the precursor-set facilitates this.\n> > >\n> > >\n> > >\n> >\n> >\n> >\n>\n>\n>\n\n\n\n", "id": "lists-006-2615827"}, {"subject": "Last Call for DAV:checked-out-vcr Proposa", "content": "The DAV:checked-out-vcr property addresses the use case where a\nworking resource has been created for the purpose of updating a\nVCR, and then that VCR has been moved while the working resource\nwas checked-out.  Since the client cannot easily track the\nmovement of the VCR, the DAV:checked-out-vcr property provides\nfunctionality that cannot be achieved by the current protocol\nfor the client-workspace package (the server-workspace package\ndoes not have this problem, since it does not support working\nresources).\n\nDoes anyone object to adding this functionality?  I am ambivalent,\nin that I would prefer to not add functionality to the protocol\n(it's already complex enough), but this is useful, consistent\nfunctionality that does not present any interoperability issues.\nI'd like a few more \"yes, add it in\" or at least \"I don't mind if it\nis added\" comments from the working group before making this addition.\n\nAs a reminder, the proposed additions to the protocol are:\n\nAdd a protected DAV:checked-out-vcr property for a working resource.\nSet this property on the working resource created when a CHECKOUT with\nthe DAV:apply-to-version flag is applied to a VCR.  Add a\npostcondition to \"CHECKIN\" of a working resource that says that if\nthere is a DAV:checked-out-VCR on the working resource, the specified\nVCR will automatically be updated to reflect the content and dead\nproperties of the new version.  Add a postcondition to \"MOVE\" of a VCR\nthat says that if there is a DAV:checked-out-VCR that identifies that\nVCR, that property is updated to reflect the new location of the VCR.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2632872"}, {"subject": "RE: Actually, you don't need COPY or MOVE, what you really seem t  o want is CLONE", "content": "Actually, this is the long-awaited much needed:\n\"DeltaV Book of Why Not\" (a companion document to\nYaron's \"WebDAV Book of Why\".  It is currently up\nfor public contributions in the DeltaV auto-FAQ\npage, set up by Tim Ellison a while back on the\ndeltav web site (thanks again, Tim!).\n\nSo please contribute anything you think of value to\nthis document.  When it has sufficient mass, I'd be\nhappy to format it in the form of an informational\nRFC, so we can get it published as a companion document\nto the protocol.\n\nI would object to folding all this material into the\nprotocol itself, since it is much too easy to misconstrue\nthe motivational statements as normative statements.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\nSent: Tuesday, June 19, 2001 7:54 AM\nTo: ietf-dav-versioning@w3.org\nSubject: AW: Actually, you don't need COPY or MOVE, what you really seem\nt o want is CLONE.\n\n\nI think this thread calls for the definition of a \"Quantum Property\"\nwhich is spontaneously created and annihilated and exists in a\nprobabilistic state as long as nobody looks into the mailing list\narchives.\n\nClients and servers implemented during this time, will share the\nprobabilistic state. It will be unknown if they are brilliant\nor rather a piece of junk until \"Geoff starts thumbing\".\n\nNotice that a collapsed quantum property can be made probabilistic\nagain when\na) someone asks a questions about it on the list\nb) enough time has gone by that Geoff did last \"thumb\".\nc) it is not mentioned in the spec what happened last time\n\nI therefore propose to document the result of \"thumbing\" in\nthe Spec.\n\nRegards, Stefan\n\n> -----Urspr?ngliche Nachricht-----\n> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n> Gesendet: Dienstag, 19. Juni 2001 13:35\n> An: ietf-dav-versioning@w3.org\n> Betreff: RE: Actually, you don't need COPY or MOVE, what you really seem\n> t o want is CLONE.\n>\n>\n> I went thumbing through the archives (which I should have done\n> in the first place ...), and found another motivation for\n> the DAV:precursor-set property.\n>\n> A workspace is only allowed to have one VCR for a given version\n> history, to ensure that baselining and merging is unambiguous\n> (baselining and merging in a workspace is based on finding the\n> version history that corresponds to the version being merged),\n> so if you want to create a \"variant\" of a resource in the same\n> workspace, this requires two different version histories.\n> In order to track the relationship between these two variants\n> (i.e. when the diverged, and from what common version), the\n> DAV:precursor-set property was introduced.\n>\n> It was then decided by the working group that this \"history of\n> a COPY\" was something of general utility (using arguments similar\n> to those that Rick posted), and since it provides utility with\n> minimal server implementation cost, it was made part of the base\n> protocol.\n>\n> With respect to John's argument that a resource created by COPY\n> has its content \"overlaid\" by later changes, that's the case for\n> any new version in a version history as well, so I don't see this\n> as an argument against tracking this relationship.\n>\n> So in conclusion, although it is fair to ask the working group\n> to defend any element of the protocol (and desireable to remove\n> anything that has no such defense), I believe the case for the\n> DAV:precursor-set has been resurrected, so an implementation\n> difficulty would need to be identified in order to remove this\n> protocol element.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net]\n> Sent: Tuesday, June 19, 2001 1:45 AM\n> To: 'John Hall'; 'Rick Rupp'; ietf-dav-versioning@w3.org\n> Subject: Actually, you don't need COPY or MOVE, what you really seem to\n> want is CLONE.\n>\n>\n> I still can't see where it is useful to know about two different version\n> histories, one that you have poor information on (the source of the\n> COPY) and an old version history that is no longer relevent to the\n> actual content (since you overlayed it).\n>\n>\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of John Hall\n> > Sent: Monday, June 18, 2001 8:30 PM\n> > To: 'Rick Rupp'; ietf-dav-versioning@w3.org\n> > Subject: RE: [ietf-dav-versioning] <none>\n> >\n> >\n> > I disagree.\n> >\n> > I see no difference between creating a new version from\n> > scratch and copying data from somewhere else to create a new\n> > version from scratch. If I open file1 and then do a save-as\n> > on file2, the server doesn't know and precussor isn't set in\n> > any case.  So why is it so important to know that someone\n> > grabbed a copy of file1's current version and copied it to\n> > file2 without editing it first?  If you really want the\n> > version history, use MOVE not COPY.\n> >\n> > Do you have a 'for example' use case where that origin\n> > information is valuable?  And would it still remain valuable\n> > after a few more edits were done?\n> >\n> >\n> >\n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Rick Rupp\n> > > Sent: Monday, June 18, 2001 5:39 PM\n> > > To: ietf-dav-versioning@w3.org\n> > > Subject: [ietf-dav-versioning] <none>\n> > >\n> > >\n> > > The precursor-set property seems to be an important concept\n> > > of a versions\n> > > history. Without it there is no indication that a version has a\n> > > relationship to another version history.\n> > >\n> > > I don't think it will be unusual for a client to create a new\n> > > version by\n> > > copying from a different version history. Will it be\n> > > important to know the\n> > > new version came from a different version history? I think\n> > > the answer is\n> > > yes and the precursor-set facilitates this.\n> > >\n> > >\n> > >\n> >\n> >\n> >\n>\n>\n>\n\n\n\n", "id": "lists-006-2643259"}, {"subject": "Re: AW: Actually, you don't need COPY or MOVE, what you really seem t o  want is CLONE", "content": "\"Stefan Eissing\" <stefan.eissing@greenbytes.de> wrote:\n> ...\n> I therefore propose to document the result of \"thumbing\"\n> in the Spec.\n\nI agree that these decisions should be documented, but would prefer to see\nthem added to the FAQ rather than the spec.\n(http://www.webdav.org/deltav/faq)\n\nTim\n\n\n\n", "id": "lists-006-2661494"}, {"subject": "Re: Removing the DAV:activity and DAV:version-history and DAV:baselin e   resource type value", "content": "\"Jim Amsden\" <jamsden@us.ibm.com> wrote:\n> The reason we can't introduce new resource types for\n> all of the versioning resources is because we have to\n> support down-level clients that only know about\n> DAV:collection.\n\nNot sure that I follow this argument, since 'down-level' clients will only\nbe looking for DAV:collection.\n\nBut I take this to mean you do not support extending DAV:resourcetype.\n\n> For new resources that down-level clients couldn't\n> possibly know about, workspaces, activities, baselines,\n> etc., we don't have this restriction.\n\nWhat do you mean?  I thought you just stated that we can't introduce new\nresource types to retain forward compatibility.\n\n> I agree with Greg and Tim. We should be as specific\n> as we can about declared type and only compromise when\n> required by interoperability considerations.\n\nThe type is made quite explicit by the supported live properties and\nsupported methods.  The only debate was how to marshal the 'type'.\n\nTim\n\n\n\n", "id": "lists-006-2670263"}, {"subject": "Re: Last Call for DAV:checked-out-vcr Proposa", "content": "Cc:\"DeltaV (E-mail)\"<ietf-dav-versioning@w3.org>\n\n'I don't mind if it is added'\n\nI do support your comment that additions like this only continue to add to the \ncomplexity of the protocol, however useful they may be.  I think it is fair to \nsay that a draft specification really needs to be nailed down soon and that \nadditional features like DAV:checked-out-vcr be added in the next version of \nthe specification.  \n\n     Thanks,\n\n     Mark\n\n\n\nQuoting \"Clemm, Geoff\" <gclemm@rational.com>:\n\n> The DAV:checked-out-vcr property addresses the use case where a\n> working resource has been created for the purpose of updating a\n> VCR, and then that VCR has been moved while the working resource\n> was checked-out.  Since the client cannot easily track the\n> movement of the VCR, the DAV:checked-out-vcr property provides\n> functionality that cannot be achieved by the current protocol\n> for the client-workspace package (the server-workspace package\n> does not have this problem, since it does not support working\n> resources).\n> \n> Does anyone object to adding this functionality?  I am ambivalent,\n> in that I would prefer to not add functionality to the protocol\n> (it's already complex enough), but this is useful, consistent\n> functionality that does not present any interoperability issues.\n> I'd like a few more \"yes, add it in\" or at least \"I don't mind if it\n> is added\" comments from the working group before making this addition.\n> \n> As a reminder, the proposed additions to the protocol are:\n> \n> Add a protected DAV:checked-out-vcr property for a working resource.\n> Set this property on the working resource created when a CHECKOUT with\n> the DAV:apply-to-version flag is applied to a VCR.  Add a\n> postcondition to \"CHECKIN\" of a working resource that says that if\n> there is a DAV:checked-out-VCR on the working resource, the specified\n> VCR will automatically be updated to reflect the content and dead\n> properties of the new version.  Add a postcondition to \"MOVE\" of a VCR\n> that says that if there is a DAV:checked-out-VCR that identifies that\n> VCR, that property is updated to reflect the new location of the VCR.\n> \n> Cheers,\n> Geoff\n> \n\n\n\n", "id": "lists-006-2678941"}, {"subject": "Re: Last Call for DAV:checked-out-vcr Proposa", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> The DAV:checked-out-vcr property addresses the use case\n> where a working resource has been created for the purpose\n> of updating a VCR, and then that VCR has been moved while\n> the working resource was checked-out.  Since the client\n> cannot easily track the movement of the VCR, the\n> DAV:checked-out-vcr property provides functionality that\n> cannot be achieved by the current protocol for the\n> client-workspace package\n\nI would like to see someone stand up, with their hand on their heart, and\nsay that this is an important use case for them.  I'm increasing resistant\nto adding new functionality to DeltaV unless we have these 'compelling'\ncases.\n\nIs it really the case that clients would not wish to recover from this\nsituation should it occur rarely, or lock the version-controlled resource\nshould it occur frequently?\n\nSkeptically yours,\nTim\n\n\n\n", "id": "lists-006-2689219"}, {"subject": "Re: Actually, you don't need COPY or MOVE, what you really seem to want is  CLONE", "content": "I guess I agree with John. This sort of information is generally kept in \ncomments or application specific properties. The question we have to ask \nourselves is if there is any need to have precursor information available \nin an interoperable way. I don't know off the top of my head any other \nsystem that supports this, but it could be something I just never used.\n\nI also agree with Geoff in that there are good arguments either way. \nHowever I'd lean in the direction of leaving things out if there is any \ndoubt. They can always be added in later when we have more experience and \nthe use cases are more crisp. We don't want to hold up the protocol on \nsuch issues either if we can help it.\n\n\n\n\nI still can't see where it is useful to know about two different version\nhistories, one that you have poor information on (the source of the\nCOPY) and an old version history that is no longer relevent to the\nactual content (since you overlayed it).\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of John Hall\n> Sent: Monday, June 18, 2001 8:30 PM\n> To: 'Rick Rupp'; ietf-dav-versioning@w3.org\n> Subject: RE: [ietf-dav-versioning] <none>\n> \n> \n> I disagree.\n> \n> I see no difference between creating a new version from \n> scratch and copying data from somewhere else to create a new \n> version from scratch. If I open file1 and then do a save-as \n> on file2, the server doesn't know and precussor isn't set in \n> any case.  So why is it so important to know that someone \n> grabbed a copy of file1's current version and copied it to \n> file2 without editing it first?  If you really want the \n> version history, use MOVE not COPY.\n> \n> Do you have a 'for example' use case where that origin \n> information is valuable?  And would it still remain valuable \n> after a few more edits were done?\n> \n> \n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Rick Rupp\n> > Sent: Monday, June 18, 2001 5:39 PM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: [ietf-dav-versioning] <none>\n> > \n> > \n> > The precursor-set property seems to be an important concept\n> > of a versions \n> > history. Without it there is no indication that a version has a \n> > relationship to another version history.\n> > \n> > I don't think it will be unusual for a client to create a new\n> > version by \n> > copying from a different version history. Will it be \n> > important to know the \n> > new version came from a different version history? I think \n> > the answer is \n> > yes and the precursor-set facilitates this.\n> > \n> > \n> > \n> \n> \n> \n\n\n\n", "id": "lists-006-2698075"}, {"subject": "Re: Removing the DAV:activity and DAV:version-history and DAV:baselin e    resource type value", "content": "It's not just that down-level clients are looking for DAV:collection, but \nunfortunately how. If I remember right, someone tried extending \nDAV:resourcetype and found that it broke MS web folders. I think that's \nwhy we all backed away from this solution.\n\nWhat I meant was that clients that only know about DAV:collection probably \ncan't make much use of activities, workspaces, and baselines anyway, \nexcept by treating them as simply resources. The problem is that some new \nresources might be a kind of collection where down-level clients could do \nsomething with them. I don't think DAV:resourcetype is very useful if the \nprotocol or even users can't set new values. In the spirit of XML, clients \nshould treat resource types (or MIME types for that matter) they don't \nknow aboug as simple resources.\n\nThe type may be explicit with properties, but there are some potential \nproblems with this approach. 1) the possibility of ambiguities resulting \nfrom sub-typing as Tim has pointed out,  2) the difficulty clients will \nhave in determining the type of the resource - they have to know the \nproperty semantics instead of relying on the server to hide these \nsemantics, and 3) perhaps reducing future protocol flexibility because \nwe've allow too much semantics into clients that will restrict protocol \nevolution.\n\n\n\n\n\"Jim Amsden\" <jamsden@us.ibm.com> wrote:\n> The reason we can't introduce new resource types for\n> all of the versioning resources is because we have to\n> support down-level clients that only know about\n> DAV:collection.\n\nNot sure that I follow this argument, since 'down-level' clients will only\nbe looking for DAV:collection.\n\nBut I take this to mean you do not support extending DAV:resourcetype.\n\n> For new resources that down-level clients couldn't\n> possibly know about, workspaces, activities, baselines,\n> etc., we don't have this restriction.\n\nWhat do you mean?  I thought you just stated that we can't introduce new\nresource types to retain forward compatibility.\n\n> I agree with Greg and Tim. We should be as specific\n> as we can about declared type and only compromise when\n> required by interoperability considerations.\n\nThe type is made quite explicit by the supported live properties and\nsupported methods.  The only debate was how to marshal the 'type'.\n\nTim\n\n\n\n", "id": "lists-006-2711040"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "Yes, Please.\n\nNot providing this means that implementation of working resources is\nintimately tied to UPDATE / MERGE.  \n\nProviding this makes things simpler for some common use cases.\n\nBut rememeber you have to support an error condition where the CHECKIN\nand update of VCR was not possible.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> Sent: Tuesday, June 19, 2001 5:18 AM\n> To: DeltaV (E-mail)\n> Subject: Last Call for DAV:checked-out-vcr Proposal\n> \n> \n> The DAV:checked-out-vcr property addresses the use case where \n> a working resource has been created for the purpose of \n> updating a VCR, and then that VCR has been moved while the \n> working resource was checked-out.  Since the client cannot \n> easily track the movement of the VCR, the DAV:checked-out-vcr \n> property provides functionality that cannot be achieved by \n> the current protocol for the client-workspace package (the \n> server-workspace package does not have this problem, since it \n> does not support working resources).\n> \n> Does anyone object to adding this functionality?  I am \n> ambivalent, in that I would prefer to not add functionality \n> to the protocol (it's already complex enough), but this is \n> useful, consistent functionality that does not present any \n> interoperability issues. I'd like a few more \"yes, add it in\" \n> or at least \"I don't mind if it is added\" comments from the \n> working group before making this addition.\n> \n> As a reminder, the proposed additions to the protocol are:\n> \n> Add a protected DAV:checked-out-vcr property for a working \n> resource. Set this property on the working resource created \n> when a CHECKOUT with the DAV:apply-to-version flag is applied \n> to a VCR.  Add a postcondition to \"CHECKIN\" of a working \n> resource that says that if there is a DAV:checked-out-VCR on \n> the working resource, the specified VCR will automatically be \n> updated to reflect the content and dead properties of the new \n> version.  Add a postcondition to \"MOVE\" of a VCR that says \n> that if there is a DAV:checked-out-VCR that identifies that \n> VCR, that property is updated to reflect the new location of the VCR.\n> \n> Cheers,\n> Geoff\n> \n> \n\n\n\n", "id": "lists-006-2720950"}, {"subject": "Re: Newbie question", "content": "ajk@mds.rmit.edu.au (Alan Kent) wrote:\n> Q1: When are null resources created? You can \"lock a null resource in\norder\n>     to lock the name\". Is it that if you do a lock on a name that does\nnot\n>     exist as a resource, a null resource is created?\n\nWhen you do a LOCK on a null resource then a lock-null resource is created.\n\n>     Are there other ways\n>     that null resources can be created? The text says you lock a null\nresource\n>     to create a lock-null resource. A lock-null resource has properties\nand\n>     appears under its parent container. A null resource does not appear\nunder\n>     its parent. The definition of null resource is that it is a resource\n>     that responds to requests, which implies that it exists.\n\nI also find this confusing, and I posted a message in response to Jim\nWhitehead's explanation which explains my confusion.  If I get a reply it\nmay answer both our questions :-)\n(see\nhttp://lists.w3.org/Archives/Public/w3c-dist-auth/2001AprJun/0285.html)\n\n>     My guess is that any URI that is not bound to a resource is\nimplicitly\n>     bound to a null resource which has no properties or any other state.\n\nNot _any_ URI, but any URI where the immediate parent collection already\nexists.\n\n>     When you lock a null resource, a lock-null resource is created\nallowing\n>     it to be placed under its parent container and have properties.\n>     Is this correct?\n\nYou are as close to understanding it as I am :-)\n\n> Q2: Are locks on resources or URIs identifying resources? The DeltaV\n>     documentation I have read I think said that locks are applied to the\n>     resources identified by a URL.\n\nEssentially both.  The lock applies to the resource (you cannot change its\ncontent or dead properties) and to the internal members along the URI path\n(you cannot remove or rebind those members i.e. by DELETE or MOVE or COPY)\nso that the resource cannot disappear out from under you.\n\nCaveat: I've built my own mental model of how this works because, IMHO,\nRFC2518 does a poor job of describing it.  I stand to be corrected ...\nbetter still I'd sit to have it explained clearly to me.\n\n> Q3: The MOVE documentation says that a successful MOVE on a write locked\n>     resource must not move the write lock. (It then talks about\ncollections\n>     and locks.) If the resource being moved is locked (that is, the\nresource\n>     itself, not the collection it is in), why is the lock removed when\nthe\n>     resource is moved?\n>     If the lock is applied to a URI, does this mean a\n>     lock-null is left for the old URI?  If the lock is applied to a\nresource,\n>     why does not the lock stay with the resource that is locked?\n>     Or is the text in sectino 7.7 only relating to parent collections\nthat\n>     have been locked and has nothing to do with locks directly on\nresources?\n\nSee http://lists.w3.org/Archives/Public/w3c-dist-auth/1997JulSep/0177.html\n\n> Q4: PROPFIND in section 8.1 talks about responses and errors and\nmultistatus\n>     XML elements. I have read the text several times but is confusing.\n>     It says servers must support returning a multistatus element. (It\ndoes not\n>     say that it must *always* return one, just that it must support it.)\nIt\n>     then says errors must be returned as 404 *if* a multistatus element\nis\n>     returned. etc. It was not clear when a multistatus element must be\n>     returned - is it optional or mandatory? Related, how to know when to\n>     return multistatus elements in general? Examples of packet\ncommunications\n>     are given, but no formal request/response packet grammar is given.\n\nI agree that this text is confusing.  FWIW my rule of thumb is that if the\nstatus code applies _only_ to the resource at the request-URI then 207\nMulti Status is not used (i.e. 404 Not Found, 301 Moved Permanently, and so\non).  207 Multi Status is returned when the result applies to the resource\nidentified by the request-URI and other resources (i.e. depth > 0) *or* the\nresponse applies to any number of properties.\n\nFor a discussion of this topic see\nhttp://lists.w3.org/Archives/Public/w3c-dist-auth/2000AprJun/0042.html\n\n> Q5: MKCOL behaviour with message bodies is not defined in the standard\n>     (section 8.3.1) but may be \"defined elsewhere\". Is there any such\n>     defintion around? Or is the body of MKCOL not important for\n>     interoperability.\n\nThere is no such definition around to my knowledge.  I also haven't heard\nof anyone using a body for MKCOL for their own devious means -- did you\nhave a plan?\n\n> Q6: Is there any clear definitative list of which properties are \"live\"\n>     properties?\n\nDo you mean in the spec. or in the world in general?\nIn the spec. it is those properties whose syntax and semantics are enforced\nby the server, i.e. all those in Section 13.  In the world there is no such\nregistry.\n\n>     My understanding that any property that is not a live property\n>     is a dead property, therefore if I used a property name such as\nDAV:xyz\n>     which is currently not defined, its dead, but later if DAV defines\nxyz,\n>     then it would suddenly become live. I assume the protection here\n>     is that I should never use DAV: because its a DAV namespace.\n\nYou are expected not to use the DAV namespace (despite what you might see\nin some implementations).\n\n> Q7: DELETE is defined to delete a non-collection resource, removing all\nURIs\n>     to that resource, not just the URI passed to the DELETE command\n>     (section 8.6.1).\n\nStrange isn't it?!  BTW this is explicitly overruled by the bindings\nprotocol.\n\n>     Other sections such as MOVE and COPY talk about deleting\n>     the destination. To me this therefore means that if /foo/a and /bar/a\n>     are bound to resource R1, then a COPY with overwrite to /foo/a will\ndelete\n>     the URIs /foo/a and /bar/a and resource R1 then create a new resource\nR2\n>     and only bind /foo/a to the new resource R2. Or should /foo/a and\n/bar/a\n>     both bind to R2? I noticed that DeltaV changes the DELETE semantics\n>     relating to versioning.\n\nI believe this is the issue OVERWRITE_DELETE_ALL_TOO_STRONG on the WebDAV\nissues list http://www.ics.uci.edu/pub/ietf/webdav/protocol/issues.html\n\n> Q8: In DeltaV, versions are given stable URLs such as /his/73/vr/1.\nShould\n>     these URLs be made visible via containers? Ie: should /his be a\ncontainer,\n>     and /his/73, and /his/73/vr? Or are these URLs hidden from\ncontainers?\n\nThat is your choice as a server implementer.  These URLs to a version are\nserver generated and servers are not obliged to expose \"/his/\" as a\nresource.\n\n>     My understanding that there is no standard for \"/his\", its whatever\nthe\n>     system chooses. It just seemed a potentially very expensive operation\nto\n>     get a listing of the contents of \"/his\" as a container since it would\n>     contain a child container for *every* versioned resource history\nresource.\n\nAgreed.\n\n> A short background - we have a document management system are\n> trying to work out how hard it is to support first DAV and then\n> DeltaV. The document management system uses the DMA versioning\n> model, hence any experiences of relating DeltaV to DMA would\n> also be appreciated - although this is probably the wrong list\n> for DeltaV questions.\n\nCheck out http://www.webdav.org/deltav/ for instructions on subscribing to\nthe DeltaV list.\n\n> Thanks for any help people can provide. I relise mail with lots\n> of questions can be a pain, but it was either that or send in\n> lots of separate ones (which I find worse)! Hopefully there are\n> simple answers to the above.\n\nThe questions were clearly written and beautifully formatted :-)\nShame about the answers.\n\n\nTim\n\n\n\n", "id": "lists-006-2731437"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "Consider this a stand up, hand over heart, this is a vital use case for\nthem (me) statement.\n\nNote that my use case is different from the one Geoff stated.  I don't\nwant to support UPDATE or MERGE.  Just CHECKOUT (the VCR to a working\ncopy) and CHECKIN (working copy to update the VCR).  \n\nThat is how I wish to build my server, and it tracks the semantics of\nthe 3rd party non-DeltaV versioning server I want to be compatible with.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Tim Ellison\n> Sent: Tuesday, June 19, 2001 7:01 AM\n> To: DeltaV (E-mail)\n> Subject: Re: Last Call for DAV:checked-out-vcr Proposal\n> \n> \n> \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> > The DAV:checked-out-vcr property addresses the use case\n> > where a working resource has been created for the purpose\n> > of updating a VCR, and then that VCR has been moved while\n> > the working resource was checked-out.  Since the client \n> cannot easily \n> > track the movement of the VCR, the DAV:checked-out-vcr property \n> > provides functionality that cannot be achieved by the \n> current protocol \n> > for the client-workspace package\n> \n> I would like to see someone stand up, with their hand on \n> their heart, and say that this is an important use case for \n> them.  I'm increasing resistant to adding new functionality \n> to DeltaV unless we have these 'compelling' cases.\n> \n> Is it really the case that clients would not wish to recover \n> from this situation should it occur rarely, or lock the \n> version-controlled resource should it occur frequently?\n> \n> Skeptically yours,\n> Tim\n> \n> \n\n\n\n", "id": "lists-006-2746713"}, {"subject": "Re: Removing the DAV:activity and DAV:version-history and DAV:baselin e     resource type value", "content": "\"Jim Amsden\" <jamsden@us.ibm.com> wrote:\n> It's not just that down-level clients are looking for\n> DAV:collection, but unfortunately how. If I remember\n> right, someone tried extending DAV:resourcetype and\n> found that it broke MS web folders. I think that's\n> why we all backed away from this solution.\n\nI tried that and WebFolders displayed the resource as a Folder (even if the\nDAV:resourcetype was, say, <DAV:activity>.  Trying to open the WebFolder\nresulted in no resources.  So it is broken in as much as it displays the\n'wrong' icon.\n\nMy recollection was that people decided that WebFolders could change to do\nthe \"right thing\".\n\n> What I meant was that clients that only know about\n> DAV:collection probably can't make much use of activities,\n> workspaces, and baselines anyway, except by treating\n> them as simply resources.\n\nNot so for workspaces.  A workspace is-a collection, but I take your point.\n\n> The problem is that some new resources might be a kind\n> of collection where down-level clients could do something\n> with them.\n\nAgreed.  Again, workspace would be a good example of this.\n\n> I don't think DAV:resourcetype is very useful if the protocol\n> or even users can't set new values. In the spirit of XML,\n> clients should treat resource types (or MIME types for\n> that matter) they don't know aboug as simple resources.\n\nAgreed.  WebFolders does not do this today.\n\n> The type may be explicit with properties, but there are\n> some potential problems with this approach. 1) the\n> possibility of ambiguities resulting from sub-typing as\n> Tim has pointed out,\n\nGeoff's argument was that if a resource is a sub-type then clients that\ntreat it as a super-type will still do the right thing (without being able\nto use its sub-type capabilities).\n\n> 2) the difficulty clients will have in determining the\n> type of the resource - they have to know the property\n> semantics instead of relying on the server to hide these\n> semantics,\n\nNo, they just need to look and see if the properties and/or methods are\nsupported to correctly type the resource.  The latest draft of the spec has\nan appendix that spells this out.\n\n> and 3) perhaps reducing future protocol flexibility because\n> we've allow too much semantics into clients that will restrict\n> protocol evolution.\n\nAgain, no semantics is required to correctly 'type' a resource.\n\nTim\n\n\n\n", "id": "lists-006-2756843"}, {"subject": "RE: Actually, you don't need COPY or MOVE, what you really seem to want is  CLONE", "content": "Well, not having workspaces, baselines, merge's, updates, etc. I can't\nsee any reason to waste server storage on it.  Not that I see much\nutility in this property with those features, either.  I'd be happy if\nthe element were removed and listed as a proposed (later) addition.\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Jim Amsden\n> Sent: Tuesday, June 19, 2001 7:35 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: Actually, you don't need COPY or MOVE, what you \n> really seem to want is CLONE.\n> \n> \n> I guess I agree with John. This sort of information is \n> generally kept in \n> comments or application specific properties. The question we \n> have to ask \n> ourselves is if there is any need to have precursor \n> information available \n> in an interoperable way. I don't know off the top of my head \n> any other \n> system that supports this, but it could be something I just \n> never used.\n> \n> I also agree with Geoff in that there are good arguments either way. \n> However I'd lean in the direction of leaving things out if \n> there is any \n> doubt. They can always be added in later when we have more \n> experience and \n> the use cases are more crisp. We don't want to hold up the \n> protocol on \n> such issues either if we can help it.\n> \n> \n> \n> \n> I still can't see where it is useful to know about two \n> different version histories, one that you have poor \n> information on (the source of the\n> COPY) and an old version history that is no longer relevent \n> to the actual content (since you overlayed it).\n> \n> \n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of John Hall\n> > Sent: Monday, June 18, 2001 8:30 PM\n> > To: 'Rick Rupp'; ietf-dav-versioning@w3.org\n> > Subject: RE: [ietf-dav-versioning] <none>\n> > \n> > \n> > I disagree.\n> > \n> > I see no difference between creating a new version from\n> > scratch and copying data from somewhere else to create a new \n> > version from scratch. If I open file1 and then do a save-as \n> > on file2, the server doesn't know and precussor isn't set in \n> > any case.  So why is it so important to know that someone \n> > grabbed a copy of file1's current version and copied it to \n> > file2 without editing it first?  If you really want the \n> > version history, use MOVE not COPY.\n> > \n> > Do you have a 'for example' use case where that origin\n> > information is valuable?  And would it still remain valuable \n> > after a few more edits were done?\n> > \n> > \n> > \n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Rick Rupp\n> > > Sent: Monday, June 18, 2001 5:39 PM\n> > > To: ietf-dav-versioning@w3.org\n> > > Subject: [ietf-dav-versioning] <none>\n> > > \n> > > \n> > > The precursor-set property seems to be an important concept of a \n> > > versions history. Without it there is no indication that \n> a version \n> > > has a relationship to another version history.\n> > > \n> > > I don't think it will be unusual for a client to create a new \n> > > version by copying from a different version history. Will it be\n> > > important to know the \n> > > new version came from a different version history? I think \n> > > the answer is \n> > > yes and the precursor-set facilitates this.\n> > > \n> > > \n> > > \n> > \n> > \n> > \n> \n> \n> \n> \n> \n\n\n\n", "id": "lists-006-2766984"}, {"subject": "AW: AW: Actually, you don't need COPY or MOVE, what you really seem to  want is CLONE", "content": "> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Tim Ellison\n>\n> \"Stefan Eissing\" <stefan.eissing@greenbytes.de> wrote:\n> > ...\n> > I therefore propose to document the result of \"thumbing\"\n> > in the Spec.\n>\n> I agree that these decisions should be documented, but would prefer to see\n> them added to the FAQ rather than the spec.\n> (http://www.webdav.org/deltav/faq)\n\nI dared to add a category \"Properties\" and put Geoff's explanation\nabout the precursor-set there.\n\nRegards, Stefan (ducks and covers)\n\n\n\n", "id": "lists-006-2782103"}, {"subject": "Re: AW: AW: Actually, you don't need COPY or MOVE, what you really seem to   want is CLONE", "content": "\"Stefan Eissing\" <stefan.eissing@greenbytes.de> wrote:\n> > I agree that these decisions should be documented, but would\n> > prefer to see them added to the FAQ rather than the spec.\n> > (http://www.webdav.org/deltav/faq)\n>\n> I dared to add a category \"Properties\" and put Geoff's explanation\n> about the precursor-set there.\n\n\nGreat -- and I encourage everyone, when you get an answer to a question, to\nadd the Q&A to the FAQ.\n\nTim\n\n\n\n", "id": "lists-006-2791994"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "\"John Hall\" <johnhall@evergo.net> wrote:\n> Note that my use case is different from the one Geoff\n> stated.\n\nWell lets ensure that we are solving the problem.\n\n> I don't want to support UPDATE or MERGE.  Just CHECKOUT\n> (the VCR to a working copy) and CHECKIN (working copy to\n> update the VCR).\n\n... and you don't want in-place-checkout semantics?  even with locks? but\nyou do want to track moves to the version-controlled resource while you are\nupdating it in the working resource?\n\nTim\n\n\n\n", "id": "lists-006-2800219"}, {"subject": "RE: versioning lock null resource", "content": "> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n>\n> (which would probably require Web transactions). What problem would be\n> solved by allowing versioning of lock null resources? What would it mean?\n> What would be the contents of the root revision? These are all questions\n> that will be difficult and arbitrary to answer resulting in the current\n> approach to handling lock null resources.\n\nI could agree with you about VERSION-CONTROL, but not about MKACTIVITY and\nthe other new verbs that create a new resource.  Users must be able to lock\nnew resources simultaneously with creation.\n\nlisa\n\n\n\n", "id": "lists-006-2808661"}, {"subject": "[ietf-dav-versioning] &lt;none&gt", "content": "> 2) the difficulty clients will have in determining the\n> type of the resource - they have to know the property\n> semantics instead of relying on the server to hide these\n> semantics,\n\nNo, they just need to look and see if the properties and/or methods are\nsupported to correctly type the resource.  The latest draft of the spec \nhas\nan appendix that spells this out.\n\n> and 3) perhaps reducing future protocol flexibility because\n> we've allow too much semantics into clients that will restrict\n> protocol evolution.\n\nAgain, no semantics is required to correctly 'type' a resource.\n\nIn response to Tim:\n\nThe \"semantics\" I referred to above is checking for the existence of some \nset of properties. What if changes in the protocol necessitate changes in \nthese properties at some time in the future? This also leads down the \nslippery slope of using properties with particular values to determine \ntype - that is, confusing state with dynamic type. Most modern computer \nlanguages in common use do use named types and do not require clients to \nlook inside to figure out what they are. Smalltalk, C++, and Java (at \nleast by default) don't even let clients see in. Encapsulation is a good \nthing. I think it would be nice if WebDAV could use it too.\n\n\n\n", "id": "lists-006-2816854"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "In-place-checkout introduces the unwanted behavior of allowing other\nclients to see a work in progress.\n\nIn my system I have no problem tracking moves, but it isn't my\nobjective.  My objective is having a CHECKIN of the working resource\nupdate the VCR.  That isn't a 'gee it would be nice to have' request.\nIt is far more important to me than that.  Lack of such a feature would\nbe quite painful.\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Tim Ellison\n> Sent: Tuesday, June 19, 2001 9:59 AM\n> To: 'DeltaV (E-mail)'\n> Subject: RE: Last Call for DAV:checked-out-vcr Proposal\n> \n> \n> \n> \"John Hall\" <johnhall@evergo.net> wrote:\n> > Note that my use case is different from the one Geoff\n> > stated.\n> \n> Well lets ensure that we are solving the problem.\n> \n> > I don't want to support UPDATE or MERGE.  Just CHECKOUT\n> > (the VCR to a working copy) and CHECKIN (working copy to update the \n> > VCR).\n> \n> ... and you don't want in-place-checkout semantics?  even \n> with locks? but you do want to track moves to the \n> version-controlled resource while you are updating it in the \n> working resource?\n> \n> Tim\n> \n> \n> \n\n\n\n", "id": "lists-006-2825434"}, {"subject": "RE: [ietf-dav-versioning] &lt;none&gt", "content": "   > From: Jim Amsden [mailto:jamsden@us.ibm.com]\n   > 2) the difficulty clients will have in determining the\n   > type of the resource - they have to know the property\n   > semantics instead of relying on the server to hide these\n   > semantics,\n\n   From: Tim Ellison\n   No, they just need to look and see if the properties and/or methods\n   are supported to correctly type the resource.  The latest draft of\n   the spec has an appendix that spells this out.\n\n\n   From: Jim Amsden\n\n   The \"semantics\" I referred to above is checking for the existence\n   of some set of properties.\n\nJust to be precise, the check is for whether the properties\nare supported, not whether or not they exist (i.e. a resource\ncan support a property even if the property does not currently\nexist on that resource).\n\n   What if changes in the protocol necessitate changes in these\n   properties at some time in the future?\n\nA change in the protocol must be backward compatible.  Just as we\ncannot say \"COPY no longer accepts a Depth header\", we will not be\nable to say \"an activity no longer supports a DAV:subactivity\nproperty\".  In addition, any future extensions to the semantics of\nDAV:subactivity will have to be compatible with its current semantics.\n\n   This also leads down the slippery slope of using properties with\n   particular values to determine type - that is, confusing state with\n   dynamic type.\n\nThis is not an issue because we do not check for the existence of a\nproperty (much less it having a particular value), but rather just \"is\nthat property supported\".  (But for the record, we're already\nat the bottom of that slippery slope, because the distinction\nbetween state and dynamic type is a fuzzy one at best.)\n\n   Most modern computer languages in common use do use\n   named types and do not require clients to look inside to figure out\n   what they are. Smalltalk, C++, and Java (at least by default) don't\n   even let clients see in. Encapsulation is a good thing. I think it\n   would be nice if WebDAV could use it too.\n\nEncapsulation is preventing you from seeing the implementation.  That\nis exactly what an IETF protocol does ... you can only see and use the\npublic parts (which are the methods and properties defined by the\nprotocol).  A public property is as much a part of the type signature\nas a public method.  All we are saying is that we should be using type\nsignature equivalence, rather than type name equivalence, since HTTP\ndoes not provide a \"subtype declaration\" mechanism, but the versioning\nprotocol has defined a type signature exposure mechanism\n(DAV:supported-method-set and DAV:supported-live-property-set).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-2835239"}, {"subject": "RE: [ietf-dav-versioning] &lt;none&gt", "content": "Geoff says:\nEncapsulation is preventing you from seeing the implementation.  That\nis exactly what an IETF protocol does ... you can only see and use the\npublic parts (which are the methods and properties defined by the\nprotocol).  A public property is as much a part of the type signature\nas a public method.  All we are saying is that we should be using type\nsignature equivalence, rather than type name equivalence, since HTTP\ndoes not provide a \"subtype declaration\" mechanism, but the versioning\nprotocol has defined a type signature exposure mechanism\n(DAV:supported-method-set and DAV:supported-live-property-set).\n\nEncapsulation can also be used to suppress detail and provide higher level \nabstractions to reduce complexity for some client classes. I agree a \nprotocol does present an encapsulation of a server's services in a \nstandard way. What we're talking about here is encapsulating the details \nof the protocol itself - we're up a meta-level. HTTP doesn't provide a \nsubtype declaration mechanism, but WebDAV does - DAV:resourcetype. I think \nsome of us would just like to be able to use it to hide the details and \nname the things in the protocol the way we name them in the specification. \nThis, ideally, shouldn't have to be discovered through introspection as it \nrequires the introspector to know protocol details that might better be \nhandled by the server. Its a many-to-one thing for complexity management. \nYou have one server doing the work instead of many clients.\n\n\n\n", "id": "lists-006-2845428"}, {"subject": "Not missing the precurso", "content": "\"Jim Amsden\" <jamsden@us.ibm.com> wrote:\n> I guess I agree with John. This sort of information is generally kept in \n> comments or application specific properties. The question we have to ask \n> ourselves is if there is any need to have precursor information available \n> in an interoperable way. I don't know off the top of my head any other \n> system that supports this, but it could be something I just never used.\nIMHO the precursor set isn't worth the trouble.\nIn the past I worked a lot with source code in RCS. When I had the need to take\nsomething form another version history I normally dropped most of the old\nversions history ($Log$) and added a comment which explained the rationale for\nthe starting a new version history.\nI guess even with precursor information you would need to do some explaining.\nAnd with subsequent further changes the information from which foreign version\nthe resource came looses it's value. As long as the other version history still\nexists you can easily go back and find the precursor version by some poking\naround and diffing. This seems accectable to me because I see it as a rare\nevent.\nSo I wouldn't miss the precursor set.\n\nCheers, Edgar\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-2853734"}, {"subject": "Re (2): Last Call for DAV:checked-out-vcr Proposa", "content": "johnhall@evergo.net wrote:\n> In my system I have no problem tracking moves, but it isn't my\n> objective.  My objective is having a CHECKIN of the working resource\n> update the VCR.  That isn't a 'gee it would be nice to have' request.\n> It is far more important to me than that.  Lack of such a feature would\n> be quite painful.\nI guess you want the feature you get in RCS with 'ci -u <filename>'.\nIf that's basically what you want then I wholeheartedly agree. That's\nat least my default usecase while creating new versions. I just hope I didn't\nmiss something :-)\n\nCheers, Edgar\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-2861816"}, {"subject": "RE: Deleting version", "content": "If a DeltaV server is also a DAV level 2 server (supports LOCK and \nUNLOCK), then it has to handle lock null resources - meaning it is \npossible to lock a null resource to create a lock null resource. In the \nspirit of RFC2518, we should allow all resource creation methods \n(MKWORKSPACE, MKACTIVITY, etc.) to operate successfully on a lock null \nresource converting them to the indicated resource type. That doesn't mean \nthat all DeltaV methods have to operate on lock null resources. As with \nRFRC2518, we have to treat each one as a special case.\n\n\n\n\n\n\"Clemm, Geoff\" <gclemm@rational.com>\nSent by: ietf-dav-versioning-request@w3.org\n06/06/2001 11:07 AM\n\n \n        To:     DeltaV <ietf-dav-versioning@w3.org>\n        cc: \n        Subject:        RE: Deleting versions\n\n \n\nI agree that if a client is likely to get disconnected\nin the middle of its MKWORKSPACE/LOCK request sequence, and if a server\nlets you change the ACL's on a workspace but does not let\nyou create a workspace, and if a workspace can have its ACL's\nupdated by anyone other than the owner, then there is a use\ncase for issuing a MKWORKSPACE against a lock null resource.\n\nBut as you said earlier, RFC 2518 only constrains what HTTP\nand DAV methods can be applied to a lock null resource,\nso a compliant DelataV server can support this use case if it wishes.\nWe can't say it MUST support this use case, since a DeltaV\nserver is not required to support lock null resources at all.\n\nCheers,\nGeoff \n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Tuesday, June 05, 2001 7:43 PM\nTo: Clemm, Geoff; DeltaV\nSubject: RE: Deleting versions\n\n\nThe problem is that the \"client that got there before them\" may have\npermission to alter a workspace, but they may NOT have permission to \nCREATE\na workspace.\n\nThe problem is not that the other client locked it, but that they might\napply changes before you get a chance to prevent them!  I create a \nWorkspace\n(or a resource, or a collection).  I want to then set the ACLs so that I'm\nthe only one that can alter this resource, because it's MINE.  But, in\nbetween the MKWORKSPACE and the subsequent LOCK, the other client comes in\nand sets ACLs so that they can write the workspace and I can't!  Ouch.\n\nNull resource went through similar discussions, and was kept for reasons\nwhich apply to MKWORKSPACE the same way they apply to PUT, MKCOL.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Tuesday, June 05, 2001 3:48 PM\n> To: DeltaV\n> Subject: RE: Deleting versions\n>\n>\n>    From: Lisa Dusseault [mailto:lisa@xythos.com]\n>\n>    If somebody who's not supposed to, gets in and changes something in\n>    between a MKWORKSPACE command and a ACL request, that's a serious\n>    problem.  Null resources help avoid that.\n>\n>    It's not that somebody got their MKWORKSPACE request in ahead of\n>    mine --that's not the purpose of null resources at all.\n>\n> My point was not that a lock can prevent somebody from\n> creating the workspace ahead of you, but rather that\n> someone locking \"your\" workspace is no different from\n> someone creating a workspace by that name before you\n> can lock that URL.\n>\n> In particular, we are discussing two alternative sequences:\n>  LOCK/MKWORKSPACE/ACL/UNLOCK\n> or\n>  MKWORKSPACE/LOCK/ACL/UNLOCK\n>\n> In the first sequence, the LOCK may fail (because there already\n> is a lock on that URL), so you tell the user \"that workspace is\n> already in use by another user\".\n>\n> In the second sequence, either the MKWORKSPACE may fail (because\n> somebody got in and created a workspace before you) or the LOCK\n> may fail (because somebody got in and locked the workspace before\n> you).  In either case, you still tell the user \"that workspace is\n> already in use by another user\".\n>\n> So from the user's perspective, it doesn't matter whether\n> or not their client did a LOCK/MKWORKSPACE or a\n> MKWORKSPACE/LOCK.  Their request can fail because another\n> client \"got there before them\".\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-2870045"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and  DAV:ba seline  resource type value", "content": "Geoff says:\n>>But I do care in general that DeltaV (and in general WebDAV)\nprotocols be designed to encourage good client design, and\nit seems to me that there is a basic lesson from programming\nlanguage design (i.e. that typeless languages are more suited\nto environments where clients and servers get changed)\nthat is being ignored in this drive to extend DAV:resourcetype.<<\n\nJust to clarify, Smalltalk in not a typeless language, it is strongly \ntyped, but employes dynamic typing. That is, it determines the type of a \nclass at runtime rather than compile  time. Such late binding provides \nextra flexibility in the language at some cost in performance. In any \ncase, such types are named and described with meta-classes in Smalltalk. \nImagine using the Smalltalk class libraries without class names!\n\n\n\n", "id": "lists-006-2882845"}, {"subject": "Re: Actually, you don't need COPY or MOVE, what you really   seem to want is  CLONE", "content": "I agree with the group that there are other ways to track relationships \nbetween version histories. If this is the only use case for the \nprecursor-set and the consensus of the group is it should be dropped, I'm \nokay with this decision.\n\nI understand what a variant is however I don't fully understand how the \nprecursor-set is used to create one in a workspace. If that is how variants \nare created then I recommend the precursor-set be kept and moved from the \nversion-control feature into the workspace feature.\n\nAt 10:34 AM 6/19/01 -0400, Jim Amsden wrote:\n>I guess I agree with John. This sort of information is generally kept in\n>comments or application specific properties. The question we have to ask\n>ourselves is if there is any need to have precursor information available\n>in an interoperable way. I don't know off the top of my head any other\n>system that supports this, but it could be something I just never used.\n>\n>I also agree with Geoff in that there are good arguments either way.\n>However I'd lean in the direction of leaving things out if there is any\n>doubt. They can always be added in later when we have more experience and\n>the use cases are more crisp. We don't want to hold up the protocol on\n>such issues either if we can help it.\n>\n>\n>\n>\n>I still can't see where it is useful to know about two different version\n>histories, one that you have poor information on (the source of the\n>COPY) and an old version history that is no longer relevent to the\n>actual content (since you overlayed it).\n>\n>\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of John Hall\n> > Sent: Monday, June 18, 2001 8:30 PM\n> > To: 'Rick Rupp'; ietf-dav-versioning@w3.org\n> > Subject: RE: [ietf-dav-versioning] <none>\n> >\n> >\n> > I disagree.\n> >\n> > I see no difference between creating a new version from\n> > scratch and copying data from somewhere else to create a new\n> > version from scratch. If I open file1 and then do a save-as\n> > on file2, the server doesn't know and precussor isn't set in\n> > any case.  So why is it so important to know that someone\n> > grabbed a copy of file1's current version and copied it to\n> > file2 without editing it first?  If you really want the\n> > version history, use MOVE not COPY.\n> >\n> > Do you have a 'for example' use case where that origin\n> > information is valuable?  And would it still remain valuable\n> > after a few more edits were done?\n> >\n> >\n> >\n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Rick Rupp\n> > > Sent: Monday, June 18, 2001 5:39 PM\n> > > To: ietf-dav-versioning@w3.org\n> > > Subject: [ietf-dav-versioning] <none>\n> > >\n> > >\n> > > The precursor-set property seems to be an important concept\n> > > of a versions\n> > > history. Without it there is no indication that a version has a\n> > > relationship to another version history.\n> > >\n> > > I don't think it will be unusual for a client to create a new\n> > > version by\n> > > copying from a different version history. Will it be\n> > > important to know the\n> > > new version came from a different version history? I think\n> > > the answer is\n> > > yes and the precursor-set facilitates this.\n> > >\n> > >\n> > >\n> >\n> >\n> >\n\n\n\n", "id": "lists-006-2891500"}, {"subject": "Re: Last Call for DAV:checked-out-vcr Proposa", "content": "I don't mind if it is added.\n\nI also agree with the comment Mark made about getting a draft specification \nnailed down. We need this soon.\n\nAt 06:02 AM 6/19/01 -0700, Mark A. Hale wrote:\n>'I don't mind if it is added'\n>\n>I do support your comment that additions like this only continue to add to \n>the\n>complexity of the protocol, however useful they may be.  I think it is \n>fair to\n>say that a draft specification really needs to be nailed down soon and that\n>additional features like DAV:checked-out-vcr be added in the next version of\n>the specification.\n>\n>      Thanks,\n>\n>      Mark\n>\n>\n>\n>Quoting \"Clemm, Geoff\" <gclemm@rational.com>:\n>\n> > The DAV:checked-out-vcr property addresses the use case where a\n> > working resource has been created for the purpose of updating a\n> > VCR, and then that VCR has been moved while the working resource\n> > was checked-out.  Since the client cannot easily track the\n> > movement of the VCR, the DAV:checked-out-vcr property provides\n> > functionality that cannot be achieved by the current protocol\n> > for the client-workspace package (the server-workspace package\n> > does not have this problem, since it does not support working\n> > resources).\n> >\n> > Does anyone object to adding this functionality?  I am ambivalent,\n> > in that I would prefer to not add functionality to the protocol\n> > (it's already complex enough), but this is useful, consistent\n> > functionality that does not present any interoperability issues.\n> > I'd like a few more \"yes, add it in\" or at least \"I don't mind if it\n> > is added\" comments from the working group before making this addition.\n> >\n> > As a reminder, the proposed additions to the protocol are:\n> >\n> > Add a protected DAV:checked-out-vcr property for a working resource.\n> > Set this property on the working resource created when a CHECKOUT with\n> > the DAV:apply-to-version flag is applied to a VCR.  Add a\n> > postcondition to \"CHECKIN\" of a working resource that says that if\n> > there is a DAV:checked-out-VCR on the working resource, the specified\n> > VCR will automatically be updated to reflect the content and dead\n> > properties of the new version.  Add a postcondition to \"MOVE\" of a VCR\n> > that says that if there is a DAV:checked-out-VCR that identifies that\n> > VCR, that property is updated to reflect the new location of the VCR.\n> >\n> > Cheers,\n> > Geoff\n> >\n\n\n\n", "id": "lists-006-2904889"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and  DAV:ba seline  resource type value", "content": "By \"typeless\", I meant that you do not declare the type of a\nvariable in a Smalltalk routine.  You just apply a method to it, and\nif that method is not supported by that object, then you get\na runtime error.\n\nSo the analogy is that just as it is bad form in a Smalltalk\nroutine to ask an object \"are you of type xxx\", it is bad\nform in a HTTP client to ask a resource \"are you of resourcetype\nxxx\".\n\nBut this is just an analogy, and HTTP is not Smalltalk, so\neven if we agreed that the analogy is valid, it really wouldn't\nanswer the question, so please forgive my playing analogy games\nin the first place.  And if anyone choses to continue this\nanalogy, I promise not to respond (:-).\n\nBut if someone has something specific and concrete that you\ncould do by inspecting the value of DAV:resourcetype that you\ncould not do by inspecting the values of DAV:supported-method-set\nand DAV:supported-live-property-set, I would be interested.\n\nNote that I did not see enough support (or any support, for\nthat matter :-) in the working group\nfor removing DAV:activity, DAV:version-history, or DAV:baseline,\nso I am assuming that they stay unless there is a sudden\ngroundswell of support for taking them out.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Amsden [mailto:jamsden@us.ibm.com]\nSent: Tuesday, June 19, 2001 5:25 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Removing the DAV:activity and DAV:version-history and\nDAV:ba seline resource type values\n\n\nGeoff says:\n>>But I do care in general that DeltaV (and in general WebDAV)\nprotocols be designed to encourage good client design, and\nit seems to me that there is a basic lesson from programming\nlanguage design (i.e. that typeless languages are more suited\nto environments where clients and servers get changed)\nthat is being ignored in this drive to extend DAV:resourcetype.<<\n\nJust to clarify, Smalltalk in not a typeless language, it is strongly \ntyped, but employes dynamic typing. That is, it determines the type of a \nclass at runtime rather than compile  time. Such late binding provides \nextra flexibility in the language at some cost in performance. In any \ncase, such types are named and described with meta-classes in Smalltalk. \nImagine using the Smalltalk class libraries without class names!\n\n\n\n", "id": "lists-006-2915611"}, {"subject": "RE: Actually, you don't need COPY or MOVE, what you really   seem  to want is  CLONE", "content": "Actually, I shouldn't have used the word \"variant\" since that has a\nspecific HTTP meaning (an alternative form of a resource content,\nsuch as another language), and I was using it to mean \"a resource that\nwill have a separate version history, but which is based on a version\nfrom another version history\".\n\nI think the working group consensus is to just get rid of it until\nit gets more support, so unless you are strongly attached to it,\nI'd like to resolve this particular issue by pulling DAV:precursor-set\nfrom the protocol.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Rick Rupp [mailto:rick.rupp@merant.com]\nSent: Tuesday, June 19, 2001 8:08 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: Actually, you don't need COPY or MOVE, what you really seem\nto want is CLONE.\n\n\nI agree with the group that there are other ways to track relationships \nbetween version histories. If this is the only use case for the \nprecursor-set and the consensus of the group is it should be dropped, I'm \nokay with this decision.\n\nI understand what a variant is however I don't fully understand how the \nprecursor-set is used to create one in a workspace. If that is how variants \nare created then I recommend the precursor-set be kept and moved from the \nversion-control feature into the workspace feature.\n\nAt 10:34 AM 6/19/01 -0400, Jim Amsden wrote:\n>I guess I agree with John. This sort of information is generally kept in\n>comments or application specific properties. The question we have to ask\n>ourselves is if there is any need to have precursor information available\n>in an interoperable way. I don't know off the top of my head any other\n>system that supports this, but it could be something I just never used.\n>\n>I also agree with Geoff in that there are good arguments either way.\n>However I'd lean in the direction of leaving things out if there is any\n>doubt. They can always be added in later when we have more experience and\n>the use cases are more crisp. We don't want to hold up the protocol on\n>such issues either if we can help it.\n>\n>\n>\n>\n>I still can't see where it is useful to know about two different version\n>histories, one that you have poor information on (the source of the\n>COPY) and an old version history that is no longer relevent to the\n>actual content (since you overlayed it).\n>\n>\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of John Hall\n> > Sent: Monday, June 18, 2001 8:30 PM\n> > To: 'Rick Rupp'; ietf-dav-versioning@w3.org\n> > Subject: RE: [ietf-dav-versioning] <none>\n> >\n> >\n> > I disagree.\n> >\n> > I see no difference between creating a new version from\n> > scratch and copying data from somewhere else to create a new\n> > version from scratch. If I open file1 and then do a save-as\n> > on file2, the server doesn't know and precussor isn't set in\n> > any case.  So why is it so important to know that someone\n> > grabbed a copy of file1's current version and copied it to\n> > file2 without editing it first?  If you really want the\n> > version history, use MOVE not COPY.\n> >\n> > Do you have a 'for example' use case where that origin\n> > information is valuable?  And would it still remain valuable\n> > after a few more edits were done?\n> >\n> >\n> >\n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Rick Rupp\n> > > Sent: Monday, June 18, 2001 5:39 PM\n> > > To: ietf-dav-versioning@w3.org\n> > > Subject: [ietf-dav-versioning] <none>\n> > >\n> > >\n> > > The precursor-set property seems to be an important concept\n> > > of a versions\n> > > history. Without it there is no indication that a version has a\n> > > relationship to another version history.\n> > >\n> > > I don't think it will be unusual for a client to create a new\n> > > version by\n> > > copying from a different version history. Will it be\n> > > important to know the\n> > > new version came from a different version history? I think\n> > > the answer is\n> > > yes and the precursor-set facilitates this.\n> > >\n> > >\n> > >\n> >\n> >\n> >\n\n\n\n", "id": "lists-006-2926090"}, {"subject": "AW: [ietf-dav-versioning] &lt;none&gt", "content": "> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n> \n>    > From: Jim Amsden [mailto:jamsden@us.ibm.com]\n>    > 2) the difficulty clients will have in determining the\n>    > type of the resource - they have to know the property\n>    > semantics instead of relying on the server to hide these\n>    > semantics,\n> \n>    From: Tim Ellison\n>    No, they just need to look and see if the properties and/or methods\n>    are supported to correctly type the resource.  The latest draft of\n>    the spec has an appendix that spells this out.\n> \n> \n>    From: Jim Amsden\n> \n>    The \"semantics\" I referred to above is checking for the existence\n>    of some set of properties.\n> \n> Just to be precise, the check is for whether the properties\n> are supported, not whether or not they exist (i.e. a resource\n> can support a property even if the property does not currently\n> exist on that resource).\n\nI knew I had not fully understood this. :(\n\nThe spec is silent about what a \"supported\" property is compared\nto an \"existing\" property. \n\nGeoff, could you define exectly when a property is part of\nthe supported-live-property-set?\n\nIs there a newer working draft than 15.1? Where can I get it?\n\nStefan\n\n\n\n", "id": "lists-006-2941186"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and  DAV:ba seline   resource type value", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n\n> Note that I did not see enough support (or any support,\n> for that matter :-) in the working group for removing\n> DAV:activity, DAV:version-history, or DAV:baseline,\n> so I am assuming that they stay unless there is a sudden\n> groundswell of support for taking them out.\n\nI support taking them out.  We don't need them.\n\nTim\n\n\n\n", "id": "lists-006-2950524"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "John Hall wrote:\n> In my system I have no problem tracking moves, but it isn't my\n> objective.  My objective is having a CHECKIN of the working resource\n> update the VCR.  That isn't a 'gee it would be nice to have' request.\n> It is far more important to me than that.  Lack of such a feature would\n> be quite painful.\n\nI think you may have said this already, so apologies if you did.  Instead of\na new property on a working resource that tracks MOVEs (which I think will\nbe hard to implement on distributed systems), how about a new CHECKIN option\nto do the checkin and version-controlled resource update atomically with a\nspecific error condition if either cannot be achieved?\n\nI'd be happier with that.\n\nTim\n\n\n\n", "id": "lists-006-2958512"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "If we are going to add a protocol element for allowing a CHECKIN\nof a working resource to update a VCR, it would seem appropriate\nto define this in a way that is friendly to clients (i.e. they\nare not required to \"LOCK\" the VCR namespace, and they are not\nat risk of being told \"sorry, that VCR you wanted to update is somewhere\nelse,\nbut I won't tell you where\".\n\nI don't buy the \"hard to implement\" argument, since anyone who is\nimplementing a distributed versioning system will have to deal with\nfar more difficult implementation issues than reliably associating\nworking resources with version-controlled resources.  And for the\ncommon case (where the working resources and the version-controlled\nresources are on the same server), it is not hard for the *server*\nto track these moves, but it is very hard for the *client* to track\nthese moves, which is why the server should be required to do so.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim Ellison [mailto:tim@peir.com]\nSent: Wednesday, June 20, 2001 9:46 AM\nTo: 'DeltaV (E-mail)'\nSubject: RE: Last Call for DAV:checked-out-vcr Proposal\n\n\nJohn Hall wrote:\n> In my system I have no problem tracking moves, but it isn't my\n> objective.  My objective is having a CHECKIN of the working resource\n> update the VCR.  That isn't a 'gee it would be nice to have' request.\n> It is far more important to me than that.  Lack of such a feature would\n> be quite painful.\n\nI think you may have said this already, so apologies if you did.  Instead of\na new property on a working resource that tracks MOVEs (which I think will\nbe hard to implement on distributed systems), how about a new CHECKIN option\nto do the checkin and version-controlled resource update atomically with a\nspecific error condition if either cannot be achieved?\n\nI'd be happier with that.\n\nTim\n\n\n\n", "id": "lists-006-2966660"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "Geoff Clemm wrote:\n\n> If we are going to add a protocol element for allowing a CHECKIN\n> of a working resource to update a VCR, it would seem appropriate\n> to define this in a way that is friendly to clients (i.e. they\n> are not required to \"LOCK\" the VCR namespace,\n\nThis would be the pessimistic approach, to prevent the MOVE.\n\n> and they are not at risk of being told \"sorry, that VCR you\n> wanted to update is somewhere else, but I won't tell you where\".\n\nThat is going to occur anyway with an explicit UPDATE of a\nversion-controlled resource.\n\n> I don't buy the \"hard to implement\" argument, since anyone who is\n> implementing a distributed versioning system will have to deal with\n> far more difficult implementation issues than reliably associating\n> working resources with version-controlled resources.\n\nThat argument has already been debunked (by Greg and others with their\nhigh-jumping analogies :-)\n\n> And for the common case (where the working resources and the\n> version-controlled resources are on the same server), it is not\n> hard for the *server* to track these moves,\n\nOn what basis do you say this?  We have no other examples of the server\nbeing required to track resource MOVEs and I believe that it will require\nsubstantial housekeeping for a number of implementations to do this.\n\n> but it is very hard for the *client* to track these moves,\n> which is why the server should be required to do so.\n\nI'm not suggesting the client track them either.  I think the client should\nbe pessimistic or be prepared to deal with the consequences (as for all\nother MOVE scenarios).\n\nTim\n\n\n\n", "id": "lists-006-2976291"}, {"subject": "RE: Actually, you don't need COPY or MOVE, what you really     seem  to want is  CLONE", "content": "Lets move forward and remove it from the protocol.\n\nAt 11:59 PM 6/19/01 -0400, Clemm, Geoff wrote:\n>Actually, I shouldn't have used the word \"variant\" since that has a\n>specific HTTP meaning (an alternative form of a resource content,\n>such as another language), and I was using it to mean \"a resource that\n>will have a separate version history, but which is based on a version\n>from another version history\".\n>\n>I think the working group consensus is to just get rid of it until\n>it gets more support, so unless you are strongly attached to it,\n>I'd like to resolve this particular issue by pulling DAV:precursor-set\n>from the protocol.\n>\n>Cheers,\n>Geoff\n>\n>-----Original Message-----\n>From: Rick Rupp [mailto:rick.rupp@merant.com]\n>Sent: Tuesday, June 19, 2001 8:08 PM\n>To: ietf-dav-versioning@w3.org\n>Subject: Re: Actually, you don't need COPY or MOVE, what you really seem\n>to want is CLONE.\n>\n>\n>I agree with the group that there are other ways to track relationships\n>between version histories. If this is the only use case for the\n>precursor-set and the consensus of the group is it should be dropped, I'm\n>okay with this decision.\n>\n>I understand what a variant is however I don't fully understand how the\n>precursor-set is used to create one in a workspace. If that is how variants\n>are created then I recommend the precursor-set be kept and moved from the\n>version-control feature into the workspace feature.\n>\n>At 10:34 AM 6/19/01 -0400, Jim Amsden wrote:\n> >I guess I agree with John. This sort of information is generally kept in\n> >comments or application specific properties. The question we have to ask\n> >ourselves is if there is any need to have precursor information available\n> >in an interoperable way. I don't know off the top of my head any other\n> >system that supports this, but it could be something I just never used.\n> >\n> >I also agree with Geoff in that there are good arguments either way.\n> >However I'd lean in the direction of leaving things out if there is any\n> >doubt. They can always be added in later when we have more experience and\n> >the use cases are more crisp. We don't want to hold up the protocol on\n> >such issues either if we can help it.\n> >\n> >\n> >\n> >\n> >I still can't see where it is useful to know about two different version\n> >histories, one that you have poor information on (the source of the\n> >COPY) and an old version history that is no longer relevent to the\n> >actual content (since you overlayed it).\n> >\n> >\n> >\n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of John Hall\n> > > Sent: Monday, June 18, 2001 8:30 PM\n> > > To: 'Rick Rupp'; ietf-dav-versioning@w3.org\n> > > Subject: RE: [ietf-dav-versioning] <none>\n> > >\n> > >\n> > > I disagree.\n> > >\n> > > I see no difference between creating a new version from\n> > > scratch and copying data from somewhere else to create a new\n> > > version from scratch. If I open file1 and then do a save-as\n> > > on file2, the server doesn't know and precussor isn't set in\n> > > any case.  So why is it so important to know that someone\n> > > grabbed a copy of file1's current version and copied it to\n> > > file2 without editing it first?  If you really want the\n> > > version history, use MOVE not COPY.\n> > >\n> > > Do you have a 'for example' use case where that origin\n> > > information is valuable?  And would it still remain valuable\n> > > after a few more edits were done?\n> > >\n> > >\n> > >\n> > > > -----Original Message-----\n> > > > From: ietf-dav-versioning-request@w3.org\n> > > > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Rick Rupp\n> > > > Sent: Monday, June 18, 2001 5:39 PM\n> > > > To: ietf-dav-versioning@w3.org\n> > > > Subject: [ietf-dav-versioning] <none>\n> > > >\n> > > >\n> > > > The precursor-set property seems to be an important concept\n> > > > of a versions\n> > > > history. Without it there is no indication that a version has a\n> > > > relationship to another version history.\n> > > >\n> > > > I don't think it will be unusual for a client to create a new\n> > > > version by\n> > > > copying from a different version history. Will it be\n> > > > important to know the\n> > > > new version came from a different version history? I think\n> > > > the answer is\n> > > > yes and the precursor-set facilitates this.\n> > > >\n> > > >\n> > > >\n> > >\n> > >\n> > >\n\n\n\n", "id": "lists-006-2985117"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "   From: Tim Ellison [mailto:tim@peir.com]\n\n   Geoff Clemm wrote:\n\n   > If we are going to add a protocol element for allowing a CHECKIN\n   > of a working resource to update a VCR, it would seem appropriate\n   > to define this in a way that is friendly to clients (i.e. they\n   > are not required to \"LOCK\" the VCR namespace,\n\n   This would be the pessimistic approach, to prevent the MOVE.\n\nOne of the key motivators for the versioning protocol is to\nallow parallel development, as opposed to single threading\nvia LOCKs.  A working resource gives you a stable URL to do\nyour editing against, which means that a namespace lock should\nnot be necessary for you get your information back to the server.\n\n   > and they are not at risk of being told \"sorry, that VCR you\n   > wanted to update is somewhere else, but I won't tell you where\".\n\n   That is going to occur anyway with an explicit UPDATE of a\n   version-controlled resource.\n\nAn UPDATE to a VCR does not move that VCR somewhere else (it still has\nthe same URL).  But that's beside the point ... which is that whatever\noperation may have caused the VCR to be found under a new URL, the\nserver can much more easily track which VCR is associated with the\nworking resource than the client can.\n\n   > I don't buy the \"hard to implement\" argument, since anyone who is\n   > implementing a distributed versioning system will have to deal with\n   > far more difficult implementation issues than reliably associating\n   > working resources with version-controlled resources.\n\n   That argument has already been debunked (by Greg and others with their\n   high-jumping analogies :-)\n\nWas that the high-jumping analogy that was used to explain why\na client shouldn't have to do a subset operation?  As I recall,\nyou found that a less than compelling counter-argument (:-).\n\nIn any case, the point was not that \"those servers are hard to write,\nand therefore it is OK to make them do other hard things\", but rather\nthat \"a distributed versioning server will have to keep track of many\nrelationships between resources on the different servers (e.g. all the\nversion-to-version relationships), and therefore an additional\nrelationship to track does not obviously add to the implementation\nburden of such a server\".\n\nSo I'm not saying you are wrong, but that you have not made your case.\nFor example, can you point to a versioning server today (that supports\nthe equivalent of working resources) for which tracking this\nrelationship would be a problem?  I'm not saying there aren't any, but\njust that something concrete here would be more convincing.\n\n   > And for the common case (where the working resources and the\n   > version-controlled resources are on the same server), it is not\n   > hard for the *server* to track these moves,\n\n   On what basis do you say this?  We have no other examples of the\n   server being required to track resource MOVEs and I believe that it\n   will require substantial housekeeping for a number of\n   implementations to do this.\n\nLook at the MOVE request postconditions in 6.6 and 13.9.\n\n   > but it is very hard for the *client* to track these moves,\n   > which is why the server should be required to do so.\n\n   I'm not suggesting the client track them either.  I think the\n   client should be pessimistic or be prepared to deal with the\n   consequences (as for all other MOVE scenarios).\n\nWhat did you have in mind for the client to deal with\nthe consequences?  Tell the user to go find out where\nthat VCR ended up on the server?\n\nThe point here is that a natural semantics of the proposed\nprotocol extension would solve this use case, so it would\nbe good to see a convincing argument for why we should not\ndo so (if we are going to pay the cost of introducing a\nnew protocol element to handle the \"vcr updated by working\nresource checkin\" scenario).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3001041"}, {"subject": "CHECKIN to update a VCR ..", "content": "First, to reiterate, this is a very important feature to me (CHECKIN of\nworking copy to update a VCR).  I'm willing to accept almost any\nsolution that accomplishes that goal.  Note that on my server this is\nthe only CHECKIN of a working copy that is allowed.  \n\nI thought that Geoff's proposal to have the VCR address be updated in\nthe CHECKIN to be quite sensible, and I didn't mind tracking the VCR\neven if it was moved.  Probably because that was easy for my\nimplementation to do.\n\nHowever, Geoff's proposal said that I had to let the client modify the\ncontents of this property.  That means that I have to deal with the case\nwhere the client specifies a bad value (I need an error either on the\nPROPFIND or the CHECKIN.  If I prohibit the bad value from being set the\nerror is on PROPFIND.  If the bad value is set, then an error may occur\non the CHECKIN and update VCR where it won't work.).\n\nIf I had written the proposal, I'd have made the new property\n\"apply-to-VCR\" removable but not client modifiable.  That way everyone\nknows that the field either exists and is valid or doesn't exist.\n\nI would also have considered having the element apply-to-version sent on\nthe CHECKIN rather than the CHECKOUT (which means \"apply-to-VCR\" would\nalways be set).  But that is a nit.  I'm happy with it on the CHECKOUT.\n\nSo my full proposal, based on Geoff's, would be:\n\nCHECKOUT postcondition:\nIf CHECKOUT is sent with the \"apply-to-version\" element, then the\nworking copy will have \"apply-to-VCR href-of-VCR\" set.\n\nIf \"apply-to-VCR\" is set, then this field will be updated if the VCR is\nmoved.  (You could let the server refuse to move such a VCR but I'm\nassuming that is a non-starter).\n\n\"apply-to-VCR\" may be removed by a client, but not modified.\n\nCHECKIN poscondition:\nA CHECKIN of a working copy with the \"apply-to-VCR\" property set will\nupdate the VCR associated with the working copy.  If this isn't\npossible, an error \"FILL-IN-HERE\" is generated if this isn't possible.\n\nA CHECKIN of a working copy without \"apply-to-VCR\" set when the working\ncopy can not be used to update a VCR will fail with the error\n\"DAV:update-of-vcr-impossible\".  (Well, I thought I'd ask.  Our server\nwill fail such a checkin.  The only question is the error code that gets\nkicked back.)\n\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> Sent: Wednesday, June 20, 2001 7:25 AM\n> To: 'DeltaV (E-mail)'\n> Subject: RE: Last Call for DAV:checked-out-vcr Proposal\n> \n> \n> If we are going to add a protocol element for allowing a \n> CHECKIN of a working resource to update a VCR, it would seem \n> appropriate to define this in a way that is friendly to \n> clients (i.e. they are not required to \"LOCK\" the VCR \n> namespace, and they are not at risk of being told \"sorry, \n> that VCR you wanted to update is somewhere else, but I won't \n> tell you where\".\n> \n> I don't buy the \"hard to implement\" argument, since anyone \n> who is implementing a distributed versioning system will have \n> to deal with far more difficult implementation issues than \n> reliably associating working resources with \n> version-controlled resources.  And for the common case (where \n> the working resources and the version-controlled resources \n> are on the same server), it is not hard for the *server* to \n> track these moves, but it is very hard for the *client* to \n> track these moves, which is why the server should be required \n> to do so.\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: Tim Ellison [mailto:tim@peir.com]\n> Sent: Wednesday, June 20, 2001 9:46 AM\n> To: 'DeltaV (E-mail)'\n> Subject: RE: Last Call for DAV:checked-out-vcr Proposal\n> \n> \n> John Hall wrote:\n> > In my system I have no problem tracking moves, but it isn't my \n> > objective.  My objective is having a CHECKIN of the working \n> resource \n> > update the VCR.  That isn't a 'gee it would be nice to \n> have' request. \n> > It is far more important to me than that.  Lack of such a feature \n> > would be quite painful.\n> \n> I think you may have said this already, so apologies if you \n> did.  Instead of a new property on a working resource that \n> tracks MOVEs (which I think will be hard to implement on \n> distributed systems), how about a new CHECKIN option to do \n> the checkin and version-controlled resource update atomically \n> with a specific error condition if either cannot be achieved?\n> \n> I'd be happier with that.\n> \n> Tim\n> \n> \n\n\n\n", "id": "lists-006-3012765"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:baselin e  resource type value", "content": "> The reason we can't introduce new resource types for all of the\n> versioning\n> resources is because we have to support down-level clients that only know\n> about DAV:collection. For new resources that down-level clients couldn't\n> possibly know about, workspaces, activities, baselines, etc., we don't\n> have this restriction. I agree with Greg and Tim. We should be as\n> specific\n> as we can about declared type and only compromise when required by\n> interoperability considerations.\n\nI thought we had rather strong guidance that working around bugs in a single\nimplementation was NOT recommended.  Clarification, Jim?\n\nI'd also point out that frequently it will be OK even with buggy clients to\nintroduce new resource types.  For example, I don't suppose it will be that\neasy for non-versioning-aware clients to stumble across URLs of collections\nof version-histories, activities, baselines and workspaces.  Not all of\nthese new resources are even browsable, and they may not appear in any\nregular URL space that regular clients are expected to use.\n\nlisa\n\n\n\n", "id": "lists-006-3025966"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "Geoff wrote:\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: 20 June 2001 18:31\n> To: 'DeltaV (E-mail)'\n> Subject: RE: Last Call for DAV:checked-out-vcr Proposal\n>\n>\n>    From: Tim Ellison [mailto:tim@peir.com]\n>\n>    Geoff Clemm wrote:\n>\n>    > If we are going to add a protocol element for allowing a CHECKIN\n>    > of a working resource to update a VCR, it would seem appropriate\n>    > to define this in a way that is friendly to clients (i.e. they\n>    > are not required to \"LOCK\" the VCR namespace,\n>\n>    This would be the pessimistic approach, to prevent the MOVE.\n>\n> One of the key motivators for the versioning protocol is to\n> allow parallel development, as opposed to single threading\n> via LOCKs.  A working resource gives you a stable URL to do\n> your editing against, which means that a namespace lock should\n> not be necessary for you get your information back to the server.\n\nI'm merely pointing out that in the face of MOVEs you are required to use\nLOCKs to ensure people do not rearrange the namespace under your feet.  This\nis as true today for in-place-checkout as it will be tomorrow with\nCHECKIN&UPDATE.  It will therefore not inhibit parallel development any more\nthan it is inhibited already.\n\nJust to be clear, if I do an in-place checkout of a version-controlled\nresource, and you MOVE it, then my subsequent PUTs will fail and I will have\nno indication of where the version-controlled resource was MOVEd.  If I want\nto prevent that I must be pessimistic and LOCK the version-controlled\nresource.\n\nI suggest that we provide the operation John requested -- that is a CHECK-IN\noption to update a given version-controlled resource (referenced by its\nURL).  If clients do not want that operation to fail due to the\nversion-controlled resource being MOVEd then they must LOCK the\nversion-controlled resource.\n\n>    > and they are not at risk of being told \"sorry, that VCR you\n>    > wanted to update is somewhere else, but I won't tell you where\".\n>\n>    That is going to occur anyway with an explicit UPDATE of a\n>    version-controlled resource.\n>\n> An UPDATE to a VCR does not move that VCR somewhere else (it still has\n> the same URL).\n\nSorry, I didn't mean that will occur because of an UPDATE, rather that that\nsituation will occur when clients attempt an UPDATE of a URL that has been\nMOVEd by another client.  They *will* be told  \"sorry, that VCR you wanted\nto update is somewhere else, but I won't tell you where\"\n\n> But that's beside the point ... which is that whatever\n> operation may have caused the VCR to be found under a new URL, the\n> server can much more easily track which VCR is associated with the\n> working resource than the client can.\n>\n>    > I don't buy the \"hard to implement\" argument, since anyone who is\n>    > implementing a distributed versioning system will have to deal with\n>    > far more difficult implementation issues than reliably associating\n>    > working resources with version-controlled resources.\n>\n>    That argument has already been debunked (by Greg and others with their\n>    high-jumping analogies :-)\n>\n> Was that the high-jumping analogy that was used to explain why\n> a client shouldn't have to do a subset operation?  As I recall,\n> you found that a less than compelling counter-argument (:-).\n\n<g> Just because I found it unconvincing doesn't mean that I can't use it on\nyou and that _you_ also will be unconvinced! <g> (if you can follow all\nthose negatives :->\n\n> In any case, the point was not that \"those servers are hard to write,\n> and therefore it is OK to make them do other hard things\", but rather\n> that \"a distributed versioning server will have to keep track of many\n> relationships between resources on the different servers (e.g. all the\n> version-to-version relationships),\n\nVersions cannot MOVE.\n\n> and therefore an additional\n> relationship to track does not obviously add to the implementation\n> burden of such a server\".\n\nIts the nature of the relationship that is different.  Relationships between\nserver defined URLs will likely be easier than those involving user-defined\nURLs since the server has ultimate control over that namespace.\n\n> So I'm not saying you are wrong, but that you have not made your case.\n> For example, can you point to a versioning server today (that supports\n> the equivalent of working resources) for which tracking this\n> relationship would be a problem?\n\nYes.  {At this stage you have to imagine me pointing}\n\n> I'm not saying there aren't any, but\n> just that something concrete here would be more convincing.\n>\n>    > And for the common case (where the working resources and the\n>    > version-controlled resources are on the same server), it is not\n>    > hard for the *server* to track these moves,\n>\n>    On what basis do you say this?  We have no other examples of the\n>    server being required to track resource MOVEs and I believe that it\n>    will require substantial housekeeping for a number of\n>    implementations to do this.\n>\n> Look at the MOVE request postconditions in 6.6 and 13.9.\n\n<cough>\nWell, 6.6 is easily explained in terms of workspace containment, so that's a\ndifferent kind of beast.\n\n13.9 is going to be a real pain to people.\n\n>    > but it is very hard for the *client* to track these moves,\n>    > which is why the server should be required to do so.\n>\n>    I'm not suggesting the client track them either.  I think the\n>    client should be pessimistic or be prepared to deal with the\n>    consequences (as for all other MOVE scenarios).\n>\n> What did you have in mind for the client to deal with\n> the consequences?  Tell the user to go find out where\n> that VCR ended up on the server?\n\nI'll tell them to follow the same logic that they follow when any resource\nMOVEs out from under them.  Panic probably.\n\n> The point here is that a natural semantics of the proposed\n> protocol extension would solve this use case, so it would\n> be good to see a convincing argument for why we should not\n> do so (if we are going to pay the cost of introducing a\n> new protocol element to handle the \"vcr updated by working\n> resource checkin\" scenario).\n\nThe argument is that your way is hard, and it is not what John asked for.\nThe simpler solution that I presented is closer to John's request and is\nconsistent with the existing client and server expectations in the face of\nMOVEs.\n\nTim\n\n\n\n", "id": "lists-006-3035136"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:baselin e   resource type value", "content": "Lisa,\nThis is really a sticky one. On the one hand, we have introduced many new \nresource types in DeltaV, but only defined DAV:resourcetype for some of \nthem, and we know this causes problems for some servers. If we don't use \nDAV:resourcetype, then we don't introduce compatibility problems with DAV \nlevel 1 or 2, and DeltaV servers can interoperate somewhat with DAV \nclients (one of our primary requirements). We're not really just trying to \nsupport existing servers with bugs, but make sure we maintain \ninteroperability. Just providing new resource types isn't enough. We need \nto provide a backward compatible type hierarchy scheme so down-level \nclients can see for example, a baseline as a DAV:collection. We could do \nthis, but it would be another rat-hole, and then there's the problem with \nexisting servers that might not parse the extended XML properly. These are \nof course things we'd like to avoid if we can.\n\nSo we're left with removing our DAV:resourcetypes, and requiring clients \nto introspect supported properties on a resource to figure out the type \nbased on a table in the spec. This works *except* for (sub)types that \ndon't introduce additional properties. Its a little more inconvenient, but \nperhaps won't be that different if we really solved the type hierarchy \nproblem. The end result is that DAV:resourcetype is pretty useless.\n\nGeoff, do we still have a potential problem with the introspection \napproach in cases where new types don't introduce new properties? \nUnfortunately type depends on more than signature, it also depends on \nbehavior, and this isn't captured in the supported properties in all \ncases. Collections in DAV are an example. They can be considered a kind of \nresource that doesn't introduce new properties, but does change method \nbehavior. Clients will of course have to be able to distinguish them in \norder for users to understand the results of their requests.\n\n\n\n\n\n\"Lisa Dusseault\" <lisa@xythos.com>\n06/20/2001 04:32 PM\n\n \n        To:     \"DeltaV\" <ietf-dav-versioning@w3.org>, \"Jim Amsden\" <jamsden@us.ibm.com>, \n\"Jim Whitehead\" <ejw@cse.ucsc.edu>\n        cc: \n        Subject:        RE: Removing the DAV:activity and DAV:version-history and DAV:baselin   e \nresource type values\n\n \n\n\n> The reason we can't introduce new resource types for all of the\n> versioning\n> resources is because we have to support down-level clients that only \nknow\n> about DAV:collection. For new resources that down-level clients couldn't\n> possibly know about, workspaces, activities, baselines, etc., we don't\n> have this restriction. I agree with Greg and Tim. We should be as\n> specific\n> as we can about declared type and only compromise when required by\n> interoperability considerations.\n\nI thought we had rather strong guidance that working around bugs in a \nsingle\nimplementation was NOT recommended.  Clarification, Jim?\n\nI'd also point out that frequently it will be OK even with buggy clients \nto\nintroduce new resource types.  For example, I don't suppose it will be \nthat\neasy for non-versioning-aware clients to stumble across URLs of \ncollections\nof version-histories, activities, baselines and workspaces.  Not all of\nthese new resources are even browsable, and they may not appear in any\nregular URL space that regular clients are expected to use.\n\nlisa\n\n\n\n", "id": "lists-006-3050073"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline  resource type value", "content": "Yes, the consensus of the working group was that we would not\nuse a bug in a single (albeit very widespread :-) implementation\nas a driver for this issue.\n\nSo the current argument for removal of these resourcetype values\nis not because they interact poorly with the buggy client, but rather\nthat they are not needed for any client (buggy or not).  \n\nCheers,\nGeoff \n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\n\n> From: Jim Amsden\n> The reason we can't introduce new resource types for all of the\n> versioning\n> resources is because we have to support down-level clients that only know\n> about DAV:collection. For new resources that down-level clients couldn't\n> possibly know about, workspaces, activities, baselines, etc., we don't\n> have this restriction. I agree with Greg and Tim. We should be as\n> specific\n> as we can about declared type and only compromise when required by\n> interoperability considerations.\n\nI thought we had rather strong guidance that working around bugs in a single\nimplementation was NOT recommended.  Clarification, Jim?\n\nI'd also point out that frequently it will be OK even with buggy clients to\nintroduce new resource types.  For example, I don't suppose it will be that\neasy for non-versioning-aware clients to stumble across URLs of collections\nof version-histories, activities, baselines and workspaces.  Not all of\nthese new resources are even browsable, and they may not appear in any\nregular URL space that regular clients are expected to use.\n\n\n\n", "id": "lists-006-3062957"}, {"subject": "Re: Removing the DAV:activity and DAV:version-history and DAV:baselin e   resource type value", "content": "On Wed, Jun 20, 2001 at 05:21:27PM -0400, Jim Amsden wrote:\n> So we're left with removing our DAV:resourcetypes, and requiring clients \n> to introspect supported properties on a resource to figure out the type \n> based on a table in the spec. This works *except* for (sub)types that \n> don't introduce additional properties.\n\nI guess you could force new subtypes to always introduce at least one\nnew property, as an extreme DAV:deltavresourctype...     1/2 :-)\n\nAlan\n\nDisclaimer: My ignorance is my own. I think.\n\n\n\n", "id": "lists-006-3072924"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "The idea proposed by Tim concerning a new CHECKIN option to replace what is \ntrying to be done with DAV:checked-out-vcr seems good. This allows a client \nto request the server to do the checkin/update operations and not require \nit to be done. I am not convinced that servers supporting other core \nversioning features should be required in all cases to update the VCR on \ncheck in.\n\nIf the DAV:checked-out-vcr property is made part of the specification then \nI would prefer it to be OPTIONAL and not REQUIRED. I'm also wondering if a \nnew core versioning package shouldn't be described similar to the \nbasic-client-workspace package without the update and label features.\n\nAt 02:45 PM 6/20/01 +0100, Tim Ellison wrote:\n>John Hall wrote:\n> > In my system I have no problem tracking moves, but it isn't my\n> > objective.  My objective is having a CHECKIN of the working resource\n> > update the VCR.  That isn't a 'gee it would be nice to have' request.\n> > It is far more important to me than that.  Lack of such a feature would\n> > be quite painful.\n>\n>I think you may have said this already, so apologies if you did.  Instead of\n>a new property on a working resource that tracks MOVEs (which I think will\n>be hard to implement on distributed systems), how about a new CHECKIN option\n>to do the checkin and version-controlled resource update atomically with a\n>specific error condition if either cannot be achieved?\n>\n>I'd be happier with that.\n>\n>Tim\n\n\n\n", "id": "lists-006-3081667"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "   From: Tim Ellison [mailto:tim@peir.com]\n\n   Geoff wrote:\n   > One of the key motivators for the versioning protocol is to\n   > allow parallel development, as opposed to single threading\n   > via LOCKs.  A working resource gives you a stable URL to do\n   > your editing against, which means that a namespace lock should\n   > not be necessary for you get your information back to the server.\n\n   I'm merely pointing out that in the face of MOVEs you are required\n   to use LOCKs to ensure people do not rearrange the namespace under\n   your feet.  This is as true today for in-place-checkout as it will\n   be tomorrow with CHECKIN&UPDATE.  It will therefore not inhibit\n   parallel development any more than it is inhibited already.\n\nYes, but that's the whole point.  I'd be much more comfortable with\nadding a feature if it actually supported something we could not do\ntoday, rather than just \"not making make it worse\".  Admittedly, not\nmaking it worse is better than some of the other things we're\ndiscussing (:-), but I'd like to raise the bar a bit.  In particular,\nwith working resources, the server has already gone to the trouble of\nallocating a stable URL for the client to use.  All we need to do is\nto add a server-maintained DAV:checked-out-vcr property to track the\nVCR, and this becomes a *really* valuable feature which allows a\nfeature to reliably update a VCR without having to lock it.\n\n   I suggest that we provide the operation John requested -- that is a\n   CHECK-IN option to update a given version-controlled resource\n   (referenced by its URL).  If clients do not want that operation to\n   fail due to the version-controlled resource being MOVEd then they\n   must LOCK the version-controlled resource.\n\nThen why add the feature at all?  A client can just issue a CHECKIN\nfollowed by an UPDATE and achieve the same result.  These compound\noperations do not come for free.  We have to define the results in\ncase the first part of the operations succeeds (i.e. the creation of\nthe new version) but the second fails (i.e. the update of the VCR).\nDo we make them atomic?  If so, that could be an implementation challenge\nsince you'd have to make the server \"undo\" the \"create-version\" part\nof the request, which many servers do not allow (ours, for one, and\nwe allow you to do virtually anything :-).  If it is not atomic,\nthen you have to figure out a way to convey back to the client\nhow much of the operations succeeded.  We're getting all tar-babied\nup just to save a round trip.\n\n   <g> Just because I found it unconvincing doesn't mean that I can't\n   use it on you and that _you_ also will be unconvinced! <g> (if you\n   can follow all those negatives :->\n\nYeah, well, I was as unconvinced by it the first time as I am now (:-).\n\n   > In any case, the point was not that \"those servers are hard to write,\n   > and therefore it is OK to make them do other hard things\", but rather\n   > that \"a distributed versioning server will have to keep track of many\n   > relationships between resources on the different servers (e.g. all the\n   > version-to-version relationships),\n\n   Versions cannot MOVE.\n\nTheir URL's cannot change, but their underlying physical location does\nneed to change when distributed repositories are relocated or\nmulti-sited to other servers.  The same machinery that is used to\ntrack this physical location change is appropriate for computing\nthe current URL location.  In any case, the likelihood that a\nversion-controlled resource and its versions are located on a separate\nserver from the working resources for that version-controlled resource\nare pretty slim, even in a distributed implementation.\n\n   > and therefore an additional\n   > relationship to track does not obviously add to the implementation\n   > burden of such a server\".\n\n   Its the nature of the relationship that is different.\n   Relationships between server defined URLs will likely be easier\n   than those involving user-defined URLs since the server has\n   ultimate control over that namespace.\n\nAnd versions are just one example.  Workspaces and activities can MOVE,\nand servers are required to update the properties that refer to them.\nThe point is that servers can notice when server-controlled objects are\nmoved, while clients cannot.\n\n   > What did you have in mind for the client to deal with\n   > the consequences?  Tell the user to go find out where\n   > that VCR ended up on the server?\n\n   I'll tell them to follow the same logic that they follow when any\n   resource MOVEs out from under them.  Panic probably.\n\nAnd you aren't tempted to try to give them some machinery that does\nbetter than that?  And given that the majority of the implementations\nwill probably not be distributed and be able to maintain this property\nbasically \"for free\", wouldn't it be remiss of us not to give them\nsomething better?\n\n   > The point here is that a natural semantics of the proposed\n   > protocol extension would solve this use case, so it would\n   > be good to see a convincing argument for why we should not\n   > do so (if we are going to pay the cost of introducing a\n   > new protocol element to handle the \"vcr updated by working\n   > resource checkin\" scenario).\n\n   The argument is that your way is hard, and it is not what John\n   asked for.\n\nWell, I'm still looking for a more convincing argument for why it\nis hard (so far all I've got is \"Tim said so\" :-).  As a counter-\nargument, consider the following: every time a VCR is moved, you\ninspect the checkout-set of that VCR (i.e. the checkout-set of\nevery version of that VCR), and update it to point to the new\nlocation of VCR.\n\nAnother argument: if a server is supporting the in-place-checkout\noption, it will have to update the checkout-set every time a\n(checked-out) version-controlled resource moves.  Is it that\nunreasonable to have a server that supports the working-resource\noption do the corresponding thing for the DAV:checked-out-VCR?\n\n   The simpler solution that I presented is closer to\n   John's request and is consistent with the existing client and\n   server expectations in the face of MOVEs.\n\nIf we are going to burden the protocol with the complexity of a\ncompound operation (where the \"burden\" is described above), I'd want\nto see more user/client benefit than \"saves one round trip\".  Similar\nresponse to the \"doesn't make the protocol worse than it is now\"\nargument.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3090497"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "   From: Rick Rupp [mailto:rick.rupp@merant.com]\n\n   The idea proposed by Tim concerning a new CHECKIN option to replace\n   what is trying to be done with DAV:checked-out-vcr seems good. This\n   allows a client to request the server to do the checkin/update\n   operations and not require it to be done.\n\nI'm not sure what you mean by \"not require it to be done\".\n\n   I am not convinced that\n   servers supporting other core versioning features should be\n   required in all cases to update the VCR on check in.\n\nA server that supports the core-versioning package is not\nrequired to support the working-resource feature, and therefore\nis not affected by this update-the-VCR-on-checkin issue.\n\n   If the DAV:checked-out-vcr property is made part of the\n   specification then I would prefer it to be OPTIONAL and not\n   REQUIRED.\n\nOptional features are close to useless for an interoperable client\nwriter.  It's hard enough to write a client that works against the 5\ndifferent packages that have been defined, so the only clients likely\nto take advantage of \"optional\" features will be those written against\na specific server, and those clients don't need the feature defined in\nthe protocol.\n\n   I'm also wondering if a new core versioning package shouldn't be\n   described similar to the basic-client-workspace package without the\n   update and label features.\n\nI'd be strongly against introducing a new package.  We already have\n5 packages defined, and that is 4 too many.  A poor client writer is\nalready faced with too many server variations (and that's just in\nthe versioning axis!).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3104809"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "> We're getting all tar-babied up just to save a round trip.\n\nNo, you are supporting smaller subset servers (like mine) in addition to\nsaving a round trip.  If you wish to have servers track the location of\nthe VCR in order to provide this, then I'm all for it.  I've already\nadded a field in my database just to track the new value and allow\nclients to write illegal values there.  (I'll take it out if you say I\ncan protect the value from such abuse, since I can infer the valid\ninformation).\n\nLook at it from the opposite end of the spectrum.  From my point of\nview, I'm trying to un-tar-baby this part of the spec.  Working\nresources?  Sure that is useful.  UPDATE, don't need it.  MERGE, don't\nneed it. 'Versioning' of the working resource, don't need it.\n\nYou say that your implementation makes it hard to make CHECKIN/UPDATE\natomic.  On my system, they are naturally atomic.  That is why I want\nthe atomic operation offered.\n\nIt might be easier if you reversed the nomenclature.  If instead of\nCHECKIN/UDPATE you thought in terms of UPDATE/CHECKIN the problems would\nprobably fall out.  In UPDATE/CHECKIN the UPDATE does a 'new version on\nthe working resource' which would be optional for a server to allow and\nthe CHECKIN then retains its natural meaning (like it has when you\nCHECKIN an in-place-checkout).\n\nI realize that it is probably too late to reverse that nomenclature.\n\nIt comes back to 1) working resources are cool 2) an atomic operation\nmakes sense for a wide selection of clients demonstrated by the fact it\nis often the only option offered and 3) it is very, very, important to\nme. \n\n\n\n", "id": "lists-006-3113802"}, {"subject": "AW: Removing the DAV:activity and DAV:version-history and DAV:baseline   resource type value", "content": "Well, I'm amazed how much energy is spend here on that\nDAV:resourcetype thing and MS WebFolders.\n\nIF (and that's the point worth discussing) deltaV introduces\n_types_ of resources, then it can define a protected live\nproperty DAV:subtype/DAV:interface/DAV:reallyresourcetype,\nput it's new type definitions there and leave DAV:resourcetype\nas it is. (Include the new property in an <allprop/> response,\nMS Webfolder will never see it, it does not use allprop.)\n\nThe alternative is to have no new types and introduce only\nnew live properties, which a client can learn about with\nDAV:supported-live-property-set.\n\nI got the impression somehow that Geoff is in favour of the latter\none, Tim is undecided, Greg is opposed to it, and the rest\nis trying to figure out what DAV:supported-live-property-set\nmeans, how it is interpreted and how it might survive future\nextensions.\n\nWhat other examples beside deltaV do we have in other drafts:\n- Redirect Refs: -> new DAV:resourcetype + property\n- Ordered Collections -> new property\n- Binding: none\n- DASL: none\n- ACL: none\n\nBest Regards,\n\nStefan\n\n> -----Ursprungliche Nachricht-----\n> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Jim Amsden\n> Gesendet: Mittwoch, 20. Juni 2001 23:21\n> An: ietf-dav-versioning@w3.org\n> Betreff: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:baselin e resource type values\n>\n>\n> Lisa,\n> This is really a sticky one. On the one hand, we have introduced many new\n> resource types in DeltaV, but only defined DAV:resourcetype for some of\n> them, and we know this causes problems for some servers. If we don't use\n> DAV:resourcetype, then we don't introduce compatibility problems with DAV\n> level 1 or 2, and DeltaV servers can interoperate somewhat with DAV\n> clients (one of our primary requirements). We're not really just\n> trying to\n> support existing servers with bugs, but make sure we maintain\n> interoperability. Just providing new resource types isn't enough. We need\n> to provide a backward compatible type hierarchy scheme so down-level\n> clients can see for example, a baseline as a DAV:collection. We could do\n> this, but it would be another rat-hole, and then there's the problem with\n> existing servers that might not parse the extended XML properly.\n> These are\n> of course things we'd like to avoid if we can.\n>\n> So we're left with removing our DAV:resourcetypes, and requiring clients\n> to introspect supported properties on a resource to figure out the type\n> based on a table in the spec. This works *except* for (sub)types that\n> don't introduce additional properties. Its a little more\n> inconvenient, but\n> perhaps won't be that different if we really solved the type hierarchy\n> problem. The end result is that DAV:resourcetype is pretty useless.\n>\n> Geoff, do we still have a potential problem with the introspection\n> approach in cases where new types don't introduce new properties?\n> Unfortunately type depends on more than signature, it also depends on\n> behavior, and this isn't captured in the supported properties in all\n> cases. Collections in DAV are an example. They can be considered\n> a kind of\n> resource that doesn't introduce new properties, but does change method\n> behavior. Clients will of course have to be able to distinguish them in\n> order for users to understand the results of their requests.\n>\n>\n>\n>\n>\n> \"Lisa Dusseault\" <lisa@xythos.com>\n> 06/20/2001 04:32 PM\n>\n>\n>         To:     \"DeltaV\" <ietf-dav-versioning@w3.org>, \"Jim\n> Amsden\" <jamsden@us.ibm.com>,\n> \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n>         cc:\n>         Subject:        RE: Removing the DAV:activity and\n> DAV:version-history and DAV:baselin   e\n> resource type values\n>\n>\n>\n>\n> > The reason we can't introduce new resource types for all of the\n> > versioning\n> > resources is because we have to support down-level clients that only\n> know\n> > about DAV:collection. For new resources that down-level clients couldn't\n> > possibly know about, workspaces, activities, baselines, etc., we don't\n> > have this restriction. I agree with Greg and Tim. We should be as\n> > specific\n> > as we can about declared type and only compromise when required by\n> > interoperability considerations.\n>\n> I thought we had rather strong guidance that working around bugs in a\n> single\n> implementation was NOT recommended.  Clarification, Jim?\n>\n> I'd also point out that frequently it will be OK even with buggy clients\n> to\n> introduce new resource types.  For example, I don't suppose it will be\n> that\n> easy for non-versioning-aware clients to stumble across URLs of\n> collections\n> of version-histories, activities, baselines and workspaces.  Not all of\n> these new resources are even browsable, and they may not appear in any\n> regular URL space that regular clients are expected to use.\n>\n> lisa\n>\n>\n\n\n\n", "id": "lists-006-3122995"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n\n>    From: Tim Ellison [mailto:tim@peir.com]\n>\n>    Geoff wrote:\n>    > One of the key motivators for the versioning protocol is to\n>    > allow parallel development, as opposed to single threading\n>    > via LOCKs.  A working resource gives you a stable URL to do\n>    > your editing against, which means that a namespace lock should\n>    > not be necessary for you get your information back to the server.\n>\n>    I'm merely pointing out that in the face of MOVEs you are required\n>    to use LOCKs to ensure people do not rearrange the namespace under\n>    your feet.  This is as true today for in-place-checkout as it will\n>    be tomorrow with CHECKIN&UPDATE.  It will therefore not inhibit\n>    parallel development any more than it is inhibited already.\n>\n> Yes, but that's the whole point.  I'd be much more comfortable with\n> adding a feature if it actually supported something we could not do\n> today, rather than just \"not making make it worse\".\n\nThe feature is to update a version-controlled resource at the same time as\nchecking in a working resource.  We can't do that today.  Nobody has asked\nfor a feature to track a moving version-controlled resource, and, although\nI agree we cannot do that today, I don't want to introduce unnecessary\nfunctionality.\n\n(I think it would be useful if the CHECKIN failed if the\nDAV:checked-out-VCR's DAV:checked-in property was not the same as the\nworking resource's DAV:checked-out property, which would indicate you are\nabout to overwrite someone else's update ... but nobody has asked for that\neither.)\n\n> Admittedly, not\n> making it worse is better than some of the other things we're\n> discussing (:-), but I'd like to raise the bar a bit.  In particular,\n> with working resources, the server has already gone to the trouble of\n> allocating a stable URL for the client to use.  All we need to do is\n> to add a server-maintained DAV:checked-out-vcr property to track the\n> VCR, and this becomes a *really* valuable feature which allows a\n> feature to reliably update a VCR without having to lock it.\n\nIts only valuable if people need it, otherwise the value is in a simple\nspecification.\n\n>    I suggest that we provide the operation John requested -- that is a\n>    CHECK-IN option to update a given version-controlled resource\n>    (referenced by its URL).  If clients do not want that operation to\n>    fail due to the version-controlled resource being MOVEd then they\n>    must LOCK the version-controlled resource.\n>\n> Then why add the feature at all?  A client can just issue a CHECKIN\n> followed by an UPDATE and achieve the same result.\n\nJohn stated that he does not intend to support UPDATE, otherwise I totally\nagree.\n\n> These compound\n> operations do not come for free.  We have to define the results in\n> case the first part of the operations succeeds (i.e. the creation of\n> the new version) but the second fails (i.e. the update of the VCR).\n> Do we make them atomic?  If so, that could be an implementation challenge\n> since you'd have to make the server \"undo\" the \"create-version\" part\n> of the request, which many servers do not allow (ours, for one, and\n> we allow you to do virtually anything :-).\n\nIf your server supports locks then a simple two-phase approach will work.\n\n> If it is not atomic,\n> then you have to figure out a way to convey back to the client\n> how much of the operations succeeded.  We're getting all tar-babied\n> up just to save a round trip.\n\nI'd suggest we do make it atomic.\n(Still waiting for that BATCH method...:-)\n\n>    > In any case, the point was not that \"those servers are hard to\nwrite,\n>    > and therefore it is OK to make them do other hard things\", but\nrather\n>    > that \"a distributed versioning server will have to keep track of\nmany\n>    > relationships between resources on the different servers (e.g. all\nthe\n>    > version-to-version relationships),\n>\n>    Versions cannot MOVE.\n>\n> Their URL's cannot change, but their underlying physical location does\n> need to change when distributed repositories are relocated or\n> multi-sited to other servers.  The same machinery that is used to\n> track this physical location change is appropriate for computing\n> the current URL location.\n\nI strongly disagree.  The user's URL references to resources are very\n*un*likely to be managed by the same machinery used to track the resources'\nphysical locations; in the same way that they are not today to achieve\nload-balancing, website deployment, and so on.  But we digress.\n\n> In any case, the likelihood that a\n> version-controlled resource and its versions are located on a separate\n> server from the working resources for that version-controlled resource\n> are pretty slim, even in a distributed implementation.\n>\n>    > and therefore an additional\n>    > relationship to track does not obviously add to the implementation\n>    > burden of such a server\".\n>\n>    Its the nature of the relationship that is different.\n>    Relationships between server defined URLs will likely be easier\n>    than those involving user-defined URLs since the server has\n>    ultimate control over that namespace.\n>\n> And versions are just one example.  Workspaces and activities can MOVE,\n> and servers are required to update the properties that refer to them.\n> The point is that servers can notice when server-controlled objects are\n> moved, while clients cannot.\n>\n>    > What did you have in mind for the client to deal with\n>    > the consequences?  Tell the user to go find out where\n>    > that VCR ended up on the server?\n>\n>    I'll tell them to follow the same logic that they follow when any\n>    resource MOVEs out from under them.  Panic probably.\n>\n> And you aren't tempted to try to give them some machinery that does\n> better than that?\n\nNo I'm not tempted since it only solves one particular case (the check-out\nof a version-controlled reosurce with an apply to version tag).  There are\nso many more cases where MOVE can disrupt the client that fixing it for\nthis one case is of little benefit overall.\n\n> And given that the majority of the implementations\n> will probably not be distributed and be able to maintain this property\n> basically \"for free\", wouldn't it be remiss of us not to give them\n> something better?\n\nI'm not sure why you think the server can maintain this \"for free\".  It\nwill make MOVEs very expensive if the server has to update a number of\nresources, and will require the server to maintain numerous indices of\nthese resource dependencies.\n\n>    > The point here is that a natural semantics of the proposed\n>    > protocol extension would solve this use case, so it would\n>    > be good to see a convincing argument for why we should not\n>    > do so (if we are going to pay the cost of introducing a\n>    > new protocol element to handle the \"vcr updated by working\n>    > resource checkin\" scenario).\n>\n>    The argument is that your way is hard, and it is not what John\n>    asked for.\n>\n> Well, I'm still looking for a more convincing argument for why it\n> is hard (so far all I've got is \"Tim said so\" :-).  As a counter-\n> argument, consider the following: every time a VCR is moved, you\n> inspect the checkout-set of that VCR (i.e. the checkout-set of\n> every version of that VCR), and update it to point to the new\n> location of VCR.\n>\n> Another argument: if a server is supporting the in-place-checkout\n> option, it will have to update the checkout-set every time a\n> (checked-out) version-controlled resource moves.  Is it that\n> unreasonable to have a server that supports the working-resource\n> option do the corresponding thing for the DAV:checked-out-VCR?\n\nOk, you're right.  Provided I can move a resource and update a number of\nproperties on different resources atomically then I can do this -- and this\nis already a requirement for implementing some advanced features of the\nspecification.  But it makes me *really* nervous to make this REQUIRED\nfunctionality for the working resource feature.  Please keep it simple.\n\n>    The simpler solution that I presented is closer to\n>    John's request and is consistent with the existing client and\n>    server expectations in the face of MOVEs.\n>\n> If we are going to burden the protocol with the complexity of a\n> compound operation (where the \"burden\" is described above), I'd want\n> to see more user/client benefit than \"saves one round trip\".  Similar\n> response to the \"doesn't make the protocol worse than it is now\"\n> argument.\n\nAs mentioned above, I agree if a server supports UPDATE this problem does\nnot arise.\n\nTim\n\n\n\n", "id": "lists-006-3138263"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:baselin e    resource type value", "content": "\"Jim Amsden\" <jamsden@us.ibm.com> wrote:\n> This is really a sticky one. On the one hand, we have\n> introduced many new resource types in DeltaV, but only\n> defined DAV:resourcetype for some of them,\n\nWithout wanting to open the can of worms again, I have argued previously\nthat a resource's _state_ is equally important to it _type_; and that there\nis no universal definition of state and type.\n\n> and we know this causes problems for some servers.\n\nI'd be interested to know what problems these are.\n\n> If we don't use\n> DAV:resourcetype, then we don't introduce compatibility\n> problems with DAV level 1 or 2, and DeltaV servers can\n> interoperate somewhat with DAV clients (one of our\n> primary requirements). We're not really just trying to\n> support existing servers with bugs, but make sure we\n> maintain interoperability.\n\nAgreed.\n\n> Just providing new resource\n> types isn't enough. We need to provide a backward\n> compatible type hierarchy scheme so down-level clients\n> can see for example, a baseline as a DAV:collection.\n\nA baseline is not a collection, but if you had said \"so that clients can\nsee workspaces as a DAV:collection\" then I would agree with you <g>\n\n> We\n> could do this, but it would be another rat-hole, and\n> then there's the problem with existing servers that\n> might not parse the extended XML properly. These are\n> of course things we'd like to avoid if we can.\n\nI don't think this is a rat-hole.  The only case from RFC2518 that we have\nto deal with is DAV:collection.  The DeltaV spec. states which resources\nare compatible with DAV:collection semantics.\n\n> So we're left with removing our DAV:resourcetypes, and\n> requiring clients to introspect supported properties on\n> a resource to figure out the type based on a table in\n> the spec.\n\nI'm not sure why you call it \"introspection\".  Clients must consider a set\nof values reported by two required properties\n(DAV:supported-live-property-set and DAV:supported-method-set).\n\nI argue that the alternative is that clients must consider a set of values\nreported by a different rquired property (DAV:resourcetype) if we choose to\nextend that property with state and type information.\n\nThe third alternative is to require clients to deduce type from\nDAV:resourcetype and state from DAV:supported-live-property-set and\nDAV:supported-method-set, but there seems little advantage to that\napproach.\n\n> This works *except* for (sub)types that don't\n> introduce additional properties.\n\nThe argument goes, if the subtype does not introduce additional properties\n(or methods) then it is not a subtype at all since it is indistinguishable\nfrom its supertype.\n\nFurthermore, since a subtype supports all the properties and methods of its\nsupertype that subtype can be correctly treat as an instance of the\nsupertype.  This provides the future compatibility with specifications that\nintroduce new subtypes.  However, if types are simply named then there is\nno reason to deduce that a DAV:workspace can be treat as a DAV:collection.\n\n> Its a little more\n> inconvenient, but perhaps won't be that different if\n> we really solved the type hierarchy problem.\n\nDoes DAV:supported-live-property-set and DAV:supported-method-set do this\nfor you?\n\n> The end\n> result is that DAV:resourcetype is pretty useless.\n\nAgreed.  Geoff suggested previously that RFC2518 would have been better to\ndefine a distinguishing property for a collection resource.\n\n> Geoff, do we still have a potential problem with the\n> introspection approach in cases where new types don't\n> introduce new properties?\n\nSee above.\n\n> Unfortunately type depends\n> on more than signature, it also depends on behavior,\n> and this isn't captured in the supported properties\n> in all cases.\n\nSee DAV:supported-method-set\n\n> Collections in DAV are an example.\n> They can be considered a kind of resource that doesn't\n> introduce new properties, but does change method behavior.\n> Clients will of course have to be able to distinguish\n> them in order for users to understand the results of\n> their requests.\n\nAgreed.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-3155672"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline   resource type value", "content": "Nice summary, Stefan!\n\nOne addendum: Notice that the binding protocol addresses\nthe 2518 omission of a few critical collection operations\n(BIND, UNBIND, REBIND).  If we merge the \"bind\"\nprotocol into the next draft of 2518 (which we should do),\nthen DAV:supported-method-set allows you to distinguish a\ncollection from a non-collection.  Arguably, there are a few\nkey collection properties (e.g. DAV:child-count) that should\nbe added as well.  My experience is that every new type\nof resource normally brings at least one new method or property\nin with it.\n\nAlso note that Tim recently posted on this thread:\n  I support taking them out.  We don't need them.\n\nSo that puts Tim and me pretty much in the same camp.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\nSent: Thursday, June 21, 2001 4:17 AM\nTo: ietf-dav-versioning@w3.org\nSubject: AW: Removing the DAV:activity and DAV:version-history and\nDAV:baseline resource type values\n\n\nWell, I'm amazed how much energy is spend here on that\nDAV:resourcetype thing and MS WebFolders.\n\nIF (and that's the point worth discussing) deltaV introduces\n_types_ of resources, then it can define a protected live\nproperty DAV:subtype/DAV:interface/DAV:reallyresourcetype,\nput it's new type definitions there and leave DAV:resourcetype\nas it is. (Include the new property in an <allprop/> response,\nMS Webfolder will never see it, it does not use allprop.)\n\nThe alternative is to have no new types and introduce only\nnew live properties, which a client can learn about with\nDAV:supported-live-property-set.\n\nI got the impression somehow that Geoff is in favour of the latter\none, Tim is undecided, Greg is opposed to it, and the rest\nis trying to figure out what DAV:supported-live-property-set\nmeans, how it is interpreted and how it might survive future\nextensions.\n\nWhat other examples beside deltaV do we have in other drafts:\n- Redirect Refs: -> new DAV:resourcetype + property\n- Ordered Collections -> new property\n- Binding: none\n- DASL: none\n- ACL: none\n\nBest Regards,\n\nStefan\n\n> -----Ursprungliche Nachricht-----\n> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Jim Amsden\n> Gesendet: Mittwoch, 20. Juni 2001 23:21\n> An: ietf-dav-versioning@w3.org\n> Betreff: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:baselin e resource type values\n>\n>\n> Lisa,\n> This is really a sticky one. On the one hand, we have introduced many new\n> resource types in DeltaV, but only defined DAV:resourcetype for some of\n> them, and we know this causes problems for some servers. If we don't use\n> DAV:resourcetype, then we don't introduce compatibility problems with DAV\n> level 1 or 2, and DeltaV servers can interoperate somewhat with DAV\n> clients (one of our primary requirements). We're not really just\n> trying to\n> support existing servers with bugs, but make sure we maintain\n> interoperability. Just providing new resource types isn't enough. We need\n> to provide a backward compatible type hierarchy scheme so down-level\n> clients can see for example, a baseline as a DAV:collection. We could do\n> this, but it would be another rat-hole, and then there's the problem with\n> existing servers that might not parse the extended XML properly.\n> These are\n> of course things we'd like to avoid if we can.\n>\n> So we're left with removing our DAV:resourcetypes, and requiring clients\n> to introspect supported properties on a resource to figure out the type\n> based on a table in the spec. This works *except* for (sub)types that\n> don't introduce additional properties. Its a little more\n> inconvenient, but\n> perhaps won't be that different if we really solved the type hierarchy\n> problem. The end result is that DAV:resourcetype is pretty useless.\n>\n> Geoff, do we still have a potential problem with the introspection\n> approach in cases where new types don't introduce new properties?\n> Unfortunately type depends on more than signature, it also depends on\n> behavior, and this isn't captured in the supported properties in all\n> cases. Collections in DAV are an example. They can be considered\n> a kind of\n> resource that doesn't introduce new properties, but does change method\n> behavior. Clients will of course have to be able to distinguish them in\n> order for users to understand the results of their requests.\n>\n>\n>\n>\n>\n> \"Lisa Dusseault\" <lisa@xythos.com>\n> 06/20/2001 04:32 PM\n>\n>\n>         To:     \"DeltaV\" <ietf-dav-versioning@w3.org>, \"Jim\n> Amsden\" <jamsden@us.ibm.com>,\n> \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n>         cc:\n>         Subject:        RE: Removing the DAV:activity and\n> DAV:version-history and DAV:baselin   e\n> resource type values\n>\n>\n>\n>\n> > The reason we can't introduce new resource types for all of the\n> > versioning\n> > resources is because we have to support down-level clients that only\n> know\n> > about DAV:collection. For new resources that down-level clients couldn't\n> > possibly know about, workspaces, activities, baselines, etc., we don't\n> > have this restriction. I agree with Greg and Tim. We should be as\n> > specific\n> > as we can about declared type and only compromise when required by\n> > interoperability considerations.\n>\n> I thought we had rather strong guidance that working around bugs in a\n> single\n> implementation was NOT recommended.  Clarification, Jim?\n>\n> I'd also point out that frequently it will be OK even with buggy clients\n> to\n> introduce new resource types.  For example, I don't suppose it will be\n> that\n> easy for non-versioning-aware clients to stumble across URLs of\n> collections\n> of version-histories, activities, baselines and workspaces.  Not all of\n> these new resources are even browsable, and they may not appear in any\n> regular URL space that regular clients are expected to use.\n>\n> lisa\n>\n>\n\n\n\n", "id": "lists-006-3167592"}, {"subject": "DAV:resourcetyp", "content": "See <jar> tags below. My mailer doesn't put in the >'s. Sorry.\n\n> This works *except* for (sub)types that don't\n> introduce additional properties.\n\nThe argument goes, if the subtype does not introduce additional properties\n(or methods) then it is not a subtype at all since it is indistinguishable\nfrom its supertype.\n<jra>\nAbsoultely not! A subtype may override methods in such a way that very \ndifferent behavior occurs even though the signatures are the same. That's \nwhy interfaces aren't enough. You need the subtype name to make the \ndistinction unless you're willing to invoke the method and use the result \nto determine the type. This is often too late though.\n</jra>\n\nFurthermore, since a subtype supports all the properties and methods of \nits\nsupertype that subtype can be correctly treat as an instance of the\nsupertype.  This provides the future compatibility with specifications \nthat\nintroduce new subtypes.  However, if types are simply named then there is\nno reason to deduce that a DAV:workspace can be treat as a DAV:collection.\n<jra>\nSubtypes are interface compatible with their supertypes, but that doesn't \nmean they are the same object. Yes a client can invoke the same methods \nand access the same properties, but the meaning might (should) be \ndifferent. Its this information we capture in the DAV:resourcetype.\n</jra>\n\n> Its a little more\n> inconvenient, but perhaps won't be that different if\n> we really solved the type hierarchy problem.\n\nDoes DAV:supported-live-property-set and DAV:supported-method-set do this\nfor you?\n<jra>\nNo. For example a resource and a collection will respond to the same \nmethods and have the same properties. But they respond to GET in very \ndifferent ways that a client is most interested in.\n</jra>\n\n> The end\n> result is that DAV:resourcetype is pretty useless.\n\nAgreed.  Geoff suggested previously that RFC2518 would have been better to\ndefine a distinguishing property for a collection resource.\n<jra>\nBut this only moves the problem to the next time behavior changes. Then, \nas Alan pointed out, we're forced to add distinguishing properties that \nlook a lot like DAV:resourcetype.\n</jra>\n\n> Geoff, do we still have a potential problem with the\n> introspection approach in cases where new types don't\n> introduce new properties?\n\nSee above.\n\n> Unfortunately type depends\n> on more than signature, it also depends on behavior,\n> and this isn't captured in the supported properties\n> in all cases.\n\nSee DAV:supported-method-set\n<jra>\nThis isn't enough. It's not just the supported methods, but what those \nmethods do.\n</jra>\n\n> Collections in DAV are an example.\n> They can be considered a kind of resource that doesn't\n> introduce new properties, but does change method behavior.\n> Clients will of course have to be able to distinguish\n> them in order for users to understand the results of\n> their requests.\n\nAgreed.\n\n\n\n", "id": "lists-006-3184848"}, {"subject": "Working Resource Issues ..", "content": "\"If you remain calm while everyone else is panicking, then you probably\ndon't understand the situation.\" -- old Naval saying.\n\nIt appears that some of the long discussion on this topic has been\nprompted by completely different understandings of what a\n\"WORKING-RESOURCE\" is and should mean.\n\nI just thought it was a bit-bucket where the user could store his state\nuntil he was finished.  Check out VCR, get bit bucket, modify bit\nbucket, Check In.  The critical difference between Check-Out-In-Place\nand Check-Out-Working-Version was the visibility of the bit bucket to\nother users.  In-Place, they can see it.  Working-Version, they can't.\n\nI've also mentioned that I'm concerned with 3rd party emulation.  The\n3rd party has a 'working version', and that is exactly how they\nimplemented the concept.\n\nThat IS NOT what this spec defines.  In the post conditions for 9.3\ncreate-working-resource-from-checked-in-version the spec states that\n\"... the version-controlled resource remains checked-in.\"\n\nThat is why you have seen two operations when I've only seen one, and\nneed an UPDATE or MERGE.  Meanwhile, I'm going \"of COURSE the VCR is\nchecked out.  I got a successful return on my CHECKOUT didn't I?\"  I\nthink you should create a new verb (MKWORKING), personally.\n\nSo how about leaving the WORKING-RESOURCE definition as-is and modify\nthe CHECKOUT-IN-PLACE feature to make invisibility to other users a\n(REQUIRED) option?  I think you will have to finesse a much smaller\nnumber of issues if you do that.  Since it is required, it doesn't raise\nthe issue of client interoperability.  It is new functionality; you\ncan't do what I need to do with the spec defined as is.  And by moving\nit down there you don't confuse the complex 'package' issues Geoff\nraised.  You put it in the basic package, and you don't have clients\ntrying to figure out why they have WORKING-RESOURCE provided but not\nUPDATE or MERGE.\n\n4.1.3  DAV:checkout-invisible\n\nNormally, edits made on a resource while checked out are visible to\nother users.  If checkout-invisible is specified, however, other users\nwill only see the last checked-in version.  A client is encouraged to\nsee this feature as \"lite\" version of WORKING-RESOURCE which leaves the\nVCR in the checked-out state.\n\n4.2 CHECKOUT Marshalling:\n\nIf the element checkout-invisible is present, the response MUST include\na Location header.\n\n4.6: Additional PUT / PROPPATCH semantics.\n\nIf a Location header was returned with the CHECKOUT, the URL specified\nin the Location header MUST be used for PUT and PROPPATCH requests.\nOtherwise, the server will return\ncannot-modify-version-controlled-content.\n\n4.7: Additional DELETE semantics.\n\nA delete on the URL returned by a CHECKOUT Location header will undo the\nCHECKOUT which created it.\n\n\n\n", "id": "lists-006-3194228"}, {"subject": "What is a supported property", "content": "All this resourcetype and state thing aside:\n\nWhat is a supported property?\n\nA resource has properties, let's call these existing properties,\nwhich might or might not have values. But when a client does\na PROPFIND on them, he will get them listed in a propstat\nelement with 200 OK status code. I think that is a good definition\nof an \"existing property of a resource\".\n\nNow, every existing property would also be a supported property\nand, being live, would appear in the supported-live-property-set.\nOk.\n\nNow Geoff mentioned that a VCR with in-place editing would have\nboth DAV:checked-in and DAV:checked-out as supported properties,\nand that independant of the checked in/out state of the resource!\n\nNow, here I became confused, since it means that not every supported\nproperty is an existing property! \n\nIf we define supported properties with: \na property which will exist, when a method is applied successfully\nthen all non-versioned resources will have the DAV:checked-in as\nsupported property, since you can apply VERSION-CONTROL. So, that\ndoes not seem to be a good definition...\n\nAnd what about supported methods? Is CHECKIN a supported method for\na checked-in resource, too? It will fail all the time...\n\nGeoff and Tim to the rescue, please!\n\nStefan\n\n\n\n", "id": "lists-006-3204795"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline    resource type value", "content": "I agree with Geoff that *most* new resource types do result in at least \none new method and/or property. But this is fundamentally a poor thing to \ndepend on as we know there can be (and therefore probably will be) \nsubtypes that don't add new methods or properties, but only override \nbehavior of their superclass. By not resolving the resource type issue to \nsupport such situations, we may be just putting the problem off in such a \nway that it will need to be solved in some very different manner by some \nfuture protocol extension. This is what keeps nagging at me.\n\n\n\n\n\"Clemm, Geoff\" <gclemm@rational.com>\nSent by: ietf-dav-versioning-request@w3.org\n06/21/2001 08:38 AM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline \nresource type values\n\n \n\nNice summary, Stefan!\n\nOne addendum: Notice that the binding protocol addresses\nthe 2518 omission of a few critical collection operations\n(BIND, UNBIND, REBIND).  If we merge the \"bind\"\nprotocol into the next draft of 2518 (which we should do),\nthen DAV:supported-method-set allows you to distinguish a\ncollection from a non-collection.  Arguably, there are a few\nkey collection properties (e.g. DAV:child-count) that should\nbe added as well.  My experience is that every new type\nof resource normally brings at least one new method or property\nin with it.\n\nAlso note that Tim recently posted on this thread:\n  I support taking them out.  We don't need them.\n\nSo that puts Tim and me pretty much in the same camp.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\nSent: Thursday, June 21, 2001 4:17 AM\nTo: ietf-dav-versioning@w3.org\nSubject: AW: Removing the DAV:activity and DAV:version-history and\nDAV:baseline resource type values\n\n\nWell, I'm amazed how much energy is spend here on that\nDAV:resourcetype thing and MS WebFolders.\n\nIF (and that's the point worth discussing) deltaV introduces\n_types_ of resources, then it can define a protected live\nproperty DAV:subtype/DAV:interface/DAV:reallyresourcetype,\nput it's new type definitions there and leave DAV:resourcetype\nas it is. (Include the new property in an <allprop/> response,\nMS Webfolder will never see it, it does not use allprop.)\n\nThe alternative is to have no new types and introduce only\nnew live properties, which a client can learn about with\nDAV:supported-live-property-set.\n\nI got the impression somehow that Geoff is in favour of the latter\none, Tim is undecided, Greg is opposed to it, and the rest\nis trying to figure out what DAV:supported-live-property-set\nmeans, how it is interpreted and how it might survive future\nextensions.\n\nWhat other examples beside deltaV do we have in other drafts:\n- Redirect Refs: -> new DAV:resourcetype + property\n- Ordered Collections -> new property\n- Binding: none\n- DASL: none\n- ACL: none\n\nBest Regards,\n\nStefan\n\n> -----Ursprungliche Nachricht-----\n> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Jim Amsden\n> Gesendet: Mittwoch, 20. Juni 2001 23:21\n> An: ietf-dav-versioning@w3.org\n> Betreff: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:baselin e resource type values\n>\n>\n> Lisa,\n> This is really a sticky one. On the one hand, we have introduced many \nnew\n> resource types in DeltaV, but only defined DAV:resourcetype for some of\n> them, and we know this causes problems for some servers. If we don't use\n> DAV:resourcetype, then we don't introduce compatibility problems with \nDAV\n> level 1 or 2, and DeltaV servers can interoperate somewhat with DAV\n> clients (one of our primary requirements). We're not really just\n> trying to\n> support existing servers with bugs, but make sure we maintain\n> interoperability. Just providing new resource types isn't enough. We \nneed\n> to provide a backward compatible type hierarchy scheme so down-level\n> clients can see for example, a baseline as a DAV:collection. We could do\n> this, but it would be another rat-hole, and then there's the problem \nwith\n> existing servers that might not parse the extended XML properly.\n> These are\n> of course things we'd like to avoid if we can.\n>\n> So we're left with removing our DAV:resourcetypes, and requiring clients\n> to introspect supported properties on a resource to figure out the type\n> based on a table in the spec. This works *except* for (sub)types that\n> don't introduce additional properties. Its a little more\n> inconvenient, but\n> perhaps won't be that different if we really solved the type hierarchy\n> problem. The end result is that DAV:resourcetype is pretty useless.\n>\n> Geoff, do we still have a potential problem with the introspection\n> approach in cases where new types don't introduce new properties?\n> Unfortunately type depends on more than signature, it also depends on\n> behavior, and this isn't captured in the supported properties in all\n> cases. Collections in DAV are an example. They can be considered\n> a kind of\n> resource that doesn't introduce new properties, but does change method\n> behavior. Clients will of course have to be able to distinguish them in\n> order for users to understand the results of their requests.\n>\n>\n>\n>\n>\n> \"Lisa Dusseault\" <lisa@xythos.com>\n> 06/20/2001 04:32 PM\n>\n>\n>         To:     \"DeltaV\" <ietf-dav-versioning@w3.org>, \"Jim\n> Amsden\" <jamsden@us.ibm.com>,\n> \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n>         cc:\n>         Subject:        RE: Removing the DAV:activity and\n> DAV:version-history and DAV:baselin   e\n> resource type values\n>\n>\n>\n>\n> > The reason we can't introduce new resource types for all of the\n> > versioning\n> > resources is because we have to support down-level clients that only\n> know\n> > about DAV:collection. For new resources that down-level clients \ncouldn't\n> > possibly know about, workspaces, activities, baselines, etc., we don't\n> > have this restriction. I agree with Greg and Tim. We should be as\n> > specific\n> > as we can about declared type and only compromise when required by\n> > interoperability considerations.\n>\n> I thought we had rather strong guidance that working around bugs in a\n> single\n> implementation was NOT recommended.  Clarification, Jim?\n>\n> I'd also point out that frequently it will be OK even with buggy clients\n> to\n> introduce new resource types.  For example, I don't suppose it will be\n> that\n> easy for non-versioning-aware clients to stumble across URLs of\n> collections\n> of version-histories, activities, baselines and workspaces.  Not all of\n> these new resources are even browsable, and they may not appear in any\n> regular URL space that regular clients are expected to use.\n>\n> lisa\n>\n>\n\n\n\n", "id": "lists-006-3214551"}, {"subject": "AW: Working Resource Issues ..", "content": "John,\n\nif I understand your proposal correctly, one user could not\nhave two working resources of the same version resource, since\nthere is only a single URL to access it. Correct?\n\nWouldn't that be a major drawback for a versioning repository?\n\nStefan\n\n> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von John Hall\n> \n> \"If you remain calm while everyone else is panicking, then you probably\n> don't understand the situation.\" -- old Naval saying.\n> \n> It appears that some of the long discussion on this topic has been\n> prompted by completely different understandings of what a\n> \"WORKING-RESOURCE\" is and should mean.\n> \n> I just thought it was a bit-bucket where the user could store his state\n> until he was finished.  Check out VCR, get bit bucket, modify bit\n> bucket, Check In.  The critical difference between Check-Out-In-Place\n> and Check-Out-Working-Version was the visibility of the bit bucket to\n> other users.  In-Place, they can see it.  Working-Version, they can't.\n> \n> I've also mentioned that I'm concerned with 3rd party emulation.  The\n> 3rd party has a 'working version', and that is exactly how they\n> implemented the concept.\n> \n> That IS NOT what this spec defines.  In the post conditions for 9.3\n> create-working-resource-from-checked-in-version the spec states that\n> \"... the version-controlled resource remains checked-in.\"\n> \n> That is why you have seen two operations when I've only seen one, and\n> need an UPDATE or MERGE.  Meanwhile, I'm going \"of COURSE the VCR is\n> checked out.  I got a successful return on my CHECKOUT didn't I?\"  I\n> think you should create a new verb (MKWORKING), personally.\n> \n> So how about leaving the WORKING-RESOURCE definition as-is and modify\n> the CHECKOUT-IN-PLACE feature to make invisibility to other users a\n> (REQUIRED) option?  I think you will have to finesse a much smaller\n> number of issues if you do that.  Since it is required, it doesn't raise\n> the issue of client interoperability.  It is new functionality; you\n> can't do what I need to do with the spec defined as is.  And by moving\n> it down there you don't confuse the complex 'package' issues Geoff\n> raised.  You put it in the basic package, and you don't have clients\n> trying to figure out why they have WORKING-RESOURCE provided but not\n> UPDATE or MERGE.\n> \n> 4.1.3  DAV:checkout-invisible\n> \n> Normally, edits made on a resource while checked out are visible to\n> other users.  If checkout-invisible is specified, however, other users\n> will only see the last checked-in version.  A client is encouraged to\n> see this feature as \"lite\" version of WORKING-RESOURCE which leaves the\n> VCR in the checked-out state.\n> \n> 4.2 CHECKOUT Marshalling:\n> \n> If the element checkout-invisible is present, the response MUST include\n> a Location header.\n> \n> 4.6: Additional PUT / PROPPATCH semantics.\n> \n> If a Location header was returned with the CHECKOUT, the URL specified\n> in the Location header MUST be used for PUT and PROPPATCH requests.\n> Otherwise, the server will return\n> cannot-modify-version-controlled-content.\n> \n> 4.7: Additional DELETE semantics.\n> \n> A delete on the URL returned by a CHECKOUT Location header will undo the\n> CHECKOUT which created it.\n> \n> \n\n\n\n", "id": "lists-006-3233640"}, {"subject": "Re: What is a supported property", "content": "Stefan makes a good point. But I think the answer is that a resource's \nsupported properties and methods are not static, but are rather dependent \non its state. So getting the supported live properties may return \ndifferent results at different times.\n\n\n\n\n\n\"Stefan Eissing\" <stefan.eissing@greenbytes.de>\nSent by: ietf-dav-versioning-request@w3.org\n06/21/2001 10:14 AM\n\n \n        To:     \"Ietf-Dav-Versioning\" <ietf-dav-versioning@w3.org>\n        cc: \n        Subject:        What is a supported property?\n\n \n\nAll this resourcetype and state thing aside:\n\nWhat is a supported property?\n\nA resource has properties, let's call these existing properties,\nwhich might or might not have values. But when a client does\na PROPFIND on them, he will get them listed in a propstat\nelement with 200 OK status code. I think that is a good definition\nof an \"existing property of a resource\".\n\nNow, every existing property would also be a supported property\nand, being live, would appear in the supported-live-property-set.\nOk.\n\nNow Geoff mentioned that a VCR with in-place editing would have\nboth DAV:checked-in and DAV:checked-out as supported properties,\nand that independant of the checked in/out state of the resource!\n\nNow, here I became confused, since it means that not every supported\nproperty is an existing property! \n\nIf we define supported properties with: \n                 a property which will exist, when a method is applied \nsuccessfully\nthen all non-versioned resources will have the DAV:checked-in as\nsupported property, since you can apply VERSION-CONTROL. So, that\ndoes not seem to be a good definition...\n\nAnd what about supported methods? Is CHECKIN a supported method for\na checked-in resource, too? It will fail all the time...\n\nGeoff and Tim to the rescue, please!\n\nStefan\n\n\n\n", "id": "lists-006-3245644"}, {"subject": "RE: Working Resource Issues ..", "content": "That is how I would implement it.  But it isn't required, and I could\nchange my implementation in the future.\n\nSince a Location record is returned with the invisible-checkout, just\nlike with a WORKING-RESOURCE checkout, there is no reason there\ntheoretically could not be more than one.  I deliberately said that a\ndeletion of the URL you were given would undo the checkout that resulted\nin the working resource being created, not perform an UNCHECKOUT that\nwould zap all checkouts.  So a repository that provides multiple\ncheckouts like this would be advised to count them.\n\nNo, I don't see that as a major drawback.  But that is because I'm\ndeveloping a simple document server that doesn't allow forking and its\ncomplications anyway.  Not allowing multiple concurrent checkouts is not\nan *additional* drawback, and it isn't a drawback at all if you don't\nneed those features.\n\nI'm not building a versioning repository that could be used in a\ndiskless workstation environment for software development.  It doesn't\nfollow that what I am building is useless.\n\n\n\n> -----Original Message-----\n> From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de] \n> Sent: Thursday, June 21, 2001 7:20 AM\n> To: John Hall; 'DeltaV (E-mail)'\n> Subject: AW: Working Resource Issues ...\n> \n> \n> John,\n> \n> if I understand your proposal correctly, one user could not \n> have two working resources of the same version resource, \n> since there is only a single URL to access it. Correct?\n> \n> Wouldn't that be a major drawback for a versioning repository?\n> \n> Stefan\n> \n> > Von: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von John Hall\n> > \n> > \"If you remain calm while everyone else is panicking, then you \n> > probably don't understand the situation.\" -- old Naval saying.\n> > \n> > It appears that some of the long discussion on this topic has been \n> > prompted by completely different understandings of what a \n> > \"WORKING-RESOURCE\" is and should mean.\n> > \n> > I just thought it was a bit-bucket where the user could store his \n> > state until he was finished.  Check out VCR, get bit bucket, modify \n> > bit bucket, Check In.  The critical difference between \n> > Check-Out-In-Place and Check-Out-Working-Version was the \n> visibility of \n> > the bit bucket to other users.  In-Place, they can see it.  \n> > Working-Version, they can't.\n> > \n> > I've also mentioned that I'm concerned with 3rd party \n> emulation.  The \n> > 3rd party has a 'working version', and that is exactly how they \n> > implemented the concept.\n> > \n> > That IS NOT what this spec defines.  In the post conditions for 9.3 \n> > create-working-resource-from-checked-in-version the spec \n> states that \n> > \"... the version-controlled resource remains checked-in.\"\n> > \n> > That is why you have seen two operations when I've only \n> seen one, and \n> > need an UPDATE or MERGE.  Meanwhile, I'm going \"of COURSE \n> the VCR is \n> > checked out.  I got a successful return on my CHECKOUT \n> didn't I?\"  I \n> > think you should create a new verb (MKWORKING), personally.\n> > \n> > So how about leaving the WORKING-RESOURCE definition as-is \n> and modify \n> > the CHECKOUT-IN-PLACE feature to make invisibility to other users a\n> > (REQUIRED) option?  I think you will have to finesse a much smaller \n> > number of issues if you do that.  Since it is required, it doesn't \n> > raise the issue of client interoperability.  It is new \n> functionality; \n> > you can't do what I need to do with the spec defined as is.  And by \n> > moving it down there you don't confuse the complex 'package' issues \n> > Geoff raised.  You put it in the basic package, and you don't have \n> > clients trying to figure out why they have WORKING-RESOURCE \n> provided \n> > but not UPDATE or MERGE.\n> > \n> > 4.1.3  DAV:checkout-invisible\n> > \n> > Normally, edits made on a resource while checked out are visible to \n> > other users.  If checkout-invisible is specified, however, \n> other users \n> > will only see the last checked-in version.  A client is \n> encouraged to \n> > see this feature as \"lite\" version of WORKING-RESOURCE which leaves \n> > the VCR in the checked-out state.\n> > \n> > 4.2 CHECKOUT Marshalling:\n> > \n> > If the element checkout-invisible is present, the response MUST \n> > include a Location header.\n> > \n> > 4.6: Additional PUT / PROPPATCH semantics.\n> > \n> > If a Location header was returned with the CHECKOUT, the \n> URL specified \n> > in the Location header MUST be used for PUT and PROPPATCH requests. \n> > Otherwise, the server will return \n> > cannot-modify-version-controlled-content.\n> > \n> > 4.7: Additional DELETE semantics.\n> > \n> > A delete on the URL returned by a CHECKOUT Location header \n> will undo \n> > the CHECKOUT which created it.\n> > \n> > \n> \n> \n\n\n\n", "id": "lists-006-3255290"}, {"subject": "Re: What is a supported property", "content": "\"Stefan Eissing\" <stefan.eissing@greenbytes.de> wrote:\n> All this resourcetype and state thing aside:\n>\n> What is a supported property?\n>\n> A resource has properties, let's call these existing\n> properties, which might or might not have values. But\n> when a client does a PROPFIND on them, he will get\n> them listed in a propstat element with 200 OK status\n> code. I think that is a good definition of an \"existing\n> property of a resource\".\n\nIf I was going to be pedantic I'd say that the status code for an existing\nproperty is not 404 Not Found, since the PROPFIND may fail due to\nauthorization problems etc., but I know what you mean.\n\n> Now, every existing property would also be a supported\n> property and, being live, would appear in the\n> supported-live-property-set. Ok.\n\nAgain, just to be completely precise, every live property (in the DAV:\nnamespace) of a DeltaV-compliant resource will be in the\nDAV:supported-live-property-set.\n\n> Now Geoff mentioned that a VCR with in-place editing\n> would have both DAV:checked-in and DAV:checked-out as\n> supported properties, and that independant of the\n> checked in/out state of the resource!\n\n(I've not received Geoff's post on that yet, I think it was held up in\ncustoms<g>)\nI agree with this view.  The server supports the semantics of\nDAV:checked-in and DAV:checked-out on a version-controlled resource even\nthough those properties cannot appear simultaneously.\n\n> Now, here I became confused, since it means that not\n> every supported property is an existing property!\n\nCorrect.\n\n> If we define supported properties with:\n>    a property which will exist, when a method is applied\n>     successfully\n> then all non-versioned resources will have the\n> DAV:checked-in as supported property, since you can\n> apply VERSION-CONTROL. So, that does not seem to be\n> a good definition...\n\nWell we are back to that _type_ thing again I'm afraid.  The document\nstates that a versionable resource is a different type of resource to a\nversion-controlled resource, and so on.  It makes these distinctions so\nthat we can talk about \"Activities\" and \"Workspaces\" and\n\"Version-controlled resources\" and know what affect named property values\nand methods have on that resource.\n\nTo avoid confusion the server is required to disallow setting resource\nproperties that are defined in the specification but are not supported\n(i.e. a PROPPATCH of DAV:checked-in on a DeltaV-compliant versionable\nresource MUST fail).\n\nThe DAV:supported-*-set properties are defined for each type of resource.\nThe supported-property-set tells you which properties will/can be defined\nfor that resource _and_ have the meaning defined in the specification.  (It\ntherefore states that DAV:checked-in will&can not be defined on a\nversionable resource.)\n\n> And what about supported methods? Is CHECKIN a supported\n> method for a checked-in resource, too? It will fail all\n> the time...\n\nThe CHECKIN method is not supported for a checked-in resource, i.e., there\nare no (non-failure) semantics for that operation in the specification.\nThe analogy is with HTTP/1.1 Allow.\n\nTim\n\n\n\n", "id": "lists-006-3268662"}, {"subject": "Re: What is a supported property", "content": "Jim Amsden wrote:\n> Stefan makes a good point. But I think the answer is\n> that a resource's supported properties and methods\n> are not static, but are rather dependent on its state.\n> So getting the supported live properties may return\n> different results at different times.\n\nStrongly disagree.\n\nTim\n\n\n\n", "id": "lists-006-3279529"}, {"subject": "A simpler response ... RE: Working Resource Issues ..", "content": "There is only one 'in-place-checkout' now, so perhaps we should insist\nthat any \"invisible\" in-place-checkout's should be unique.  Therefore,\nthe only difference is the visibility of the work in progress.\n\nThe only reason I made them different URL's is to preserve the semantics\nwhere if you PUT on a resource and then GET you are supposed to GET what\nyou just PUT.  Therefore, for the PUT's to be invisible it must be a\ndifferent URL.\n\nThis isn't much different than lock resource, GET, modifing the local\ncopy, PUT, unlock.\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of \n> Stefan Eissing\n> Sent: Thursday, June 21, 2001 7:20 AM\n> To: John Hall; 'DeltaV (E-mail)'\n> Subject: AW: Working Resource Issues ...\n> \n> \n> John,\n> \n> if I understand your proposal correctly, one user could not \n> have two working resources of the same version resource, \n> since there is only a single URL to access it. Correct?\n> \n> Wouldn't that be a major drawback for a versioning repository?\n> \n> Stefan\n> \n> > Von: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von John Hall\n> > \n> > \"If you remain calm while everyone else is panicking, then you \n> > probably don't understand the situation.\" -- old Naval saying.\n> > \n> > It appears that some of the long discussion on this topic has been \n> > prompted by completely different understandings of what a \n> > \"WORKING-RESOURCE\" is and should mean.\n> > \n> > I just thought it was a bit-bucket where the user could store his \n> > state until he was finished.  Check out VCR, get bit bucket, modify \n> > bit bucket, Check In.  The critical difference between \n> > Check-Out-In-Place and Check-Out-Working-Version was the \n> visibility of \n> > the bit bucket to other users.  In-Place, they can see it.  \n> > Working-Version, they can't.\n> > \n> > I've also mentioned that I'm concerned with 3rd party \n> emulation.  The \n> > 3rd party has a 'working version', and that is exactly how they \n> > implemented the concept.\n> > \n> > That IS NOT what this spec defines.  In the post conditions for 9.3 \n> > create-working-resource-from-checked-in-version the spec \n> states that \n> > \"... the version-controlled resource remains checked-in.\"\n> > \n> > That is why you have seen two operations when I've only \n> seen one, and \n> > need an UPDATE or MERGE.  Meanwhile, I'm going \"of COURSE \n> the VCR is \n> > checked out.  I got a successful return on my CHECKOUT \n> didn't I?\"  I \n> > think you should create a new verb (MKWORKING), personally.\n> > \n> > So how about leaving the WORKING-RESOURCE definition as-is \n> and modify \n> > the CHECKOUT-IN-PLACE feature to make invisibility to other users a\n> > (REQUIRED) option?  I think you will have to finesse a much smaller \n> > number of issues if you do that.  Since it is required, it doesn't \n> > raise the issue of client interoperability.  It is new \n> functionality; \n> > you can't do what I need to do with the spec defined as is.  And by \n> > moving it down there you don't confuse the complex 'package' issues \n> > Geoff raised.  You put it in the basic package, and you don't have \n> > clients trying to figure out why they have WORKING-RESOURCE \n> provided \n> > but not UPDATE or MERGE.\n> > \n> > 4.1.3  DAV:checkout-invisible\n> > \n> > Normally, edits made on a resource while checked out are visible to \n> > other users.  If checkout-invisible is specified, however, \n> other users \n> > will only see the last checked-in version.  A client is \n> encouraged to \n> > see this feature as \"lite\" version of WORKING-RESOURCE which leaves \n> > the VCR in the checked-out state.\n> > \n> > 4.2 CHECKOUT Marshalling:\n> > \n> > If the element checkout-invisible is present, the response MUST \n> > include a Location header.\n> > \n> > 4.6: Additional PUT / PROPPATCH semantics.\n> > \n> > If a Location header was returned with the CHECKOUT, the \n> URL specified \n> > in the Location header MUST be used for PUT and PROPPATCH requests. \n> > Otherwise, the server will return \n> > cannot-modify-version-controlled-content.\n> > \n> > 4.7: Additional DELETE semantics.\n> > \n> > A delete on the URL returned by a CHECKOUT Location header \n> will undo \n> > the CHECKOUT which created it.\n> > \n> > \n> \n> \n> \n\n\n\n", "id": "lists-006-3286962"}, {"subject": "Re: DAV:resourcetyp", "content": "\"Jim Amsden\" <jamsden@us.ibm.com> wrote:\n\n> The argument goes, if the subtype does not introduce\n> additional properties (or methods) then it is not a\n> subtype at all since it is indistinguishable from its\n> supertype.\n> <jra>\n> Absoultely not! A subtype may override methods in such\n> a way that very different behavior occurs even though\n> the signatures are the same. That's why interfaces\n> aren't enough. You need the subtype name to make the\n> distinction unless you're willing to invoke the method\n> and use the result to determine the type. This is often\n> too late though.\n> </jra>\n\nIf we are talking about Java classes and interfaces then I agree.  But\nlet's focus on webdav resources that simply exhibit well-defined behavior\nto methods and have well-defined properties (that may affect that\nbehavior).\n\nShould a future protocol designer come along and redefine the meaning for\nDAV:checked-in to mean something other than it does for DeltaV, then they\nwill be deliberately introducing an incompatibility and the protocol will\nfail.  We have been careful to retain the meaning of RFC2518 methods and\nproperties and RFC2616 methods in designing DeltaV.\n\nWhere such 'subtyping' makes sense, and I predict it is in very few cases,\nthe well-defined behavior must be the same.  An example is workspace\nretaining the meaning of collection.\n\n>\n> <jra>\n> Subtypes are interface compatible with their supertypes,\n> but that doesn't mean they are the same object. Yes a\n> client can invoke the same methods and access the same\n> properties, but the meaning might (should) be different.\n> Its this information we capture in the DAV:resourcetype.\n> </jra>\n\nSo just how would you capture it in DAV:resourcetype?\n\nImagine you had a workspace.  If you just set the resource type to be:\n  <DAV:resourcetype><DAV:workspace/></DAV:resourcetype>\nthen existing clients would not treat this as a collection (ok except\nWebFolders, incorrectly), and all new clients would have to be programmed\nto 'know' that a workspace is-a collection.\n\nNow imagine you set it's DAV:resourcetype as follows:\n  <DAV:resourcetype>\n    <DAV:workspace/>\n    <DAV:collection/>\n  </DAV:resourcetype>\n\nThis is better since existing clients work fine, and the rule for new\nclients is \"if it has a <DAV:collection> element then it is a\ncollection-type resource\".\n\nOk, now we bring the workspace under version control.  By the same argument\nyou wouldn't use <DAV:version-controlled-workspace-collection/>, but\nrather:\n\n  <DAV:resourcetype>\n    <DAV:workspace/>\n    <DAV:collection/>\n    <DAV:version-controlled/>\n  </DAV:resourcetype>\n\nand then,\n\n  <DAV:resourcetype>\n    <DAV:workspace/>\n    <DAV:collection/>\n    <DAV:version-controlled/>\n    <DAV:version/>\n  </DAV:resourcetype>\n\nand so on.  The only workable solution is to make DAV:resourcetype a *set*\nof types and/or states.\n\nNow, tell me how is this different to DAV:supported-*-set?\n\nWhat if someone in the future decides to redefine the meaning of\n<DAV:workspace/>.  It would be a breaking change, and it is incumbant upon\nthem not to do so.\n\n> <jra>\n> No. For example a resource and a collection will respond\n> to the same methods and have the same properties.\n\nA collection responds to MKCOL whereas a non-collection resource does not\n(successfully).\n\n> But\n> they respond to GET in very different ways that a client\n> is most interested in.\n> </jra>\n\nSection 8.4 of RFC2518 states explicitly \"The semantics of GET are\nunchanged when applied to a collection\".  So we are cool.\n\nTim\n\n\n\n", "id": "lists-006-3300988"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:baseline resource type value", "content": "I second what Jim's saying.  Furthermore, I'd point out that server\nimplementations differ.  Servers may not implement all live properties or\nmethods that a client expects.  Some servers may add new, custom live\nproperties.  Does that change the type and make the client unable to\nconfidently deal with the resource?\n\nI've heard the argument here before that the spec isn't done until you've\ntaken out anything that needs to be taken out.  Taking that too literally\nwould be abuse of a guideline that has proved useful to us.  Let's be a\nlittle less dogmatic:  the intent of that guideline is to encourage spec\nwriters to pare down the sets of features and options, to reduce complexity.\nOr to think of it another way, to improve simplicity.\n\nSo ask yourself if removing resource types in DeltaV improves simplicity.\nIt does not.  The resource type is a piece of information that is easily\nprovided by the server and makes things immensely simpler for the client.\nIt is not an option, therefore clients can rely on it.  It improves\nrobustness and can foster better extensions in the future.  It should\nremain.\n\nLisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n> Sent: Thursday, June 21, 2001 7:16 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:bas eline resource type values\n>\n>\n> I agree with Geoff that *most* new resource types do result in at least\n> one new method and/or property. But this is fundamentally a poor thing to\n> depend on as we know there can be (and therefore probably will be)\n> subtypes that don't add new methods or properties, but only override\n> behavior of their superclass. By not resolving the resource type issue to\n> support such situations, we may be just putting the problem off in such a\n> way that it will need to be solved in some very different manner by some\n> future protocol extension. This is what keeps nagging at me.\n>\n>\n>\n>\n> \"Clemm, Geoff\" <gclemm@rational.com>\n> Sent by: ietf-dav-versioning-request@w3.org\n> 06/21/2001 08:38 AM\n>\n>\n>         To:     ietf-dav-versioning@w3.org\n>         cc:\n>         Subject:        RE: Removing the DAV:activity and\n> DAV:version-history and DAV:bas eline\n> resource type values\n>\n>\n>\n> Nice summary, Stefan!\n>\n> One addendum: Notice that the binding protocol addresses\n> the 2518 omission of a few critical collection operations\n> (BIND, UNBIND, REBIND).  If we merge the \"bind\"\n> protocol into the next draft of 2518 (which we should do),\n> then DAV:supported-method-set allows you to distinguish a\n> collection from a non-collection.  Arguably, there are a few\n> key collection properties (e.g. DAV:child-count) that should\n> be added as well.  My experience is that every new type\n> of resource normally brings at least one new method or property\n> in with it.\n>\n> Also note that Tim recently posted on this thread:\n>   I support taking them out.  We don't need them.\n>\n> So that puts Tim and me pretty much in the same camp.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n> Sent: Thursday, June 21, 2001 4:17 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: AW: Removing the DAV:activity and DAV:version-history and\n> DAV:baseline resource type values\n>\n>\n> Well, I'm amazed how much energy is spend here on that\n> DAV:resourcetype thing and MS WebFolders.\n>\n> IF (and that's the point worth discussing) deltaV introduces\n> _types_ of resources, then it can define a protected live\n> property DAV:subtype/DAV:interface/DAV:reallyresourcetype,\n> put it's new type definitions there and leave DAV:resourcetype\n> as it is. (Include the new property in an <allprop/> response,\n> MS Webfolder will never see it, it does not use allprop.)\n>\n> The alternative is to have no new types and introduce only\n> new live properties, which a client can learn about with\n> DAV:supported-live-property-set.\n>\n> I got the impression somehow that Geoff is in favour of the latter\n> one, Tim is undecided, Greg is opposed to it, and the rest\n> is trying to figure out what DAV:supported-live-property-set\n> means, how it is interpreted and how it might survive future\n> extensions.\n>\n> What other examples beside deltaV do we have in other drafts:\n> - Redirect Refs: -> new DAV:resourcetype + property\n> - Ordered Collections -> new property\n> - Binding: none\n> - DASL: none\n> - ACL: none\n>\n> Best Regards,\n>\n> Stefan\n>\n> > -----Ursprungliche Nachricht-----\n> > Von: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Jim Amsden\n> > Gesendet: Mittwoch, 20. Juni 2001 23:21\n> > An: ietf-dav-versioning@w3.org\n> > Betreff: RE: Removing the DAV:activity and DAV:version-history and\n> > DAV:baselin e resource type values\n> >\n> >\n> > Lisa,\n> > This is really a sticky one. On the one hand, we have introduced many\n> new\n> > resource types in DeltaV, but only defined DAV:resourcetype for some of\n> > them, and we know this causes problems for some servers. If we don't use\n> > DAV:resourcetype, then we don't introduce compatibility problems with\n> DAV\n> > level 1 or 2, and DeltaV servers can interoperate somewhat with DAV\n> > clients (one of our primary requirements). We're not really just\n> > trying to\n> > support existing servers with bugs, but make sure we maintain\n> > interoperability. Just providing new resource types isn't enough. We\n> need\n> > to provide a backward compatible type hierarchy scheme so down-level\n> > clients can see for example, a baseline as a DAV:collection. We could do\n> > this, but it would be another rat-hole, and then there's the problem\n> with\n> > existing servers that might not parse the extended XML properly.\n> > These are\n> > of course things we'd like to avoid if we can.\n> >\n> > So we're left with removing our DAV:resourcetypes, and requiring clients\n> > to introspect supported properties on a resource to figure out the type\n> > based on a table in the spec. This works *except* for (sub)types that\n> > don't introduce additional properties. Its a little more\n> > inconvenient, but\n> > perhaps won't be that different if we really solved the type hierarchy\n> > problem. The end result is that DAV:resourcetype is pretty useless.\n> >\n> > Geoff, do we still have a potential problem with the introspection\n> > approach in cases where new types don't introduce new properties?\n> > Unfortunately type depends on more than signature, it also depends on\n> > behavior, and this isn't captured in the supported properties in all\n> > cases. Collections in DAV are an example. They can be considered\n> > a kind of\n> > resource that doesn't introduce new properties, but does change method\n> > behavior. Clients will of course have to be able to distinguish them in\n> > order for users to understand the results of their requests.\n> >\n> >\n> >\n> >\n> >\n> > \"Lisa Dusseault\" <lisa@xythos.com>\n> > 06/20/2001 04:32 PM\n> >\n> >\n> >         To:     \"DeltaV\" <ietf-dav-versioning@w3.org>, \"Jim\n> > Amsden\" <jamsden@us.ibm.com>,\n> > \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n> >         cc:\n> >         Subject:        RE: Removing the DAV:activity and\n> > DAV:version-history and DAV:baselin   e\n> > resource type values\n> >\n> >\n> >\n> >\n> > > The reason we can't introduce new resource types for all of the\n> > > versioning\n> > > resources is because we have to support down-level clients that only\n> > know\n> > > about DAV:collection. For new resources that down-level clients\n> couldn't\n> > > possibly know about, workspaces, activities, baselines, etc., we don't\n> > > have this restriction. I agree with Greg and Tim. We should be as\n> > > specific\n> > > as we can about declared type and only compromise when required by\n> > > interoperability considerations.\n> >\n> > I thought we had rather strong guidance that working around bugs in a\n> > single\n> > implementation was NOT recommended.  Clarification, Jim?\n> >\n> > I'd also point out that frequently it will be OK even with buggy clients\n> > to\n> > introduce new resource types.  For example, I don't suppose it will be\n> > that\n> > easy for non-versioning-aware clients to stumble across URLs of\n> > collections\n> > of version-histories, activities, baselines and workspaces.  Not all of\n> > these new resources are even browsable, and they may not appear in any\n> > regular URL space that regular clients are expected to use.\n> >\n> > lisa\n> >\n> >\n>\n>\n>\n\n\n\n", "id": "lists-006-3312279"}, {"subject": "RE: DAV:resourcetyp", "content": "[Tim's logic process mostly deleted]\n\n> Ok, now we bring the workspace under version control.  By the\n> same argument\n> you wouldn't use <DAV:version-controlled-workspace-collection/>, but\n> rather:\n>\n>   <DAV:resourcetype>\n>     <DAV:workspace/>\n>     <DAV:collection/>\n>     <DAV:version-controlled/>\n>   </DAV:resourcetype>\n>\n\nTim, at this point, you're taking the argument rather father than I, for\none, would wish you to.  Rather than criticize the argument taken to an\nextreme, realize that we can stop before then.\n\nIt's been pointed out by many that there is a fuzzy line between type and\nstate.  Fine.  We're humans designing this protocol, and we can handle a\nlittle fuzziness.  There's no need for our implementations to worry about\ntelling the difference between a type change and a state change, as long as\nour implementations can tell both the type and the state reliably.  So let's\nattack the problem of most clearly delineating the type and the state.\n\nI've always prefered to have type defined as something which changes rather\nunfrequently, perhaps never.  So we could stop before version-controlled is\nadded to the resourcetype.  Both version-controlled and\nnon-version-controlled workspaces could be represented as\n  <DAV:resourcetype><DAV:workspace/><DAV:collection/></DAV:resourcetype>\n\nAs you point out, this allows clients to easily recognize that the workspace\ncan be treated as a collection for depth requests and other purposes.  They\ndon't need to know if it's version-controlled to be able to deal with it;\nthat's a major feature of the DeltaV specification.\n\nIf there's a version of a baseline, I'd represent it as\n\n<DAV:resourcetype><DAV:workspace/><DAV:collection/><DAV:version/></DAV:resou\nrcetype>\n\nTim said:\n> The only workable solution is to make DAV:resourcetype a *set*\n> of types and/or states.\n\nThat's incorrect.  There are other workable solutions.  State can be\nindicated in other ways.  We don't put <DAV:locked/> into the resourcetype\nin the base DAV specification -- we have <DAV:lockdiscovery> to do a much\nbetter job of this.  Similarly, we don't need to put checkin/checkout state,\nor even version-controlled state into the resourcetype.  Although, as you\npoint out, we could.\n\n> Now, tell me how is this different to DAV:supported-*-set?\n\nIt is different.\n - It's less variable.  Supported-*-set can contain a whole mess of things\ndepending on what the server chooses to implement.\n - It's more directly purposed.  Supported-*-set is not intended to show the\ntype of things.  As JimA points out, just because two things support method\nFOO, doesn't mean they have the same behaviour when you tell them to FOO.\n - It more closely maps to what the client needs to know first of all --\nthat is, what *kind* of thing is this so that I can display a correct icon\nwhen the user browses.  Afterward, the client may need to know the\nsupported-*-set for other purposes.\n\nLisa\n\n\n\n", "id": "lists-006-3334091"}, {"subject": "Re: What is a supported property", "content": "I disagree with myself too - that is, agree with Tim. \n\n\n\n\n\"Tim Ellison\" <Tim_Ellison@uk.ibm.com>\nSent by: ietf-dav-versioning-request@w3.org\n06/21/2001 11:35 AM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        Re: What is a supported property?\n\n \n\nJim Amsden wrote:\n> Stefan makes a good point. But I think the answer is\n> that a resource's supported properties and methods\n> are not static, but are rather dependent on its state.\n> So getting the supported live properties may return\n> different results at different times.\n\nStrongly disagree.\n\nTim\n\n\n\n", "id": "lists-006-3344498"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "For those (likely very few) new resource types that have exactly\nthe same properties and methods as an existing resource type, you would\nbe free to add an additional value to the DAV:resourcetype property.\nBut since none of the resources introduced by the versioning protocol\nhave this characteristic (i.e. they all have a set of new properties\nor methods that they support), we needn't add new resource type values\nin the DeltaV protocol.\n\nCheers,\nGeoff \n\n\n-----Original Message-----\nFrom: Jim Amsden [mailto:jamsden@us.ibm.com]\nSent: Thursday, June 21, 2001 10:16 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Removing the DAV:activity and DAV:version-history and\nDAV:bas eline resource type values\n\n\nI agree with Geoff that *most* new resource types do result in at least \none new method and/or property. But this is fundamentally a poor thing to \ndepend on as we know there can be (and therefore probably will be) \nsubtypes that don't add new methods or properties, but only override \nbehavior of their superclass. By not resolving the resource type issue to \nsupport such situations, we may be just putting the problem off in such a \nway that it will need to be solved in some very different manner by some \nfuture protocol extension. This is what keeps nagging at me.\n\n\n\n", "id": "lists-006-3353426"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline  resource type value", "content": "So I think we're real close here. Since we agree that there *may* be \ncircumstances where new DAV:resourcetypes will need to be introduced \n(otherwise its a pretty useless property), then any issues with current \nservers that don't parse DAV:resourcetype properly would have to be \naddressed anyway. Given solutions to that problem, we are then faced with \nan opportunity to describe some of the more interesting static \ncharacteristics of the new DeltaV resources in a DAV:resourcetype as a \nconvenience to client writers so they don't have to know the methods and \nproperties supported by a particular type to know the type. This is of \ncourse not required, but since it is 1) more convenient, 2) standard OO \npractice, 3) established DAV practice, 4) solves any potential subtype \noverride ambiguity problem, 5) is already (partially) in the DeltaV spec, \nand 6) fits well with our use of resource type names in the spec, it seems \nlike a reasonable thing to conisder.\n\nI like Tim's approach of including the supertype tags in the resource type \nwith the subtype name first. This shouldn't break any client that follows \nthe RFC2518 convention of ignoring unknown XML tags, provides all the \nstatic type information needed, and makes it very easy for clients to \ncheck for the type they are interested in by simply using \ngetAllElementsByTagName() on the DAV:resourcetype element. Clients that \ncan't handle this are not following the DAV spec and should probably be \nfixed rather than forcing the protocol to work around them.\n\n\n\n\n\"Clemm, Geoff\" <gclemm@rational.com>\nSent by: ietf-dav-versioning-request@w3.org\n06/21/2001 02:05 PM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline \nresource type values\n\n \n\nFor those (likely very few) new resource types that have exactly\nthe same properties and methods as an existing resource type, you would\nbe free to add an additional value to the DAV:resourcetype property.\nBut since none of the resources introduced by the versioning protocol\nhave this characteristic (i.e. they all have a set of new properties\nor methods that they support), we needn't add new resource type values\nin the DeltaV protocol.\n\nCheers,\nGeoff \n\n\n-----Original Message-----\nFrom: Jim Amsden [mailto:jamsden@us.ibm.com]\nSent: Thursday, June 21, 2001 10:16 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Removing the DAV:activity and DAV:version-history and\nDAV:bas eline resource type values\n\n\nI agree with Geoff that *most* new resource types do result in at least \none new method and/or property. But this is fundamentally a poor thing to \ndepend on as we know there can be (and therefore probably will be) \nsubtypes that don't add new methods or properties, but only override \nbehavior of their superclass. By not resolving the resource type issue to \nsupport such situations, we may be just putting the problem off in such a \nway that it will need to be solved in some very different manner by some \nfuture protocol extension. This is what keeps nagging at me.\n\n\n\n", "id": "lists-006-3363203"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline resource type value", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   I second what Jim's saying.  Furthermore, I'd point out that server\n   implementations differ.  Servers may not implement all live\n   properties or methods that a client expects.  Some servers may add\n   new, custom live properties.  Does that change the type and make\n   the client unable to confidently deal with the resource?\n\nSo, how does a client interoperate with such a server?  Either the\nserver lies, and says it supports a given \"resourcetype\" when it only\nsupports a subset of the methods and properties defined for that\n\"resourcetype\", or it makes up some new server-specific resourcetype\nfor that resource.  In the former case, an interoperable client\nassumes that the server is telling the truth, only to find that\ncertain unimplemented methods fail and certain live properties are\nabsent or have unexpected values.  In the latter case, an\ninteroperable client (that hasn't been coded specifically against that\nserver) says \"I don't know what that resource is\", and doesn't try to\naccess any methods or properties from that resource (since it doesn't\nrecognize the value in the DAV:resourcetype property).\n\nNow suppose instead the client uses the values in\nDAV:supported-live-property-set and DAV:supported-method-set to\ndetermine if a given resource provides a set of services that it\nwill use (note that this might be a subset of the defined\nproperties and methods for a \"resourcetype\", since it might not use\nall the defined properties and methods).  In this case, the client\nworks properly against a server that either subsets or extends the\nsupported methods and properties.\n\nSo I applaud your argument, but point out that it leads\nto the opposite conclusion from the one you reached.\n\n   So ask yourself if removing resource types in DeltaV improves simplicity.\n   It does not.\n\nThe simplicity argument is minor to irrelevant.  The argument against\nDAV:resourcetype is that it is at best redundant, and at worst,\nas your scenario illustrates, it is even harmful since it decreases\nthe likelihood that a client will interoperate with a wide range of\nservers.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3377230"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "Jim said:\n> John, Lisa: Let me note that one of the foundations of your argument in\n> favor of this capability is an indirect appeal to authority, namely the\n> authority of your users/customers. Now, you almost certainly cannot (or\n> don't want to) reveal the market research that led to your position. But,\n> let me note that when you (or anyone else on the list) make this kind of\n> argument, you have a responsibility to ensure that you have, in fact done\n> due diligence when reflecting your customer's requirements.\n\nI thought it would be more informative to say that customers wanted it,\nrather than to say that Xythos developers thought it would be \"a good idea\".\nAn appeal to (customer) authority can be an even stronger argument than\nsimply personal experience or educated guesses, particularly in this case\nwhere Geoff asked for \"use cases\".  Who can do a better job of providing use\ncases than the customer?  But I accept the due diligence point.\n\nLet me give a use case that's entirely non-opaque, where I can give full\ndetails, and where the due-diligence is automatic.\n\nThe site www.sharemation.com uses quotas.  We couldn't afford to run this\nfree service without quotas, and note that usage numbers count both regular\nresources and stored versions.  We also couldn't run this quota-based\nservice without allowing users to free up their quotas.\n\nSo here's the problem scenario on Sharemation: user 'scrooge' turns on\nversioning on /~scrooge/foo.txt through the UI or through a hypothetical\nDeltaV client.  Then Scrooge uses Web Folders one day to delete a bunch of\nstuff.  Web Folders issues a plain DELETE, possibly even issuing DELETE on\nentire collections.  Once Web Folders' DELETE is issued, Scrooge would have\nno way of finding or cleaning out old versions or version history resources\nthat still are counted under his quota.  Scrooge's quota would soon be\nunusable.\n\nThis use case applies to any situation where quotas are needed.  Just a few:\n - A university provides web storage and collaboration space to its students\nand professors.  It limits this space (quotas) in order to discourage\nimproper use.\n - A ISP offers web site hosting to its customers, on a fee-based service.\nCustomers pay for their quota.\n - XDrive, IDrive etc. - all these free hosting services (some of which\nsupported Web Folders) restricted quota.\n\nLisa\n\n\n\n", "id": "lists-006-3387684"}, {"subject": "DAV:resourcetyp", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   I second what Jim's saying.  Furthermore, I'd point out that server\n   implementations differ.  Servers may not implement all live\n   properties or methods that a client expects.  Some servers may add\n   new, custom live properties.  Does that change the type and make\n   the client unable to confidently deal with the resource?\n\nA server can't say it supports a resource type unless it supports all the \nbehavior and properties specified for that resource within the bounds \noffered by its options as specified in the spec. So I don't support the \nnotion of using DAV:resourcetype as a way of indicating support for a \nresource type without implementing all its required properties and \nmethods. Servers aren't that free in claiming support for the protocol. \nAdding new custom live properties is OK though as this is just defining a \nsubtype.\n\n\n\n", "id": "lists-006-3397909"}, {"subject": "Re: Working Resource Issues ..", "content": "johnhall@evergo.net wrote:\n> prompted by completely different understandings of what a\n> \"WORKING-RESOURCE\" is and should mean.\n> \n> I just thought it was a bit-bucket where the user could store his state\n> until he was finished.  Check out VCR, get bit bucket, modify bit\n> bucket, Check In.  The critical difference between Check-Out-In-Place\n> and Check-Out-Working-Version was the visibility of the bit bucket to\n> other users.  In-Place, they can see it.  Working-Version, they can't.\n> \n> I've also mentioned that I'm concerned with 3rd party emulation.  The\n> 3rd party has a 'working version', and that is exactly how they\n> implemented the concept.\nYes, I know tools which have a 'working version'. But this means that\na version has a state 'working' (modifiable) and finally 'frozen'.\nMore complexity that I would like to avoid. You can get the same result\nby having a working resource and a following UPDATE.\nI prefer the simpler concept in this case.\n\n> 4.1.3  DAV:checkout-invisible\n> Normally, edits made on a resource while checked out are visible to\n> other users.  If checkout-invisible is specified, however, other users\n> will only see the last checked-in version.  A client is encouraged to\n> see this feature as \"lite\" version of WORKING-RESOURCE which leaves the\n> VCR in the checked-out state.\nYou say you don't need UPDATE (BTW, I read with great interest your \n'A compelling use case ...' a while ago. When I have time I will comment\non it, because I'm only a hobby deltaver unlike some other people who do\nit by profession :-) so here I say that I don't need this invisible thing.\nBecause I get it by using a workspace. And in addition the workspace has\nthe advantage that I can tell a selected few where they find the workspace\nwhere I'm doing my secret stuff.\nI dislike it if there are too many ways to achieve the same result.\n(OK, I admit I'm a purist sometimes). But this makes things difficult\nfor the DAUs (d?mmster anzunehmender User, free translation to English:\ndumbest imaginable user). Sure, versioning isn't trivial but many tools\nnowadays aren't accepted by developers because they give them a flood of\nfeatures they drown in. So we should try to avoid too much redundancy.\nBecause I probably won't have time to write a long comment to John's\n'A compelling use case ...' just a short statement from what I still\nremember.\nIs seems that you describe a very simple use case. A resource\nis a resource and a recource and this resource has versions. So if\nyou delete your working resource the versions history also can go down\nthe closet.\nBut I guess (Perhaps I'm wrong) that most of the people discussing here\nhave more complex problems we want to solve.\nWe have thousands of source files which we have to freeze in baselines.\nSome resources are contained in overlapping baselines. Just mention one\npoint. Baselining of multiple resources already begins with your\npersonal website.\nSo even if you delete a resource from your work package some versions\nof it will still be necessary for other work packages or being contained\nin other baselines. You can't delete these versions just because\nYOU don't need them anymore.\nYou talk about your typing pool. So isn't it imaginable that a typist\nsuddenly thinks: Hey, the changes I made today are wrong. Let's go back to\nand earlier version (Perhaps not the last one). That's what UPDATE is for.\nSo at last my question: Couldn't agreee to implement UPDATE ?\nNot that complex and uncommon I guess (co -r <filename>)\nPerhaps we then could stop some threads which threaten to make the spec\nmore complex.\n\nCheers, Edgar\n\nP.S. Will there be any DeltaV action on the upcoming IETF in London ?\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-3406379"}, {"subject": "RE: DAV:resourcetyp", "content": "The only (very minor) quibble I have with Tim's excellent analysis\nis that MKCOL is defined in 2518 to be supported by all resources\nso that is not a differentiator.  So until the BIND, REBIND, and\nUNBIND methods are added to the spec, I believe a collection is\nthe one place you currently need DAV:resourcetype.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\nSent: Thursday, June 21, 2001 12:34 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: DAV:resourcetype\n\n\n\n\"Jim Amsden\" <jamsden@us.ibm.com> wrote:\n\n> The argument goes, if the subtype does not introduce\n> additional properties (or methods) then it is not a\n> subtype at all since it is indistinguishable from its\n> supertype.\n> <jra>\n> Absoultely not! A subtype may override methods in such\n> a way that very different behavior occurs even though\n> the signatures are the same. That's why interfaces\n> aren't enough. You need the subtype name to make the\n> distinction unless you're willing to invoke the method\n> and use the result to determine the type. This is often\n> too late though.\n> </jra>\n\nIf we are talking about Java classes and interfaces then I agree.  But\nlet's focus on webdav resources that simply exhibit well-defined behavior\nto methods and have well-defined properties (that may affect that\nbehavior).\n\nShould a future protocol designer come along and redefine the meaning for\nDAV:checked-in to mean something other than it does for DeltaV, then they\nwill be deliberately introducing an incompatibility and the protocol will\nfail.  We have been careful to retain the meaning of RFC2518 methods and\nproperties and RFC2616 methods in designing DeltaV.\n\nWhere such 'subtyping' makes sense, and I predict it is in very few cases,\nthe well-defined behavior must be the same.  An example is workspace\nretaining the meaning of collection.\n\n>\n> <jra>\n> Subtypes are interface compatible with their supertypes,\n> but that doesn't mean they are the same object. Yes a\n> client can invoke the same methods and access the same\n> properties, but the meaning might (should) be different.\n> Its this information we capture in the DAV:resourcetype.\n> </jra>\n\nSo just how would you capture it in DAV:resourcetype?\n\nImagine you had a workspace.  If you just set the resource type to be:\n  <DAV:resourcetype><DAV:workspace/></DAV:resourcetype>\nthen existing clients would not treat this as a collection (ok except\nWebFolders, incorrectly), and all new clients would have to be programmed\nto 'know' that a workspace is-a collection.\n\nNow imagine you set it's DAV:resourcetype as follows:\n  <DAV:resourcetype>\n    <DAV:workspace/>\n    <DAV:collection/>\n  </DAV:resourcetype>\n\nThis is better since existing clients work fine, and the rule for new\nclients is \"if it has a <DAV:collection> element then it is a\ncollection-type resource\".\n\nOk, now we bring the workspace under version control.  By the same argument\nyou wouldn't use <DAV:version-controlled-workspace-collection/>, but\nrather:\n\n  <DAV:resourcetype>\n    <DAV:workspace/>\n    <DAV:collection/>\n    <DAV:version-controlled/>\n  </DAV:resourcetype>\n\nand then,\n\n  <DAV:resourcetype>\n    <DAV:workspace/>\n    <DAV:collection/>\n    <DAV:version-controlled/>\n    <DAV:version/>\n  </DAV:resourcetype>\n\nand so on.  The only workable solution is to make DAV:resourcetype a *set*\nof types and/or states.\n\nNow, tell me how is this different to DAV:supported-*-set?\n\nWhat if someone in the future decides to redefine the meaning of\n<DAV:workspace/>.  It would be a breaking change, and it is incumbant upon\nthem not to do so.\n\n> <jra>\n> No. For example a resource and a collection will respond\n> to the same methods and have the same properties.\n\nA collection responds to MKCOL whereas a non-collection resource does not\n(successfully).\n\n> But\n> they respond to GET in very different ways that a client\n> is most interested in.\n> </jra>\n\nSection 8.4 of RFC2518 states explicitly \"The semantics of GET are\nunchanged when applied to a collection\".  So we are cool.\n\nTim\n\n\n\n", "id": "lists-006-3417791"}, {"subject": "RE: DAV:resourcetyp", "content": "   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   > Now, tell me how is this different to DAV:supported-*-set?\n\n   It is different.\n    - It's less variable.  Supported-*-set can contain a whole mess of\nthings\n   depending on what the server chooses to implement.\n\nA server will want to expose this whole mess of things in a way that\ncan be discovered and used by a client.  If clients use\nDAV:resourcetype to discover what kind of resource they are dealing with,\nthen that information would have to be added to DAV:resourcetype.\n\n    - It's more directly purposed.  Supported-*-set is not intended to show\nthe\n   type of things.  As JimA points out, just because two things support\nmethod\n   FOO, doesn't mean they have the same behaviour when you tell them to FOO.\n\nI'm not quite sure what \"directly purposed\" means, but as Tim\nresponded to JimA, we require extensions to the protocol to be\ncompatible with existing semantics of the protocol, and so the fact\nthat two things support method FOO *does* mean that they have\nbasically the same behavior when you tell them to do FOO.  When we\nextend a method for some resource, all we do is add a few extra\npreconditions and post conditions that *supplement* the existing\npreconditions and postconditions that define the behavior of a method.\nThis ensures that a client can confidently apply a given method or\naccess a given live property for any resource, and have it work \"as\nexpected\".\n\n    - It more closely maps to what the client needs to know first of all --\n   that is, what *kind* of thing is this so that I can display a correct\nicon\n   when the user browses.  Afterward, the client may need to know the\n   supported-*-set for other purposes.\n\nFor versioning resources, the DAV:supported-*-set tells you precisely\nwhat kind of thing you are dealing with, and therefore provides the\ninformation you need to decide on a correct icon.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3429479"}, {"subject": "RE: A simpler response ... RE: Working Resource Issues ..", "content": "I don't see where you addressed Stefan's question.\nAllowing multiple checkouts of the same version is\na key use case.  Limiting this to a single checkout\nis supported in an interoperable way by allowing the\nserver to set the DAV:checkout-fork property to DAV:forbidden.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Thursday, June 21, 2001 12:19 PM\nTo: 'Stefan Eissing'; 'DeltaV (E-mail)'\nSubject: A simpler response ... RE: Working Resource Issues ...\n\n\nThere is only one 'in-place-checkout' now, so perhaps we should insist\nthat any \"invisible\" in-place-checkout's should be unique.  Therefore,\nthe only difference is the visibility of the work in progress.\n\nThe only reason I made them different URL's is to preserve the semantics\nwhere if you PUT on a resource and then GET you are supposed to GET what\nyou just PUT.  Therefore, for the PUT's to be invisible it must be a\ndifferent URL.\n\nThis isn't much different than lock resource, GET, modifing the local\ncopy, PUT, unlock.\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of \n> Stefan Eissing\n> Sent: Thursday, June 21, 2001 7:20 AM\n> To: John Hall; 'DeltaV (E-mail)'\n> Subject: AW: Working Resource Issues ...\n> \n> \n> John,\n> \n> if I understand your proposal correctly, one user could not \n> have two working resources of the same version resource, \n> since there is only a single URL to access it. Correct?\n> \n> Wouldn't that be a major drawback for a versioning repository?\n> \n> Stefan\n> \n> > Von: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von John Hall\n> > \n> > \"If you remain calm while everyone else is panicking, then you \n> > probably don't understand the situation.\" -- old Naval saying.\n> > \n> > It appears that some of the long discussion on this topic has been \n> > prompted by completely different understandings of what a \n> > \"WORKING-RESOURCE\" is and should mean.\n> > \n> > I just thought it was a bit-bucket where the user could store his \n> > state until he was finished.  Check out VCR, get bit bucket, modify \n> > bit bucket, Check In.  The critical difference between \n> > Check-Out-In-Place and Check-Out-Working-Version was the \n> visibility of \n> > the bit bucket to other users.  In-Place, they can see it.  \n> > Working-Version, they can't.\n> > \n> > I've also mentioned that I'm concerned with 3rd party \n> emulation.  The \n> > 3rd party has a 'working version', and that is exactly how they \n> > implemented the concept.\n> > \n> > That IS NOT what this spec defines.  In the post conditions for 9.3 \n> > create-working-resource-from-checked-in-version the spec \n> states that \n> > \"... the version-controlled resource remains checked-in.\"\n> > \n> > That is why you have seen two operations when I've only \n> seen one, and \n> > need an UPDATE or MERGE.  Meanwhile, I'm going \"of COURSE \n> the VCR is \n> > checked out.  I got a successful return on my CHECKOUT \n> didn't I?\"  I \n> > think you should create a new verb (MKWORKING), personally.\n> > \n> > So how about leaving the WORKING-RESOURCE definition as-is \n> and modify \n> > the CHECKOUT-IN-PLACE feature to make invisibility to other users a\n> > (REQUIRED) option?  I think you will have to finesse a much smaller \n> > number of issues if you do that.  Since it is required, it doesn't \n> > raise the issue of client interoperability.  It is new \n> functionality; \n> > you can't do what I need to do with the spec defined as is.  And by \n> > moving it down there you don't confuse the complex 'package' issues \n> > Geoff raised.  You put it in the basic package, and you don't have \n> > clients trying to figure out why they have WORKING-RESOURCE \n> provided \n> > but not UPDATE or MERGE.\n> > \n> > 4.1.3  DAV:checkout-invisible\n> > \n> > Normally, edits made on a resource while checked out are visible to \n> > other users.  If checkout-invisible is specified, however, \n> other users \n> > will only see the last checked-in version.  A client is \n> encouraged to \n> > see this feature as \"lite\" version of WORKING-RESOURCE which leaves \n> > the VCR in the checked-out state.\n> > \n> > 4.2 CHECKOUT Marshalling:\n> > \n> > If the element checkout-invisible is present, the response MUST \n> > include a Location header.\n> > \n> > 4.6: Additional PUT / PROPPATCH semantics.\n> > \n> > If a Location header was returned with the CHECKOUT, the \n> URL specified \n> > in the Location header MUST be used for PUT and PROPPATCH requests. \n> > Otherwise, the server will return \n> > cannot-modify-version-controlled-content.\n> > \n> > 4.7: Additional DELETE semantics.\n> > \n> > A delete on the URL returned by a CHECKOUT Location header \n> will undo \n> > the CHECKOUT which created it.\n> > \n> > \n> \n> \n> \n\n\n\n", "id": "lists-006-3438345"}, {"subject": "RE: Working Resource Issues ..", "content": "> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of \n> Edgar@EdgarSchwarz.de\n> johnhall@evergo.net wrote:\n> > I've also mentioned that I'm concerned with 3rd party \n> emulation.  The \n> > 3rd party has a 'working version', and that is exactly how they \n> > implemented the concept.\n\n> Yes, I know tools which have a 'working version'. But this \n> means that a version has a state 'working' (modifiable) and \n> finally 'frozen'. More complexity that I would like to avoid. \n> You can get the same result by having a working resource and \n> a following UPDATE. I prefer the simpler concept in this case.\n\nI'm *asking* for the simpler case.\n\nThe current state of things is far more complex than what I have asked\nfor.  It is far more complex than some existing clients have asked for.\nAll I've really asked for is a CHECKOUT that means checkout, a working\nresource that isn't visible to the world, and a CHECKIN that means\ncheckin.\n\nThere is no need to introduce the additional complexity and operations\nof WORKSPACE, UPDATE, and MERGE, or to change the commonly understood\nimplications of the words 'checkin' and 'checkout'.  \n\nThe path of execution a client goes through under my proposal is almost\ncompletely identical to the check-out-in-place and let the world see\nyour stuff thread.  The workspace system isn't.\n\nIn common terminology we have an excellent word for 'frozen'.  CHECKIN.\n\n\n> \n> > 4.1.3  DAV:checkout-invisible\n> > Normally, edits made on a resource while checked out are visible to \n> > other users.  If checkout-invisible is specified, however, \n> other users \n> > will only see the last checked-in version.  A client is \n> encouraged to \n> > see this feature as \"lite\" version of WORKING-RESOURCE which leaves \n> > the VCR in the checked-out state.\n\n> You say you don't need UPDATE so here I say \n> that I don't need this invisible thing.\n\nSince I don't begrudge you your WORKSPACE, you shouldn't begrudge me\nthis 'invisible thing'. \n\nThe problem is that you want to compel me to either not deliver my\nfunctionality to my users, or to implment workspaces and bring in a load\nof other things / issues / complexity / problems.\n\nIf you HAVE implemented a workspace feature, then you have already\nimplemented 99% of this 'invisible thing'.  The reverse is far from\ntrue.\n\n\n> But this makes things difficult for the DAUs \n\nDon't worry about them, they'll be using my clients and not bothering\nwith WORKSPACE at all.\n\n> So if you delete \n> your working resource the versions history also can go down \n> the closet. \n\nMy working resources do not have their own independent version history,\nand I'm not sure you can really take that from the spec on WORKSPACE\neither.\n\n> We have thousands of source files which we have to \n> freeze in baselines. \n\nThen don't use my server, I don't support baselines.  And I've been\ninvolved in some very large systems projects with thousands of source\nfiles and millions of lines of code.  We got by without baselines and\ncode forking.  But my server isn't targeted to source code control, the\nidea of versioning has wider application than that.\n\n> Hey, the changes I \n> made today are wrong. Let's go back to and earlier version \n> (Perhaps not the last one). That's what UPDATE is for.\n\n1) that is what \"DELETE version\" is for.\n2) or CHECKOUT, GET old.version, FILE SAVEAS, CHECKIN if you'd prefer. \n\n> So at last my question: Couldn't agreee to implement UPDATE ? \n\nNO.\n\n> Not \n> that complex and uncommon I guess (co -r <filename>) Perhaps \n> we then could stop some threads which threaten to make the \n> spec more complex.\n\nIt has already been made complex.  I'm trying to add something to make\nthe complexity optional and ignorable.\n\n\n\n", "id": "lists-006-3452707"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "Which brings me back to the point I made a long time ago: Why can't the\ndefault for dump clients be \"zap the version history\"?\n\nWe already have the server option NOT to zap history if the server\ndoesn't want to do so.  I always thought that a default of 'ZAP it'\nunless instructed otherwise solved both problems.\n\nEarlier, Geoff said:\nFirst, I'd like to emphasize that I agree with the following \nstatements:\n- the protocol should support the explicit deletion of versions\n(although a server may refuse the deletion request)\n- servers will provide some mechanism for reclaiming space (possibly\ninvolving auto-archiving, and maybe even auto-deletion).\n================= SO ==========================\nWhy isn't \"servers will provide some mechanism for reclaiming space\n...maybe even auto-deletion\"\n\nSolved by having the server zap the version history on DELETE?  By not\nhaving a client tell the server what it wants to happen, you make it\nimpossible to separate an uninformed client from an informed client.\n\nIf the spec said an implementation MAY zap it unless directed not to do\nso, a smart DeltaV client knows what to do.  If it wants the version\nhistory destroyed, zap the VHR then the VCR.  If it doesn't, say so on\nthe DELETE.  Then it knows what will happen, consistently.  So the\nclient gets its consistency and the server dealing with older clients\ngets its flexibility in the presence of features like quota limitations.\n\nMeanwhile, a server that supports WORKSPACES and doesn't consider the\nreclimation of space orphaned by dump clients an issue can choose a\ndifferent default.  The default doesn't effect smart clients, only dumb\nones.  The dumb ones can't be confused, since they don't know they are\nusing a DeltaV server anyway.\n\nWhy isn't that better than having a server implement \"auto-deletion\"\nwithout any ability to effect the process?\n\nPeace\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Lisa \n> Dusseault\n> Sent: Thursday, June 21, 2001 12:00 PM\n> To: Jim Whitehead; DeltaV\n> Subject: RE: Removing a resource: A compromise that satisfies?\n> \n> \n> \n> Jim said:\n> > John, Lisa: Let me note that one of the foundations of your \n> argument \n> > in favor of this capability is an indirect appeal to \n> authority, namely \n> > the authority of your users/customers. Now, you almost certainly \n> > cannot (or don't want to) reveal the market research that \n> led to your \n> > position. But, let me note that when you (or anyone else on \n> the list) \n> > make this kind of argument, you have a responsibility to \n> ensure that \n> > you have, in fact done due diligence when reflecting your \n> customer's \n> > requirements.\n> \n> I thought it would be more informative to say that customers \n> wanted it, rather than to say that Xythos developers thought \n> it would be \"a good idea\". An appeal to (customer) authority \n> can be an even stronger argument than simply personal \n> experience or educated guesses, particularly in this case \n> where Geoff asked for \"use cases\".  Who can do a better job \n> of providing use cases than the customer?  But I accept the \n> due diligence point.\n> \n> Let me give a use case that's entirely non-opaque, where I \n> can give full details, and where the due-diligence is automatic.\n> \n> The site www.sharemation.com uses quotas.  We couldn't afford \n> to run this free service without quotas, and note that usage \n> numbers count both regular resources and stored versions.  We \n> also couldn't run this quota-based service without allowing \n> users to free up their quotas.\n> \n> So here's the problem scenario on Sharemation: user 'scrooge' \n> turns on versioning on /~scrooge/foo.txt through the UI or \n> through a hypothetical DeltaV client.  Then Scrooge uses Web \n> Folders one day to delete a bunch of stuff.  Web Folders \n> issues a plain DELETE, possibly even issuing DELETE on entire \n> collections.  Once Web Folders' DELETE is issued, Scrooge \n> would have no way of finding or cleaning out old versions or \n> version history resources that still are counted under his \n> quota.  Scrooge's quota would soon be unusable.\n> \n> This use case applies to any situation where quotas are \n> needed.  Just a few:\n>  - A university provides web storage and collaboration space \n> to its students and professors.  It limits this space \n> (quotas) in order to discourage improper use.\n>  - A ISP offers web site hosting to its customers, on a \n> fee-based service. Customers pay for their quota.\n>  - XDrive, IDrive etc. - all these free hosting services \n> (some of which supported Web Folders) restricted quota.\n> \n> Lisa\n> \n> \n\n\n\n", "id": "lists-006-3464858"}, {"subject": "RE: Working Resource Issues ..", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   ... In the post conditions for 9.3\n   create-working-resource-from-checked-in-version the spec states\n   that \"... the version-controlled resource remains checked-in.\"\n\n   That is why you have seen two operations when I've only seen one, and\n   need an UPDATE or MERGE.  Meanwhile, I'm going \"of COURSE the VCR is\n   checked out.  I got a successful return on my CHECKOUT didn't I?\"  I\n   think you should create a new verb (MKWORKING), personally.\n\nWe did discuss having two verbs a long time ago, but it seemed\nunnecessary (and it would raise the issue of which verb was called\nCHECKOUT, and therefore represented the *real* checkout :-).\n\n   So how about leaving the WORKING-RESOURCE definition as-is and modify\n   the CHECKOUT-IN-PLACE feature to make invisibility to other users a\n   (REQUIRED) option?\n\nThe whole point of CHECKOUT-IN-PLACE is to make the modifiable\nresource visible at the original URL, so that references to that\nresource see the intermediate states.  So we'd have to supplement\nthe existing functionality, not replace it, and an addition of this\nkind would need a compelling use case behind it.\n\n   I think you will have to finesse a much smaller\n   number of issues if you do that.  Since it is required, it doesn't raise\n   the issue of client interoperability.  It is new functionality; you\n   can't do what I need to do with the spec defined as is.  And by moving\n   it down there you don't confuse the complex 'package' issues Geoff\n   raised.  You put it in the basic package, and you don't have clients\n   trying to figure out why they have WORKING-RESOURCE provided but not\n   UPDATE or MERGE.\n\nCurrently clients don't have to figure out why they have\nworking-resource provided but not update, because there is no defined\npackage that has working-resource but not update.\n\nOn the other hand, I am sympathetic to servers that do not want to\nsupport update (heck, I tried to get rid of the update feature\nall together :-), which is why I think it is worth pursuing this\nthread.  But keep in mind that the protocol has already passed\nlast working group call, and is in the hands of the area director,\nso it would need to be a really glaring flaw for us to add/change\nthe protocol at this point (deletion is still fair game, though).\n\n   4.1.3  DAV:checkout-invisible\n\n   Normally, edits made on a resource while checked out are visible to\n   other users.  If checkout-invisible is specified, however, other users\n   will only see the last checked-in version.  A client is encouraged to\n   see this feature as \"lite\" version of WORKING-RESOURCE which leaves the\n   VCR in the checked-out state.\n\nHow do users see \"their\" checkouts?  We don't want to tie the\nversioning protocol to some kind of authentication mechanism.\n\n   4.2 CHECKOUT Marshalling:\n\n   If the element checkout-invisible is present, the response MUST include\n   a Location header.\n\n   4.6: Additional PUT / PROPPATCH semantics.\n\n   If a Location header was returned with the CHECKOUT, the URL specified\n   in the Location header MUST be used for PUT and PROPPATCH requests.\n   Otherwise, the server will return\n   cannot-modify-version-controlled-content.\n\n   4.7: Additional DELETE semantics.\n\n   A delete on the URL returned by a CHECKOUT Location header will undo the\n   CHECKOUT which created it.\n\nYou'd have to also define how every other HTTP method acts against\nthese \"invisible\" resources.  What about MOVE, LOCK, COPY?  (This\nwould make even lock-null resources look good in comparison :-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3478214"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "I agree with Lisa's argument that some servers will want to \nimplement quota services.  I just want to keep the quota services\nand policies orthogonal from the versioning services.\n\nSo how about the following:  I just delete the non-normative\ntext concerning version deletion from the \"how to remove a \nresource from version control\" sentence.  This then allows\nLisa's servers to do all the version deletion it wants without\nviolating anything in the protocol.\n\n(Just goes to show you how much trouble you can get into from\nan apparently innocuous \"explanation\" added to the text of the\nprotocol ... although this is nothing compared to the \"move is a\ncopy followed by a delete\" debacle :-).\n\nCheers,\nGeoff \n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Thursday, June 21, 2001 3:00 PM\nTo: Jim Whitehead; DeltaV\nSubject: RE: Removing a resource: A compromise that satisfies?\n\n\n\nJim said:\n> John, Lisa: Let me note that one of the foundations of your argument in\n> favor of this capability is an indirect appeal to authority, namely the\n> authority of your users/customers. Now, you almost certainly cannot (or\n> don't want to) reveal the market research that led to your position. But,\n> let me note that when you (or anyone else on the list) make this kind of\n> argument, you have a responsibility to ensure that you have, in fact done\n> due diligence when reflecting your customer's requirements.\n\nI thought it would be more informative to say that customers wanted it,\nrather than to say that Xythos developers thought it would be \"a good idea\".\nAn appeal to (customer) authority can be an even stronger argument than\nsimply personal experience or educated guesses, particularly in this case\nwhere Geoff asked for \"use cases\".  Who can do a better job of providing use\ncases than the customer?  But I accept the due diligence point.\n\nLet me give a use case that's entirely non-opaque, where I can give full\ndetails, and where the due-diligence is automatic.\n\nThe site www.sharemation.com uses quotas.  We couldn't afford to run this\nfree service without quotas, and note that usage numbers count both regular\nresources and stored versions.  We also couldn't run this quota-based\nservice without allowing users to free up their quotas.\n\nSo here's the problem scenario on Sharemation: user 'scrooge' turns on\nversioning on /~scrooge/foo.txt through the UI or through a hypothetical\nDeltaV client.  Then Scrooge uses Web Folders one day to delete a bunch of\nstuff.  Web Folders issues a plain DELETE, possibly even issuing DELETE on\nentire collections.  Once Web Folders' DELETE is issued, Scrooge would have\nno way of finding or cleaning out old versions or version history resources\nthat still are counted under his quota.  Scrooge's quota would soon be\nunusable.\n\nThis use case applies to any situation where quotas are needed.  Just a few:\n - A university provides web storage and collaboration space to its students\nand professors.  It limits this space (quotas) in order to discourage\nimproper use.\n - A ISP offers web site hosting to its customers, on a fee-based service.\nCustomers pay for their quota.\n - XDrive, IDrive etc. - all these free hosting services (some of which\nsupported Web Folders) restricted quota.\n\nLisa\n\n\n\n", "id": "lists-006-3489248"}, {"subject": "RE: A simpler response ... RE: Working Resource Issues ..", "content": "Assume the server wants to implement multiple concurrent checkouts.\n\nUser1: CHECKOUT /foo.txt <invisible>\nResponse:\nOK\nLocation: /invisible?file_id=4301&ver_id=7549\n\nUser2: CHECKOUT /foo.txt <invisible>\nResponse:\nOK\nLocation: /invisible?file_id=4301&ver_id=8051\n\nUser3: CHECKOUT /foo.txt <invisible>\nResponse:\nOK\nLocation: /invisible?file_id=4301&ver_id=9051\n\nUser1: PUT /invisible?file_id=4301&ver_id=7549\n\nUser2: DELETE /invisible?file_id=4301&ver_id=9051\n\nUser2: PUT /invisible?file_id=4301&ver_id=8051\n\nUser2: CHECKIN /invisible?file_id=4301&ver_id=8051\nResponse OK // I win!\n\nUser1: CHECKIN /invisible?file_id=4301&ver_id=7549\nResponse:\nConflict\n<cannot-modify-version-controlled-content/>\n\n========================================================\nAt that point you have a number of places you can go.  The simplest for\nUser1 is to vow to use a lock next time, but in this case (to be\npolite):\n\nGET /foo.txt\nDiff _local_copy_with_working_copy\nEdit _local_copy_with_working_copy\nPUT /invisible?file_id=4301&ver_id=7549\nCHECKOUT /foo.txt\nCHECKIN /invisible?file_id=4301&ver_id=7549\n========= OR if not polite ==============\nCHECKOUT /foo.txt\nCHECKIN /invisible?file_id=4301&ver_id=7549\n\n----------------------------\nIs that clear how multiple checkouts of the same version could work?\nBasically, you have the same mechanism you had with your\nWORKING-RESOURCE feature to allow multiple checkouts (the Location\nheader).  Now, ALLOWING mutliple checkouts yeilds the problem of\nconflict / merge resolution.  The simpliest policy is to make the user\nresolve it.\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> Sent: Thursday, June 21, 2001 1:58 PM\n> To: 'DeltaV (E-mail)'\n> Subject: RE: A simpler response ... RE: Working Resource Issues ...\n> \n> \n> I don't see where you addressed Stefan's question.\n> Allowing multiple checkouts of the same version is\n> a key use case.  Limiting this to a single checkout\n> is supported in an interoperable way by allowing the\n> server to set the DAV:checkout-fork property to DAV:forbidden.\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net]\n> Sent: Thursday, June 21, 2001 12:19 PM\n> To: 'Stefan Eissing'; 'DeltaV (E-mail)'\n> Subject: A simpler response ... RE: Working Resource Issues ...\n> \n> \n> There is only one 'in-place-checkout' now, so perhaps we \n> should insist that any \"invisible\" in-place-checkout's should \n> be unique.  Therefore, the only difference is the visibility \n> of the work in progress.\n> \n> The only reason I made them different URL's is to preserve \n> the semantics where if you PUT on a resource and then GET you \n> are supposed to GET what you just PUT.  Therefore, for the \n> PUT's to be invisible it must be a different URL.\n> \n> This isn't much different than lock resource, GET, modifing \n> the local copy, PUT, unlock.\n> \n> \n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of \n> > Stefan Eissing\n> > Sent: Thursday, June 21, 2001 7:20 AM\n> > To: John Hall; 'DeltaV (E-mail)'\n> > Subject: AW: Working Resource Issues ...\n> > \n> > \n> > John,\n> > \n> > if I understand your proposal correctly, one user could not\n> > have two working resources of the same version resource, \n> > since there is only a single URL to access it. Correct?\n> > \n> > Wouldn't that be a major drawback for a versioning repository?\n> > \n> > Stefan\n> > \n> > > Von: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von \n> John Hall\n> > > \n> > > \"If you remain calm while everyone else is panicking, then you\n> > > probably don't understand the situation.\" -- old Naval saying.\n> > > \n> > > It appears that some of the long discussion on this topic has been\n> > > prompted by completely different understandings of what a \n> > > \"WORKING-RESOURCE\" is and should mean.\n> > > \n> > > I just thought it was a bit-bucket where the user could store his\n> > > state until he was finished.  Check out VCR, get bit \n> bucket, modify \n> > > bit bucket, Check In.  The critical difference between \n> > > Check-Out-In-Place and Check-Out-Working-Version was the \n> > visibility of\n> > > the bit bucket to other users.  In-Place, they can see it.\n> > > Working-Version, they can't.\n> > > \n> > > I've also mentioned that I'm concerned with 3rd party\n> > emulation.  The\n> > > 3rd party has a 'working version', and that is exactly how they\n> > > implemented the concept.\n> > > \n> > > That IS NOT what this spec defines.  In the post \n> conditions for 9.3\n> > > create-working-resource-from-checked-in-version the spec \n> > states that\n> > > \"... the version-controlled resource remains checked-in.\"\n> > > \n> > > That is why you have seen two operations when I've only\n> > seen one, and\n> > > need an UPDATE or MERGE.  Meanwhile, I'm going \"of COURSE\n> > the VCR is\n> > > checked out.  I got a successful return on my CHECKOUT\n> > didn't I?\"  I\n> > > think you should create a new verb (MKWORKING), personally.\n> > > \n> > > So how about leaving the WORKING-RESOURCE definition as-is\n> > and modify\n> > > the CHECKOUT-IN-PLACE feature to make invisibility to \n> other users a\n> > > (REQUIRED) option?  I think you will have to finesse a \n> much smaller\n> > > number of issues if you do that.  Since it is required, \n> it doesn't \n> > > raise the issue of client interoperability.  It is new \n> > functionality;\n> > > you can't do what I need to do with the spec defined as \n> is.  And by\n> > > moving it down there you don't confuse the complex \n> 'package' issues \n> > > Geoff raised.  You put it in the basic package, and you \n> don't have \n> > > clients trying to figure out why they have WORKING-RESOURCE \n> > provided\n> > > but not UPDATE or MERGE.\n> > > \n> > > 4.1.3  DAV:checkout-invisible\n> > > \n> > > Normally, edits made on a resource while checked out are \n> visible to\n> > > other users.  If checkout-invisible is specified, however, \n> > other users\n> > > will only see the last checked-in version.  A client is\n> > encouraged to\n> > > see this feature as \"lite\" version of WORKING-RESOURCE \n> which leaves\n> > > the VCR in the checked-out state.\n> > > \n> > > 4.2 CHECKOUT Marshalling:\n> > > \n> > > If the element checkout-invisible is present, the response MUST\n> > > include a Location header.\n> > > \n> > > 4.6: Additional PUT / PROPPATCH semantics.\n> > > \n> > > If a Location header was returned with the CHECKOUT, the\n> > URL specified\n> > > in the Location header MUST be used for PUT and PROPPATCH \n> requests.\n> > > Otherwise, the server will return \n> > > cannot-modify-version-controlled-content.\n> > > \n> > > 4.7: Additional DELETE semantics.\n> > > \n> > > A delete on the URL returned by a CHECKOUT Location header\n> > will undo\n> > > the CHECKOUT which created it.\n> > > \n> > > \n> > \n> > \n> > \n> \n> \n> \n\n\n\n", "id": "lists-006-3500407"}, {"subject": "Why it's bad to rely on other information to determine typ", "content": "I just ran across an explanation for a RFC 2616 feature which leads me to\nbelieve that the feature should be implemented for all methods -- the Expect\nheader (See separate post to w3c-dist-auth for details).\n\nDo all your DAV servers support the Expect header properly on all methods?\nI suspect not.  CLients don't actually send it.  And yet, it's required by\nHTTP/1.1\n\nThis is an example of theoretical \"non-compliance\".  A required feature is\nmissing.  Oh horrors!  Note that it doesn't seriously impede\ninteroperability.  Perhaps nobody was sure how to use the feature.  Shrug.\n\nThe implication of a situation like this is that designers of a\nspecification cannot foresee how everything is going to fall out.  Not all\n\"required\" features may be implemented, and this might be OK.  If there was\nsome kind of \"allowed-headers-set\" that could be queried, a compliant client\nshould see \"Expect\" in there for all resources and all methods -- yet it\nwon't.\n\nRelying on a set of methods and properties supported in order to determine\ntype is brittle because of these kinds of failures of perfect foreknowledge.\nFor all Geoff's wisdom, it's conceivable that some REQUIRED live property\nwill end up not being supported by some, most, or all servers.  And that\nwould ruin a client's ability to use the supported-*-set values to see what\ntype things are.\n\nWe're human, and we could be wrong.  Please design a system that takes that\ninto account, and does not entirely break down if we do not predict the\nfuture completely accurately.\n\nLisa\n\n\n\n", "id": "lists-006-3518436"}, {"subject": "RE: A simpler response ... RE: Working Resource Issues ..", "content": "Stefan and I were interpreting \"unique\", when you said:\n\n> There is only one 'in-place-checkout' now, so perhaps we \n> should insist that any \"invisible\" in-place-checkout's should \n> be unique.  \n\nas saying that there could only be one \"invisible\"\ncheckout from a given version-controlled resource.\nSorry if we misunderstood what you were proposing.\n\nAs indicated in the previous message, though, it would not\nbe acceptable to replace the current checkout-in-place\nfeature with this invisible checkout-in-place feature,\nand since \"invisible checkout-in-place\" is basically\nidentical to the working-resource option except for\nthe \"update vcr\" functionality, it makes more sense to\ndiscuss this in the context of the working-resource\nfeature, and not the checkout-in-place feature.\n\nCheers,\nGeoff\n\n\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\nSent: Thursday, June 21, 2001 5:37 PM\nTo: 'Clemm, Geoff'; 'DeltaV (E-mail)'\nSubject: RE: A simpler response ... RE: Working Resource Issues ...\n\n\nAssume the server wants to implement multiple concurrent checkouts.\n\nUser1: CHECKOUT /foo.txt <invisible>\nResponse:\nOK\nLocation: /invisible?file_id=4301&ver_id=7549\n\nUser2: CHECKOUT /foo.txt <invisible>\nResponse:\nOK\nLocation: /invisible?file_id=4301&ver_id=8051\n\nUser3: CHECKOUT /foo.txt <invisible>\nResponse:\nOK\nLocation: /invisible?file_id=4301&ver_id=9051\n\nUser1: PUT /invisible?file_id=4301&ver_id=7549\n\nUser2: DELETE /invisible?file_id=4301&ver_id=9051\n\nUser2: PUT /invisible?file_id=4301&ver_id=8051\n\nUser2: CHECKIN /invisible?file_id=4301&ver_id=8051\nResponse OK // I win!\n\nUser1: CHECKIN /invisible?file_id=4301&ver_id=7549\nResponse:\nConflict\n<cannot-modify-version-controlled-content/>\n\n========================================================\nAt that point you have a number of places you can go.  The simplest for\nUser1 is to vow to use a lock next time, but in this case (to be\npolite):\n\nGET /foo.txt\nDiff _local_copy_with_working_copy\nEdit _local_copy_with_working_copy\nPUT /invisible?file_id=4301&ver_id=7549\nCHECKOUT /foo.txt\nCHECKIN /invisible?file_id=4301&ver_id=7549\n========= OR if not polite ==============\nCHECKOUT /foo.txt\nCHECKIN /invisible?file_id=4301&ver_id=7549\n\n----------------------------\nIs that clear how multiple checkouts of the same version could work?\nBasically, you have the same mechanism you had with your\nWORKING-RESOURCE feature to allow multiple checkouts (the Location\nheader).  Now, ALLOWING mutliple checkouts yeilds the problem of\nconflict / merge resolution.  The simpliest policy is to make the user\nresolve it.\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> Sent: Thursday, June 21, 2001 1:58 PM\n> To: 'DeltaV (E-mail)'\n> Subject: RE: A simpler response ... RE: Working Resource Issues ...\n> \n> \n> I don't see where you addressed Stefan's question.\n> Allowing multiple checkouts of the same version is\n> a key use case.  Limiting this to a single checkout\n> is supported in an interoperable way by allowing the\n> server to set the DAV:checkout-fork property to DAV:forbidden.\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net]\n> Sent: Thursday, June 21, 2001 12:19 PM\n> To: 'Stefan Eissing'; 'DeltaV (E-mail)'\n> Subject: A simpler response ... RE: Working Resource Issues ...\n> \n> \n> There is only one 'in-place-checkout' now, so perhaps we \n> should insist that any \"invisible\" in-place-checkout's should \n> be unique.  Therefore, the only difference is the visibility \n> of the work in progress.\n> \n> The only reason I made them different URL's is to preserve \n> the semantics where if you PUT on a resource and then GET you \n> are supposed to GET what you just PUT.  Therefore, for the \n> PUT's to be invisible it must be a different URL.\n> \n> This isn't much different than lock resource, GET, modifing \n> the local copy, PUT, unlock.\n> \n> \n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of \n> > Stefan Eissing\n> > Sent: Thursday, June 21, 2001 7:20 AM\n> > To: John Hall; 'DeltaV (E-mail)'\n> > Subject: AW: Working Resource Issues ...\n> > \n> > \n> > John,\n> > \n> > if I understand your proposal correctly, one user could not\n> > have two working resources of the same version resource, \n> > since there is only a single URL to access it. Correct?\n> > \n> > Wouldn't that be a major drawback for a versioning repository?\n> > \n> > Stefan\n> > \n> > > Von: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von \n> John Hall\n> > > \n> > > \"If you remain calm while everyone else is panicking, then you\n> > > probably don't understand the situation.\" -- old Naval saying.\n> > > \n> > > It appears that some of the long discussion on this topic has been\n> > > prompted by completely different understandings of what a \n> > > \"WORKING-RESOURCE\" is and should mean.\n> > > \n> > > I just thought it was a bit-bucket where the user could store his\n> > > state until he was finished.  Check out VCR, get bit \n> bucket, modify \n> > > bit bucket, Check In.  The critical difference between \n> > > Check-Out-In-Place and Check-Out-Working-Version was the \n> > visibility of\n> > > the bit bucket to other users.  In-Place, they can see it.\n> > > Working-Version, they can't.\n> > > \n> > > I've also mentioned that I'm concerned with 3rd party\n> > emulation.  The\n> > > 3rd party has a 'working version', and that is exactly how they\n> > > implemented the concept.\n> > > \n> > > That IS NOT what this spec defines.  In the post \n> conditions for 9.3\n> > > create-working-resource-from-checked-in-version the spec \n> > states that\n> > > \"... the version-controlled resource remains checked-in.\"\n> > > \n> > > That is why you have seen two operations when I've only\n> > seen one, and\n> > > need an UPDATE or MERGE.  Meanwhile, I'm going \"of COURSE\n> > the VCR is\n> > > checked out.  I got a successful return on my CHECKOUT\n> > didn't I?\"  I\n> > > think you should create a new verb (MKWORKING), personally.\n> > > \n> > > So how about leaving the WORKING-RESOURCE definition as-is\n> > and modify\n> > > the CHECKOUT-IN-PLACE feature to make invisibility to \n> other users a\n> > > (REQUIRED) option?  I think you will have to finesse a \n> much smaller\n> > > number of issues if you do that.  Since it is required, \n> it doesn't \n> > > raise the issue of client interoperability.  It is new \n> > functionality;\n> > > you can't do what I need to do with the spec defined as \n> is.  And by\n> > > moving it down there you don't confuse the complex \n> 'package' issues \n> > > Geoff raised.  You put it in the basic package, and you \n> don't have \n> > > clients trying to figure out why they have WORKING-RESOURCE \n> > provided\n> > > but not UPDATE or MERGE.\n> > > \n> > > 4.1.3  DAV:checkout-invisible\n> > > \n> > > Normally, edits made on a resource while checked out are \n> visible to\n> > > other users.  If checkout-invisible is specified, however, \n> > other users\n> > > will only see the last checked-in version.  A client is\n> > encouraged to\n> > > see this feature as \"lite\" version of WORKING-RESOURCE \n> which leaves\n> > > the VCR in the checked-out state.\n> > > \n> > > 4.2 CHECKOUT Marshalling:\n> > > \n> > > If the element checkout-invisible is present, the response MUST\n> > > include a Location header.\n> > > \n> > > 4.6: Additional PUT / PROPPATCH semantics.\n> > > \n> > > If a Location header was returned with the CHECKOUT, the\n> > URL specified\n> > > in the Location header MUST be used for PUT and PROPPATCH \n> requests.\n> > > Otherwise, the server will return \n> > > cannot-modify-version-controlled-content.\n> > > \n> > > 4.7: Additional DELETE semantics.\n> > > \n> > > A delete on the URL returned by a CHECKOUT Location header\n> > will undo\n> > > the CHECKOUT which created it.\n> > > \n> > > \n> > \n> > \n> > \n> \n> \n> \n\n\n\n", "id": "lists-006-3527299"}, {"subject": "RE: A simpler response ... RE: Working Resource Issues ..", "content": "I am assuming this is a case where the server does not support forking. Why \ndid the second and third checkout succeed? /foo.txt should have changed \ninto a checked out resource after the first checkout.\n\nCould you explain how and why User2 deleted the invisible resource for User3?\n\nAt 02:37 PM 6/21/01 -0700, John Hall wrote:\n>Assume the server wants to implement multiple concurrent checkouts.\n>\n>User1: CHECKOUT /foo.txt <invisible>\n>Response:\n>OK\n>Location: /invisible?file_id=4301&ver_id=7549\n>\n>User2: CHECKOUT /foo.txt <invisible>\n>Response:\n>OK\n>Location: /invisible?file_id=4301&ver_id=8051\n>\n>User3: CHECKOUT /foo.txt <invisible>\n>Response:\n>OK\n>Location: /invisible?file_id=4301&ver_id=9051\n>\n>User1: PUT /invisible?file_id=4301&ver_id=7549\n>\n>User2: DELETE /invisible?file_id=4301&ver_id=9051\n>\n>User2: PUT /invisible?file_id=4301&ver_id=8051\n>\n>User2: CHECKIN /invisible?file_id=4301&ver_id=8051\n>Response OK // I win!\n>\n>User1: CHECKIN /invisible?file_id=4301&ver_id=7549\n>Response:\n>Conflict\n><cannot-modify-version-controlled-content/>\n>\n>========================================================\n>At that point you have a number of places you can go.  The simplest for\n>User1 is to vow to use a lock next time, but in this case (to be\n>polite):\n>\n>GET /foo.txt\n>Diff _local_copy_with_working_copy\n>Edit _local_copy_with_working_copy\n>PUT /invisible?file_id=4301&ver_id=7549\n>CHECKOUT /foo.txt\n>CHECKIN /invisible?file_id=4301&ver_id=7549\n>========= OR if not polite ==============\n>CHECKOUT /foo.txt\n>CHECKIN /invisible?file_id=4301&ver_id=7549\n>\n>----------------------------\n>Is that clear how multiple checkouts of the same version could work?\n>Basically, you have the same mechanism you had with your\n>WORKING-RESOURCE feature to allow multiple checkouts (the Location\n>header).  Now, ALLOWING mutliple checkouts yeilds the problem of\n>conflict / merge resolution.  The simpliest policy is to make the user\n>resolve it.\n>\n>\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> > Sent: Thursday, June 21, 2001 1:58 PM\n> > To: 'DeltaV (E-mail)'\n> > Subject: RE: A simpler response ... RE: Working Resource Issues ...\n> >\n> >\n> > I don't see where you addressed Stefan's question.\n> > Allowing multiple checkouts of the same version is\n> > a key use case.  Limiting this to a single checkout\n> > is supported in an interoperable way by allowing the\n> > server to set the DAV:checkout-fork property to DAV:forbidden.\n> >\n> > Cheers,\n> > Geoff\n> >\n> > -----Original Message-----\n> > From: John Hall [mailto:johnhall@evergo.net]\n> > Sent: Thursday, June 21, 2001 12:19 PM\n> > To: 'Stefan Eissing'; 'DeltaV (E-mail)'\n> > Subject: A simpler response ... RE: Working Resource Issues ...\n> >\n> >\n> > There is only one 'in-place-checkout' now, so perhaps we\n> > should insist that any \"invisible\" in-place-checkout's should\n> > be unique.  Therefore, the only difference is the visibility\n> > of the work in progress.\n> >\n> > The only reason I made them different URL's is to preserve\n> > the semantics where if you PUT on a resource and then GET you\n> > are supposed to GET what you just PUT.  Therefore, for the\n> > PUT's to be invisible it must be a different URL.\n> >\n> > This isn't much different than lock resource, GET, modifing\n> > the local copy, PUT, unlock.\n> >\n> >\n> >\n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of\n> > > Stefan Eissing\n> > > Sent: Thursday, June 21, 2001 7:20 AM\n> > > To: John Hall; 'DeltaV (E-mail)'\n> > > Subject: AW: Working Resource Issues ...\n> > >\n> > >\n> > > John,\n> > >\n> > > if I understand your proposal correctly, one user could not\n> > > have two working resources of the same version resource,\n> > > since there is only a single URL to access it. Correct?\n> > >\n> > > Wouldn't that be a major drawback for a versioning repository?\n> > >\n> > > Stefan\n> > >\n> > > > Von: ietf-dav-versioning-request@w3.org\n> > > > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von\n> > John Hall\n> > > >\n> > > > \"If you remain calm while everyone else is panicking, then you\n> > > > probably don't understand the situation.\" -- old Naval saying.\n> > > >\n> > > > It appears that some of the long discussion on this topic has been\n> > > > prompted by completely different understandings of what a\n> > > > \"WORKING-RESOURCE\" is and should mean.\n> > > >\n> > > > I just thought it was a bit-bucket where the user could store his\n> > > > state until he was finished.  Check out VCR, get bit\n> > bucket, modify\n> > > > bit bucket, Check In.  The critical difference between\n> > > > Check-Out-In-Place and Check-Out-Working-Version was the\n> > > visibility of\n> > > > the bit bucket to other users.  In-Place, they can see it.\n> > > > Working-Version, they can't.\n> > > >\n> > > > I've also mentioned that I'm concerned with 3rd party\n> > > emulation.  The\n> > > > 3rd party has a 'working version', and that is exactly how they\n> > > > implemented the concept.\n> > > >\n> > > > That IS NOT what this spec defines.  In the post\n> > conditions for 9.3\n> > > > create-working-resource-from-checked-in-version the spec\n> > > states that\n> > > > \"... the version-controlled resource remains checked-in.\"\n> > > >\n> > > > That is why you have seen two operations when I've only\n> > > seen one, and\n> > > > need an UPDATE or MERGE.  Meanwhile, I'm going \"of COURSE\n> > > the VCR is\n> > > > checked out.  I got a successful return on my CHECKOUT\n> > > didn't I?\"  I\n> > > > think you should create a new verb (MKWORKING), personally.\n> > > >\n> > > > So how about leaving the WORKING-RESOURCE definition as-is\n> > > and modify\n> > > > the CHECKOUT-IN-PLACE feature to make invisibility to\n> > other users a\n> > > > (REQUIRED) option?  I think you will have to finesse a\n> > much smaller\n> > > > number of issues if you do that.  Since it is required,\n> > it doesn't\n> > > > raise the issue of client interoperability.  It is new\n> > > functionality;\n> > > > you can't do what I need to do with the spec defined as\n> > is.  And by\n> > > > moving it down there you don't confuse the complex\n> > 'package' issues\n> > > > Geoff raised.  You put it in the basic package, and you\n> > don't have\n> > > > clients trying to figure out why they have WORKING-RESOURCE\n> > > provided\n> > > > but not UPDATE or MERGE.\n> > > >\n> > > > 4.1.3  DAV:checkout-invisible\n> > > >\n> > > > Normally, edits made on a resource while checked out are\n> > visible to\n> > > > other users.  If checkout-invisible is specified, however,\n> > > other users\n> > > > will only see the last checked-in version.  A client is\n> > > encouraged to\n> > > > see this feature as \"lite\" version of WORKING-RESOURCE\n> > which leaves\n> > > > the VCR in the checked-out state.\n> > > >\n> > > > 4.2 CHECKOUT Marshalling:\n> > > >\n> > > > If the element checkout-invisible is present, the response MUST\n> > > > include a Location header.\n> > > >\n> > > > 4.6: Additional PUT / PROPPATCH semantics.\n> > > >\n> > > > If a Location header was returned with the CHECKOUT, the\n> > > URL specified\n> > > > in the Location header MUST be used for PUT and PROPPATCH\n> > requests.\n> > > > Otherwise, the server will return\n> > > > cannot-modify-version-controlled-content.\n> > > >\n> > > > 4.7: Additional DELETE semantics.\n> > > >\n> > > > A delete on the URL returned by a CHECKOUT Location header\n> > > will undo\n> > > > the CHECKOUT which created it.\n> > > >\n> > > >\n> > >\n> > >\n> > >\n> >\n> >\n> >\n\n\n\n", "id": "lists-006-3546171"}, {"subject": "RE: Working Resource Issues ..", "content": "The challenge of writing a protocol is not to make it work\nfor a wide variety of servers, and many of the servers today\nrequire workspace functionality.  Therefore ignoring the requirements\nfor compatibility with servers that support workspaces is\nnot an effective path forward.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: John Hall [mailto:johnhall@evergo.net]\n\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of \n> Edgar@EdgarSchwarz.de\n> johnhall@evergo.net wrote:\n> > I've also mentioned that I'm concerned with 3rd party \n> emulation.  The \n> > 3rd party has a 'working version', and that is exactly how they \n> > implemented the concept.\n\nThe current state of things is far more complex than what I have asked\nfor.  It is far more complex than some existing clients have asked for.\nAll I've really asked for is a CHECKOUT that means checkout, a working\nresource that isn't visible to the world, and a CHECKIN that means\ncheckin.\n\nThere is no need to introduce the additional complexity and operations\nof WORKSPACE, UPDATE, and MERGE, or to change the commonly understood\nimplications of the words 'checkin' and 'checkout'.  \n\nThe path of execution a client goes through under my proposal is almost\ncompletely identical to the check-out-in-place and let the world see\nyour stuff thread.  The workspace system isn't.\n\nIn common terminology we have an excellent word for 'frozen'.  CHECKIN.\n\n\n> \n> > 4.1.3  DAV:checkout-invisible\n> > Normally, edits made on a resource while checked out are visible to \n> > other users.  If checkout-invisible is specified, however, \n> other users \n> > will only see the last checked-in version.  A client is \n> encouraged to \n> > see this feature as \"lite\" version of WORKING-RESOURCE which leaves \n> > the VCR in the checked-out state.\n\n> You say you don't need UPDATE so here I say \n> that I don't need this invisible thing.\n\nSince I don't begrudge you your WORKSPACE, you shouldn't begrudge me\nthis 'invisible thing'. \n\nThe problem is that you want to compel me to either not deliver my\nfunctionality to my users, or to implment workspaces and bring in a load\nof other things / issues / complexity / problems.\n\nIf you HAVE implemented a workspace feature, then you have already\nimplemented 99% of this 'invisible thing'.  The reverse is far from\ntrue.\n\n\n> But this makes things difficult for the DAUs \n\nDon't worry about them, they'll be using my clients and not bothering\nwith WORKSPACE at all.\n\n> So if you delete \n> your working resource the versions history also can go down \n> the closet. \n\nMy working resources do not have their own independent version history,\nand I'm not sure you can really take that from the spec on WORKSPACE\neither.\n\n> We have thousands of source files which we have to \n> freeze in baselines. \n\nThen don't use my server, I don't support baselines.  And I've been\ninvolved in some very large systems projects with thousands of source\nfiles and millions of lines of code.  We got by without baselines and\ncode forking.  But my server isn't targeted to source code control, the\nidea of versioning has wider application than that.\n\n> Hey, the changes I \n> made today are wrong. Let's go back to and earlier version \n> (Perhaps not the last one). That's what UPDATE is for.\n\n1) that is what \"DELETE version\" is for.\n2) or CHECKOUT, GET old.version, FILE SAVEAS, CHECKIN if you'd prefer. \n\n> So at last my question: Couldn't agreee to implement UPDATE ? \n\nNO.\n\n> Not \n> that complex and uncommon I guess (co -r <filename>) Perhaps \n> we then could stop some threads which threaten to make the \n> spec more complex.\n\nIt has already been made complex.  I'm trying to add something to make\nthe complexity optional and ignorable.\n\n\n\n", "id": "lists-006-3565242"}, {"subject": "RE: Working Resource Issues ..", "content": "> \n> The whole point of CHECKOUT-IN-PLACE is to make the \n> modifiable resource visible at the original URL, so that \n> references to that resource see the intermediate states.  So \n> we'd have to supplement the existing functionality, not \n> replace it, and an addition of this kind would need a \n> compelling use case behind it.\n\n\nI'm talking about a supplement, not a replacement.\n\nThe compelling case is that the feature is useful (otherwise you\nwouldn't have WORKING-RESOURCE) supports logic that parallels existing\nversioning clients (prior art) and is inclusive of the requirements that\ncompanies attempting to implement the spec consider critical.\n\n> ... so it would need to be a \n> really glaring flaw for us to add/change the protocol at this \n> point (deletion is still fair game, though).\n\nHow do you determine glaring flaw?  It meets my definition, and the use\ncase is not unheard of if you are sympathetic to servers that don't want\nto support UPDATE.\n\n>    4.1.3  DAV:checkout-invisible\n> \n> How do users see \"their\" checkouts?  We don't want to tie the \n> versioning protocol to some kind of authentication mechanism.\n\nSame way you do for WORKING-RESOURCE -- by responding with a Location\nrecord.\n\n>    4.7: Additional DELETE semantics.\n> \n>    A delete on the URL returned by a CHECKOUT Location header \n> will undo the\n>    CHECKOUT which created it.\n> \n> You'd have to also define how every other HTTP method acts \n> against these \"invisible\" resources.  What about MOVE, LOCK, \n> COPY?  (This would make even lock-null resources look good in \n> comparison :-).\n\nWell, the spec doesn't define how a checkout-in-place works against\nthese verbs, either.\n\nMOVE: See 9.7\nCOPY: See 9.6\nLOCK: Locks the VCR.\nUNLOCK: Unlocks the VCR.\nPROPFIND, PROPPATCH, PUT, GET: see 2518\nDELETE: already addressed\nAnything not mentioned: behaves as if issued against the VCR.\n\n\n\n", "id": "lists-006-3577531"}, {"subject": "RE: Removing a resource: A compromise that satisfies", "content": "Works for me.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> Sent: Thursday, June 21, 2001 2:22 PM\n> To: DeltaV\n> Subject: RE: Removing a resource: A compromise that satisfies?\n> \n> \n> I agree with Lisa's argument that some servers will want to \n> implement quota services.  I just want to keep the quota \n> services and policies orthogonal from the versioning services.\n> \n> So how about the following:  I just delete the non-normative \n> text concerning version deletion from the \"how to remove a \n> resource from version control\" sentence.  This then allows \n> Lisa's servers to do all the version deletion it wants \n> without violating anything in the protocol.\n> \n> (Just goes to show you how much trouble you can get into from \n> an apparently innocuous \"explanation\" added to the text of \n> the protocol ... although this is nothing compared to the \n> \"move is a copy followed by a delete\" debacle :-).\n> \n> Cheers,\n> Geoff \n> \n> -----Original Message-----\n> From: Lisa Dusseault [mailto:lisa@xythos.com]\n> Sent: Thursday, June 21, 2001 3:00 PM\n> To: Jim Whitehead; DeltaV\n> Subject: RE: Removing a resource: A compromise that satisfies?\n> \n> \n> \n> Jim said:\n> > John, Lisa: Let me note that one of the foundations of your \n> argument \n> > in favor of this capability is an indirect appeal to \n> authority, namely \n> > the authority of your users/customers. Now, you almost certainly \n> > cannot (or don't want to) reveal the market research that \n> led to your \n> > position. But, let me note that when you (or anyone else on \n> the list) \n> > make this kind of argument, you have a responsibility to \n> ensure that \n> > you have, in fact done due diligence when reflecting your \n> customer's \n> > requirements.\n> \n> I thought it would be more informative to say that customers \n> wanted it, rather than to say that Xythos developers thought \n> it would be \"a good idea\". An appeal to (customer) authority \n> can be an even stronger argument than simply personal \n> experience or educated guesses, particularly in this case \n> where Geoff asked for \"use cases\".  Who can do a better job \n> of providing use cases than the customer?  But I accept the \n> due diligence point.\n> \n> Let me give a use case that's entirely non-opaque, where I \n> can give full details, and where the due-diligence is automatic.\n> \n> The site www.sharemation.com uses quotas.  We couldn't afford \n> to run this free service without quotas, and note that usage \n> numbers count both regular resources and stored versions.  We \n> also couldn't run this quota-based service without allowing \n> users to free up their quotas.\n> \n> So here's the problem scenario on Sharemation: user 'scrooge' \n> turns on versioning on /~scrooge/foo.txt through the UI or \n> through a hypothetical DeltaV client.  Then Scrooge uses Web \n> Folders one day to delete a bunch of stuff.  Web Folders \n> issues a plain DELETE, possibly even issuing DELETE on entire \n> collections.  Once Web Folders' DELETE is issued, Scrooge \n> would have no way of finding or cleaning out old versions or \n> version history resources that still are counted under his \n> quota.  Scrooge's quota would soon be unusable.\n> \n> This use case applies to any situation where quotas are \n> needed.  Just a few:\n>  - A university provides web storage and collaboration space \n> to its students and professors.  It limits this space \n> (quotas) in order to discourage improper use.\n>  - A ISP offers web site hosting to its customers, on a \n> fee-based service. Customers pay for their quota.\n>  - XDrive, IDrive etc. - all these free hosting services \n> (some of which supported Web Folders) restricted quota.\n> \n> Lisa\n> \n> \n\n\n\n", "id": "lists-006-3586757"}, {"subject": "RE: DAV:resourcetyp", "content": "> [Tim's logic process mostly deleted]\n\nProbably best place for it <g>.\n\n> > Ok, now we bring the workspace under version control.  By the\n> > same argument\n> > you wouldn't use <DAV:version-controlled-workspace-collection/>, but\n> > rather:\n> >\n> >   <DAV:resourcetype>\n> >     <DAV:workspace/>\n> >     <DAV:collection/>\n> >     <DAV:version-controlled/>\n> >   </DAV:resourcetype>\n> >\n>\n> Tim, at this point, you're taking the argument rather father than I, for\n> one, would wish you to.\n\n[snip]\n\n> I've always prefered to have type defined as something which\n> changes rather unfrequently, perhaps never.  So we could stop\n> before version-controlled is added to the resourcetype.\n\nI'm surprised that you think a resource may be brought under version\ncontrol, then taken out of version control, very often -- but it is a\njudgement call, so whatever.\n\n> Both version-controlled and non-version-controlled workspaces\n> could be represented as\n>   <DAV:resourcetype><DAV:workspace/><DAV:collection/></DAV:resourcetype>\n\nOk, and to detect if the resource is version-controlled you would presumably\n... look at the DAV:supported-*-set(s) properties? or fish (PROPFIND) for\nspecific properties.\n\n> As you point out, this allows clients to easily recognize that\n> the workspace can be treated as a collection for depth requests\n> and other purposes.\n\nAgreed.  We should retain the RFC2518-way of denoting a collection so that\nwe do not disturb the existing clients (or require a change to RFC2518).\n\n> They don't need to know if it's version-controlled to be able\n> to deal with it; that's a major feature of the DeltaV specification.\n\n\"deal with it [as a collection]\".  Agreed.  Clients can deal with it as a\ncollection using the RFC2518 procedure for detecting collection-type.\n\nVersioning clients that are interested whether a resource is, say,\nversion-controlled or checked-in would use some other mechanism for\ndetermining the resource state.\n\nHopefully you agree that we have to say in the DeltaV spec. what that\nmechanism is, and I'm cool with that.\n\n> If there's a version of a baseline, I'd represent it as\n>\n> <DAV:resourcetype><DAV:workspace/><DAV:collection/><DAV:version/><\n> /DAV:resourcetype>\n\nNot so, since a baseline is neither a workspace nor a collection.  It does\nnot behave like a collection (i.e., support collection-type methods such as\nMKCOL and Depth: operations); and it does not act like a workspace (i.e.,\nhave DAV:workspace-checkout-set property).\n\nMy point is only that we need to specify what it means for a resource to\nhave those elements in the resource type.\n\n> Tim said:\n> > The only workable solution is to make DAV:resourcetype a *set*\n> > of types and/or states.\n>\n> That's incorrect.  There are other workable solutions.  State can be\n> indicated in other ways.  We don't put <DAV:locked/> into the resourcetype\n> in the base DAV specification -- we have <DAV:lockdiscovery> to do a much\n> better job of this.  Similarly, we don't need to put checkin/checkout\nstate,\n> or even version-controlled state into the resourcetype.  Although, as you\n> point out, we could.\n\nI _really_ don't want to go round the state vs. type argument again, so\nwould you like that original statement better if I said:\n  \"The only workable solution is to make DAV:resourcetype a *set* of\nclassifiers.\"\n(You can choose your favourite word here, but the point is that the value\nwill be a _set_.)\n\nEach element in the DAV:resourcetype value names what you can expect the\nresource to support in terms of methods and/or properties.\n\n> > Now, tell me how is this different to DAV:supported-*-set?\n>\n> It is different.\n>  - It's less variable.  Supported-*-set can contain a whole mess of things\n> depending on what the server chooses to implement.\n\nThis is true.\n\n>  - It's more directly purposed.  Supported-*-set is not intended\n> to show the type of things.\n\nI thought we were debating that <g>.\n\n> As JimA points out, just because two things support method\n> FOO, doesn't mean they have the same behaviour when you tell\n> them to FOO.\n\nI agree.  (I don't think anyone suggested that would happen.)\n\n>  - It more closely maps to what the client needs to know first\n> of all -- that is, what *kind* of thing is this so that I can\n> display a correct icon when the user browses.  Afterward, the\n> client may need to know the supported-*-set for other purposes.\n\nMaybe, depending upon the values we choose for DAV:resourcetype.  I can\nimagine clients wanting to know if a resource is mutable or not in order to\ndetermine the correct icon, menu options to offer, etc.\n\n\nI've said it before, but I'll say it again, I don't believe that this is a\nfundamental problem in the specification that should cause any hold up.  I\nhave no problem with defining elements to add in to DAV:resourcetype that\nrepresent a classification/type/category of behavior for a resource.\nHowever, such elements MUST have a well-defined meaning in terms of the\nproperties they imply are supported and the methods it imply are supported.\nObviously we cannot have an element meaning one thing for one server and\nanother thing for another server.\n\nI would like to put on record that I believe that such an element is\nredundant, since if it is well-defined in terms of the properties and\nmethods it implies, that information WILL also be available in the\nDAV:supported-*-set properties (yes, most likely as a sub-set of the entire\nsupported-*-set values).\n\nI will further point out, merely as an observation, that the process for\ndetecting the defined subset of properties and methods in the\nDAV:supported-*-set values is going to be no more difficult than detecting\nthe subset of elements in the DAV:resourcetype value.  And, clients that\nretrieve the DAV:supported-*-set values can determine state and other\ninformation without subsequent interaction with the server (the client gets\nit all in one gulp).\n\nWe will be interoperable.  It will work for both of us.  Let's wrap this up\nand move on.\n\nTim\n\n\n\n", "id": "lists-006-3599202"}, {"subject": "RE: Working Resource Issues ..", "content": "I'm not asking you to ignore the needs of workspace functionality.  \n\nIndeed, I moved my focus to make the seperation easier to understand.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> Sent: Thursday, June 21, 2001 3:26 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Working Resource Issues ...\n> \n> \n> The challenge of writing a protocol is not to make it work\n> for a wide variety of servers, and many of the servers today \n> require workspace functionality.  Therefore ignoring the \n> requirements for compatibility with servers that support \n> workspaces is not an effective path forward.\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: John Hall [mailto:johnhall@evergo.net]\n> \n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of \n> > Edgar@EdgarSchwarz.de\n> > johnhall@evergo.net wrote:\n> > > I've also mentioned that I'm concerned with 3rd party\n> > emulation.  The\n> > > 3rd party has a 'working version', and that is exactly how they\n> > > implemented the concept.\n> \n> The current state of things is far more complex than what I \n> have asked for.  It is far more complex than some existing \n> clients have asked for. All I've really asked for is a \n> CHECKOUT that means checkout, a working resource that isn't \n> visible to the world, and a CHECKIN that means checkin.\n> \n> There is no need to introduce the additional complexity and \n> operations of WORKSPACE, UPDATE, and MERGE, or to change the \n> commonly understood implications of the words 'checkin' and \n> 'checkout'.  \n> \n> The path of execution a client goes through under my proposal \n> is almost completely identical to the check-out-in-place and \n> let the world see your stuff thread.  The workspace system isn't.\n> \n> In common terminology we have an excellent word for 'frozen'. \n>  CHECKIN.\n> \n> \n> > \n> > > 4.1.3  DAV:checkout-invisible\n> > > Normally, edits made on a resource while checked out are \n> visible to\n> > > other users.  If checkout-invisible is specified, however, \n> > other users\n> > > will only see the last checked-in version.  A client is\n> > encouraged to\n> > > see this feature as \"lite\" version of WORKING-RESOURCE \n> which leaves\n> > > the VCR in the checked-out state.\n> \n> > You say you don't need UPDATE so here I say\n> > that I don't need this invisible thing.\n> \n> Since I don't begrudge you your WORKSPACE, you shouldn't \n> begrudge me this 'invisible thing'. \n> \n> The problem is that you want to compel me to either not \n> deliver my functionality to my users, or to implment \n> workspaces and bring in a load of other things / issues / \n> complexity / problems.\n> \n> If you HAVE implemented a workspace feature, then you have \n> already implemented 99% of this 'invisible thing'.  The \n> reverse is far from true.\n> \n> \n> > But this makes things difficult for the DAUs\n> \n> Don't worry about them, they'll be using my clients and not \n> bothering with WORKSPACE at all.\n> \n> > So if you delete\n> > your working resource the versions history also can go down \n> > the closet. \n> \n> My working resources do not have their own independent \n> version history, and I'm not sure you can really take that \n> from the spec on WORKSPACE either.\n> \n> > We have thousands of source files which we have to\n> > freeze in baselines. \n> \n> Then don't use my server, I don't support baselines.  And \n> I've been involved in some very large systems projects with \n> thousands of source files and millions of lines of code.  We \n> got by without baselines and code forking.  But my server \n> isn't targeted to source code control, the idea of versioning \n> has wider application than that.\n> \n> > Hey, the changes I\n> > made today are wrong. Let's go back to and earlier version \n> > (Perhaps not the last one). That's what UPDATE is for.\n> \n> 1) that is what \"DELETE version\" is for.\n> 2) or CHECKOUT, GET old.version, FILE SAVEAS, CHECKIN if \n> you'd prefer. \n> \n> > So at last my question: Couldn't agreee to implement UPDATE ?\n> \n> NO.\n> \n> > Not\n> > that complex and uncommon I guess (co -r <filename>) Perhaps \n> > we then could stop some threads which threaten to make the \n> > spec more complex.\n> \n> It has already been made complex.  I'm trying to add \n> something to make the complexity optional and ignorable.\n> \n> \n\n\n\n", "id": "lists-006-3612223"}, {"subject": "RE: A simpler response ... RE: Working Resource Issues ..", "content": "They asked how a server could allow multiple checkouts of the same\nversion.\n\nI mistyped, the DELETION was meant to come from user3.\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Rick Rupp\n> Sent: Thursday, June 21, 2001 3:15 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: A simpler response ... RE: Working Resource Issues ...\n> \n> \n> I am assuming this is a case where the server does not \n> support forking. Why \n> did the second and third checkout succeed? /foo.txt should \n> have changed \n> into a checked out resource after the first checkout.\n> \n> Could you explain how and why User2 deleted the invisible \n> resource for User3?\n> \n> At 02:37 PM 6/21/01 -0700, John Hall wrote:\n> >Assume the server wants to implement multiple concurrent checkouts.\n> >\n> >User1: CHECKOUT /foo.txt <invisible>\n> >Response:\n> >OK\n> >Location: /invisible?file_id=4301&ver_id=7549\n> >\n> >User2: CHECKOUT /foo.txt <invisible>\n> >Response:\n> >OK\n> >Location: /invisible?file_id=4301&ver_id=8051\n> >\n> >User3: CHECKOUT /foo.txt <invisible>\n> >Response:\n> >OK\n> >Location: /invisible?file_id=4301&ver_id=9051\n> >\n> >User1: PUT /invisible?file_id=4301&ver_id=7549\n> >\n> >User2: DELETE /invisible?file_id=4301&ver_id=9051\n> >\n> >User2: PUT /invisible?file_id=4301&ver_id=8051\n> >\n> >User2: CHECKIN /invisible?file_id=4301&ver_id=8051\n> >Response OK // I win!\n> >\n> >User1: CHECKIN /invisible?file_id=4301&ver_id=7549\n> >Response:\n> >Conflict\n> ><cannot-modify-version-controlled-content/>\n> >\n> >========================================================\n> >At that point you have a number of places you can go.  The \n> simplest for \n> >User1 is to vow to use a lock next time, but in this case (to be\n> >polite):\n> >\n> >GET /foo.txt\n> >Diff _local_copy_with_working_copy\n> >Edit _local_copy_with_working_copy\n> >PUT /invisible?file_id=4301&ver_id=7549\n> >CHECKOUT /foo.txt\n> >CHECKIN /invisible?file_id=4301&ver_id=7549\n> >========= OR if not polite ==============\n> >CHECKOUT /foo.txt\n> >CHECKIN /invisible?file_id=4301&ver_id=7549\n> >\n> >----------------------------\n> >Is that clear how multiple checkouts of the same version could work? \n> >Basically, you have the same mechanism you had with your \n> >WORKING-RESOURCE feature to allow multiple checkouts (the Location \n> >header).  Now, ALLOWING mutliple checkouts yeilds the problem of \n> >conflict / merge resolution.  The simpliest policy is to \n> make the user \n> >resolve it.\n> >\n> >\n> >\n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, \n> > > Geoff\n> > > Sent: Thursday, June 21, 2001 1:58 PM\n> > > To: 'DeltaV (E-mail)'\n> > > Subject: RE: A simpler response ... RE: Working Resource \n> Issues ...\n> > >\n> > >\n> > > I don't see where you addressed Stefan's question.\n> > > Allowing multiple checkouts of the same version is\n> > > a key use case.  Limiting this to a single checkout\n> > > is supported in an interoperable way by allowing the\n> > > server to set the DAV:checkout-fork property to DAV:forbidden.\n> > >\n> > > Cheers,\n> > > Geoff\n> > >\n> > > -----Original Message-----\n> > > From: John Hall [mailto:johnhall@evergo.net]\n> > > Sent: Thursday, June 21, 2001 12:19 PM\n> > > To: 'Stefan Eissing'; 'DeltaV (E-mail)'\n> > > Subject: A simpler response ... RE: Working Resource Issues ...\n> > >\n> > >\n> > > There is only one 'in-place-checkout' now, so perhaps we should \n> > > insist that any \"invisible\" in-place-checkout's should be \n> unique.  \n> > > Therefore, the only difference is the visibility of the work in \n> > > progress.\n> > >\n> > > The only reason I made them different URL's is to preserve the \n> > > semantics where if you PUT on a resource and then GET you are \n> > > supposed to GET what you just PUT.  Therefore, for the \n> PUT's to be \n> > > invisible it must be a different URL.\n> > >\n> > > This isn't much different than lock resource, GET, modifing the \n> > > local copy, PUT, unlock.\n> > >\n> > >\n> > >\n> > > > -----Original Message-----\n> > > > From: ietf-dav-versioning-request@w3.org\n> > > > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Stefan \n> > > > Eissing\n> > > > Sent: Thursday, June 21, 2001 7:20 AM\n> > > > To: John Hall; 'DeltaV (E-mail)'\n> > > > Subject: AW: Working Resource Issues ...\n> > > >\n> > > >\n> > > > John,\n> > > >\n> > > > if I understand your proposal correctly, one user could \n> not have \n> > > > two working resources of the same version resource, \n> since there is \n> > > > only a single URL to access it. Correct?\n> > > >\n> > > > Wouldn't that be a major drawback for a versioning repository?\n> > > >\n> > > > Stefan\n> > > >\n> > > > > Von: ietf-dav-versioning-request@w3.org\n> > > > > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von\n> > > John Hall\n> > > > >\n> > > > > \"If you remain calm while everyone else is panicking, \n> then you \n> > > > > probably don't understand the situation.\" -- old Naval saying.\n> > > > >\n> > > > > It appears that some of the long discussion on this topic has \n> > > > > been prompted by completely different understandings \n> of what a \n> > > > > \"WORKING-RESOURCE\" is and should mean.\n> > > > >\n> > > > > I just thought it was a bit-bucket where the user could store \n> > > > > his state until he was finished.  Check out VCR, get bit\n> > > bucket, modify\n> > > > > bit bucket, Check In.  The critical difference between \n> > > > > Check-Out-In-Place and Check-Out-Working-Version was the\n> > > > visibility of\n> > > > > the bit bucket to other users.  In-Place, they can see it. \n> > > > > Working-Version, they can't.\n> > > > >\n> > > > > I've also mentioned that I'm concerned with 3rd party\n> > > > emulation.  The\n> > > > > 3rd party has a 'working version', and that is \n> exactly how they \n> > > > > implemented the concept.\n> > > > >\n> > > > > That IS NOT what this spec defines.  In the post\n> > > conditions for 9.3\n> > > > > create-working-resource-from-checked-in-version the spec\n> > > > states that\n> > > > > \"... the version-controlled resource remains checked-in.\"\n> > > > >\n> > > > > That is why you have seen two operations when I've only\n> > > > seen one, and\n> > > > > need an UPDATE or MERGE.  Meanwhile, I'm going \"of COURSE\n> > > > the VCR is\n> > > > > checked out.  I got a successful return on my CHECKOUT\n> > > > didn't I?\"  I\n> > > > > think you should create a new verb (MKWORKING), personally.\n> > > > >\n> > > > > So how about leaving the WORKING-RESOURCE definition as-is\n> > > > and modify\n> > > > > the CHECKOUT-IN-PLACE feature to make invisibility to\n> > > other users a\n> > > > > (REQUIRED) option?  I think you will have to finesse a\n> > > much smaller\n> > > > > number of issues if you do that.  Since it is required,\n> > > it doesn't\n> > > > > raise the issue of client interoperability.  It is new\n> > > > functionality;\n> > > > > you can't do what I need to do with the spec defined as\n> > > is.  And by\n> > > > > moving it down there you don't confuse the complex\n> > > 'package' issues\n> > > > > Geoff raised.  You put it in the basic package, and you\n> > > don't have\n> > > > > clients trying to figure out why they have WORKING-RESOURCE\n> > > > provided\n> > > > > but not UPDATE or MERGE.\n> > > > >\n> > > > > 4.1.3  DAV:checkout-invisible\n> > > > >\n> > > > > Normally, edits made on a resource while checked out are\n> > > visible to\n> > > > > other users.  If checkout-invisible is specified, however,\n> > > > other users\n> > > > > will only see the last checked-in version.  A client is\n> > > > encouraged to\n> > > > > see this feature as \"lite\" version of WORKING-RESOURCE\n> > > which leaves\n> > > > > the VCR in the checked-out state.\n> > > > >\n> > > > > 4.2 CHECKOUT Marshalling:\n> > > > >\n> > > > > If the element checkout-invisible is present, the \n> response MUST \n> > > > > include a Location header.\n> > > > >\n> > > > > 4.6: Additional PUT / PROPPATCH semantics.\n> > > > >\n> > > > > If a Location header was returned with the CHECKOUT, the\n> > > > URL specified\n> > > > > in the Location header MUST be used for PUT and PROPPATCH\n> > > requests.\n> > > > > Otherwise, the server will return \n> > > > > cannot-modify-version-controlled-content.\n> > > > >\n> > > > > 4.7: Additional DELETE semantics.\n> > > > >\n> > > > > A delete on the URL returned by a CHECKOUT Location header\n> > > > will undo\n> > > > > the CHECKOUT which created it.\n> > > > >\n> > > > >\n> > > >\n> > > >\n> > > >\n> > >\n> > >\n> > >\n> \n> \n> \n\n\n\n", "id": "lists-006-3626335"}, {"subject": "Re: Removing the DAV:activity and DAV:version-history and DAV:bas eline  resource type value", "content": "On Thu, Jun 21, 2001 at 02:32:38PM -0400, Jim Amsden wrote:\n> Since we agree that there *may* be \n> circumstances where new DAV:resourcetypes will need to be introduced \n> (otherwise its a pretty useless property), then any issues with current \n> servers that don't parse DAV:resourcetype properly would have to be \n> addressed anyway.\n\nI don't have any strong opinion, but when I saw a recent mail that listed\nabout 5 values in <resourcetype>, it made me wonder if there was a subtype\nhierarchy for all the values listed (especially when values such as\n<version-controlled/> were added) or whether they were orthogonal concepts.\n\nIf orthogonal concepts were present, then they *could* be in separate\nproperties rather than introducing the concept of sub-types etc.\nEg:\n  <resourcetype>\n    <workspace/>\n    <collection/>\n    <version-controlled/>\n  </resourcetype>\n\n*could* be done as\n\n  <resourcetype>\n    <collection/>\n  </resourcetype>\n  <version-controlled> TRUE <version-controlled/>\n  <workspace> TRUE </workspace>\n\nI am not recommending it - just raising it as an alternative. I am still\nstruggling to understand all the versioning concepts flying around here\nand after reading the DeltaV draft spec! In some ways I am happy to\nsee that people on this list are still trying to work out things too\n(ie - its not just me!) Mind you it also makes me a little worried that\npeople are still trying sort out what basic concepts mean. And the\ncomplexity of it all seems quite high to me (a new comer) at the moment.\nBut I guess that is why it is draft! :-) :-) :-)\n\najk\n\n\n\n", "id": "lists-006-3647916"}, {"subject": "Re: Why it's bad to rely on other information to determine typ", "content": "If a server tells a client that it is HTTP/1.1 compliant, then the client\ncan rightly expect the Expect: header to be supported since it is required\nby the spec.\n\nSay the client sends Expect: and the server never 100-Continues.  The\noptions for the client writer are:\n(1) Scream at the server implementer about what a heap-'o-junk that server\nis, preach the value of standards, take their custom elsewhere, etc. or,\n(2) accept that the server states it is compilant, but code around it.  In\nthis case, don't rely on that server feature.\n\nSwitch to DeltaV...\n\nSay a server states that a resource is a\n<DAV:resourcetype><DAV:activity/></DAV:resourcetype>.  The client goes to\nPROPPATCH the DAV:subactivity-set, which is required by the activity\nfeature, and the server responds with 501 Not Implemented (or whatever).\nThe options for the client are exactly the same, complain and/or don't rely\non that feature.\nOnly this time the client was fooled into thinking that the resource\n_would_ support that live property because it advertises it is an\nactivity-type.\n\nHad the client asked for the DAV:supported-live-property-set it would have\nseen that the DAV:subactivity-set was not present and not attempted the\noperation.  If anything this is preferrable.\n\nStating <DAV:activity/> in the resourcetype is *just* a shorthand for\nstating the properties and methods that an activity resource is expected to\nsupport.\n\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n------------------\n\"Lisa Dusseault\" <lisa@xythos.com> wrote:\n\nI just ran across an explanation for a RFC 2616 feature which leads me to\nbelieve that the feature should be implemented for all methods -- the\nExpect\nheader (See separate post to w3c-dist-auth for details).\n\nDo all your DAV servers support the Expect header properly on all methods?\nI suspect not.  CLients don't actually send it.  And yet, it's required by\nHTTP/1.1\n\nThis is an example of theoretical \"non-compliance\".  A required feature is\nmissing.  Oh horrors!  Note that it doesn't seriously impede\ninteroperability.  Perhaps nobody was sure how to use the feature.  Shrug.\n\nThe implication of a situation like this is that designers of a\nspecification cannot foresee how everything is going to fall out.  Not all\n\"required\" features may be implemented, and this might be OK.  If there was\nsome kind of \"allowed-headers-set\" that could be queried, a compliant\nclient\nshould see \"Expect\" in there for all resources and all methods -- yet it\nwon't.\n\nRelying on a set of methods and properties supported in order to determine\ntype is brittle because of these kinds of failures of perfect\nforeknowledge.\nFor all Geoff's wisdom, it's conceivable that some REQUIRED live property\nwill end up not being supported by some, most, or all servers.  And that\nwould ruin a client's ability to use the supported-*-set values to see what\ntype things are.\n\nWe're human, and we could be wrong.  Please design a system that takes that\ninto account, and does not entirely break down if we do not predict the\nfuture completely accurately.\n\nLisa\n\n\n\n", "id": "lists-006-3657710"}, {"subject": "AW: What is a supported property", "content": "> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Tim Ellison\n>\n> \"Stefan Eissing\" <stefan.eissing@greenbytes.de> wrote:\n> > All this resourcetype and state thing aside:\n> >\n> > What is a supported property?\n> >\n> > A resource has properties, let's call these existing\n> > properties, which might or might not have values. But\n> > when a client does a PROPFIND on them, he will get\n> > them listed in a propstat element with 200 OK status\n> > code. I think that is a good definition of an \"existing\n> > property of a resource\".\n>\n> If I was going to be pedantic I'd say that the status code for an existing\n> property is not 404 Not Found, since the PROPFIND may fail due to\n> authorization problems etc., but I know what you mean.\n\n<g/> Ok.\n\n> > Now, every existing property would also be a supported\n> > property and, being live, would appear in the\n> > supported-live-property-set. Ok.\n>\n> Again, just to be completely precise, every live property (in the DAV:\n> namespace) of a DeltaV-compliant resource will be in the\n> DAV:supported-live-property-set.\n\nI don't buy that it needs to be in the DAV: namespace. After all,\nwhat is the namespace attribute in DAV:supported-live-property\nthen good for?\n\n> > Now Geoff mentioned that a VCR with in-place editing\n> > would have both DAV:checked-in and DAV:checked-out as\n> > supported properties, and that independant of the\n> > checked in/out state of the resource!\n>\n> (I've not received Geoff's post on that yet, I think it was held up in\n> customs<g>)\n> I agree with this view.  The server supports the semantics of\n> DAV:checked-in and DAV:checked-out on a version-controlled resource even\n> though those properties cannot appear simultaneously.\n>\n> > Now, here I became confused, since it means that not\n> > every supported property is an existing property!\n>\n> Correct.\n>\n> > If we define supported properties with:\n> >    a property which will exist, when a method is applied\n> >     successfully\n> > then all non-versioned resources will have the\n> > DAV:checked-in as supported property, since you can\n> > apply VERSION-CONTROL. So, that does not seem to be\n> > a good definition...\n>\n> Well we are back to that _type_ thing again I'm afraid.  The document\n\nI was afraid so, too.\n\n> states that a versionable resource is a different type of resource to a\n> version-controlled resource, and so on.  It makes these distinctions so\n> that we can talk about \"Activities\" and \"Workspaces\" and\n> \"Version-controlled resources\" and know what affect named property values\n> and methods have on that resource.\n>\n> To avoid confusion the server is required to disallow setting resource\n> properties that are defined in the specification but are not supported\n> (i.e. a PROPPATCH of DAV:checked-in on a DeltaV-compliant versionable\n> resource MUST fail).\n\nIt does not say so in the spec. In fact, I think it would be unwise\nto say so in the spec.\nImagine a server which complies to DeltaV in regard to supported-*-set, but\ndoes not implement DeltaV resource types. This server could allow a\nPROPPATCH\non DAV:checked-in. If you call such a resource versionable would depend\non the supported-method-set then, not on the supported-property-set.\n\nI think that is a valid case, since you cannot couple supported-*-set to\nimplementation of DeltaV resource types. supported-*-set has to be a feature\nthat can be used by other (orthogonal) extensions as well in the future.\n\n> The DAV:supported-*-set properties are defined for each type of resource.\n\nThere you go with this type thing again. <g/>\n\n> The supported-property-set tells you which properties will/can be defined\n> for that resource _and_ have the meaning defined in the\n> specification.  (It\n> therefore states that DAV:checked-in will&can not be defined on a\n> versionable resource.)\n>\n> > And what about supported methods? Is CHECKIN a supported\n> > method for a checked-in resource, too? It will fail all\n> > the time...\n>\n> The CHECKIN method is not supported for a checked-in resource, i.e., there\n> are no (non-failure) semantics for that operation in the specification.\n> The analogy is with HTTP/1.1 Allow.\n\nSo, supported-method-set will change for a resource type, but\nsupported-live-property-set will not. Correct?\n\n> Tim\n>\n>\n\nWell, I still have no definition of a supported property which does\nnot use the word \"type\" in any way. :(\n\nI smell a certain odor of circular reasoning here:\nClient: \"How do I determine the resource type?\"\nServer: \"You don't. Types are bad for you, look at the properties.\"\nClient: \"Ok, what properties can I expect?\"\nServer: \"That depends on the type of the resource!\"\n\nI could live with the current way of things, like it or not. But\nI have this nagging feeling that someday my daughter will come\nto me and ask: \"Daddy, what did you do when they defined deltaV?\"\n\n;)\n\n//Stefan\n\n\n\n", "id": "lists-006-3668590"}, {"subject": "AW: Removing the DAV:activity and DAV:version-history and DAV:bas eline   resource type value", "content": "One correction though:\n\nACL (0.6) defines resource type DAV:principal and for collection\nprincipals it reports:\n\n<D:resourcetype>\n  <D:collection/>\n  <D:principal/>\n</D:resourcetype>\n\nSo, all arguments with or without Webfolders for or against putting\nadditional things into DAV:resourcetype are void, unless someone\nthrows all the supported-* stuff into the ACL spec as well (it's\non last call, in case someone missed that).\n\nMy expectation would be that clients have to deal at least as often\nwith ACL WebDAV servers than DeltaV WebDAV servers.\n\nCase closed. There is not additional burden on clients with deltaV\nresourcetype extensions.\n\n//Stefan\n\n> -----Urspr?ngliche Nachricht-----\n> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n> Gesendet: Donnerstag, 21. Juni 2001 14:38\n> An: ietf-dav-versioning@w3.org\n> Betreff: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:bas eline resource type values\n>\n>\n> Nice summary, Stefan!\n>\n> One addendum: Notice that the binding protocol addresses\n> the 2518 omission of a few critical collection operations\n> (BIND, UNBIND, REBIND).  If we merge the \"bind\"\n> protocol into the next draft of 2518 (which we should do),\n> then DAV:supported-method-set allows you to distinguish a\n> collection from a non-collection.  Arguably, there are a few\n> key collection properties (e.g. DAV:child-count) that should\n> be added as well.  My experience is that every new type\n> of resource normally brings at least one new method or property\n> in with it.\n>\n> Also note that Tim recently posted on this thread:\n>   I support taking them out.  We don't need them.\n>\n> So that puts Tim and me pretty much in the same camp.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n> Sent: Thursday, June 21, 2001 4:17 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: AW: Removing the DAV:activity and DAV:version-history and\n> DAV:baseline resource type values\n>\n>\n> Well, I'm amazed how much energy is spend here on that\n> DAV:resourcetype thing and MS WebFolders.\n>\n> IF (and that's the point worth discussing) deltaV introduces\n> _types_ of resources, then it can define a protected live\n> property DAV:subtype/DAV:interface/DAV:reallyresourcetype,\n> put it's new type definitions there and leave DAV:resourcetype\n> as it is. (Include the new property in an <allprop/> response,\n> MS Webfolder will never see it, it does not use allprop.)\n>\n> The alternative is to have no new types and introduce only\n> new live properties, which a client can learn about with\n> DAV:supported-live-property-set.\n>\n> I got the impression somehow that Geoff is in favour of the latter\n> one, Tim is undecided, Greg is opposed to it, and the rest\n> is trying to figure out what DAV:supported-live-property-set\n> means, how it is interpreted and how it might survive future\n> extensions.\n>\n> What other examples beside deltaV do we have in other drafts:\n> - Redirect Refs: -> new DAV:resourcetype + property\n> - Ordered Collections -> new property\n> - Binding: none\n> - DASL: none\n> - ACL: none\n>\n> Best Regards,\n>\n> Stefan\n>\n> > -----Ursprungliche Nachricht-----\n> > Von: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Jim Amsden\n> > Gesendet: Mittwoch, 20. Juni 2001 23:21\n> > An: ietf-dav-versioning@w3.org\n> > Betreff: RE: Removing the DAV:activity and DAV:version-history and\n> > DAV:baselin e resource type values\n> >\n> >\n> > Lisa,\n> > This is really a sticky one. On the one hand, we have\n> introduced many new\n> > resource types in DeltaV, but only defined DAV:resourcetype for some of\n> > them, and we know this causes problems for some servers. If we don't use\n> > DAV:resourcetype, then we don't introduce compatibility\n> problems with DAV\n> > level 1 or 2, and DeltaV servers can interoperate somewhat with DAV\n> > clients (one of our primary requirements). We're not really just\n> > trying to\n> > support existing servers with bugs, but make sure we maintain\n> > interoperability. Just providing new resource types isn't\n> enough. We need\n> > to provide a backward compatible type hierarchy scheme so down-level\n> > clients can see for example, a baseline as a DAV:collection. We could do\n> > this, but it would be another rat-hole, and then there's the\n> problem with\n> > existing servers that might not parse the extended XML properly.\n> > These are\n> > of course things we'd like to avoid if we can.\n> >\n> > So we're left with removing our DAV:resourcetypes, and requiring clients\n> > to introspect supported properties on a resource to figure out the type\n> > based on a table in the spec. This works *except* for (sub)types that\n> > don't introduce additional properties. Its a little more\n> > inconvenient, but\n> > perhaps won't be that different if we really solved the type hierarchy\n> > problem. The end result is that DAV:resourcetype is pretty useless.\n> >\n> > Geoff, do we still have a potential problem with the introspection\n> > approach in cases where new types don't introduce new properties?\n> > Unfortunately type depends on more than signature, it also depends on\n> > behavior, and this isn't captured in the supported properties in all\n> > cases. Collections in DAV are an example. They can be considered\n> > a kind of\n> > resource that doesn't introduce new properties, but does change method\n> > behavior. Clients will of course have to be able to distinguish them in\n> > order for users to understand the results of their requests.\n> >\n> >\n> >\n> >\n> >\n> > \"Lisa Dusseault\" <lisa@xythos.com>\n> > 06/20/2001 04:32 PM\n> >\n> >\n> >         To:     \"DeltaV\" <ietf-dav-versioning@w3.org>, \"Jim\n> > Amsden\" <jamsden@us.ibm.com>,\n> > \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n> >         cc:\n> >         Subject:        RE: Removing the DAV:activity and\n> > DAV:version-history and DAV:baselin   e\n> > resource type values\n> >\n> >\n> >\n> >\n> > > The reason we can't introduce new resource types for all of the\n> > > versioning\n> > > resources is because we have to support down-level clients that only\n> > know\n> > > about DAV:collection. For new resources that down-level\n> clients couldn't\n> > > possibly know about, workspaces, activities, baselines, etc., we don't\n> > > have this restriction. I agree with Greg and Tim. We should be as\n> > > specific\n> > > as we can about declared type and only compromise when required by\n> > > interoperability considerations.\n> >\n> > I thought we had rather strong guidance that working around bugs in a\n> > single\n> > implementation was NOT recommended.  Clarification, Jim?\n> >\n> > I'd also point out that frequently it will be OK even with buggy clients\n> > to\n> > introduce new resource types.  For example, I don't suppose it will be\n> > that\n> > easy for non-versioning-aware clients to stumble across URLs of\n> > collections\n> > of version-histories, activities, baselines and workspaces.  Not all of\n> > these new resources are even browsable, and they may not appear in any\n> > regular URL space that regular clients are expected to use.\n> >\n> > lisa\n> >\n> >\n>\n>\n>\n\n\n\n", "id": "lists-006-3682193"}, {"subject": "Re: DAV:resourcetyp", "content": "\"Jim Amsden\" <jamsden@us.ibm.com> wrote:\n\n[snip]\n\n> <jra>\n> Now you're mixing in (static) type declaration with state\n> (or dynamic type). That's OK, but we could draw the line\n> on static typing in DAV:resourcetype, and let clients use\n> other property values to indicate dynamic state. This is\n> of course typical of any OO application.\n> </jra>\n\nI don't know what you mean by static and dynamic for a web resource.  There\nis only dynamic.\n\n> Now, tell me how is this different to DAV:supported-*-set?\n> <jra>\n> Just that supported-*-set doesn't deal with override.\n\nNeither does adding tags to DAV:resourcetype.  If I state <DAV:collection/>\nwhat does that mean for the semantics of GET, PUT, etc.?  I claim it has to\nmean what is written in RFC2518 for a DAV:collection otherwise clients have\nno hope.\n\n> What if someone in the future decides to redefine the meaning\n> of <DAV:workspace/>.  It would be a breaking change, and it\n> is incumbant upon them not to do so.\n> <jra>\n> Yes, but not if they define a new subtype that responds to the\n> same methods and has the same properties, but behaves differently.\n> The protocol is still OK.\n> </jra>\n\nI strongly disagree.  If a 'subtype' does not honour the semantics of the\nsupertype then existing clients are screwed.\n\n[Java digression]\nIf you try subclassing java.util.Hashtable and redefining the methods to\nplay tunes, you can still pass those instances to methods that expect a\nhashtable; but I guarantee you that those clients will not work properly.\nYou have to honour the semantics of the superclass.\n\n> <jra>\n> ...\n> The fact that we have subsections in the DeltaV spec indicating\n> the effect on DAV methods indicates the new DeltaV resources\n> have different behavior.\n\nThey have extended, compatible behaviour.  We don't (for example) say that\nMOVE no longer moves the resource as described by RFC2518.\n\nTim\n\n\n\n", "id": "lists-006-3702880"}, {"subject": "Re: AW: What is a supported property", "content": "\"Stefan Eissing\" <stefan.eissing@greenbytes.de> wrote:\n> > Again, just to be completely precise, every live\n> > property (in the DAV:namespace) of a DeltaV-compliant\n> > resource will be in the DAV:supported-live-property-set.\n>\n> I don't buy that it needs to be in the DAV: namespace.\n> After all, what is the namespace attribute in\n> DAV:supported-live-property then good for?\n\nI agree it doesn't need to be in the DAV: namespace to be in the\nsupported-live-property-set, rather that every existant property in the DAV\nnamespace will be in the set.\n\n> > To avoid confusion the server is required to disallow\n> > setting resource properties that are defined in the\n> > specification but are not supported (i.e. a PROPPATCH\n> > of DAV:checked-in on a DeltaV-compliant versionable\n> > resource MUST fail).\n>\n> It does not say so in the spec. In fact, I think it would\n> be unwise to say so in the spec.\n\nYou're right, I can't find that statement any longer in the spec.\n\nI think it is useful to have such a requirement otherwise any client can\nset, say, DAV:checked-in and DAV:checked-out to a resource (with\nunspecified semantics).\n\n> Imagine a server which complies to DeltaV in regard to\n> supported-*-set, but does not implement DeltaV resource\n> types. This server could allow a PROPPATCH on DAV:checked-in.\n> If you call such a resource versionable would depend\n> on the supported-method-set then, not on the\n> supported-property-set.\n\nI think allowing properties to be set in the DAV: namespace that do not\nhave the semantics defined in the DAV protocols is extremely dangerous.\n\n> I think that is a valid case, since you cannot couple\n> supported-*-set to implementation of DeltaV resource types.\n> supported-*-set has to be a feature that can be used by\n> other (orthogonal) extensions as well in the future.\n\nI agree that the supported sets will be used by other protocol extensions\nto declare the capabilities of a resource.\n\n> So, supported-method-set will change for a resource type, but\n> supported-live-property-set will not. Correct?\n\nLets not use 'type' -- debating that word is getting us into too much\ntrouble.\n\n> Well, I still have no definition of a supported property\n> which does not use the word \"type\" in any way. :(\n>\n> I smell a certain odor of circular reasoning here:\n> Client: \"How do I determine the resource type?\"\n> Server: \"You don't. Types are bad for you, look at the properties.\"\n> Client: \"Ok, what properties can I expect?\"\n> Server: \"That depends on the type of the resource!\"\n\nClient: \"How do I determine the resource type?\"\nServer: What do you mean by 'type'?\nClient: I mean what characteristics can I expect of this resource?\nServer: Well we have a menu of properties and methods, whose semantics you\nare familiar with if you know the DAV specification; and as a side-order\nyou may like to know we have these a-la-carte properties and methods that\nare defined in the \"XYZ:\" namespace.\n\nTim\n\n\n\n", "id": "lists-006-3712145"}, {"subject": "Re: Re: What is a supported property", "content": "> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Tim Ellison\n>\n> [...]\n> I agree it doesn't need to be in the DAV: namespace to be in the\n> supported-live-property-set, rather that every existant property\n> in the DAV\n> namespace will be in the set.\n\nI try to summarize a partial definition of supported-live-property-set:\n\nEvery existing live property of a resource, be it in the DAV: or\nany other namespace, is part of the DAV:supported-live-property-set\non a server which complies to DAV:supported-*-set as\ndefined in DeltaV.\n\n> [...]\n> > Imagine a server which complies to DeltaV in regard to\n> > supported-*-set, but does not implement DeltaV resource\n> > types. This server could allow a PROPPATCH on DAV:checked-in.\n> > If you call such a resource versionable would depend\n> > on the supported-method-set then, not on the\n> > supported-property-set.\n>\n> I think allowing properties to be set in the DAV: namespace that do not\n> have the semantics defined in the DAV protocols is extremely dangerous.\n\nI think you mean \"defining a new DAV protocol which assigns new\nsemantics to a property defined in earlier protocols, is extremely\ndangerous.\"\n\nThis is done, IMHO, for DAV:resourcetype and especially for\nDAV:supported-live-property-set. DeltaV explicitly proposes that\nsemantics for DAV:supported-live-property-set does change with\nevery addition or removal in its content.\n\nThe difference between changes of DAV:resourcetype and\nDAV:supported-live-property-set is that the latter requires\nset operations to discover the semantics.\n\nWhen a client discovers DAV:collection in DAV:resourcetype, it\nis safe to assume that it can treat the resource as a collection.\n\nWhen a client discovers DAV:checked-in in DAV:supported-live-property-set\nit has to look for the appearance or absence of other properties in\nthis set in order to know what it can do with the resource.\n\nThis makes writing a client, which is foolproof to future extensions\nand different servers (in that way that it does not screw up), much\nmore challenging.\n\n...even if we could assume all servers to implement DeltaV correctly\nwith the same interpretation of the spec.\n\n>\n> > So, supported-method-set will change for a resource type, but\n> > supported-live-property-set will not. Correct?\n>\n> Lets not use 'type' -- debating that word is getting us into too much\n> trouble.\n\nAgreed, but will the one change and the other stay the same?\n\n> > Well, I still have no definition of a supported property\n> > which does not use the word \"type\" in any way. :(\n> >\n> > I smell a certain odor of circular reasoning here:\n> > Client: \"How do I determine the resource type?\"\n> > Server: \"You don't. Types are bad for you, look at the properties.\"\n> > Client: \"Ok, what properties can I expect?\"\n> > Server: \"That depends on the type of the resource!\"\n>\n> Client: \"How do I determine the resource type?\"\n> Server: What do you mean by 'type'?\n> Client: I mean what characteristics can I expect of this resource?\n> Server: Well we have a menu of properties and methods, whose semantics you\n> are familiar with if you know the DAV specification; and as a side-order\n\nLet's turn version-history for Tim's mail on:\n\"...if you know the resource types^H^H^H^H^H^Hs defined in the\nspecification\".\n;)\n\n> you may like to know we have these a-la-carte properties and methods that\n> are defined in the \"XYZ:\" namespace.\n\nStefan\n\n\n\n", "id": "lists-006-3722982"}, {"subject": "Re: Re: What is a supported property", "content": "\"Stefan Eissing\" <stefan.eissing@greenbytes.de> wrote:\n> Every existing live property of a resource, be it in the\n> DAV: or any other namespace, is part of the\n> DAV:supported-live-property-set on a server which complies\n> to DAV:supported-*-set as defined in DeltaV.\n\nAgreed.\n\n> > I think allowing properties to be set in the DAV: namespace\n> > that do not have the semantics defined in the DAV protocols\n> > is extremely dangerous.\n>\n> I think you mean \"defining a new DAV protocol which assigns new\n> semantics to a property defined in earlier protocols, is extremely\n> dangerous.\"\n\nNo, I really meant it as I wrote it (though I also agree with what you\nwrote).\n\nI mean that if a client or server is allowed to set, say\nDAV:getcontentlength, it had better mean what RFC2518 says it means.\n\n> This is done, IMHO, for DAV:resourcetype and especially for\n> DAV:supported-live-property-set. DeltaV explicitly proposes that\n> semantics for DAV:supported-live-property-set does change with\n> every addition or removal in its content.\n\nI don't understand this.\n\n> The difference between changes of DAV:resourcetype and\n> DAV:supported-live-property-set is that the latter requires\n> set operations to discover the semantics.\n\nI suggest that since the DAV:resourcetype will be multi-valued, clients\nwill be required to perform the set operations either way.\n\n> When a client discovers DAV:collection in DAV:resourcetype, it\n> is safe to assume that it can treat the resource as a collection.\n\nAgreed.  It can treat it as a collection as defined by RFC2518.\n\n> When a client discovers DAV:checked-in in DAV:supported-live-property-set\n> it has to look for the appearance or absence of other properties in\n> this set in order to know what it can do with the resource.\n\nHow much more difficult is it to look for multiple values than single\nvalues?\n\n> This makes writing a client, which is foolproof to future\n> extensions and different servers (in that way that it does\n> not screw up), much more challenging.\n\nI disagree.  Provided protocol designers do not redefine an existing\nproperty (which we agree is bad), clients will still \"look for\" the subset\nof properties and methods in just the same way; and their existance will\nafford just the same assurances.\n\n> ...even if we could assume all servers to implement DeltaV correctly\n> with the same interpretation of the spec.\n\nI think we always have to assume erroneous clients can screw up.\n\n> > > So, supported-method-set will change for a resource type, but\n> > > supported-live-property-set will not. Correct?\n> >\n> > Lets not use 'type' -- debating that word is getting us into too much\n> > trouble.\n>\n> Agreed, but will the one change and the other stay the same?\n\nNo, that is not guranteed.\n\n> Let's turn version-history for Tim's mail on:\n>    \"...if you know the resource types^H^H^H^H^H^Hs defined\n> in the specification\".\n\nSorry, this one is lost on me?\n\nTim\n\n\n\n", "id": "lists-006-3734129"}, {"subject": "Re: DAV:resourcetyp", "content": "I think we've beaten this one to death, but I'll make just a few more \npoints.\n\n- DeltaV resources do have static (meta) data, and dynamic state. Which is \nwhich is a matter of design. Type names are just a label for the meta-data \nwhich is generally used to describe a range of potential states.\n\n- Yes, stating a resource type does require the servers to implement the \nsemantics of that type. Just like it means they have to implement \nsupported-*. No difference here. If we define DAV:resourcetypes, this will \nnot give servers the ability to return these types but not implement the \nrequired properties, methods, and semantics.\n\n- But here's the difference. In cases where new subtypes are introduced \nthat don't add methods or properties, resource type is not redundant, but \nrather can be used to distinguish that subtype where the interface alone \ncould not. This is extremely common in OO applications. The fact that we \ndon't have many instances where it is the case now in \nWebDAV/DeltaV/DASL/ACL is fortunate, but might not be permanent.\n\n- Of course a subtype could override a supertype method and do anything it \nwanted. If the behavior is completely inconsistent with the supertype, the \nmarketplace will likely treat the 'feature' accordingly. However, there \nare many degrees of compatible behavior. Its difficult to predict which \nones clients might be interested in distinguishing. \n\nIts hard to get a sense of where we are on this issue. However, if I were \nto attempt to summarize:\n\n- The working group is pretty well split on defining DAV:resourcetypes for \nDeltaV\n\n- Simply defining new resource types isn't enough, we need to be able to \nextend existing resource types to show generalization hierarchies.\n\n- Some current servers will likely break if DAV:resourcetype is extended.\n\n- The ACL spec has also proposed such extensions\n\n- DeltaV at this time can indicate type through client introspection of \nsupported properties and methods. Any new resource types would only serve \nto (redundantly) summarize this information.\n\n- Using additional DAV:resourcetypes to (potentially redundantly) indicate \ntype might simplify client implementations eliminating the need for \nclients to get and process supported properties and methods, and does \nallow the introduction of new distinguishable (sub) types when there are \nno new properties or methods if this ever became the case.\n\nWhere do I stand? Well, I'd prefer to keep the resource types because I \nthink its simpler and more flexible (although we may never need the \nadditional flexibility). But I can see how using supported properties and \nmethods can work, and I don't think its necessarily worth holding the spec \nup at this time to introduce something else. Since the ACL spec also \nintroduces the DAV:resourcetype extension problem, and the new DeltaV \nresource types are already in the spec that went through last call and is \nin the hands of the area directors, maybe the solution is to do nothing \nand leave the spec the way it is. We'd need to add support for \ngeneralization hierarchies though or down-level clients won't be able to \ndo anything with DeltaV extensions to collection.\n\n\n\n\n\n\n\"Tim Ellison\" <Tim_Ellison@uk.ibm.com>\nSent by: ietf-dav-versioning-request@w3.org\n06/22/2001 05:10 AM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        Re: DAV:resourcetype\n\n \n\n\"Jim Amsden\" <jamsden@us.ibm.com> wrote:\n\n[snip]\n\n> <jra>\n> Now you're mixing in (static) type declaration with state\n> (or dynamic type). That's OK, but we could draw the line\n> on static typing in DAV:resourcetype, and let clients use\n> other property values to indicate dynamic state. This is\n> of course typical of any OO application.\n> </jra>\n\nI don't know what you mean by static and dynamic for a web resource. There\nis only dynamic.\n\n> Now, tell me how is this different to DAV:supported-*-set?\n> <jra>\n> Just that supported-*-set doesn't deal with override.\n\nNeither does adding tags to DAV:resourcetype.  If I state \n<DAV:collection/>\nwhat does that mean for the semantics of GET, PUT, etc.?  I claim it has \nto\nmean what is written in RFC2518 for a DAV:collection otherwise clients \nhave\nno hope.\n\n> What if someone in the future decides to redefine the meaning\n> of <DAV:workspace/>.  It would be a breaking change, and it\n> is incumbant upon them not to do so.\n> <jra>\n> Yes, but not if they define a new subtype that responds to the\n> same methods and has the same properties, but behaves differently.\n> The protocol is still OK.\n> </jra>\n\nI strongly disagree.  If a 'subtype' does not honour the semantics of the\nsupertype then existing clients are screwed.\n\n[Java digression]\nIf you try subclassing java.util.Hashtable and redefining the methods to\nplay tunes, you can still pass those instances to methods that expect a\nhashtable; but I guarantee you that those clients will not work properly.\nYou have to honour the semantics of the superclass.\n\n> <jra>\n> ...\n> The fact that we have subsections in the DeltaV spec indicating\n> the effect on DAV methods indicates the new DeltaV resources\n> have different behavior.\n\nThey have extended, compatible behaviour.  We don't (for example) say that\nMOVE no longer moves the resource as described by RFC2518.\n\nTim\n\n\n\n", "id": "lists-006-3744913"}, {"subject": "AW: Re: What is a supported property", "content": "I think we agree to disagree on the complexity issues of\nextending DAV:resourcetype as compared to DAV:supported-live-\nproperty-set.\n\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Tim Ellison\n>\n> \"Stefan Eissing\" <stefan.eissing@greenbytes.de> wrote:\n> [...]\n> I mean that if a client or server is allowed to set, say\n> DAV:getcontentlength, it had better mean what RFC2518 says it means.\n>\n> > This is done, IMHO, for DAV:resourcetype and especially for\n> > DAV:supported-live-property-set. DeltaV explicitly proposes that\n> > semantics for DAV:supported-live-property-set does change with\n> > every addition or removal in its content.\n>\n> I don't understand this.\n\nDAV:supported-live-property-set will by definition be extended\nby every future extension to the DAV protocol family. That means\nit will automatically have new members with every extension.\n\nThese new members will change the way how clients interpret\nthe value of DAV:supported-live-property-set, e.g. its semantics.\n\nThus, it is an example of a property which implied semantic will be changed\nby future extensions, hopefully in a way backward compatible with\ncurrent deltaV definition.\n\n> > The difference between changes of DAV:resourcetype and\n> > DAV:supported-live-property-set is that the latter requires\n> > set operations to discover the semantics.\n>\n> I suggest that since the DAV:resourcetype will be multi-valued, clients\n> will be required to perform the set operations either way.\n>\n> > When a client discovers DAV:collection in DAV:resourcetype, it\n> > is safe to assume that it can treat the resource as a collection.\n>\n> Agreed.  It can treat it as a collection as defined by RFC2518.\n>\n> > When a client discovers DAV:checked-in in\n> DAV:supported-live-property-set\n> > it has to look for the appearance or absence of other properties in\n> > this set in order to know what it can do with the resource.\n>\n> How much more difficult is it to look for multiple values than single\n> values?\n\nReal world example: my client has to detect and work with lock-null\nresources.\nThey have no special resource type in RFC 2518. So I have to look at the\nproperties:\n- resourcetype: not collection\n- lockdiscovery: a lock-null resource should have a write lock.\n- getcontentlength: present, but without a value.\n\nAccording to spec: this should work. However\n\n1) IIS pretends to implement lock-null. It creates empty files which\n   do not vanish when the lock expires. Detection of the resource my\n   client creates (successfully according to response code) fails, since\n   the getcontentlength is 0. But I would like to do MKCOL on it...\n\n2) moddav supports lock-null with some special quirks: at first, the\nPROPFIND\n   response is OK, but the resource does not expire when the lock timeout\n   says it should. Instead it hangs around for a while afterwards and\n   the timeout value reported in seconds is bigger than 2^31-1. Oops,\n   can this be a valid lock?\n\n3) Some servers do not accept certain HTTP requests, others produce invalid\n   (e.g. not well-formed) xml and some throw a whole range of nowhere\n   defined properties in the DAV: namespace at a client.\n\nDoes my client have to work with those servers? It sure does!\n\nWould I be glad for a resource type lock-null? Take a wild guess.\n\nStefan\n\n\n\n", "id": "lists-006-3757892"}, {"subject": "RE: Dav:resourcetyp", "content": "I don't think we are getting close to a consensus on this issue.  I'm\npersonally in favor of using dav:resourcetype for type information \n(after Yaron used his Jedi mind tricks on me), but I don't care enough\nto argue about it anymore.\n\nIs there a defined IETF procedure for flipping a coin to decide on what\nto do with a spec, or some other source of randomness?  How about if \neverybody agrees that if the Dow is an even number on Monday (at the\nclose, truncating fractional part) we will put type information in \ndav:resourcetype, and if it is an odd number,\nwe will use supported-*-resource-set (and go back to <dav:is-principal>\nin the ACL spec)?\n\nDeal?  Geoff?\n\n(P.S.  I have a suggested topic as an alternative for those who want to \nargue about this more:  Is operator overloading in C++ a good idea or\nnot?  Discuss.)\n\n--Eric\n\n\n\n", "id": "lists-006-3769296"}, {"subject": "RE: What is a supported property", "content": "   From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n\n   All this resourcetype and state thing aside:\n   What is a supported property?\n\nExcellent question!  This should be made clearer in the spec.\nHow about the following:\n\n-------------\n\n3.1.3DAV:supported-method-set (protected)\n\nThis property identifies the methods that are supported by the\nresource.  A method is supported by a resource if an application of\nthat method to that resource has the semantics defined for that\nmethod by the features supported by that resource.\n\n3.1.4DAV:supported-live-property-set (protected)\n\nThis property identifies the live properties that are supported by\nthe resource.  A live property is supported by a resource if that\nproperty has the semantics defined for that property by the\nfeatures supported by that resource.\n\n-------------\n\nOK, now let's see how these definitions hold up under\nthe rest of this message.\n\n   A resource has properties, let's call these existing properties,\n   which might or might not have values. But when a client does\n   a PROPFIND on them, he will get them listed in a propstat\n   element with 200 OK status code. I think that is a good definition\n   of an \"existing property of a resource\".\n\nYup.\n\n   Now, every existing property would also be a supported property\n   and, being live, would appear in the supported-live-property-set.\n   Ok.\n\nIf the server complies with the protocol, yes, this is true.\n\n   Now Geoff mentioned that a VCR with in-place editing would have\n   both DAV:checked-in and DAV:checked-out as supported properties,\n   and that independant of the checked in/out state of the resource!\n\nYes.\n\n   Now, here I became confused, since it means that not every supported\n   property is an existing property! \n\nYour DAV:checked-in and DAV:checked-out is a good example.\nOnly one of those properties can exist on a version-controlled\nresource, but both of them are supported.\n\n   If we define supported properties with: \n           a property which will exist, when a method is applied\nsuccessfully\n   then all non-versioned resources will have the DAV:checked-in as\n   supported property, since you can apply VERSION-CONTROL. So, that\n   does not seem to be a good definition...\n\nNo, I like mine much better (:-).\n\n   And what about supported methods? Is CHECKIN a supported method for\n   a checked-in resource, too? It will fail all the time...\n\nWhether or not a resource is \"checked-in\" can change over time.\nWhile it is checked-in, the CHECKIN request will fail, but while\nit is checked-out, the CHECKIN request might succeed (unless\nprevented by insufficient privileges or whatever).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3776883"}, {"subject": "RE: What is a supported property", "content": "I agree with all of Tim's responses to this post,\nwith the following clarification:\n\n   From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n\n   \"Stefan Eissing\" <stefan.eissing@greenbytes.de> wrote:\n\n   > And what about supported methods? Is CHECKIN a supported\n   > method for a checked-in resource, too? It will fail all\n   > the time...\n\n   The CHECKIN method is not supported for a checked-in resource,\n   i.e., there are no (non-failure) semantics for that operation in\n   the specification.  The analogy is with HTTP/1.1 Allow.\n\nThe answer to this question depends on whether or not your\nserver supports in-place-checkout feature.  If it does not,\nthen I agree with Tim.  If it does, then there is something\nyou can do to the resource to make the CHECKIN succeed,\nnamely first applying the CHECKOUT method.  Just as with \nthe PUT and PROPPPATCH methods, they are supported by a\nchecked-in VCR, even though you first have to check it out\nfor them to succeed.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3787045"}, {"subject": "RE: What is a supported property", "content": "On 22 Jun 2001 14:03:17 -0400, Clemm, Geoff wrote:\n> \n>    From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n> \n>    All this resourcetype and state thing aside:\n>    What is a supported property?\n> \n> Excellent question!  This should be made clearer in the spec.\n> How about the following:\n> \n> -------------\n> \n> 3.1.3DAV:supported-method-set (protected)\n> \n> This property identifies the methods that are supported by the\n> resource.  A method is supported by a resource if an application of\n> that method to that resource has the semantics defined for that\n> method by the features supported by that resource.\n> \n> 3.1.4DAV:supported-live-property-set (protected)\n> \n> This property identifies the live properties that are supported by\n> the resource.  A live property is supported by a resource if that\n> property has the semantics defined for that property by the\n> features supported by that resource.\n\nFrom following the whole discussion, I can see what you're trying to get\nat, but that wording is incredibly confusing. If I saw that in a \nspecification with no further explanation, I'd have no idea of\nwhat it meant. \n\nIt's even misleading: \"a live property is supported ... if that\nproperty has the semantics defined for that property ...\". It reads like\nthe property must exist for the resource - and yet, what we're talking\nabout is the set of properties which *can*, but may not currently, exist\nfor the resource. \n\nI *think* that the meaning of a supported property is the following\n(which is very close to what you said, but unfortunately re-introduces\nthat dangerous \"type\" word). \n\nA live property is supported for a given resource if, according\nto the semantics of the resource type, that property may\nexist for that resource.\n\nAssuming that I'm right about what it means, that's not a difficult\nconcept, but it's hard to find a precise way of wording it that \ndoesn't appear circular.\n\n-Mark\n \n--\n  \"There's nothing I like better than the sound of a banjo, unless of \n   course it's the sound of a chicken caught in a vacuum cleaner. \"\nMark Craig Chu-Carroll   (mcc@watson.ibm.com) \nIBM T.J. Watson Research Center  \n\n\n\n", "id": "lists-006-3795498"}, {"subject": "RE: Re (2): Last Call for DAV:checked-out-vcr Proposa", "content": "You can't really make an analogue between RCS commands \nand version-controlled resources, because RCS does not\nprovide the concept of a version-controlled resource\n(it has version history resources - the ,v files, and it\nhas workspaces).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Edgar@EdgarSchwarz.de [mailto:Edgar@EdgarSchwarz.de]\nSent: Tuesday, June 19, 2001 4:43 PM\nTo: ietf-dav-versioning@w3.org\nCc: Edgar@EdgarSchwarz.de\nSubject: Re (2): Last Call for DAV:checked-out-vcr Proposal\n\n\njohnhall@evergo.net wrote:\n> In my system I have no problem tracking moves, but it isn't my\n> objective.  My objective is having a CHECKIN of the working resource\n> update the VCR.  That isn't a 'gee it would be nice to have' request.\n> It is far more important to me than that.  Lack of such a feature would\n> be quite painful.\nI guess you want the feature you get in RCS with 'ci -u <filename>'.\nIf that's basically what you want then I wholeheartedly agree. That's\nat least my default usecase while creating new versions. I just hope I\ndidn't\nmiss something :-)\n\nCheers, Edgar\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Active Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-3805514"}, {"subject": "RE: CHECKIN to update a VCR ..", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   I thought that Geoff's proposal to have the VCR address be updated in\n   the CHECKIN to be quite sensible, and I didn't mind tracking the VCR\n   even if it was moved.  Probably because that was easy for my\n   implementation to do.\n\n   However, Geoff's proposal said that I had to let the client modify the\n   contents of this property.\n\nNote that the revised proposal no longer allows the client to do so\n(it is a protected property, maintained by the server).\n\n   That means that I have to deal with the case\n   where the client specifies a bad value (I need an error either on the\n   PROPFIND or the CHECKIN.  If I prohibit the bad value from being set the\n   error is on PROPFIND.  If the bad value is set, then an error may occur\n   on the CHECKIN and update VCR where it won't work.).\n\nYes, one of the reasons to make it a server-maintained protected\nproperty is to avoid these error cases.  It also prevents interoperability\nproblems when some servers let you play with the value, and others\ndon't.\n\n   If I had written the proposal, I'd have made the new property\n   \"apply-to-VCR\" removable but not client modifiable.  That way everyone\n   knows that the field either exists and is valid or doesn't exist.\n\nI'd go even farther ... you cannot modify or delete the property\n(i.e. it is protected).  You can of course delete the working resource\nif you are no longer interested in it.\n\n   I would also have considered having the element apply-to-version sent on\n   the CHECKIN rather than the CHECKOUT (which means \"apply-to-VCR\" would\n   always be set).  But that is a nit.  I'm happy with it on the CHECKOUT.\n\nOne reason I'd rather not have it on the CHECKIN is that this\nreintroduces the error cases (i.e. the specified URL is not a VCR, the\nworking resource is not checked-out from a version in the version\nhistory of the VCR, etc.)\n\n   So my full proposal, based on Geoff's, would be:\n\n   CHECKOUT postcondition:\n   If CHECKOUT is sent with the \"apply-to-version\" element, then the\n   working copy will have \"apply-to-VCR href-of-VCR\" set.\n\nYup.\n\n   If \"apply-to-VCR\" is set, then this field will be updated if the VCR is\n   moved.  (You could let the server refuse to move such a VCR but I'm\n   assuming that is a non-starter).\n\nA server could do this (a client needs to be prepared for the\nMOVE to fail because of locking or whatever anyway), but I wouldn't\nhightlight this possibility in the protocol (e.g. by giving it\nits own error code).\n\n   \"apply-to-VCR\" may be removed by a client, but not modified.\n\nI'd get rid of the \"may be removed by a client\".  Don't see any\ncompelling benefit, and it is simpler to just make the property protected\n(we have no \"cannot change but can delete\" properties as of yet).\n\n   CHECKIN poscondition:\n   A CHECKIN of a working copy with the \"apply-to-VCR\" property set will\n   update the VCR associated with the working copy.  If this isn't\n   possible, an error \"FILL-IN-HERE\" is generated if this isn't possible.\n\nYup.\n\n   A CHECKIN of a working copy without \"apply-to-VCR\" set when the working\n   copy can not be used to update a VCR will fail with the error\n   \"DAV:update-of-vcr-impossible\".  (Well, I thought I'd ask.  Our server\n   will fail such a checkin.  The only question is the error code that gets\n   kicked back.)\n\nI feel the same way about this as the \"disallow move\" case.\nA server can do this, and a client will need to handle the\nCHECKIN failing in any case (for locking reasons, for example),\nbut I wouldn't want to hightlight this in the protocol by\ngiving it its own error token).\n\nJust for interests sake, is anyone other than Tim against this\nset of semantics?  My current inclination is to leave the spec\nalone if there is even a single \"strong\" objection to a change,\nso Tim's objection is sufficient, but I was wondering if there\nare any versioning server implementors out there which actually\nwould have a problem implementing the \"move tracking\" behavior.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3815174"}, {"subject": "RE: Last Call for DAV:checked-out-vcr Proposa", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   You say that your implementation makes it hard to make CHECKIN/UPDATE\n   atomic.  On my system, they are naturally atomic.  That is why I want\n   the atomic operation offered.\n\n   It might be easier if you reversed the nomenclature.  If instead of\n   CHECKIN/UDPATE you thought in terms of UPDATE/CHECKIN the problems would\n   probably fall out.\n\nOK, I'm a dufus (:-).  Yes, on my system at least, if you do the\n\"update\" part first (for my system, an in-place checkout, followed by a\nPUT/PROPPATCH), then you can easily roll-back if the CHECKIN fails (by\njust doing an UNCHECKOUT).\n\nSo I retract my concern that an \"atomic CHECKIN/UPDATE\" would be\na problem to implement (for us, at least).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3826757"}, {"subject": "RE: What is a supported property", "content": "   From: Mark Chu-Carroll [mailto:mcc@watson.ibm.com]\n\n   On 22 Jun 2001 14:03:17 -0400, Clemm, Geoff wrote:\n   > How about the following:\n   > \n   > -------------\n   > \n   > 3.1.3DAV:supported-method-set (protected)\n   > \n   > This property identifies the methods that are supported by the\n   > resource.  A method is supported by a resource if an application of\n   > that method to that resource has the semantics defined for that\n   > method by the features supported by that resource.\n   > \n   > 3.1.4DAV:supported-live-property-set (protected)\n   > \n   > This property identifies the live properties that are supported by\n   > the resource.  A live property is supported by a resource if that\n   > property has the semantics defined for that property by the\n   > features supported by that resource.\n\n   From following the whole discussion, I can see what you're trying\n   to get at, but that wording is incredibly confusing. If I saw that\n   in a specification with no further explanation, I'd have no idea of\n   what it meant.\n\nWell, that wouldn't be a good thing (:-).  All suggestions for\nhow to make this clearer/better are greatly appreciated!\nHowever the \"great resourcetype debate\" falls out, minimally\nwe need to clearly define what the supported-*-set properties\nmean.\n\n   It's even misleading: \"a live property is supported ... if that\n   property has the semantics defined for that property ...\". It reads\n   like the property must exist for the resource - and yet, what we're\n   talking about is the set of properties which *can*, but may not\n   currently, exist for the resource.\n\nI used the phrase \"has the semantics defined for that property\"\nas an attempt to *not* imply that it must exist (but apparently\nfailed :-).\n\n   I *think* that the meaning of a supported property is the following\n   (which is very close to what you said, but unfortunately re-introduces\n   that dangerous \"type\" word). \n\n           A live property is supported for a given resource if, according\n           to the semantics of the resource type, that property may\n           exist for that resource.\n\nUnfortunately, this just defers the question to another undefined\nphrase \"according to the semantics of the resource type\".  Adding\nvalues to DAV:resourcetype wouldn't solve this problem, because the\nprotocol would then have to state when a resource has a particular\nvalue in the DAV:resourcetype field.  We'd be tempted to say \"when it\nsupports the semantics of all the methods and live properties defined\nfor that resource\", but then we'd have closed the circle again (:-).\n\n   Assuming that I'm right about what it means, that's not a difficult\n   concept, but it's hard to find a precise way of wording it that \n   doesn't appear circular.\n\nAll suggestions are greatly appreciated!  One comment: the definition\nprobably has to include a reference to the set of features supported\nby a resource.  For example, the activity feature adds the\nDAV:activity-set to a version, so it is not the case that all versions\nsupport the DAV:activity-set property, but rather that all versions\nthat support the activity feature support the DAV:activity-set\nproperty.  Happily, the concept of \"feature\" *is* well defined, so\nwe're OK using that term.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3834599"}, {"subject": "RE: Re: What is a supported property", "content": "> I think we agree to disagree on the complexity issues of\n> extending DAV:resourcetype as compared to DAV:supported-live-\n> property-set.\n\nOk.\n\n> DAV:supported-live-property-set will by definition be extended\n> by every future extension to the DAV protocol family. That means\n> it will automatically have new members with every extension.\n\nAgreed.\n\n> These new members will change the way how clients interpret\n> the value of DAV:supported-live-property-set, e.g. its semantics.\n\nI disagree.  The property still means the set of supported live properties\nno matter what the size of the set.\n\n> > How much more difficult is it to look for multiple values than single\n> > values?\n>\n> Real world example: my client has to detect and work with lock-null\n> resources.\n\n[Snipped problems with IIS, mod_dav and HTTP servers in general.]\n\n> Does my client have to work with those servers? It sure does!\n>\n> Would I be glad for a resource type lock-null? Take a wild guess.\n\nThat won't fix the server implementations.\n\nTim\n\n\n\n", "id": "lists-006-3845397"}, {"subject": "RE: What is a supported property", "content": "   From: Clemm, Geoff [mailto:gclemm@Rational.Com]\n\n   One comment: the definition probably has to include a reference to\n   the set of features supported by a resource.  For example, the\n   activity feature adds the DAV:activity-set to a version, so it is\n   not the case that all versions support the DAV:activity-set\n   property, but rather that all versions that support the activity\n   feature support the DAV:activity-set property.  Happily, the\n   concept of \"feature\" *is* well defined, so we're OK using that\n   term.\n\nOh, ARGHHH. My brain is a twisty maze of passages,\nall of which are starting to look alike.  The \"depends\non the feature set\" only applies to the DAV:supported-method-set,\nnot to the DAV:supported-live-property-set.\n\nSo I need to take out the reference to features in\nDAV:supported-live-property-set, and retract my bogus example from\nthe quoted message.  A correct example would be:\n\n\"For example, a VCR that supports the activity feature must\nsupport the various semantics added by the activity feature,\nbut a VCR that does not support the activity feature does not.\"\n\nHere's the revised (proposed) definitions:\n\n--------------\n\n3.1.3DAV:supported-method-set (protected)\n\nThis property identifies the methods that are supported by the\nresource.  A method is supported by a resource if an application of\nthat method to that resource has the semantics defined by the features\nsupported by that resource.\n\n3.1.4DAV:supported-live-property-set (protected)\n\nThis property identifies the live properties that are supported by the\nresource.  A live property is supported by a resource if that property\nhas the semantics defined for that property.\n\n3.1.5DAV:supported-report-set (protected)\n\nThis property identifies the reports that are supported by the\nresource.  A report is supported by a resource if it produces the\nresults defined for that report.\n\n--------------\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3853435"}, {"subject": "RE: What is a supported property", "content": ">    From following the whole discussion, I can see what you're trying\n>    to get at, but that wording is incredibly confusing. If I saw that\n>    in a specification with no further explanation, I'd have no idea of\n>    what it meant.\n>\n> Well, that wouldn't be a good thing (:-).  All suggestions for\n> how to make this clearer/better are greatly appreciated!\n> However the \"great resourcetype debate\" falls out, minimally\n> we need to clearly define what the supported-*-set properties\n> mean.\n\nI have to agree that the suggested wording is very confusing (but I'll need\na moment to think of a reasonable alternative).\n\nTim\n\n\n\n", "id": "lists-006-3862778"}, {"subject": "RE: Re: What is a supported property", "content": "Stefan:\n\nThese kinds of concrete examples are great!  I believe it leads to\na different conclusion than you perhaps intended, but this allows\nthe discussion to be grounded in concrete interoperability issues,\nwhich I think are far more constructive than the somewhat \nmetaphysical directions which I and others have been guilty of in\nother postings.\n\nComments below ...\n\n   From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n\n   Real world example: my client has to detect and work with lock-null\n   resources.\n   They have no special resource type in RFC 2518. So I have to look at the\n   properties:\n   - resourcetype: not collection\n   - lockdiscovery: a lock-null resource should have a write lock.\n   - getcontentlength: present, but without a value.\n\nWell, actually, you would look for the properties and methods that\nyou are going to use, and see if the resource supports them.\n\n   According to spec: this should work. However\n\n   1) IIS pretends to implement lock-null. It creates empty files which\n      do not vanish when the lock expires. Detection of the resource my\n      client creates (successfully according to response code) fails, since\n      the getcontentlength is 0. But I would like to do MKCOL on it...\n\nWith the DAV:supported-*-set approach, if you want to do a MKCOL, you\nwould check whether MKCOL was in the DAV:supported-method-set.  IIS\nhas the opportunity here to tell you what is going on, by *not*\nputting MKCOL in the DAV:supported-method-set.\n\nContrast this with the DAV:resourcetype approach (i.e. having the\nclient check for the presence of \"DAV:lock-null-resource\" in\nDAV:resourcetype).  If IIS set this value, and based on it you tried\nthe MKCOL operation (which should work, according to the protocol),\nyou would be disappointed.  If IIS was \"honest\" and left this out\nof the DAV:resourcetype, then your client would have to assume\nthis resource has *none* of the methods or properties of a\nlock null resource.  Now I'm not in favor of buggy non-compliant\nservers, but they are there, and it sure looks like we'd be\nbetter of using DAV:supported-method-set to deal with this.\n\n   2) moddav supports lock-null with some special quirks: at first, the\n   PROPFIND\n      response is OK, but the resource does not expire when the lock timeout\n      says it should. Instead it hangs around for a while afterwards and\n      the timeout value reported in seconds is bigger than 2^31-1. Oops,\n      can this be a valid lock?\n\nAnd if you looked at the actual properties and methods supported by\nthat resource, you'd have a reasonable chance of interoperating with\nit, as opposed to trying to rely on the meaningfulness of\n\"DAV:lock-null-resource\" in the DAV:resourcetype field.\n\n   3) Some servers do not accept certain HTTP requests, others produce\ninvalid\n      (e.g. not well-formed) xml and some throw a whole range of nowhere\n      defined properties in the DAV: namespace at a client.\n\nAnd if you looked at the DAV:supported-method-set, you would\nknow whether or not a server accepted those certain HTTP requests\nor not.  Not much you can do about a server that produces invalid\nXML ... if it does that, it is unlikely you will be able to put\nmuch faith in its correctly returning any property value,\nincluding DAV:resourcetype or DAV:supported-*-set.\n\n   Does my client have to work with those servers? It sure does!\n\nAnd it would work even better if it had DAV:supported-*-set\nto tell it what was really going with the resources on at that server.\n\n   Would I be glad for a resource type lock-null? Take a wild guess.\n\nNot if you had the option of using DAV:supported-*-set (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3870363"}, {"subject": "RE: What is a supported property", "content": "What about\n\n'A method is supported if the server is not going to return a \"501 Not\nImplemented\" whenever the method is received for that resource.'\n\nThere could be similar wordings for live-property and report, based on\nwhether the server will succeed or fail a request for that property/report.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Friday, June 22, 2001 1:24 PM\n> To: Ietf-Dav-Versioning\n> Subject: RE: What is a supported property?\n>\n>\n>    From: Clemm, Geoff [mailto:gclemm@Rational.Com]\n>\n>    One comment: the definition probably has to include a reference to\n>    the set of features supported by a resource.  For example, the\n>    activity feature adds the DAV:activity-set to a version, so it is\n>    not the case that all versions support the DAV:activity-set\n>    property, but rather that all versions that support the activity\n>    feature support the DAV:activity-set property.  Happily, the\n>    concept of \"feature\" *is* well defined, so we're OK using that\n>    term.\n>\n> Oh, ARGHHH. My brain is a twisty maze of passages,\n> all of which are starting to look alike.  The \"depends\n> on the feature set\" only applies to the DAV:supported-method-set,\n> not to the DAV:supported-live-property-set.\n>\n> So I need to take out the reference to features in\n> DAV:supported-live-property-set, and retract my bogus example from\n> the quoted message.  A correct example would be:\n>\n> \"For example, a VCR that supports the activity feature must\n> support the various semantics added by the activity feature,\n> but a VCR that does not support the activity feature does not.\"\n>\n> Here's the revised (proposed) definitions:\n>\n> --------------\n>\n> 3.1.3DAV:supported-method-set (protected)\n>\n> This property identifies the methods that are supported by the\n> resource.  A method is supported by a resource if an application of\n> that method to that resource has the semantics defined by the features\n> supported by that resource.\n>\n> 3.1.4DAV:supported-live-property-set (protected)\n>\n> This property identifies the live properties that are supported by the\n> resource.  A live property is supported by a resource if that property\n> has the semantics defined for that property.\n>\n> 3.1.5DAV:supported-report-set (protected)\n>\n> This property identifies the reports that are supported by the\n> resource.  A report is supported by a resource if it produces the\n> results defined for that report.\n>\n> --------------\n>\n> Cheers,\n> Geoff\n>\n\n\n\n", "id": "lists-006-3881504"}, {"subject": "RE: CHECKIN to update a VCR ..", "content": "> From: ietf-dav-versioning-request@w3.org \n> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> Sent: Friday, June 22, 2001 12:02 PM\n> To: 'DeltaV (E-mail)'\n> Subject: RE: CHECKIN to update a VCR ...\n> \n>    From: John Hall [mailto:johnhall@evergo.net]\n> \n>    However, Geoff's proposal said that I had to let the \n> client modify the contents of this property.\n> \n> Note that the revised proposal no longer allows the client to \n> do so (it is a protected property, maintained by the server).\n\nGreat, we agree and I'll edit out this part of the conversation.\n\n> I'd go even farther ... you cannot modify or delete the \n> property (i.e. it is protected).  You can of course delete \n> the working resource if you are no longer interested in it.\n\nAlso agreed.\n\n> One reason I'd rather not have it on the CHECKIN is that this \n> reintroduces the error cases (i.e. the specified URL is not a \n> VCR, the working resource is not checked-out from a version \n> in the version history of the VCR, etc.)\n\nOk.\n\n>    So my full proposal, based on Geoff's, would be:\n> \n>    CHECKOUT postcondition:\n>    If CHECKOUT is sent with the \"apply-to-version\" element, then the\n>    working copy will have \"apply-to-VCR href-of-VCR\" set.\n> \n> Yup.\n> \n>    If \"apply-to-VCR\" is set, then this field will be updated \n> if the VCR is moved.\n\n> \n>    CHECKIN poscondition:\n>    A CHECKIN of a working copy with the \"apply-to-VCR\" \n> property set will\n>    update the VCR associated with the working copy.  If this isn't\n>    possible, an error \"FILL-IN-HERE\" is generated if this \n> isn't possible.\n> \n> Yup.\n\nPlease define \"FILL-IN-HERE\"\n\n\n\n", "id": "lists-006-3892297"}, {"subject": "RE: What is a supported property", "content": "I like it!\n(I believe it should \"405\" rather than \"501\" though.)\n\nFor supported reports, how about just adding a DAV:supported-report\nprecondition to the REPORT method?  Then we can say:\n\"A report is supported if the response to a REPORT request\nfor that report is not 403 with a DAV:supported-report error token\".\n\nNow how about properties?  2518 only defines a 404\n(not found) value, so we would have to extend that.\nUnfortunately, we probably shouldn't use 405, since\nthat's defined as \"Method Not Allowed\".  Probably\nbest to just add a DAV:supported-property precondition\nto the PROPFIND method?  Then we can say:\n\"A live property is supported if the response to a\nPROPFIND request for that property is not 403 with a\nDAV:supported-property error token\".\n\nHow does this sound to everyone else (both the general approach,\nand the specifics)?  I assume nobody wants to support my\noriginal approach (I sure don't :-).\n\nCheers,\nGeoff\n\n\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\n\nWhat about\n\n'A method is supported if the server is not going to return a \"501 Not\nImplemented\" whenever the method is received for that resource.'\n\nThere could be similar wordings for live-property and report, based on\nwhether the server will succeed or fail a request for that property/report.\n\nlisa\n\n\n\n", "id": "lists-006-3902155"}, {"subject": "Resolving outstanding issues in Delta", "content": "My current approach, unless guided otherwise by our working\ngroup chair, is to only make changes to the protocol if there\nis consensus that the change should be made.  Currently,\nI do not see consensus on either the resourcetype issue, or\nthe working resource checkin issue (note: this means that\nthe current DAV:resourcetype values in the protocol stay in).\n\nSince I believe that neither of these issues represent a critical flaw in\nthe protocol (but rather represent possibly useful extensions\nthat we could add in later), I propose that we table the issues\nfor now.\n\nWould anyone like to take these topics to our Friday noon\nconference call?  It is possible that we could make more\nprogress with that higher bandwidth medium.  In any case,\nwe will discuss them at the DeltaV working group meeting\nin London.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\nSent: Friday, June 22, 2001 11:07 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Dav:resourcetype\n\n\nI don't think we are getting close to a consensus on this issue.  I'm\npersonally in favor of using dav:resourcetype for type information \n(after Yaron used his Jedi mind tricks on me), but I don't care enough\nto argue about it anymore.\n\nIs there a defined IETF procedure for flipping a coin to decide on what\nto do with a spec, or some other source of randomness?  How about if \neverybody agrees that if the Dow is an even number on Monday (at the\nclose, truncating fractional part) we will put type information in \ndav:resourcetype, and if it is an odd number,\nwe will use supported-*-resource-set (and go back to <dav:is-principal>\nin the ACL spec)?\n\nDeal?  Geoff?\n\n(P.S.  I have a suggested topic as an alternative for those who want to \nargue about this more:  Is operator overloading in C++ a good idea or\nnot?  Discuss.)\n\n--Eric\n\n\n\n", "id": "lists-006-3910801"}, {"subject": "RE: Resolving outstanding issues in Delta", "content": "I'd be happy to be in the conf call and bring up what I see as two major\nremaining problems.  They are not merely marshalling problems.  If it were\nmy implementation design that had these problems, I would call them\n\"showstoppers\".\n\n1. Stored resources can get lost, or unfindable.  This happens when VCRs are\ndeleted (possibly by clients that don't understand versioning).  The problem\nis that even versioning-aware clients may not subsequently be able to find\nthe VHRs and Version resources that are thus orphaned.  This is a memory\nleak.\n\nSolutions to problem 1 might involve something like a \"orphaned resources\nreport\" that allowed the storage losses to be \"found\".\n\n2. Features which DeltaV has presented as \"independent\" are not.  Working\nResource requires UPDATE and possibly workspaces.\n\nSolutions to problem 2 might involve defining a CHECKIN verb that includes\nthe update functionality.  Or it might involve recombining the sections of\nDeltaV so that a server cannot advertise support for Working Resource if it\ndoes not support UPDATE and possibly workspaces.\n\nPlease let me know when the conf call is and how to join.\n\nLisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Friday, June 22, 2001 3:13 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: Resolving outstanding issues in DeltaV\n>\n>\n> My current approach, unless guided otherwise by our working\n> group chair, is to only make changes to the protocol if there\n> is consensus that the change should be made.  Currently,\n> I do not see consensus on either the resourcetype issue, or\n> the working resource checkin issue (note: this means that\n> the current DAV:resourcetype values in the protocol stay in).\n>\n> Since I believe that neither of these issues represent a critical flaw in\n> the protocol (but rather represent possibly useful extensions\n> that we could add in later), I propose that we table the issues\n> for now.\n>\n> Would anyone like to take these topics to our Friday noon\n> conference call?  It is possible that we could make more\n> progress with that higher bandwidth medium.  In any case,\n> we will discuss them at the DeltaV working group meeting\n> in London.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\n> Sent: Friday, June 22, 2001 11:07 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Dav:resourcetype\n>\n>\n> I don't think we are getting close to a consensus on this issue.  I'm\n> personally in favor of using dav:resourcetype for type information\n> (after Yaron used his Jedi mind tricks on me), but I don't care enough\n> to argue about it anymore.\n>\n> Is there a defined IETF procedure for flipping a coin to decide on what\n> to do with a spec, or some other source of randomness?  How about if\n> everybody agrees that if the Dow is an even number on Monday (at the\n> close, truncating fractional part) we will put type information in\n> dav:resourcetype, and if it is an odd number,\n> we will use supported-*-resource-set (and go back to <dav:is-principal>\n> in the ACL spec)?\n>\n> Deal?  Geoff?\n>\n> (P.S.  I have a suggested topic as an alternative for those who want to\n> argue about this more:  Is operator overloading in C++ a good idea or\n> not?  Discuss.)\n>\n> --Eric\n\n\n\n", "id": "lists-006-3920676"}, {"subject": "RE: AW: What is a supported property", "content": "   From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n\n   \"Stefan Eissing\" <stefan.eissing@greenbytes.de> wrote:\n\n   > > To avoid confusion the server is required to disallow setting\n   > > resource properties that are defined in the specification but\n   > > are not supported (i.e. a PROPPATCH of DAV:checked-in on a\n   > > DeltaV-compliant versionable resource MUST fail).\n\n   > It does not say so in the spec. In fact, I think it would\n   > be unwise to say so in the spec.\n\n   You're right, I can't find that statement any longer in the spec.\n\nTim: In this case, your memory wins out over your eyesight (:-).\nIn particular, look at the following PROPPATCH postcondition:\n\n(DAV:cannot-modify-unsupported-property): An attempt to modify a\nproperty defined by this document whose semantics are not enforced by\nthe server MUST fail.  This helps ensure that a client will be\nnotified when it is trying to use a property whose semantics are not\nsupported by the server.\n\n   > Imagine a server which complies to DeltaV in regard to\n   > supported-*-set, but does not implement DeltaV resource\n   > types. This server could allow a PROPPATCH on DAV:checked-in.\n   > If you call such a resource versionable would depend\n   > on the supported-method-set then, not on the\n   > supported-property-set.\n\n   I think allowing properties to be set in the DAV: namespace that do not\n   have the semantics defined in the DAV protocols is extremely dangerous.\n\nI agree.  Although I do not believe this thread matters for the\nDeltaV protocol (the DeltaV protocol explicitly forbids this kind\nof redefinition), I believe this thread does matter for WebDAV\nfuture evolution (to ensure that other extensions do not violate\nthis principle).\n\n   > I think that is a valid case, since you cannot couple\n   > supported-*-set to implementation of DeltaV resource types.\n   > supported-*-set has to be a feature that can be used by\n   > other (orthogonal) extensions as well in the future.\n\nBut we can require that those other extensions have compatible\nsemantics.  An explicit registration of property names with IANA would\nbe an appropriate path to take here.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3932871"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline   resource type value", "content": "Neither Tim nor I ever used the interaction of DAV:resourcetype\nwith Web Folders as a reason to not use DAV:resourcetype, so although I\nagree that the case is closed on the Web Folders treatment of\nDAV:resourcetype (or at least, was closed until JimA raised it\nagain :-), this has little or no bearing on the discussion\nof whether adding new values to DAV:resourcetype or using\nDAV:supported-*-set\nis a better way for clients to interoperate with DeltaV servers.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\nSent: Friday, June 22, 2001 5:29 AM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: AW: Removing the DAV:activity and DAV:version-history and\nDAV:bas eline resource type values\n\n\nOne correction though:\n\nACL (0.6) defines resource type DAV:principal and for collection\nprincipals it reports:\n\n<D:resourcetype>\n  <D:collection/>\n  <D:principal/>\n</D:resourcetype>\n\nSo, all arguments with or without Webfolders for or against putting\nadditional things into DAV:resourcetype are void, unless someone\nthrows all the supported-* stuff into the ACL spec as well (it's\non last call, in case someone missed that).\n\nMy expectation would be that clients have to deal at least as often\nwith ACL WebDAV servers than DeltaV WebDAV servers.\n\nCase closed. There is not additional burden on clients with deltaV\nresourcetype extensions.\n\n//Stefan\n\n> -----Urspr?ngliche Nachricht-----\n> Von: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n> Gesendet: Donnerstag, 21. Juni 2001 14:38\n> An: ietf-dav-versioning@w3.org\n> Betreff: RE: Removing the DAV:activity and DAV:version-history and\n> DAV:bas eline resource type values\n>\n>\n> Nice summary, Stefan!\n>\n> One addendum: Notice that the binding protocol addresses\n> the 2518 omission of a few critical collection operations\n> (BIND, UNBIND, REBIND).  If we merge the \"bind\"\n> protocol into the next draft of 2518 (which we should do),\n> then DAV:supported-method-set allows you to distinguish a\n> collection from a non-collection.  Arguably, there are a few\n> key collection properties (e.g. DAV:child-count) that should\n> be added as well.  My experience is that every new type\n> of resource normally brings at least one new method or property\n> in with it.\n>\n> Also note that Tim recently posted on this thread:\n>   I support taking them out.  We don't need them.\n>\n> So that puts Tim and me pretty much in the same camp.\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n> Sent: Thursday, June 21, 2001 4:17 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: AW: Removing the DAV:activity and DAV:version-history and\n> DAV:baseline resource type values\n>\n>\n> Well, I'm amazed how much energy is spend here on that\n> DAV:resourcetype thing and MS WebFolders.\n>\n> IF (and that's the point worth discussing) deltaV introduces\n> _types_ of resources, then it can define a protected live\n> property DAV:subtype/DAV:interface/DAV:reallyresourcetype,\n> put it's new type definitions there and leave DAV:resourcetype\n> as it is. (Include the new property in an <allprop/> response,\n> MS Webfolder will never see it, it does not use allprop.)\n>\n> The alternative is to have no new types and introduce only\n> new live properties, which a client can learn about with\n> DAV:supported-live-property-set.\n>\n> I got the impression somehow that Geoff is in favour of the latter\n> one, Tim is undecided, Greg is opposed to it, and the rest\n> is trying to figure out what DAV:supported-live-property-set\n> means, how it is interpreted and how it might survive future\n> extensions.\n>\n> What other examples beside deltaV do we have in other drafts:\n> - Redirect Refs: -> new DAV:resourcetype + property\n> - Ordered Collections -> new property\n> - Binding: none\n> - DASL: none\n> - ACL: none\n>\n> Best Regards,\n>\n> Stefan\n>\n> > -----Ursprungliche Nachricht-----\n> > Von: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Jim Amsden\n> > Gesendet: Mittwoch, 20. Juni 2001 23:21\n> > An: ietf-dav-versioning@w3.org\n> > Betreff: RE: Removing the DAV:activity and DAV:version-history and\n> > DAV:baselin e resource type values\n> >\n> >\n> > Lisa,\n> > This is really a sticky one. On the one hand, we have\n> introduced many new\n> > resource types in DeltaV, but only defined DAV:resourcetype for some of\n> > them, and we know this causes problems for some servers. If we don't use\n> > DAV:resourcetype, then we don't introduce compatibility\n> problems with DAV\n> > level 1 or 2, and DeltaV servers can interoperate somewhat with DAV\n> > clients (one of our primary requirements). We're not really just\n> > trying to\n> > support existing servers with bugs, but make sure we maintain\n> > interoperability. Just providing new resource types isn't\n> enough. We need\n> > to provide a backward compatible type hierarchy scheme so down-level\n> > clients can see for example, a baseline as a DAV:collection. We could do\n> > this, but it would be another rat-hole, and then there's the\n> problem with\n> > existing servers that might not parse the extended XML properly.\n> > These are\n> > of course things we'd like to avoid if we can.\n> >\n> > So we're left with removing our DAV:resourcetypes, and requiring clients\n> > to introspect supported properties on a resource to figure out the type\n> > based on a table in the spec. This works *except* for (sub)types that\n> > don't introduce additional properties. Its a little more\n> > inconvenient, but\n> > perhaps won't be that different if we really solved the type hierarchy\n> > problem. The end result is that DAV:resourcetype is pretty useless.\n> >\n> > Geoff, do we still have a potential problem with the introspection\n> > approach in cases where new types don't introduce new properties?\n> > Unfortunately type depends on more than signature, it also depends on\n> > behavior, and this isn't captured in the supported properties in all\n> > cases. Collections in DAV are an example. They can be considered\n> > a kind of\n> > resource that doesn't introduce new properties, but does change method\n> > behavior. Clients will of course have to be able to distinguish them in\n> > order for users to understand the results of their requests.\n> >\n> >\n> >\n> >\n> >\n> > \"Lisa Dusseault\" <lisa@xythos.com>\n> > 06/20/2001 04:32 PM\n> >\n> >\n> >         To:     \"DeltaV\" <ietf-dav-versioning@w3.org>, \"Jim\n> > Amsden\" <jamsden@us.ibm.com>,\n> > \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n> >         cc:\n> >         Subject:        RE: Removing the DAV:activity and\n> > DAV:version-history and DAV:baselin   e\n> > resource type values\n> >\n> >\n> >\n> >\n> > > The reason we can't introduce new resource types for all of the\n> > > versioning\n> > > resources is because we have to support down-level clients that only\n> > know\n> > > about DAV:collection. For new resources that down-level\n> clients couldn't\n> > > possibly know about, workspaces, activities, baselines, etc., we don't\n> > > have this restriction. I agree with Greg and Tim. We should be as\n> > > specific\n> > > as we can about declared type and only compromise when required by\n> > > interoperability considerations.\n> >\n> > I thought we had rather strong guidance that working around bugs in a\n> > single\n> > implementation was NOT recommended.  Clarification, Jim?\n> >\n> > I'd also point out that frequently it will be OK even with buggy clients\n> > to\n> > introduce new resource types.  For example, I don't suppose it will be\n> > that\n> > easy for non-versioning-aware clients to stumble across URLs of\n> > collections\n> > of version-histories, activities, baselines and workspaces.  Not all of\n> > these new resources are even browsable, and they may not appear in any\n> > regular URL space that regular clients are expected to use.\n> >\n> > lisa\n> >\n> >\n>\n>\n>\n\n\n\n", "id": "lists-006-3942750"}, {"subject": "AW: Re: What is a supported property", "content": "Geoff,\n\nI totally agree that it is _possible_ to solve all future interop\nand extension problems with the DAV:supported-*-sets. The question\nis: will it be _likely_?\n\nThe lock-null resource is an example of a resource which a client\ncan only tell apart by looking at a certain set of properties, as\nI described. As you can see, this is very \"brittle\".\n\nI would like to emphasize the case of moddav (very well compliant\nserver, thanks Greg) which bends the definition of lock-null\nand its timeouts intentionally to please people with MS Office.\n\nCertainly, moddav does not violate 2518 there, but it still comes\nas a little surprise to clients like mine. It would be easier to\ncope with this if the protocol would allow for a little bit more\nredundancy, to allow moddav to say: \"dear client, this really is\na lock-null resource, even though the lock timeout might look\nstrange. Trust me, I know what I'm doing.\"\n\nI expect the same to happen with DAV:suported-*-set. \n1. It is not trivial to understand and implement correctly\n2. Some servers will err, some clients will err. Depending on market\n   share, all other will have to cope with those errors.\n\nTo repeat: I think the likelihood and amount of such errors will\nbe higher with the DAV:supported-*-set than a DAV:resourcetype. \n\nAnd now let's talk about something else. How's the wheather at\nthe west coast?\n\nStefan\n\n> [mailto:ietf-dav-versioning-request@w3.org]Im Auftrag von Clemm, Geoff\n> \n> Stefan:\n> \n> These kinds of concrete examples are great!  I believe it leads to\n> a different conclusion than you perhaps intended, but this allows\n> the discussion to be grounded in concrete interoperability issues,\n> which I think are far more constructive than the somewhat \n> metaphysical directions which I and others have been guilty of in\n> other postings.\n> \n> Comments below ...\n> \n>    From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de]\n> \n>    Real world example: my client has to detect and work with lock-null\n>    resources.\n>    They have no special resource type in RFC 2518. So I have to \n> look at the\n>    properties:\n>    - resourcetype: not collection\n>    - lockdiscovery: a lock-null resource should have a write lock.\n>    - getcontentlength: present, but without a value.\n> \n> Well, actually, you would look for the properties and methods that\n> you are going to use, and see if the resource supports them.\n> \n>    According to spec: this should work. However\n> \n>    1) IIS pretends to implement lock-null. It creates empty files which\n>       do not vanish when the lock expires. Detection of the resource my\n>       client creates (successfully according to response code) \n> fails, since\n>       the getcontentlength is 0. But I would like to do MKCOL on it...\n> \n> With the DAV:supported-*-set approach, if you want to do a MKCOL, you\n> would check whether MKCOL was in the DAV:supported-method-set.  IIS\n> has the opportunity here to tell you what is going on, by *not*\n> putting MKCOL in the DAV:supported-method-set.\n> \n> Contrast this with the DAV:resourcetype approach (i.e. having the\n> client check for the presence of \"DAV:lock-null-resource\" in\n> DAV:resourcetype).  If IIS set this value, and based on it you tried\n> the MKCOL operation (which should work, according to the protocol),\n> you would be disappointed.  If IIS was \"honest\" and left this out\n> of the DAV:resourcetype, then your client would have to assume\n> this resource has *none* of the methods or properties of a\n> lock null resource.  Now I'm not in favor of buggy non-compliant\n> servers, but they are there, and it sure looks like we'd be\n> better of using DAV:supported-method-set to deal with this.\n> \n>    2) moddav supports lock-null with some special quirks: at first, the\n>    PROPFIND\n>       response is OK, but the resource does not expire when the \n> lock timeout\n>       says it should. Instead it hangs around for a while afterwards and\n>       the timeout value reported in seconds is bigger than 2^31-1. Oops,\n>       can this be a valid lock?\n> \n> And if you looked at the actual properties and methods supported by\n> that resource, you'd have a reasonable chance of interoperating with\n> it, as opposed to trying to rely on the meaningfulness of\n> \"DAV:lock-null-resource\" in the DAV:resourcetype field.\n> \n>    3) Some servers do not accept certain HTTP requests, others produce\n> invalid\n>       (e.g. not well-formed) xml and some throw a whole range of nowhere\n>       defined properties in the DAV: namespace at a client.\n> \n> And if you looked at the DAV:supported-method-set, you would\n> know whether or not a server accepted those certain HTTP requests\n> or not.  Not much you can do about a server that produces invalid\n> XML ... if it does that, it is unlikely you will be able to put\n> much faith in its correctly returning any property value,\n> including DAV:resourcetype or DAV:supported-*-set.\n> \n>    Does my client have to work with those servers? It sure does!\n> \n> And it would work even better if it had DAV:supported-*-set\n> to tell it what was really going with the resources on at that server.\n> \n>    Would I be glad for a resource type lock-null? Take a wild guess.\n> \n> Not if you had the option of using DAV:supported-*-set (:-).\n> \n> Cheers,\n> Geoff\n> \n> \n> \n\n\n\n", "id": "lists-006-3963849"}, {"subject": "Re: Resolving outstanding issues in Delta", "content": "I agree with this approach and conclusion. Let's focus on making sure we \nhave the full issue list and a set of candidate solutions to discuss. Some \nmay interact. The working group activity indicates we're not done, but \nwe're healthy and moving forward. Thanks to everyone for the thoughtful \ninput.\n\n\n\n\n\n\"Clemm, Geoff\" <gclemm@rational.com>\nSent by: ietf-dav-versioning-request@w3.org\n06/22/2001 06:12 PM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        Resolving outstanding issues in DeltaV\n\n \n\nMy current approach, unless guided otherwise by our working\ngroup chair, is to only make changes to the protocol if there\nis consensus that the change should be made.  Currently,\nI do not see consensus on either the resourcetype issue, or\nthe working resource checkin issue (note: this means that\nthe current DAV:resourcetype values in the protocol stay in).\n\nSince I believe that neither of these issues represent a critical flaw in\nthe protocol (but rather represent possibly useful extensions\nthat we could add in later), I propose that we table the issues\nfor now.\n\nWould anyone like to take these topics to our Friday noon\nconference call?  It is possible that we could make more\nprogress with that higher bandwidth medium.  In any case,\nwe will discuss them at the DeltaV working group meeting\nin London.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\nSent: Friday, June 22, 2001 11:07 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Dav:resourcetype\n\n\nI don't think we are getting close to a consensus on this issue.  I'm\npersonally in favor of using dav:resourcetype for type information \n(after Yaron used his Jedi mind tricks on me), but I don't care enough\nto argue about it anymore.\n\nIs there a defined IETF procedure for flipping a coin to decide on what\nto do with a spec, or some other source of randomness?  How about if \neverybody agrees that if the Dow is an even number on Monday (at the\nclose, truncating fractional part) we will put type information in \ndav:resourcetype, and if it is an odd number,\nwe will use supported-*-resource-set (and go back to <dav:is-principal>\nin the ACL spec)?\n\nDeal?  Geoff?\n\n(P.S.  I have a suggested topic as an alternative for those who want to \nargue about this more:  Is operator overloading in C++ a good idea or\nnot?  Discuss.)\n\n--Eric\n\n\n\n", "id": "lists-006-3977379"}, {"subject": "RE: Working Resource Issues ..", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   > ... so it would need to be a \n   > really glaring flaw for us to add/change the protocol at this \n   > point (deletion is still fair game, though).\n\n   How do you determine glaring flaw?  It meets my definition, and the\n   use case is not unheard of if you are sympathetic to servers that\n   don't want to support UPDATE.\n\nI am sympathetic to servers that don't want to support UPDATE, but the\nworking group as a whole was not, so the update feature was made part\nof the client-workspace package.  The consensus of the working group\nwas that making the body and dead properties of a VCR be a copy of\nthose of an arbitrary version was too simple to implement to be an\nobstacle for a basic versioning server.  I had no real\ncounter-argument to that statement, which is why update stayed as part\nof the client-workspace feature.  So you would need to provide some\ncompelling argument for why it would be hard to implement.  \"My users\ndon't want it\" would not count as a compelling argument, since we're\ntalking about compromises to achieve interoperability, and your users\nwould not be forced to use this functionality, but your server is\nforced to provide it to be interoperable with those clients written\nfor users that do want that functionality.\n\n   > How do users see \"their\" checkouts?  We don't want to tie the \n   > versioning protocol to some kind of authentication mechanism.\n\n   Same way you do for WORKING-RESOURCE -- by responding with a Location\n   record.\n\nI misunderstood what you were proposing.  I thought that you were\nproposing some new mechanism that didn't involve allocating new URL's\nfor the working resource (the word \"invisible\" led me to believe\nthat they did not get a URL).\n\n   > You'd have to also define how every other HTTP method acts \n   > against these \"invisible\" resources.  What about MOVE, LOCK, \n   > COPY?  (This would make even lock-null resources look good in \n   > comparison :-).\n\n   Well, the spec doesn't define how a checkout-in-place works against\n   these verbs, either.\n\nIf the \"invisible\" resources get a URL just like a working resource,\nthen I agree that there is no problem with defining MOVE, LOCK,\nand COPY semantics.  I thought that you were proposing that somehow\nthe server would know that the user had performed a checkout, so\nthat when the user applied a method to the VCR, the server would\nretarget that method to the \"invisible\" checked-out resource.\nApologies for the misunderstanding.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3988299"}, {"subject": "RE: Resolving outstanding issues in Delta", "content": "From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   I'd be happy to be in the conf call and bring up what I see as two\n   major remaining problems.  They are not merely marshalling\n   problems.  If it were my implementation design that had these\n   problems, I would call them \"showstoppers\".\n\nI'll add these issues to the agenda for the call.\n\n   1. Stored resources can get lost, or unfindable.  This happens when\n   VCRs are deleted (possibly by clients that don't understand\n   versioning).  The problem is that even versioning-aware clients may\n   not subsequently be able to find the VHRs and Version resources\n   that are thus orphaned.  This is a memory leak.\n\nA garbage collector that deletes objects that still have references to\nthem is as much of a bug (and arguably, more of a bug) than a garbage\ncollector that misses some objects.  Since a reference to a resource\ncan appear in some dead property or in the content of an HTML resource\nor even in some email message, we have no good way of determining\nwhether there are any outstanding references to a particular Web resource.\nOf course, that doesn't mean that we can never remove resources from\nweb sites, but it does mean that the removal policy might not be one\nwe can reach consensus about.\n\nSo until we reach consensus on the appropriate mechanisms for\nreclaiming disk space, it is likely that the protocol will remain\nneutral/silent on the issue.  Since the versioning protocol has no\nnormative statements of the form \"the server MUST NOT delete ...\", the\nversioning protocol does not conflict with any such technique, and\ntherefore it raises no barrier to any such choices a server (or future\nprotocol version) choses to make.\n\n   Solutions to problem 1 might involve something like a \"orphaned\n   resources report\" that allowed the storage losses to be \"found\".\n\nSuch a report is reasonable (and we certainly will be providing a\ncustom report of this kind for my server), but since this report is\nindependent of the current feature set, I would not suggest holding up\nstandardizing on the current set of features in order to reach consensus\non the semantics and protocol for this report.\n\n   2. Features which DeltaV has presented as \"independent\" are not.  Working\n   Resource requires UPDATE and possibly workspaces.\n\nThere are five packages defined in the versioning protocol.\nThere is no package that provides the working resource feature\nwithout the update feature, so in that sense, yes, the working\nresource feature requires the update feature (and vica versa).\n\nThere is no package that provides both the working resource\nfeature and the workspace feature, so in no sense does the\nworking resource feature require the workspace feature.\n\n   Solutions to problem 2 might involve defining a CHECKIN verb that\n   includes the update functionality.  Or it might involve recombining\n   the sections of DeltaV so that a server cannot advertise support\n   for Working Resource if it does not support UPDATE and possibly\n   workspaces.\n\nA server is already told that it SHOULD support one of the defined packages,\nand there is no package that has the working-resource feature\nwithout the update feature).  We tried to strengthen that to a\nMUST, but could not achieve consensus on that stronger statement.\n\n   Please let me know when the conf call is and how to join.\n\nI'll send out mail beginning of next week.  It should be the standard\nnumber, but I just have to confirm with our IT organization that that\nnumber is still reserved for us at that time.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-3998103"}, {"subject": "RE: Removing the DAV:activity and DAV:version-history and DAV:bas eline  resource type value", "content": "   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n\n   If orthogonal concepts were present, then they *could* be in separate\n   properties rather than introducing the concept of sub-types etc.\n   Eg:\n     <resourcetype>\n       <workspace/>\n       <collection/>\n       <version-controlled/>\n     </resourcetype>\n\n   *could* be done as\n\n     <resourcetype>\n       <collection/>\n     </resourcetype>\n     <version-controlled> TRUE <version-controlled/>\n     <workspace> TRUE </workspace>\n\nYes, this is the approach that the \"DAV:supported-live-property-set\"\nfolks are advocating.  But rather than just a property whose value\nis \"TRUE\", we try to define a property with interesting semantics that\ncharacterize the resource (e.g. DAV:version contains the stable URL\nthat identifies that version).\n\n   I am not recommending it - just raising it as an alternative. I am\n   still struggling to understand all the versioning concepts flying\n   around here and after reading the DeltaV draft spec!\n\nThere are never a shortage of interesting things to debate (:-).  Some\nthings are proposed new features or modified behavior of existing\nfeatures.  Some things are general HTTP or WebDAV issues that have\narisen in a versioning context.  Some things are questions of how\ncertain desired behaviors can be exposed or requested by the existing\nprotocol.\n\n   In some ways I am happy to\n   see that people on this list are still trying to work out things too\n   (ie - its not just me!)\n\nThere are always new folks on the list, so never feel shy about\nasking newbie questions ... sometimes the response will be just a\nreference to an old thread, but that just helps motivate us to\nget the FAQ written (:-).\n\n   Mind you it also makes me a little worried that\n   people are still trying sort out what basic concepts mean.\n\nThose are the issues that *never* get resolved (:-).\n\"What is a resource?\"  \"When should information be\nmarshalled in a header or in the body?\"  And our current\n\"What is a resource type?\".  These are the kinds of\nmetaphysical debates that occur while there aren't any\nmore concrete issues open (:-).\n\n   And the complexity of it all seems quite high to me (a new comer)\n   at the moment.\n\nI'd recommend starting by identifying the functionality that you want\nto expose on your server, and then figure out how you would support\nthe core-versioning package (just the \"version-control\" feature)\nwith your server.  Once you have done that, you have identified\nhow your server will interoperate with all core-versioning clients.\n\nIf all of your functionality is exposed by the core-versioning\npackage, then you are done, and you can ignore the rest of the versioning\nprotocol.\n\nIf you still have some interesting features you would like to expose\nin an interoperable way, decide whether you want to support the\nin-place-checkout feature or the workspace feature.  (If you want to\nsupport both, randomly pick one to investigate first.)\n\nIf you want to support in-place-checkout, that is included in the\nserver-workspace package, so you'll also need to read up on the\nversion-history and workspace features.\n\nIf you want to support working resources, that is included in\nthe client-workspace package, so you'll also need to read up on\nthe update and label features.\n\nAnd finally, if you're doing heavy duty versioning, there are\nthe advanced versioning features.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4009401"}, {"subject": "RE: Resolving outstanding issues in Delta", "content": "> [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n> From: Lisa Dusseault [mailto:lisa@xythos.com]\n> A garbage collector that deletes objects that still have \n> references to them is as much of a bug (and arguably, more of \n> a bug) than a garbage collector that misses some objects.\n\nMissing objects is fatal.\n\nDeleting objects that have references, in a loosely coupled system where\nthe references are understood to be conditional (files on the web --\never seen a broken link?) is a feature.\n\n>    Solutions to problem 1 might involve something like a \"orphaned\n>    resources report\" that allowed the storage losses to be \"found\".\n> \n> Such a report is reasonable (and we certainly will be \n> providing a custom report of this kind for my server), but \n> since this report is independent of the current feature set, \n> I would not suggest holding up standardizing on the current \n> set of features in order to reach consensus on the semantics \n> and protocol for this report.\n\nThis report would not cause changes to the current feature set, but\nwithout it the feature set is not complete without additions.  Is\ncompleteness required to be a draft, or just relative stability?\n\n\n\n", "id": "lists-006-4020623"}, {"subject": "RE: Resolving outstanding issues in Delta", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   > [mailto:ietf-dav-versioning-request@w3.org] On Behalf Of Clemm, Geoff\n\n   > A garbage collector that deletes objects that still have \n   > references to them is as much of a bug (and arguably, more of \n   > a bug) than a garbage collector that misses some objects.\n\n   Missing objects is fatal.\n\nNot for the servers of many members of this working group.\n\n   Deleting objects that have references, in a loosely coupled system where\n   the references are understood to be conditional (files on the web --\n   ever seen a broken link?) is a feature.\n\nNot for the servers of many members of this working group,\nwhose users are not happy to receive a \"404\" for information\nthey have committed to their versioning system.\n\n   >    Solutions to problem 1 might involve something like a \"orphaned\n   >    resources report\" that allowed the storage losses to be \"found\".\n   > \n   > Such a report is reasonable (and we certainly will be \n   > providing a custom report of this kind for my server), but \n   > since this report is independent of the current feature set, \n   > I would not suggest holding up standardizing on the current \n   > set of features in order to reach consensus on the semantics \n   > and protocol for this report.\n\n   This report would not cause changes to the current feature set, but\n   without it the feature set is not complete without additions.  Is\n   completeness required to be a draft, or just relative stability?\n\nThere are always additional interesting and worthwhile features that\ncould be added to any IETF protocol, and therefore \"completeness\" is\nnever required or expected from an ietf standard.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4029890"}, {"subject": "Versioning collections questio", "content": "I have been reading through all the WebDAV and now DeltaV specs etc\nand so am slowing coming up to speed. I have a funny feeling that\nsome of the recent discussions that went over my head may actually\nbe answers to the following questions. But I am happy to make a fool\nof myself in public :-)\n\nMy understanding is DeltaV supports versioning of all resources,\nincluding collections. So if a MOVE is performed to change\n/foo/a to /foo/b where /foo is a versioned resource, it is\npossible to check in the new collection resource bound to /foo\nand have /foo/b present in it instead of /foo/a.\n\nOr put another way, the URI bindings to members of a collection are\na part of the parent collection and so are versioned with the member\ncollection. The member itself (the resource identified by /foo/a)\ndoes not need to be versioned at all since it is not changed.\n\nThe reason I ask is I am looking at how to relate the DMA concept\nof 'containers' to WebDAV/DeltaV 'collections'. In DMA, there is\na 'relationship' object that is created to link a member of a container\n(that is, a 'containee') to the parent container. The 'relationship'\nobjet is therefore like a binding in WebDAV. I think there is however\na difference in that in DMA the parent container does not hold the\nbindings (relationships). The binding objects (changing over to\nDeltaV terminology) are independent to both the container and member.\nThe binding object holds the name, a pointer to the parent collection,\nand a pointer to the member resource.\n\nThe impact of this is that to rename /foo/a to /foo/b does not require\nthe collection /foo to be versioned. Instead, the binding can be\nversioned instead. The parent collection remains unchanged. The resource\nalso remains unchanged. I believe this is not the DeltaV model. I\nbelieve that it is required to version the collection because bindings\nare a part of the parent collection.\n\nA picture might help. In WebDAV/DeltaV I think bindings are stored in\nthe parent collection object as follows. This means to change a binding\nmeans the collection must be versioned.\n\n         +------------+\n         | Collection |\n         |    foo     |\n         +-----|------+\n               |\n       v\n         +------------+\n         | Collection |      Renaming 'a' to 'b' requires this collection\n         |  a     x   |      resource to be versioned.\n         +--/-----\\---+\n           /       \\\n  v         v\n  +------------+  +------------+\n  |  Resource  |  |  Resource  |\n  +------------+  +------------+\n\nIn DMA, bindings are stored as separate additional objects. Collections\nare pretty boring really. They main exist to be pointed at. The pointers\nare in the binding objects which point at the parent collection and the\nmember.\n\n         +------------+\n         | Collection |\n         +------------+\n       ^\n       |\n         +-----|------+\n         |   Binding  |\n         |    foo     |\n         +-----|------+\n               |\n       v\n         +------------+\n         | Collection |\n         +------------+\n    ^       ^\n            |       |\n  +---------|--+  +-|----------+\n  |  Binding   |  |  Binding   |    Renaming 'a' to 'b' requires the binding\n  |     a      |  |     x      |    to be versioned, not the collection.\n  +-----|------+  +-----|------+\n        |               |\nv               v\n  +------------+  +------------+\n  |  Resource  |  |  Resource  |\n  +------------+  +------------+\n\nThe nice thing about the DMA approach is that /foo/a can be moved to\n/bar/baz/other/a with the versioning of only one binding object.\nThe DeltaV approach in my understanding would require the /foo\ncollection and the /bar/baz/other collection both having new versions\ncreated.\n\nThe reason is that the binding is more linked to the resource it is\nbound to than the collection containing the binding. If you do a\nMOVE, its the binding that is being moved.\n\nMy question is have I understood things correctly above in terms of\nDeltaV? Since bindings are not resources in DeltaV I could see no\nway to associate things like version numbers to them.\n\nAlan\n\n\nps: Another model we had played around with was to represent the entire\ndirectory tree as effectively a single 'configuration resource'. We\ncould represent this as a single XML document. Then for every change\nto the directory structure, we would create a complete new version of\nthe XML document. There were problems with this in terms of merging\ndifferent people's changes, but it saved creating lots of little\npersistent objects all over the place.\n\n\n\n", "id": "lists-006-4038930"}, {"subject": "Re: Versioning collections questio", "content": "On Tue, Jun 26, 2001 at 05:17:00PM +1000, Alan Kent wrote:\n> Or put another way, the URI bindings to members of a collection are\n> a part of the parent collection and so are versioned with the member\n> collection.\n\nAn interesting follow on is that to check out a collection, I always\nget out all the members. I cannot get partial subtrees.\n(\"I want to check out /foo and /foo/a/..., but not /foo/b\" is not\npossible since the container /foo will contain the \"b\" binding\nso \"b\" will be visible). I guess \"b\" does not have to be in the\n\"checked-out\" mode or something - ie, read only (??).\nI don't know if this is important.\n\nHmmm, another question. What do bindings identify? A particular version\nof a collection? The latest version of a collection? If I check in\na new version of a collection, does the parent collection need to be\nmodified to point to the new version? Does checking in the parent\ncollection in turn require the check in of its parent, all the way\nup to the root of the configuration? Does this mean adding a new\nfile to a configuration always results in a versioning riple from\nthat resource's parent collection up to the root collection?\n\nOk, I think this means I don't understand how collection versioning\nworks because I don't know how a binding in a collection identifies\nthe member. Does it identify a version history, a particular version,\nor what? What semantic information does a version of a collection\nhold?\n\najk\n\n\n\n", "id": "lists-006-4051150"}, {"subject": "Re: Versioning collections questio", "content": "Alan,\n\nYour understanding is correct.  Delta-V does not subscribe to the\nEntity-Relationship model that you described; a collection's bindings to\nother resources are considered \"internal members\".  Modifying the bindings\n(relationships) from a collection to its members is considered a\nmodification of the collection resource.\n\nOne minor nit, your diagram concludes:\n  \"Renaming 'a' to 'b' requires this collection resource to be versioned.\"\n\nObviously, if the collection is unversioned then renaming is a simple MOVE.\nWhen the collection is versioned it must be checked-out (i.e., made\nmutable) before the MOVE can succeed.\n\nRegards,\nTim\n\n--- Original Message ---\n\nAlan Kent <ajk@mds.rmit.edu.au> wrote:\n\nI have been reading through all the WebDAV and now DeltaV specs etc\nand so am slowing coming up to speed. I have a funny feeling that\nsome of the recent discussions that went over my head may actually\nbe answers to the following questions. But I am happy to make a fool\nof myself in public :-)\n\nMy understanding is DeltaV supports versioning of all resources,\nincluding collections. So if a MOVE is performed to change\n/foo/a to /foo/b where /foo is a versioned resource, it is\npossible to check in the new collection resource bound to /foo\nand have /foo/b present in it instead of /foo/a.\n\nOr put another way, the URI bindings to members of a collection are\na part of the parent collection and so are versioned with the member\ncollection. The member itself (the resource identified by /foo/a)\ndoes not need to be versioned at all since it is not changed.\n\nThe reason I ask is I am looking at how to relate the DMA concept\nof 'containers' to WebDAV/DeltaV 'collections'. In DMA, there is\na 'relationship' object that is created to link a member of a container\n(that is, a 'containee') to the parent container. The 'relationship'\nobjet is therefore like a binding in WebDAV. I think there is however\na difference in that in DMA the parent container does not hold the\nbindings (relationships). The binding objects (changing over to\nDeltaV terminology) are independent to both the container and member.\nThe binding object holds the name, a pointer to the parent collection,\nand a pointer to the member resource.\n\nThe impact of this is that to rename /foo/a to /foo/b does not require\nthe collection /foo to be versioned. Instead, the binding can be\nversioned instead. The parent collection remains unchanged. The resource\nalso remains unchanged. I believe this is not the DeltaV model. I\nbelieve that it is required to version the collection because bindings\nare a part of the parent collection.\n\nA picture might help. In WebDAV/DeltaV I think bindings are stored in\nthe parent collection object as follows. This means to change a binding\nmeans the collection must be versioned.\n\n         +------------+\n         | Collection |\n         |    foo     |\n         +-----|------+\n               |\n            v\n         +------------+\n         | Collection |      Renaming 'a' to 'b' requires this collection\n         |  a     x   |      resource to be versioned.\n         +--/-----\\---+\n           /       \\\n       v         v\n  +------------+  +------------+\n  |  Resource  |  |  Resource  |\n  +------------+  +------------+\n\nIn DMA, bindings are stored as separate additional objects. Collections\nare pretty boring really. They main exist to be pointed at. The pointers\nare in the binding objects which point at the parent collection and the\nmember.\n\n         +------------+\n         | Collection |\n         +------------+\n            ^\n            |\n         +-----|------+\n         |   Binding  |\n         |    foo     |\n         +-----|------+\n               |\n            v\n         +------------+\n         | Collection |\n         +------------+\n         ^       ^\n            |       |\n  +---------|--+  +-|----------+\n  |  Binding   |  |  Binding   |    Renaming 'a' to 'b' requires the\nbinding\n  |     a      |  |     x      |    to be versioned, not the collection.\n  +-----|------+  +-----|------+\n        |               |\n     v               v\n  +------------+  +------------+\n  |  Resource  |  |  Resource  |\n  +------------+  +------------+\n\nThe nice thing about the DMA approach is that /foo/a can be moved to\n/bar/baz/other/a with the versioning of only one binding object.\nThe DeltaV approach in my understanding would require the /foo\ncollection and the /bar/baz/other collection both having new versions\ncreated.\n\nThe reason is that the binding is more linked to the resource it is\nbound to than the collection containing the binding. If you do a\nMOVE, its the binding that is being moved.\n\nMy question is have I understood things correctly above in terms of\nDeltaV? Since bindings are not resources in DeltaV I could see no\nway to associate things like version numbers to them.\n\nAlan\n\n\nps: Another model we had played around with was to represent the entire\ndirectory tree as effectively a single 'configuration resource'. We\ncould represent this as a single XML document. Then for every change\nto the directory structure, we would create a complete new version of\nthe XML document. There were problems with this in terms of merging\ndifferent people's changes, but it saved creating lots of little\npersistent objects all over the place.\n\n\n\n", "id": "lists-006-4059511"}, {"subject": "Re: Versioning collections questio", "content": "Alan Kent <ajk@mds.rmit.edu.au> wrote:\n\n> On Tue, Jun 26, 2001 at 05:17:00PM +1000, Alan Kent wrote:\n> > Or put another way, the URI bindings to members of a collection are\n> > a part of the parent collection and so are versioned with the member\n> > collection.\n>\n> An interesting follow on is that to check out a collection, I always\n> get out all the members.\n\nWhen you checkout a version of a collection you are not checking out the\nmembers of the collection.\n\nBy checking out a collection you make the collection resource (including\nits internal members == \"bindings\") mutable.  This means to rename /a/b to\n/a/c then the collection /a/ must be mutable, but /a/b and /a/c can be\nimmutable versions.  Same for delete, you can delete the binding /a/b if\n/a/ is mutable even if /a/b is immutable.\n\n> I cannot get partial subtrees.\n> (\"I want to check out /foo and /foo/a/..., but not /foo/b\" is not\n> possible since the container /foo will contain the \"b\" binding\n> so \"b\" will be visible). I guess \"b\" does not have to be in the\n> \"checked-out\" mode or something - ie, read only (??).\n> I don't know if this is important.\n>\n> Hmmm, another question. What do bindings identify? A particular version\n> of a collection? The latest version of a collection?\n\nA version of a collection captures its dead properties and its bindings to\nversion-controlled resources in terms of their version history.  It does\nnot capture any live properties or bindings to non-version-controlled\nresources.\n\nSo if you PROPFIND depth 1 on a version of a collection you will discover\nthe internal members are bound to version history resources.  Indeed, if\nyou check out a version of a collection you will get a working collection\nwhose internal members are bindings to version history resources.\n\nA version-controlled collection contains bindings to both\nversion-controlled and non-version-controlled members.\n\nTypically, workspaces are used to create unambiguous configurations of\nversion-controlled resources by ensuring that they contain only one\nversion-controlled resource per version history.\n\n> If I check in\n> a new version of a collection, does the parent collection need to be\n> modified to point to the new version? Does checking in the parent\n> collection in turn require the check in of its parent, all the way\n> up to the root of the configuration? Does this mean adding a new\n> file to a configuration always results in a versioning riple from\n> that resource's parent collection up to the root collection?\n\nNo, we explicitly wanted to avoid this.  The explaination is given in\ndeltav-15.1 Section 14 para.2.\n\n> Ok, I think this means I don't understand how collection versioning\n> works because I don't know how a binding in a collection identifies\n> the member. Does it identify a version history, a particular version,\n> or what? What semantic information does a version of a collection\n> hold?\n\nYup, its a version history for the reason you gave above.\n\nJust to confuse things more :-) a version-controlled collection can have a\nversion-controlled internal member with the same name as a\nnon-version-controlled-member, and they are considered distinct.  Again,\nthis is all explained in Section 14.\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n\n", "id": "lists-006-4072169"}, {"subject": "RE: Versioning collections questio", "content": "I agree with Tim's responses ... just adding a few details.\n\n   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n\n   My understanding is DeltaV supports versioning of all resources,\n   including collections. So if a MOVE is performed to change\n   /foo/a to /foo/b where /foo is a versioned resource, it is\n   possible to check in the new collection resource bound to /foo\n   and have /foo/b present in it instead of /foo/a.\n\nYes.  As a minor terminology point, we would call /foo a\nversion-controlled resource (we have found the term \"versioned\nresource\" to be often misunderstood).  As a more significant\nterminology point, a collection resource is not bound to\n/foo, but rather a new collection version is created that\nidentifies in its DAV:version-controlled-binding-set property\nthe current bindings of the version-controlled collection\nat /foo.\n\n   Or put another way, the URI bindings to members of a collection are\n   a part of the parent collection and so are versioned with the member\n   collection.\n\nTo be precise, it is better to not describe them as \"URI bindings\",\nsince that is easily confused with a \"URI mapping\" (i.e. a mapping\nfrom a URI to a resource).  A binding maps a URI segment (not a URI)\nto a resource.  In particular, a binding in /foo is the pair\n<\"b\", some_resource>.  Calling them just \"bindings\" should be fine.\nAlso, note that bindings only define the internal members,\nnot all the members of a collection.\n \n   The member itself (the resource identified by /foo/a)\n   does not need to be versioned at all since it is not changed.\n\nYes. (When you say \"does not need to be versioned\", I assume you mean\n\"does not need to have a new version created for it\".)\n\n   The reason I ask is I am looking at how to relate the DMA concept\n   of 'containers' to WebDAV/DeltaV 'collections'. In DMA, there is a\n   'relationship' object that is created to link a member of a\n   container (that is, a 'containee') to the parent container. The\n   'relationship' objet is therefore like a binding in WebDAV. I think\n   there is however a difference in that in DMA the parent container\n   does not hold the bindings (relationships). The binding objects\n   (changing over to DeltaV terminology) are independent to both the\n   container and member.  The binding object holds the name, a pointer\n   to the parent collection, and a pointer to the member resource.\n\nIn WebDAV, you need to be able to map a URL to a particular resource.\nThe URL gives you the names of a sequence of nested collections in\naddition to the name of the resource, i.e. /x/y/z identifies 4\nresources: /, /x, /x/y, and /x/y/z.  So when resources are put under\nversion control, the \"bindings\" information needs to be stored in\nthese resources (i.e. the binding information needs to be bundled\nin with these resources, since those are the only resources identified\nby the URL).\n\n   The impact of this is that to rename /foo/a to /foo/b does not require\n   the collection /foo to be versioned. Instead, the binding can be\n   versioned instead.\n\nAs indicated above, in WebDAV the binding information has to be modeled\nin either the child resource, the parent resource, or both.\nStoring it in both is the worst ... you would have to check out\nboth the parent and the child to do a move.  The reason DeltaV\nchose to model the bindings as part of the state of the collection\nis that this allows you to \"reuse\" a resource (i.e. create a\nbinding to it) without changing the state of that resource.\n\n   The parent collection remains unchanged. The resource\n   also remains unchanged. I believe this is not the DeltaV model.\n\nCorrect.  WebDAV requires that the binding information be\nmodeled either in the child or the parent, since there is no\nway to annotate the URL to identify which of the independent\n\"binding\" objects are to be used when a URL is being mapped\nto a resource.\n\n   I\n   believe that it is required to version the collection because bindings\n   are a part of the parent collection.\n\nCorrect.\n\n   A picture might help. In WebDAV/DeltaV I think bindings are stored in\n   the parent collection object as follows. This means to change a binding\n   means the collection must be versioned.\n\nOr more precisely, in order to change the binding in a version-controlled\ncollection to a version-controlled member, the version-controlled\ncollection must be checked out.  If either the collection or the member\nis not under version control, no checkout is required.\n\n   In DMA, bindings are stored as separate additional objects. Collections\n   are pretty boring really. They main exist to be pointed at. The pointers\n   are in the binding objects which point at the parent collection and the\n   member.\n\n   The nice thing about the DMA approach is that /foo/a can be moved to\n   /bar/baz/other/a with the versioning of only one binding object.\n\nSo with a URL like /foo/a, how do you know which of the many possible\nbindings named \"a\" between /foo and some other resource are to be used?\nUnfortunately, the \"independent binding\" model breaks down in the\npresence of versioning.\n\n   The DeltaV approach in my understanding would require the /foo\n   collection and the /bar/baz/other collection both having new versions\n   created.\n\nBut note that /foo would have to be checked out only if both /foo and\n/foo/a are under version control.  /bar/baz/other would have to be\nchecked out only if /foo/a and /bar/baz/other are under version\ncontrol.  (I used \"checked out\" instead of \"versioned\", because the\nprotocol doesn't require you to \"version\" things to change them, only\nthat you \"check them out\").\n\n   My question is have I understood things correctly above in terms of\n   DeltaV? Since bindings are not resources in DeltaV I could see no\n   way to associate things like version numbers to them.\n\nThat is correct.  We could have made bindings independent resources,\nbut that would have required allocating a URL space for them, and\ndefining their functionality under MOVE's and DELETE's of the parents\nand children they refer to.  And we would have had to bundle them\ninto either the parent or child anyway, so the benefit of modeling\nthem as separate resources was felt to be outweighed by the\nresulting complexity.\n\n   ps: Another model we had played around with was to represent the\n   entire directory tree as effectively a single 'configuration\n   resource'. We could represent this as a single XML document. Then\n   for every change to the directory structure, we would create a\n   complete new version of the XML document. There were problems with\n   this in terms of merging different people's changes, but it saved\n   creating lots of little persistent objects all over the place.\n\nThat is certainly a reasonable approach, and is why the \"baseline\"\nfeature is defined independently of the \"version-controlled collection\"\nfeature.\n\n   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n\n   An interesting follow on is that to check out a collection, I always\n   get out all the members. I cannot get partial subtrees.\n\nI'm not sure what you mean by \"get out\" here.  A collection has\nmembers.  When that collection is under version control, you have to\ncheck the collection out in order to change the membership of that\ncollection.  The membership of the collection is not changed by\nchecking it out (or checking it in), it is changed by MOVE, COPY,\nUPDATE, etc.\n\n   (\"I want to check out /foo and /foo/a/..., but not /foo/b\" is not\n   possible since the container /foo will contain the \"b\" binding\n   so \"b\" will be visible).\n\nVisibility is independent of whether or not something is checked out.\nWhen you check out /foo and /foo/a, then those two resources are\nchecked out, and no others.\n\n   I guess \"b\" does not have to be in the\n   \"checked-out\" mode or something - ie, read only (??).\n   I don't know if this is important.\n\nYes, it is important (it tells you what is currently checked out\nand therefore what is modifiable.\n\n   Hmmm, another question. What do bindings identify? A particular version\n   of a collection? The latest version of a collection?\n\nNo, the bindings of a version-controlled collection are\nto other version-controlled (and non-version-controlled) resources.\nThe version of a collection member is identified by the URL in the\nDAV:checked-in or DAV:checked-out property of that member.\n\nNote that a collection version is not itself a collection, but rather \ncaptures the bindings to version-controlled members in its\nDAV:version-controlled-binding-set property.\n\nSo the protocol defines no collection whose bindings identify\nparticular versions.\n\n   If I check in\n   a new version of a collection, does the parent collection need to be\n   modified to point to the new version?\n\nNo, the version-controlled collection keeps track of what was\nthe last version checked in (in its DAV:checked-in property).\nThe parent collection is not affected by changing the DAV:checked-in\nproperty of its members.\n\n   Does checking in the parent\n   collection in turn require the check in of its parent, all the way\n   up to the root of the configuration? Does this mean adding a new\n   file to a configuration always results in a versioning riple from\n   that resource's parent collection up to the root collection?\n\nNo, because each version-controlled resource keeps track of its\ncurrent version (i.e. a collection does not track what versions\nits members select).\n\n   Ok, I think this means I don't understand how collection versioning\n   works because I don't know how a binding in a collection identifies\n   the member. Does it identify a version history, a particular version,\n   or what? \n\nNeither.  A binding in a version-controlled collection is to\nanother version-controlled resource, or to a non-version-controlled\nresource, but not to a version history or to a particular version.\n\n   What semantic information does a version of a collection hold?\n\nLook at section 14.2.  It has a DAV:version-controlled-binding-set\nproperty, identifying the names and version histories of the resources\nat the time the collection version was created.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4083072"}, {"subject": "RE: Versioning collections questio", "content": "A couple of small clarification/corrections:\n\n   From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n\n   By checking out a collection you make the collection resource (including\n   its internal members == \"bindings\") mutable.  This means to rename /a/b\nto\n   /a/c then the collection /a/ must be mutable, but /a/b and /a/c can be\n   immutable versions.\n\nTim was using \"version\" in an informal way here.  /a/b and /a/c are\nchecked-in (and therefore immutable) version-controlled resources, but\nthey aren't versions in the formal DeltaV sense of the word.\n\n   So if you PROPFIND depth 1 on a version of a collection you will discover\n   the internal members are bound to version history resources.\n\nActually, a collection version is not itself a collection\n(it's state is defined by its DAV:version-controlled-binding-set).\nWe did at one time have the internal members of a collection version\nbindings to version-history resources, but that information was\nmoved to the DAV:version-controlled-binding set property.\nSo you'd just ask for a PROPFIND;Depth=0 for the\nDAV:version-controlled-binding-set.\n\n   Indeed, if\n   you check out a version of a collection you will get a working collection\n   whose internal members are bindings to version history resources.\n\nThat is correct.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4100997"}, {"subject": "Re: Versioning collections questio", "content": "Thanks for the response. It all makes sense (or at least I think\nit all makes sense :-)... but...\n\nOn Tue, Jun 26, 2001 at 01:18:22PM -0400, Clemm, Geoff wrote:\n> So with a URL like /foo/a, how do you know which of the many possible\n> bindings named \"a\" between /foo and some other resource are to be used?\n> Unfortunately, the \"independent binding\" model breaks down in the\n> presence of versioning.\n\nI am sorry - are you saying a collection can have multiple bindings\nto different resources using the same name? Or are you talking about\ndifferent versions of the same collection having different bindings\nof \"a\" to other resources?\n\n> I'm not sure what you mean by \"get out\" here.  A collection has\n> members.  When that collection is under version control, you have to\n> check the collection out in order to change the membership of that\n> collection.  The membership of the collection is not changed by\n> checking it out (or checking it in), it is changed by MOVE, COPY,\n> UPDATE, etc.\n\nMy use of \"get out\" was a vague hand wavy thing in since \"check-out\"\nhad specific semantics in DeltaV and I was not sure if I meant\ncheck-out or not. But its all sort of making sense.\n\nHowever, the above leads me on to another question. If user A checks\nout a version-controlled collection and adds a new file. User B then\nchecks out the same version-controlled collection and adds a different\nnew file. (I am thinking of a CVS like model here - I don't know the\ncorrect DeltaV jargon for this yet.) Both users then try to check\nin the resource. In CVS, the second commit might fail with a conflict,\nor CVS might be smart enough to do the merge. In DeltaV, what is\nexpected to happen? I conflict report? A merge by the server? A merge\nby the client doing the second commit?\n\n>    (\"I want to check out /foo and /foo/a/..., but not /foo/b\" is not\n>    possible since the container /foo will contain the \"b\" binding\n>    so \"b\" will be visible).\n> \n> Visibility is independent of whether or not something is checked out.\n> When you check out /foo and /foo/a, then those two resources are\n> checked out, and no others.\n> \n>    I guess \"b\" does not have to be in the\n>    \"checked-out\" mode or something - ie, read only (??).\n>    I don't know if this is important.\n> \n> Yes, it is important (it tells you what is currently checked out\n> and therefore what is modifiable.\n\nSo just to clarify, if I check out /foo and /foo/a/ but not /foo/b,\nthen in my workspace(??), what resource type is /foo/b? I was reading\nthrough the archives a bit and came across the term \"version selector\".\nIs /foo/b a \"version selector\"?\n\nFinally, Tim said:\n> Just to confuse things more :-) a version-controlled collection can have a\n> version-controlled internal member with the same name as a\n> non-version-controlled-member, and they are considered distinct.  Again,\n> this is all explained in Section 14.\n\nEgad!\n\nHmmm. I think my eyes must have glazed over by the time I got to\nsection 14. I had better go read it again more carefully! It should\nmake more sense this time.\n\nThanks everyone for the feedback.\n\najk\n\n\n\n", "id": "lists-006-4109471"}, {"subject": "RE: Versioning collections questio", "content": "   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n\n   On Tue, Jun 26, 2001 at 01:18:22PM -0400, Clemm, Geoff wrote:\n   > So with a URL like /foo/a, how do you know which of the many\n   > possible bindings named \"a\" between /foo and some other resource\n   > are to be used?  Unfortunately, the \"independent binding\" model\n   > breaks down in the presence of versioning.\n\n   I am sorry - are you saying a collection can have multiple bindings\n   to different resources using the same name? Or are you talking\n   about different versions of the same collection having different\n   bindings of \"a\" to other resources?\n\nThe latter, i.e. different versions of the same collection having\nbindings of \"a\" to different resources.\n\n   ... If user A checks\n   out a version-controlled collection and adds a new file. User B then\n   checks out the same version-controlled collection and adds a different\n   new file. (I am thinking of a CVS like model here - I don't know the\n   correct DeltaV jargon for this yet.) Both users then try to check\n   in the resource. In CVS, the second commit might fail with a conflict,\n   or CVS might be smart enough to do the merge. In DeltaV, what is\n   expected to happen? I conflict report? A merge by the server? A merge\n   by the client doing the second commit?\n\nThe behavior differs depending on whether your client included the\nDAV:apply-to-version flag with the CHECKOUT.\n\nWithout the DAV:apply-to-version flag, the server must support the\n\"server-workspace\" package.  The CHECKOUT is \"in place\", and the VCR\nitself is in a checked-out state.  In this case, the attempt by user B\nto checkout that VCR will fail (with an \"already checked out\" error).\nIn order to work in parallel, the second user would need to allocate a\nsecond workspace on the server, populate it with its own VCR for that\ncollection (and that collection's members), and work in that second\nworkspace.  One user could then \"MERGE\" the new collection version\ncreated in the other workspace, resulting in a conflict report, which\nthe user would resolve based on the information displayed by its\nclient.\n\nIf the DAV:apply-to-version flag is included in the CHECKOUT, the\nserver must support the \"client-workspace\" package.  The CHECKOUT\nleaves the VCR in the checked-in state, but creates a working\ncollection.  The second CHECKOUT creates a second working collection.\nWhen these users do a CHECKIN, it creates new versions (on separate\nlines of descent).  When the user wants to make his changes visible,\nthe client should request a MERGE with the DAV:no-checkout flag of the\nnew version to the version-controlled collection.  If there are\nconflicts, the client should create a new working resource, MERGE the\nnew version into that working resource, CHECKIN the result, and again\nrequest a MERGE with the DAV:no-checkout flag of the new version to\nthe version-controlled resource.  If no one has changed the\nversion-controlled collection, this time the MERGE will succeed.\n\n   So just to clarify, if I check out /foo and /foo/a/ but not /foo/b,\n   then in my workspace(??), what resource type is /foo/b? I was\n   reading through the archives a bit and came across the term\n   \"version selector\".  Is /foo/b a \"version selector\"?\n\nVersion selector is another piece of terminology that was rejected\nbecause it was misleading.  /foo/b is a \"version-controlled resource\"\n(assuming it is under version control), as are /foo and /foo/a.\n\nNote that a version-controlled resource may be a member of a workspace\n(a workspace is just a special kind of collection), but it doesn't\nhave to be.\n\n   Finally, Tim said:\n   > Just to confuse things more :-) a version-controlled collection can\nhave a\n   > version-controlled internal member with the same name as a\n   > non-version-controlled-member, and they are considered distinct.\nAgain,\n   > this is all explained in Section 14.\n\n   Egad!\n\n   Hmmm. I think my eyes must have glazed over by the time I got to\n   section 14. I had better go read it again more carefully! It should\n   make more sense this time.\n\nI'd suggest saving the DAV:eclipsed-set for the very end,\nsince it is the most subtle feature in versioned collections\n(arguably, the most subtle feature in the whole protocol).\n\n   Thanks everyone for the feedback.\n\nYou bet!  All excellent questions.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4119673"}, {"subject": "Jim Whitehead's Hong Kong talk - Adding versioning to the we", "content": "Slide 50 of Jim Whitehead's WWW 10 talk \"Delta V: Adding versioning to\nthe web\" has an example of creating a workspace using MKWORKSPACE and\nthen populating it using VERSION-CONTROL commands. (These slides are\ngreat stuff by the way. It makes it much easier to get an overall\nfeel for things.)\n\nThe workspace URIs were things like /users/geoff/projectX/.\nThe original project file URIs were like /projectX/makefile.\nThe VERSION-CONTROL command then created /users/geoff/projectX/makefile\nfrom /projectX/makefile.\n\nMy reading of the DeltaV spec in Section 6.7 indicates that\nVERSION-CONTROL is creating a\n\n    \"new version-controlled resource for an existing version history\".\n\nThe examples the spec has then uses URIs like /his/12/ver/V3\nidentifying a version from a history. Jim's example in his slide\nis a version controlled resource (slide 52).\n\nShould the above text in the first paragraph of section 6.7 of the spec\nbe expanded to make it clear that the URI identifies a version from the\nversion history? Or can any sort of resource be identified (version\ncontrolled, version, version history, etc) as long as the version\nhistory can somehow be identified? Or is the spec OK and the example\nin the slides is wrong.\n\nMaybe the slides are a bit hand-wavy to get concepts across more\neasily... The spec seems to state quite clearly that a version URI\nshould be supplied (it makes no comment about using a version-controlled\nresource URI - unless its mentioned somewhere else I have not found!).\n\nAlan\n\n\n\n", "id": "lists-006-4131335"}, {"subject": "Re: Proposed modification to CHECKOUT with the DAV:apply-to-version f la", "content": "As you guessed, I've been away and/or overly busy for the past couple weeks.\nThanks for dropping me a mail directly (I haven't caught up on my DAV mail\nyet).\n\nSubversion doesn't not check out VCRs (a race condition exists if you do\nthat), so this change won't affect us.\n\nAs long as that property is fully modifiable on the working resource\n(including adding it or deleting it), then it makes *some* sense to me.\nHowever, it is also Yet Another Burden on the server. If the client wants to\naffect VCRs, then it should use MERGE rather than relying on magic behavior\nlike this.\n\nPersonally, I'd suggest leaving this out because of the additional burden.\nWe already have a mechanism for updating VCRs upon checkin.\n\nCheers,\n-g\n\nOn Mon, Jun 25, 2001 at 12:47:08PM -0400, Clemm, Geoff wrote:\n> Greg: In one of the (few :-) current threads that are not just noise, we've\n> been discussing a possible modification to the behavior of CHECKOUT of a VCR\n> when the DAV:apply-to-version flag is used.  The proposal is that when a\n> client creates a working resource by applying a CHECKOUT with a\n> DAV:apply-to-version flag to a VCR, the working resource is annotated with\n> the URL of that VCR, and when the working resource is checked in, an UPDATE\n> operation with the new version is automatically applied to that VCR.  Do you\n> care about this?\n> \n> Note: If you are just to applying the CHECKOUT to the version URLs, this\n> change would not affect you.\n> \n> Cheers,\n> Geoff\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4140281"}, {"subject": "RE: Versioning collections questio", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> A couple of small clarification/corrections:\n>\n>    From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n>\n>    By checking out a collection you make the collection\n>    resource (including its internal members == \"bindings\")\n>    mutable.  This means to rename /a/b to /a/c then the\n>    collection /a/ must be mutable, but /a/b and /a/c can\n>    be immutable versions.\n>\n> Tim was using \"version\" in an informal way here.  /a/b and\n> /a/c are checked-in (and therefore immutable) version-controlled\n> resources, but they aren't versions in the formal DeltaV sense\n> of the word.\n\nOops, that just slipped out, change \"immutable vresions\" to \"checked-in\nversion-controlled resources\".\n\n> >    So if you PROPFIND depth 1 on a version of a collection\n> > you will discover the internal members are bound to version\n> > history resources.\n>\n> Actually, a collection version is not itself a collection\n> (it's state is defined by its DAV:version-controlled-binding-set).\n> We did at one time have the internal members of a collection\n> version bindings to version-history resources, but that\n> information was moved to the DAV:version-controlled-binding\n> set property. So you'd just ask for a PROPFIND;Depth=0 for\n> the DAV:version-controlled-binding-set.\n\nGoofed again, thanks for correcting that.  An instance where I should use\nmy eyes rather than relying on my memory<g>\n\nTim\n\n\n\n", "id": "lists-006-4149277"}, {"subject": "RE: What is a supported property", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> I like it!\n> (I believe it should \"405\" rather than \"501\" though.)\n>\n> For supported reports, how about just adding a DAV:supported-report\n> precondition to the REPORT method?  Then we can say:\n> \"A report is supported if the response to a REPORT request\n> for that report is not 403 with a DAV:supported-report error token\".\n>\n> Now how about properties?  2518 only defines a 404\n> (not found) value, so we would have to extend that.\n> Unfortunately, we probably shouldn't use 405, since\n> that's defined as \"Method Not Allowed\".  Probably\n> best to just add a DAV:supported-property precondition\n> to the PROPFIND method?  Then we can say:\n> \"A live property is supported if the response to a\n> PROPFIND request for that property is not 403 with a\n> DAV:supported-property error token\".\n>\n> How does this sound to everyone else (both the general approach,\n> and the specifics)?  I assume nobody wants to support my\n> original approach (I sure don't :-).\n\nI'd just point out that this is not granting the same assurances as the\noriginal approach.\n\n\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> 3.1.3   DAV:supported-method-set (protected)\n>\n> This property identifies the methods that are supported by the\n> resource.  A method is supported by a resource if an application of\n> that method to that resource has the semantics defined by the features\n> supported by that resource.\n\nThis states that the method must not only be understood (i.e. not simply\n'405 Method Not Allowed') but that it must have the semantics defined for\nthat resource.\n\n> 3.1.4   DAV:supported-live-property-set (protected)\n>\n> This property identifies the live properties that are supported by the\n> resource.  A live property is supported by a resource if that property\n> has the semantics defined for that property.\n\nSimilar to above for methods. This states that the server must retain the\nmeaning of the property defined in the specification.\n\n> 3.1.5   DAV:supported-report-set (protected)\n>\n> This property identifies the reports that are supported by the\n> resource.  A report is supported by a resource if it produces the\n> results defined for that report.\n\nAlthough others have argued that servers may, in the future, redefine the\nmeaning of methods etc., I think it is fair to state in the DeltaV spec\nthat when a server advertises support for a method/property/report using\nthe DAV:supported-*-set's it should have (at least) the semantics defined\nin this specification.\n\nTim (desperately trying not to start another philosophical argument).\n\n\n\n", "id": "lists-006-4158668"}, {"subject": "Re: Jim Whitehead's Hong Kong talk - Adding versioning to the we", "content": "When a VERSION-CONTROL contains a DAV:version element, the href must refer\nto a version.\nThe method precondition is \"DAV:must-be-version\".\n\nI haven't had the benefit of reading Jim W's slides -- but surely it\ndoesn't take 52+ slides to describe DeltaV <G>\n\nTim\n\nAlan Kent <ajk@mds.rmit.edu.au> wrote:\n> Slide 50 of Jim Whitehead's WWW 10 talk \"Delta V: Adding\n> versioning to the web\" has an example of creating a\n> workspace using MKWORKSPACE and then populating it using\n> VERSION-CONTROL commands. (These slides are great stuff\n> by the way. It makes it much easier to get an overall\n> feel for things.)\n>\n> The workspace URIs were things like /users/geoff/projectX/.\n> The original project file URIs were like /projectX/makefile.\n> The VERSION-CONTROL command then created /users/geoff/projectX/makefile\n> from /projectX/makefile.\n>\n> My reading of the DeltaV spec in Section 6.7 indicates that\n> VERSION-CONTROL is creating a\n>\n>     \"new version-controlled resource for an existing version\n> history\".\n>\n> The examples the spec has then uses URIs like /his/12/ver/V3\n> identifying a version from a history. Jim's example in his\n> slide is a version controlled resource (slide 52).\n>\n> Should the above text in the first paragraph of section 6.7\n> of the spec be expanded to make it clear that the URI\n> identifies a version from the version history? Or can any\n> sort of resource be identified (version controlled, version,\n> version history, etc) as long as the version history can\n> somehow be identified? Or is the spec OK and the example\n> in the slides is wrong.\n>\n> Maybe the slides are a bit hand-wavy to get concepts across\n> more easily... The spec seems to state quite clearly that\n> a version URI should be supplied (it makes no comment about\n> using a version-controlled resource URI - unless its mentioned\n> somewhere else I have not found!).\n\n\n\n", "id": "lists-006-4168899"}, {"subject": "RE: Jim Whitehead's Hong Kong talk - Adding versioning to the we", "content": "   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n\n   My reading of the DeltaV spec in Section 6.7 indicates that\n   VERSION-CONTROL is creating a\n\n       \"new version-controlled resource for an existing version history\".\n\nYes.  But since the VCR needs to identify a particular version\nfrom that version history, a particular version is required\nwhen you create the new VCR.\n\n   The examples the spec has then uses URIs like /his/12/ver/V3\n   identifying a version from a history. Jim's example in his slide\n   is a version controlled resource (slide 52).\n\nJim's example doesn't display the actual syntax, but describes\nthe result, so it leaves out this kind of detail.\n\n   Should the above text in the first paragraph of section 6.7 of the spec\n   be expanded to make it clear that the URI identifies a version from the\n   version history?\n\nThe introductory text gives you the motivation for the semantics,\nand adding in this kind of detail risks blurring the overall picture.\n\n   Or can any sort of resource be identified (version\n   controlled, version, version history, etc) as long as the version\n   history can somehow be identified?\n\nNo, only a version.\n\n   Or is the spec OK and the example in the slides is wrong.\n\nI'd describe the example in the slides as \"simplified\" rather than\n\"wrong\".\n\n   Maybe the slides are a bit hand-wavy to get concepts across more\n   easily... The spec seems to state quite clearly that a version URI\n   should be supplied\n\nYes.\n\n   (it makes no comment about using a version-controlled resource URI\n   - unless its mentioned somewhere else I have not found!).\n\nNope, no hidden semantics.  One of the benefits of the rigorous\nprecondition/postcondition approach, is that you don't have to worry\nabout semantics being scattered througout the protocol text ...\nif it's not in the preconditions or postconditions, it ain't so.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4178848"}, {"subject": "Versioning TeleConf Agenda, 6/29/01 (Friday) 12-1pm ES", "content": "phone: 888 819 8909  pass-code#97985\n\nAgenda:\n\nDiscuss the current mailing list topics\n\n- Support for VCR update when checking in a working resource\n\n- Deleting or adding DAV:resourcetype values\n\n- A report for finding \"orphan\" version and version history resources\n\n- Should there be language describing the effect of VCR deletion on\n  version and version history resources.\n\n- Anything else someone wants to discuss\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4188190"}, {"subject": "DAV:root-versio", "content": "What if the original root version has been deleted?\n\nI could return the earliest version, null, or somehow make the root\nversion special and non-deleteable.\n\nBut the last would require custom errors for DELETE\n\n\nAs I am coming to understand how this process works, I'm anticipating\nthe following reaction:\n\n1) The spec is silent, do it any way you want.\n2) We don't think versions should ever be deleted.\n3) If you allow the root to be deleted, returning the earliest version\nis probably the least bad option.\n4) A special cannot-delete-root-version element is out of the question.\n\n\n\n", "id": "lists-006-4196083"}, {"subject": "RE: root-versio", "content": "   From: John Hall [mailto:johnhall@evergo.net]\n\n   What if the original root version has been deleted?\n\nTo answer this, you would want to look at the DELETE semantics\nin the version-history feature.  There you will find:\n\n(DAV:version-history-has-root): If the root version of a version\nhistory was deleted, the server MUST have updated the DAV:root-version\nof the version history to refer to another version that is an ancestor\nof all other remaining versions in that version history.  A result of\nthis postcondition is that every version history will have at least\none version.\n\n   I could return the earliest version, null, or somehow make the root\n   version special and non-deleteable.\n\nYes (with a caveat), no, and yes.\n\nYou are allowed to return the earlierst version if it is the\nancestor of all other remaining versions (which it would be,\nif you do not allow branching).  You are not allowed to return\nnull (because of the DAV:version-history-has-root postcondition).\nYou can make the root version special and non-deletable.\n\n   But the last would require custom errors for DELETE\n\nThe spec defines this error code.  It is DAV:version-history-has-root.\n\n   As I am coming to understand how this process works, I'm anticipating\n   the following reaction:\n\n   1) The spec is silent, do it any way you want.\n\nNot this time (:-).\n\n   2) We don't think versions should ever be deleted.\n\nThe protocol has always supported explicit version deletion\n(it is only implicit version deletion as a side effect of\ndeleting another resource which has met resistance).\n\n   3) If you allow the root to be deleted, returning the earliest version\n   is probably the least bad option.\n\nReturning the new root (effectively updating the DAV:root-version)\nis a good option.  Refusing to delete it is also a good option.\n\n   4) A special cannot-delete-root-version element is out of the question.\n\nYes, but only because we already have defined\nDAV:version-history-has-root for this case.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4203243"}, {"subject": "RE: Versioning TeleConf Agenda, 6/29/01 (Friday) 12-1pm ES", "content": "Attending:\n  Jim Whitehead (UCIrvine)\n  John Hall (Xythos)\n  Lisa Dusseault (Xythos)\n  Peter Raymond (Merant)\n  Rick Rupp (Merant)\n  Tim Ellison (IBM)\n  Geoff Clemm (Rational)\n  \nWe first decided to focus on issues that would change existing\nsemantics in the protocol (as opposed to issues that would add new\nfeatures).  The motivation is that changing semantics after the RFC is\nissued could harm the the interoperability of clients and servers that\nwere written against the RFC, while adding new features after the RFC\nis issued would not.\n\nSince the only agenda item that might change existing semantics\nis \"Support for VCR update on working resource CHECKIN\", we decided\nto deal with that first.  \n\nWe initially focused on the motivation for making the change:\n\n- The current protocol requires that a client support either the\nupdate or the merge feature in order for the working-resource feature\nto be useful.  This is the only reason that the update feature is\ncurrently required in the basic client-workspace package.  This is\nunfortunate, since we already have a server that is likely to support\nworking-resource feature with merge and not update (the Subversion server),\nand because linear versioning servers are also likely to not want\nto support the general update feature (the Xythos server is a specific\nexample).\n\n- A CHECKOUT/CHECKIN sequence on a VCR results in a changed VCR.  It\nwould therefore be reasonably consistent if the\nCHECKOUT(apply-to-version) on a VCR followed by a CHECKIN of the\nworking resource did as well.\n\n- If you create a working resource by applying CHECKOUT(apply-to-version)\nto a VCR, there is no good way for a client to track the location\nof that VCR for a subsequent update (I don't consider locking the\nVCR a good way, since this unnecessarily freezes the namespace above\nthe VCR, which is not needed for this use case).\n\n- The protocol currently defines two different ways of achieving the\nsame result, namely applying CHECKOUT(apply-to-version) to a VCR, or\nby applying CHECKOUT to the DAV:checked-in version of the VCR.  If we\nmodify the semantics of one of these (i.e. CHECKOUT(apply-to-version)),\nand leave the semantics of the other alone (i.e. applying CHECKOUT to\na version), we can address the previous issues without adding\nnew protocol elements.\n\n- Finally, if we did add such a feature, it was agreed that the\nworking resource CHECKIN that updates the associated VCR should fail\nif the VCR has changed since the CHECKOUT (i.e. the DAV:checked-out\nproperty of the working resource is not the same as the DAV:checked-in\nproperty of the VCR).  This prevents what would appear to be\na lost overwrite to a client using that VCR.\n\nThe group then agreed on the following proposal (assuming that\nI wrote it up correctly :-) -\n\n------------------------------\n\nWhen you apply CHECKOUT directly to a version URL, the semantics of\nthe protocol are unchanged (so if you liked the old semantics and\ndidn't want any auto-update on checkin, you would always apply\nCHECKOUT directly to a version URL\n\nWhen you apply CHECKOUT with a DAV:apply-to-version flag to a VCR, you\ncreate a working resource whose DAV:checked-out version is the\nDAV:checked-in version of the VCR (as is required currently), but\nwhich now also has a protected DAV:auto-update property which contains\nthe URL of the VCR that was checked out.  (This requires one new\npostcondition for the CHECKOUT semantics in the working-resource\nfeature).\n\nThe MOVE operation is required to update the DAV:auto-update property\nif the VCR is moved (or it can fail the MOVE), so the DAV:auto-update\nproperty is always valid.  (This requires one new postcondition\nfor the MOVE semantics in the working-resource feature).\n\nWhen you CHECKIN a working resource with a DAV:auto-update property,\nthe CHECKIN fails if the DAV:checked-out property of the working\nresource does not match the DAV:checked-in property of the VCR.\nIf the CHECKIN succeeds, the VCR identified by the DAV:auto-update\nmust have been updated to have the content and dead properties\nof the new version, and the DAV:checked-in version of the VCR\nmust have been updated to identify the new version.  (This requires\none new precondition and one new postcondition for the CHECKIN\nsemantics in the working-resource feature).\n\n------------------------------\n\nAlthough several members of the working group have expressed a strong\ndesire to minimize changes to the protocol (a sentiment I believe most\nof the participants in this call share), the participants of this call\nfelt that this particular change was worth making.  In addition, no\nmember of the working group that was intending on supporting the\nDAV:apply-to-version flag for CHECKIN has identified these extended\nsemantics as being a problem to support.\n\nIf anyone objects to this proposed change, please clearly identify\nyour concerns so that Jim Amsden can determine whether this change\nhas received consensus support.\n\nNote: the DAV:auto-update property used to be called\nDAV:checked-out-vcr, or DAV:checked-out-version-controlled-resource in\nearlier proposals.  I prefer just DAV:auto-update, since who knows, we\nmight someday want to auto-update something other than a VCR (and it\nis shorter :-).  Let me know if you object to this name change.\n\nAt the end of the call, we decided to discuss an additional\nitem that was not in the original agenda (but which is a\nrecent email thread): \"firm up the definition of the DAV:supported-*\nproperty values\".  I'm still in the process of\nformulating a coherent proposal based on that discussion, and will\npost it soon.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4211646"}, {"subject": "Re: Re (4): collection version resource", "content": "<snip>\n>\n> So we've got two extremes:\n>\n> - Everything is optional (i.e. a server can pick any combination of\n> properties and methods that it wants to support).  On this extreme, we\n> make life maximally easy for servers ... just implement exactly what\n> you want for a particular client you have in mind.  But the result is\n> either very complex interoperable clients (trying to fake up\n> non-provided server functionality) or decreased interoperability (just\n> fail against any server that doesn't provide everything you need).\n>\n> - Everything is required.  On this extreme, we make life maximally easy\n> for clients (whatever you want, every server has it).  Unfortunately,\n> you have very few (if any :-) servers, since few servers want to support\n> everything.\n>\n> Clearly we don't want either extreme, so instead, we look for\n> combinations that logically go together ... i.e. if you implement\n> one, it would be easy/natural to implement the the others.\n>\n> I think our current set of options are a good compromise between\n> these extremes, but I just wanted to see if there were any minor\n> adjustments that would be worth making before we go to last call.\n\n...and if I had to choose between the two evils, I'd rather be closer to\n'everything is optional' because failing against servers that don't provide\nwhat you need is natural selection; whereas clients typically cannot cope\nwith missing-bits of claimed support (\"as described on page three of the\nreadme file\")  [and I may have a closer affinity with server developers\n<g>]\n\n<snipped out other embarrassing-to-me stuff>\n\nTim\n\n\n\n", "id": "lists-006-4529683"}, {"subject": "11.1 review (teaser", "content": "I've finished a detailed review of 11.1 and have lots of trivia but nothing\nto affect a last-call on Friday.  I'll aim to type up my observations\ntomorrow.\n\nThe spec. reads very well.  This is the first detailed read-through for me\nsince the document was restructured and it is much more logical and\nprogressive now.\n\nThe amount of work that Geoff has put into this is outstanding and clearly\nreflected in the results.\n\nTim\n\n\n\n", "id": "lists-006-4538210"}, {"subject": "proppatch label-name-set", "content": "Is it legal to PROPPATCH the DAV:label-name-set on a checked-out resource?\n(whether a checked-out VCR or a working resource)\n\nIt seems feasible to me, with the caveat of possible rejection at CHECKIN\n(or MERGE) time due to a label conflict with another version in the version\nhistory.\n\n\nSpecifically, the problem that I'm considering is how to label a baseline\nbefore checking it in. I think that I'm also okay with labelling via a\nsecond request (after the checkin/merge), but that does lead to a race\nbetween the checkin and label that I'd like to avoid if possible.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4544981"}, {"subject": "Re: proppatch label-name-set", "content": "   From: Greg Stein <gstein@lyra.org>\n\n   Is it legal to PROPPATCH the DAV:label-name-set on a checked-out resource?\n   (whether a checked-out VCR or a working resource)\n\nOnly versions have a DAV:label-name-set property, not\nversion-controlled resources or working resources.\n\n   It seems feasible to me, with the caveat of possible rejection at CHECKIN\n   (or MERGE) time due to a label conflict with another version in the version\n   history.\n\nThe possibility of a \"label conflict\" is avoided by only having\nlabels on versions.\n\n   Specifically, the problem that I'm considering is how to label a baseline\n   before checking it in. I think that I'm also okay with labelling via a\n   second request (after the checkin/merge), but that does lead to a race\n   between the checkin and label that I'd like to avoid if possible.\n\nWith the current protocol, you would have to do the labeling in a\nsecond request (after the version was created).  What is the race\ncondition you were concerned about?  And how would it be addressed\nby allowing a label on a working baseline?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4552206"}, {"subject": "Re: is this example valid", "content": "Sorry, I realized this after I sent the message. I want to do:\n\n  CHECKOUT /the/baseline/selector/some/file.c\n  Label: which-baseline\n    <DAV:apply-to-version>\n\nThus, getting a working resource for \"file.c\" from baseline\n\"which-baseline\".\n\nThis is premised on the fact that a baseline-selector operates just like a\nregular VCR, but that it sets up the children to come from a particular\nbaseline.\n\nDoes this sound right?\n\nIf not, then is there a way to do this? Would I have to create a new\nbaseline selector, UDPATE it, then CHECKOUT/apply-to-version? (I hope not\nbecause that doesn't scaleas well)\n\nthx,\n-g\n\nOn Tue, Jan 16, 2001 at 11:43:42AM -0500, Geoffrey M. Clemm wrote:\n> Ah, good!  Something not about options (:-).\n> \n>    From: Greg Stein <gstein@lyra.org>\n> \n>    Consider that I have a collection under baseline control. I want to check\n>    out a specific version resource (to get a working resource) from a specific\n>    baseline of that collection.\n> \n> Or in other words, you want to checkout a particular baseline to get\n> a \"working baseline\"?\n> \n>    I believe the order of operations would be:\n> \n>    PROPFIND /my/coll\n>      <DAV:baseline-selector>\n> \n>    CHECKOUT /the/baseline/selector\n>    Label: which-baseline\n>      <DAV:apply-to-version>\n> \n>    I'm presuming that the latter will create the working resource for me.\n> \n> The \"Label\" header makes the CHECKOUT method apply to the specified\n> baseline (rather than to the baseline selector), so the DAV:apply-to-version\n> argument is redundant.\n> \n> Cheers,\n> Geoff\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4560454"}, {"subject": "Re: is this example valid", "content": "   From: Greg Stein <gstein@lyra.org>\n\n   Sorry, I realized this after I sent the message. I want to do:\n\n     CHECKOUT /the/baseline/selector/some/file.c\n     Label: which-baseline\n       <DAV:apply-to-version>\n\nA baseline selector is not a collection ... it is just a resource that\nyou can checkout and checkin to create new baselines.\n\nMany baseline implementations will be things like \"an internal label\"\nor \"a list of version URL's\", which do not directly provide\ncollection semantics.\n\n   Thus, getting a working resource for \"file.c\" from baseline\n   \"which-baseline\".  This is premised on the fact that a\n   baseline-selector operates just like a regular VCR, but that it\n   sets up the children to come from a particular baseline.  Does this\n   sound right?\n\nA baseline-selector acts just like a regular vcr (i.e. you can\ncheck it in and check it out), but it is not a collection so it\nhas no children.\n\n   If not, then is there a way to do this? Would I have to create a new\n   baseline selector, UDPATE it, then CHECKOUT/apply-to-version?\n\nAlmost.  You can create a new collection (reasonably enough, since you\ndo want a collection :-), and then put it under baseline control, i.e.:\n\nMKCOL /collection/for-baseline/foo\nBASELINE-CONTROL /collection/for-baseline/foo\n  <DAV:baseline> /baseline/xyz34\nCHECKOUT /collection/for-baseline/foo/some/file.c\n  <DAV:apply-to-version>\n\nNote that you can continue to use /my/collection for all your subsequent\ncheckouts against baseline foo ... so you only have to do the\nBASELINE-CONTROL once for any checkout against that baseline.\n\n  (I hope not because that doesn't scale as well)\n\nFor many implementations (such as the very common label-based baseline\nimplementation), that is the only way it will scale well, because it\ntells the server when to \"cache\" a traversable form of the baseline,\nand when to empty that \"cache\" (i.e. when /my/collection is deleted).\n\nIn subversion, the BASELINE-CONTROL is a trivial operation, because\nyour baselines are already in traversable form.  So the cost to you is\nthat protocol asks you to \"publish\" important baselines in the form of\nbaseline-controlled collections, i.e. give them human meaningful\nURL's.\n\nI agree that the intermediate BASELINE-CONTROL step is not optimized\ntowards your implementation (which does not need it), but it is\nneeded for interoperability with most other baseline implementations.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4569454"}, {"subject": "Re: is this example valid", "content": "Grr. The below doesn't work either. The Label: would apply to file.c, not\n/the/baseline/selector.\n\nOkay... separate question: can I \"slash through\" a baseline?\n\nOff the cuff, I'd say \"no, the baseline is an arbitrary set of version\nresources, rather than a structured/hierarchical set of version resources.\"\n\nThe problem is how to get to a specific version resource given a label for a\nbaseline and a (relative) path within that baseline. And in as few\noperations as possible, of course :-)\n\nCheers,\n-g\n\nOn Tue, Jan 16, 2001 at 09:51:37AM -0800, Greg Stein wrote:\n> Sorry, I realized this after I sent the message. I want to do:\n> \n>   CHECKOUT /the/baseline/selector/some/file.c\n>   Label: which-baseline\n>     <DAV:apply-to-version>\n> \n> Thus, getting a working resource for \"file.c\" from baseline\n> \"which-baseline\".\n> \n> This is premised on the fact that a baseline-selector operates just like a\n> regular VCR, but that it sets up the children to come from a particular\n> baseline.\n> \n> Does this sound right?\n> \n> If not, then is there a way to do this? Would I have to create a new\n> baseline selector, UDPATE it, then CHECKOUT/apply-to-version? (I hope not\n> because that doesn't scaleas well)\n> \n> thx,\n> -g\n> \n> On Tue, Jan 16, 2001 at 11:43:42AM -0500, Geoffrey M. Clemm wrote:\n> > Ah, good!  Something not about options (:-).\n> > \n> >    From: Greg Stein <gstein@lyra.org>\n> > \n> >    Consider that I have a collection under baseline control. I want to check\n> >    out a specific version resource (to get a working resource) from a specific\n> >    baseline of that collection.\n> > \n> > Or in other words, you want to checkout a particular baseline to get\n> > a \"working baseline\"?\n> > \n> >    I believe the order of operations would be:\n> > \n> >    PROPFIND /my/coll\n> >      <DAV:baseline-selector>\n> > \n> >    CHECKOUT /the/baseline/selector\n> >    Label: which-baseline\n> >      <DAV:apply-to-version>\n> > \n> >    I'm presuming that the latter will create the working resource for me.\n> > \n> > The \"Label\" header makes the CHECKOUT method apply to the specified\n> > baseline (rather than to the baseline selector), so the DAV:apply-to-version\n> > argument is redundant.\n> > \n> > Cheers,\n> > Geoff\n> \n> -- \n> Greg Stein, http://www.lyra.org/\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4579099"}, {"subject": "Re: is this example valid", "content": "   From: Greg Stein <gstein@lyra.org>\n\n   Grr. The below doesn't work either. The Label: would apply to file.c, not\n   /the/baseline/selector.\n\n   Okay... separate question: can I \"slash through\" a baseline?\n\n   Off the cuff, I'd say \"no, the baseline is an arbitrary set of version\n   resources, rather than a structured/hierarchical set of version resources.\"\n\nCorrect.\n\n   The problem is how to get to a specific version resource given a label for a\n   baseline and a (relative) path within that baseline. And in as few\n   operations as possible, of course :-)\n\nYou would have to:\n- locate that baseline,\n- use BASELINE-CONTROL to instantiate that baseline in some collection, and\n- issue the checkout against the appropriate member of that collection\n\nAssume that /repo/proj1 identifies your subversion repository, you want\nthe baseline labeled \"foo\", and the name in that baseline was \"/some/file.c\"\n(and specifying just enough XML to get the point across):\n\n------------------------\n\nPROPFIND /repo/proj1\n  <DAV:prop> <DAV:baseline-selector/> </DAV:prop>\n=>\n  <DAV:baseline-selector> /bs/x235 </DAV:baseline-selector>\n\nPROPFIND /bs/x235\n  Label: foo\n  <DAV:prop> <DAV:version/> </DAV:prop>\n=>\n  <DAV:version> /bl/id93 </DAV:version>\n\nBASELINE-CONTROL /baseline-collection/proj1/foo\n  <DAV:baseline> /bl/id93 </DAV:baseline>\n\nCHECKOUT /baseline-collection/proj1/foo/some/file.c\n\n------------------------\n\nThe choice of the name for this baseline controlled collection\nis up to the client.  This client probably called it \"foo\"\nbecause the baseline is currently labeled foo, so that seems\na reasonable thing to put in the URL for that collection.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4588857"}, {"subject": "Re: is this example valid", "content": "On Tue, Jan 16, 2001 at 01:33:47PM -0500, Geoffrey M. Clemm wrote:\n>...\n> In subversion, the BASELINE-CONTROL is a trivial operation, because\n> your baselines are already in traversable form.  So the cost to you is\n> that protocol asks you to \"publish\" important baselines in the form of\n> baseline-controlled collections, i.e. give them human meaningful\n> URL's.\n> \n> I agree that the intermediate BASELINE-CONTROL step is not optimized\n> towards your implementation (which does not need it), but it is\n> needed for interoperability with most other baseline implementations.\n\nThat is exactly the issue that I'm pondering on :-)\n\nOkay... thanks for the feedback. I'll figure out a way to deal with this,\nthen. I don't think that we can be truly interoperable because of the\nquestion \"where can I create that (temporary) baseline-controlled collection\n(BCC)?\" I can detect an SVN server and know where an automatically\nconstructed BCC exists, but if the server is *not* an SVN server, then I\nwill need to know a location to create that BCC.\n\n[ effectively, I will automatically create a BCC each time a baseline is\n  created (via a check-in/merge). a property on the public VCR will tell me\n  the collection containing the BCCs. ]\n\n[ attaching labels to the baselines is related to this issue ]\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4597333"}, {"subject": "fetching from a baseline on a readonly serve", "content": "As a variant of my previous question, how would I fetch a particular file\nfrom a particular baseline on a readonly server? Specifically, if I'm not\nallowed to do a MKCOL, a BASELINE-CONTROL, or an UPDATE (on an existing\nbaseline selector), then how can I use a baseline?\n\nConceivably, I could get the version-history for a given VCR, use a\nDAV:baseline-version report to find the specific version of that collection,\nget the collection version's members and execute DAV:baseline-version on\nthose, etc. But this is a far cry from random-access to a specific path\nwithin a baseline.\n\nNote that I can't simply use the Depth: header, as that would apply \"once\"\nto the collection version history (which has no children); the Depth header\nwould not apply to the collection versions.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4605444"}, {"subject": "Re: fetching from a baseline on a readonly serve", "content": "   From: Greg Stein <gstein@lyra.org>\n\n   As a variant of my previous question, how would I fetch a particular file\n   from a particular baseline on a readonly server? Specifically, if I'm not\n   allowed to do a MKCOL, a BASELINE-CONTROL, or an UPDATE (on an existing\n   baseline selector), then how can I use a baseline?\n\nOK, I was wavering before, but now you've pushed me over the edge.  I\nbelieve it is reasonable to do what you want, and you shouldn't have\nto do a \"write\" operation to get it.  So I propose the following:\n\nAdd a DAV:baseline-collection property on a baseline, which holds\na DAV:href containing a server-defined URL.  This URL identifies\na read-only collection that exposes that baseline as a collection.\nAccess to that read-only collection would be the message to the\nserver to \"cache\" that baseline as a collection.  The server\nwould then just have to automatically clean up that cache when it\nneeds the space, rather than counting on a DELETE from the client\nto tell it when to do so.\n\nThis is a burden on the server, but probably not an unreasonable one.\nIn particular, I don't think that Greg's will be the only server that\nwill have very different performance/implementation tradeoffs for a\nread-only view of a baseline (what Greg wants) and a writeable view of\na baseline (aka a workspace).\n\n   Conceivably, I could get the version-history for a given VCR, use a\n   DAV:baseline-version report to find the specific version of that collection,\n   get the collection version's members and execute DAV:baseline-version on\n   those, etc. But this is a far cry from random-access to a specific path\n   within a baseline.\n\nYes, that would be really gross.\n\n   Note that I can't simply use the Depth: header, as that would apply \"once\"\n   to the collection version history (which has no children); the Depth header\n   would not apply to the collection versions.\n\nYes, that wouldn't work.\n\n\n\nSo, Greg: Does the DAV:baseline-collection property on a baseline\ngive you what you want (I presume, yes).\n\nSo, everyone else: any objections?  (For Greg at least, I presume, no :-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4613362"}, {"subject": "RE: DeltaV Draf", "content": "I think that we have now strayed off from the original intention based on\nthe teleconference last Friday.  At that time, it was agreed that the\nDAV:workspace property is a property of all resources that are in the\nworkspace.  A working resource is one such resource which can be in the\nworkspace.\n\nWhen reading section 6.1, it says that a \"working resource has all of the\nproperties of a checked-out version-controlled resource\".  I requested on\nthe teleconference for the simple addition to 6.1 specifically stating that\none of the properties can be DAV:workspace for clarity and it was agreed.\nThere are places throughout the draft in which clarifications are added and\nI feel that this aids in clarity and fully conforms to the specification as\nwritten.\n\nThanks,\n\nMark\n\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Geoffrey M.\n> Clemm\n> Sent: Tuesday, January 16, 2001 8:28 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: DeltaV Draft\n>\n>\n>\n>    From: \"Mark A. Hale\" <mark.hale@interwoven.com>\n>\n>    > I agree that a server that supports both workspaces and working\n>    > resources might reasonably make such an association, and a server is\n>    > certainly allowed to set a DAV:workspace property on a working\n>    > resource (since any resource can have a DAV:workspace property) but\n>    > what would a client do with this property value (i.e. what\n>    > interoperability would we get by highlighting this fact)?\n>    > We've already got a complex spec, so I try to leave out anything\n>    > that doesn't directly contribute to interoperability.\n>\n>    Per our telecon, it was non-obvious to an implementer that the\n> properties\n>    are inherited.\n>\n> As Tim pointed out, its probably best to avoid the term \"inherited\"\n> here.  The protocol states what kind of resources have what kinds of\n> properties.  It states that any resource can have a DAV:workspace\n> property; therefore, since a working resource is a resource, a working\n> resource can have a DAV:workspace property.\n>\n>    I feel that adding a sentence or two like the following:\n>\n>        A server may set a DAV:workspace property when a new\n>        working resource is created.  The property is asserted\n>        by servers that utilize server-managed workspaces for\n>        resource management.\n>\n>    is clear as to what the property is and when it is set in the\n>    context of the working resources creation.\n>\n> I don't see that this statement by itself would lead to any\n> significant interoperability.  Although it hints at what this property\n> could be used for, it doesn't provide anything that an interoperable\n> client can count on for it to mean.\n>\n>    I feel that a client\n>    usage discussion would actually make the Draft Specification harder\n>    to read.\n>\n> I agree.  My request for a client usage scenario was for us to\n> understand what you wanted it for, not for insertion in the protocol.\n>\n>    A client can use this property-value to its advantage for a number of\n>    reasons: it can initiate a single cleanup instruction to the server by\n>    asking for a workspace deletion, the client can decide to\n> generate the next\n>    working resource in the same workspace in order to due\n> synchronization in\n>    off-line editing, and others.\n>\n> An interoperable client can't do any of these things unless the\n> protocol requires specific behavior that produces this result.  For\n> example, we could add a postcondition to the DELETE method that says\n> \"whenever a workspace is deleted, all working resource that identify\n> that workspace in their DAV:workspace property MUST be deleted\".\n>\n> Perhaps that is the change you'd like to see in the protocol?\n> Assuming it is, do people agree that this is something that should be\n> in the protocol?  I'm a bit concerned about adding storage cleanup\n> semantics into the protocol, since this tends to be a very\n> implementation dependent area.\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-4623021"}, {"subject": "Re: DeltaV Draf", "content": "OK, I (finally :-) get it.\n\nThe section on working resource properties should enumerate the\nproperties that a working resource can have, rather than requiring a\nperson to scan through the protocol to find them.  I'll add this\nenumeration to the working resource property section, and make sure to\ninclude DAV:workspace in that list.\n\nEveryone OK with that?\n\nCheers,\nGeoff\n\n   From: \"Mark A. Hale\" <mark.hale@interwoven.com>\n   Date: Tue, 16 Jan 2001 22:16:04 -0800\n\n   I think that we have now strayed off from the original intention based on\n   the teleconference last Friday.  At that time, it was agreed that the\n   DAV:workspace property is a property of all resources that are in the\n   workspace.  A working resource is one such resource which can be in the\n   workspace.\n\n   When reading section 6.1, it says that a \"working resource has all of the\n   properties of a checked-out version-controlled resource\".  I requested on\n   the teleconference for the simple addition to 6.1 specifically stating that\n   one of the properties can be DAV:workspace for clarity and it was agreed.\n   There are places throughout the draft in which clarifications are added and\n   I feel that this aids in clarity and fully conforms to the specification as\n   written.\n\n   Thanks,\n\n   Mark\n\n\n\n\n   > -----Original Message-----\n   > From: ietf-dav-versioning-request@w3.org\n   > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Geoffrey M.\n   > Clemm\n   > Sent: Tuesday, January 16, 2001 8:28 AM\n   > To: ietf-dav-versioning@w3.org\n   > Subject: Re: DeltaV Draft\n   >\n   >\n   >\n   >    From: \"Mark A. Hale\" <mark.hale@interwoven.com>\n   >\n   >    > I agree that a server that supports both workspaces and working\n   >    > resources might reasonably make such an association, and a server is\n   >    > certainly allowed to set a DAV:workspace property on a working\n   >    > resource (since any resource can have a DAV:workspace property) but\n   >    > what would a client do with this property value (i.e. what\n   >    > interoperability would we get by highlighting this fact)?\n   >    > We've already got a complex spec, so I try to leave out anything\n   >    > that doesn't directly contribute to interoperability.\n   >\n   >    Per our telecon, it was non-obvious to an implementer that the\n   > properties\n   >    are inherited.\n   >\n   > As Tim pointed out, its probably best to avoid the term \"inherited\"\n   > here.  The protocol states what kind of resources have what kinds of\n   > properties.  It states that any resource can have a DAV:workspace\n   > property; therefore, since a working resource is a resource, a working\n   > resource can have a DAV:workspace property.\n   >\n   >    I feel that adding a sentence or two like the following:\n   >\n   >        A server may set a DAV:workspace property when a new\n   >        working resource is created.  The property is asserted\n   >        by servers that utilize server-managed workspaces for\n   >        resource management.\n   >\n   >    is clear as to what the property is and when it is set in the\n   >    context of the working resources creation.\n   >\n   > I don't see that this statement by itself would lead to any\n   > significant interoperability.  Although it hints at what this property\n   > could be used for, it doesn't provide anything that an interoperable\n   > client can count on for it to mean.\n   >\n   >    I feel that a client\n   >    usage discussion would actually make the Draft Specification harder\n   >    to read.\n   >\n   > I agree.  My request for a client usage scenario was for us to\n   > understand what you wanted it for, not for insertion in the protocol.\n   >\n   >    A client can use this property-value to its advantage for a number of\n   >    reasons: it can initiate a single cleanup instruction to the server by\n   >    asking for a workspace deletion, the client can decide to\n   > generate the next\n   >    working resource in the same workspace in order to due\n   > synchronization in\n   >    off-line editing, and others.\n   >\n   > An interoperable client can't do any of these things unless the\n   > protocol requires specific behavior that produces this result.  For\n   > example, we could add a postcondition to the DELETE method that says\n   > \"whenever a workspace is deleted, all working resource that identify\n   > that workspace in their DAV:workspace property MUST be deleted\".\n   >\n   > Perhaps that is the change you'd like to see in the protocol?\n   > Assuming it is, do people agree that this is something that should be\n   > in the protocol?  I'm a bit concerned about adding storage cleanup\n   > semantics into the protocol, since this tends to be a very\n   > implementation dependent area.\n   >\n   > Cheers,\n   > Geoff\n\n\n\n", "id": "lists-006-4635508"}, {"subject": "Re: fetching from a baseline on a readonly serve", "content": "> Add a DAV:baseline-collection property on a baseline, which holds\n> a DAV:href containing a server-defined URL.  This URL identifies\n> a read-only collection that exposes that baseline as a collection.\n> \n> ... \n> \n> So, everyone else: any objections?  (For Greg at least, I presume, no :-).\n\nNo objections at all, on the contrary: I'd really like to have this \nproperty.\n\nBoris.\n\n\n\n", "id": "lists-006-4648312"}, {"subject": "MS Web Folders limits length of DAV heade", "content": "I recently discovered that Microsoft's Web Folders (on Windows 2000 SP1, at\nleast) appears to ignore a DAV header from a server when the header value is\nlonger than 63 characters. It behaves as if no DAV header was returned at\nall, refusing to connect to the site using the WebDAV protocol. (I\ndiscovered this after adding a bunch of DeltaV options to my server.\nNon-versioning servers based on mod_dav can also run into this problem if\nsomeone defines a live property provider with long enough property namespace\nURIs, since they are also returned in the DAV header.)\n\nI've worked around this problem by submitting a change to mod_dav so it will\nemit multiple DAV headers (as allowed by the HTTP spec, section 4.2). This\nis a warning to client implementors that they should be prepared for\nmultiple DAV headers from a server, and a warning to server implementors\nabout limiting the length of a DAV header (if you care about interoperating\nwith Web Folders).\n\nJohn\n\n\n\n", "id": "lists-006-4656225"}, {"subject": "Re: fetching from a baseline on a readonly serve", "content": "   From: \"Boris Bokowski/OTT/OTI\" <Boris_Bokowski@oti.com>\n   Date: Wed, 17 Jan 2001 09:40:18 -0500\n\n   > Add a DAV:baseline-collection property on a baseline, which holds\n   > a DAV:href containing a server-defined URL.  This URL identifies\n   > a read-only collection that exposes that baseline as a collection.\n   > \n   > ... \n   > \n   > So, everyone else: any objections?  (For Greg at least, I presume, no :-).\n\n   No objections at all, on the contrary: I'd really like to have this \n   property.\n\nAlso note that this property allows us to get rid of the\nDAV:baseline-version-set property, since you can get the same\ninformation by doing a PROPFIND for the DAV:checked-in values in this\ncollection.\n\nThis is probably cleaner anyway, since the DAV:version-set property\nhad scalability problems (just imagine how useful it would be to get\nthe DAV:version-set property of a baseline with 10,000 elements).  In\ncontrast, with the collection approach, you can just obtain the\nversion info for a particular resource or subtree of interest.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4664926"}, {"subject": "11.1 revie", "content": "[freed from spam trap -rrs[\n\n Date: Wed, 17 Jan 2001 12:03:21 -0500 (EST)\n Message-ID: <004b01c0808f$400434b0$27181409@hursley.ibm.com>\n From: \"Tim Ellison\" <tim@peir.com>\n To: <ietf-dav-versioning@w3.org>\n\nI had a thorough read through 11.1 and as I indicated in my earlier message\nhad no significant changes.\nI'll post these to the list, but they are really only of interest to the\nauthors as they are small editorial changes.\nI'm sure Geoff will call-out anything that requires wider discussion.\n\nRoll-on Friday!\n\nTim\n--------\n\nGeneral beefs:\n\n    There are a number of places where the text says a property must contain\na version etc.  when it means that the property must \"contain the URL of\" a\nversion etc.\n\n    In the 'OPTIONS Additional Marshalling' sections there are DTDs for the\nrequest and the response without any indication of which is which.  Either\nsome text, or a subheading would be useful.\n\n\nTrivia:\n\n(Nothing of any significance here, just some things that I thought would add\na little more clarity or questions that came to mind as I was reading\nthrough the document.)\n\nAuthors list\n    Check Jim Whitehead's affiliation\n\n1.3 Terms\n    'This draft' --> 'This document'\n\n    'A \"version history\" is a resource that contains all the versions ...'\n    consider '... that references all the versions ...'\n\n    'Root Version Resource'\n    consider renaming the term 'Initial Version Resource' as the term root\nis used elsewhere in the document, as in a root collection.\n\n1.5.2 Property Value Locking\n    This section is too general as it can be read to mean that requests\nwhose side-effects are a modification of another resource's (computed)\nproperty MUST include the lock token of any resources that they affect.  I\ndo not believe that this is the intent.\n\n2.1.1 Creating a Version-Controlled Resource\n    para. 1 '... and creates a version in this version history...'\n    consider '...of this version history...'  (that 'contains' thing again)\n\n    para. 3 '... the resource that is now under version control.'\n    consider '... under version control (the 'version-controlled resource).'\nfor clarification and definition of the term.\n\n2.1.2 Modifying a Version-Controlled Resource\n    para. 2 '... with the DAV:auto-version property set'\n    I'm assuming that this has been rewritten based on the value of the\nproperty.\n\n2.2.1 DAV:checked-in\n    'This URL can be used to retrieve this particular state of the\nversion-controlled resource after the version-controlled resource itself has\nbeen modified.'\n    Given that this is a property of a checked-in version-controlled\nresource, I fail to see how the version-controlled resource itself can be\nmodified.\n\n2.2.3 DAV:predecessor-set\n    Should state that the predecessors MUST be part of the same history.\n\n2.2.4 DAV:precursor-set\n    Should state that the predecessors MUST NOT be part of the same history.\n    Why are we required to make this distinction between predecessors and\nprecursors?\n\n2.2.5 DAV:auto-version\n    Assuming that the vallue of the property is being defined rather than\nsaying it is set.\n    As it reads now, having it set to 'false' would cause auto-versioning to\ntake place.\n    Maybe clarify what happens when a write lock expires, presumably the\ncheckin attempt occurs, and errors are never reported to any client.\n\n2.3.5 DAV:checkin-date\n    'This property contains the date on the server when the version was\nchecked in.'\n    Consider '..when the version was created.' since the initial version is\nnot checked in.\n\n2.5 DAV:version-tree REPORT\n    Marshalling:\n    '...with at most one a DAV:prop...'  -> '..with at most one DAV:prop...'\n\n    <!ELEMENT version-tree (href, prop, version-tree*)\n    Why DAV:prop and not DAV:propstat? -- what about requests for\nnon-existant properties?\n    Why are the DAV:version-tree elements nested?  It does not convey \"true\"\nstructure, especially since 'A server MAY omit the DAV:prop and the\nsuccessor DAV:version-tree elements ...'  I don't see that the nesting is\nhelpful.\n\n2.5.1 Example - DAV:version-tree-report\n    >>REQUEST\n    Last line of the XML has a gratuitous xmlns definition.\n\n2.7 Additional PUT semantics\n    (DAV:cannot-modify-version-controlled-content) &\n    (DAV:auto-checkout)\n    Assume that the DAV:auto-version consideration is being re-written.\n\n    (DAV:auto-checkout-checkin)\n    Uses the obsolete term 'revision' twice.\n\n2.8 Additional PROPPATCH semantics\n    (DAV:cannot-modify-computed-property)\n    Consider removing this precondition and stating (earlier) that all\ncomputed properties are protected.\n\n    (DAV:auto-checkout) &\n    (DAV:auto-checkout-checkin)\n    Assume that the DAV:auto-version consideration is being re-written.\n\n    (DAV:auto-checkout-checkin)\n    Uses the obsolete term 'revision' twice.\n\n2.9 Additional DELETE semantics\n    (DAV:cannot-delete-root-version)\n    Why?  Consider that the value of DAV:root-version becomes undefined on\nits deletion.\n\n    (DAV:no-version-delete)\n    Reads more like a precondition.\n\n    (DAV:update-predecessor-set)\n    I presume this is to prevent \"holes\" in the history, but this won't work\nin the face of merges.\n\n2.10 Additional COPY semantics\n    (DAV:auto-checkout)\n    Assume that the DAV:auto-version consideration is being re-written.\n    Uses the obsolete term 'revision' twice.\n\n3.1 CHECKOUT Method\n    What happened to the text that stated a lock token is required if the\nresource is write locked?\n\n3.2 CHECKIN Method\n    (DAV:initialize-version-content-and-properties)\n    'The DAV:checkin-date of the new version MUST be set...'\n    Should state where possible to be consistent with definition of property\n(2.3.5).\n\n4.1 UPDATE Method\n    Marshalling:\n    '...with at most one DAV:version element.'\n    So what would zero elements mean?\n\n    (DAV:must-select-version)\n    Consider renaming (DAV:must-select-version-in-same-version-history)\n\n4.1.1 Example - UPDATE\n    'In this example, the content and dead properties of http://... are\ncopied to the vesion-controlled resource /foo.html, ...'\n    Consider 'In this example, the version-controlled resource /foo.html is\nupdated with the content and dead properties of http://...,'\n\n5.1.2 DAV:root-version\n    Consider renaming to DAV:initial-version\n\n5.2.1 DAV:version-history\n    Consider changing from (computed) to (protected).\n\n    Consider defining in terms of DAV:version-set (5.1.1).\n\n5.4 Additional OPTIONS Semantics\n    Is it required that the history for the resource reporting the OPTIONS\nMUST be in the version-history-collection-set?  Probably unnecessary since\nclients can get to the history via properties.\n\n    Consider an example.\n\n6.1 Working Resource Properties\n    'The server allocates a distinct new URL for each new working resource.'\n    What does this imply?  That the server cannot reuse working resource\nURLs once the working resource has been checked in or deleted?\n\n6.3 Additional COPY semantics\n    '...a new non-version-controlled resource at the destination...'\n    consider adding 'with the same content and dead properties...' as\nwritten elsewhere in the document.\n\n6.5 Additional CHECKOUT Semantics\n    Additional Marshalling:\n    'The response MAY include a Location header.'\n    How else would you find a working resource URL?  Consider MUST.\n\n6.6 Additional CHECKIN Semantics\n    '...new version whose contents and dead properties are those of the\nworking resource.'\n    consider '...and dead properties are the same as those of the..'\n\n    (DAV:delete-working-resource)\n    '...if DAV:keep-checked-out is not specified, the'\n    consider '...is not specified in the request body'\n    (there are a number of places where it is confusing as to whether the\nelement name given in text is a property name or an element in the request\nbody.\n\n7 Server-Workspace Option\n    para. 4\n    Unless the URLs are relative, the workspace name will get in the way of\ntesting.\n\n7.2 Additional Resource Properties\n    '...for an HTTP resource.' --> 'for a WebDAV resource.' (it has to\nsupport properties<g>).\n\n7.2.1 DAV:workspace\n    'The DAV:workspace property of any other type of resource MUST be the\nsame as the DAV:workspace of its parent collection.'\n    But only when the immediate parent collection defines a workspace.\n\n7.3 DAV:version-controlled-resource-url REPORT\n    Consider moving this section after 7.4 MKWORKSPACE Method.\n\n    Marshalling:\n    'The DAV:version-controlled-resource REPORT response body MUST be a\nDAV:version-controlled-resource XML element' --> 'The\nDAV:version-controlled-resource-url ...be a\nDAV:version-controlled-resource-url ...' (two corrections)\n\n    What happens if the version-controlled resouce was deleted?\n\n7.3.1 Example - DAV:version-controlled-resource-url  REPORT\n    >> RESPONSE\n        xmlns definition should be moved out a level.\n\n7.4 MKWORKSPACE Method\n    (DAV:workspace-location-ok)\n    Consider renaming to (DAV:workspace-lcoation-not-OK)\n    [All other OK's have been caps. ;-]\n\n    (DAV:initialize-workspace-properties)\n    'The DAV:resource type...' --> 'The DAV:resourcetype...'\n\n    (DAV:initialize-workspace-properties)\n    'The DAV:workspace of the workspace MUST contain the request-URL.'\n    consider 'The DAV:workspace property of the workspace MUST identify the\nnew workspace.' i.e., let servers put some alias in there if they choose.\n\n7.5 Additional OPTIONS Semantics\n    para.2\n    'If a server support the ...' --> 'If a server supports the ...'\n\n    Additional Marshalling:\n    How would a server indicate that workspaces can be created anywhere? or\nhere and below?\n\n7.7 Additional VERSION-CONTROL Semantics\n    (DAV:one-version-controlled-resource-per-history-per-workspace)\n    '...there MUST NOT already be a version-controlled member of that\nworkspace ... identifies a different version from the version history...'\n    consider ' ... identifies any version from the version history...'\n\n    (DAV:version-controlled-resource)\n    '...whose content and dead properties are initialized by those of...'\n    consider '...are the same as those of...'\n\n7.7.1 Example VERSION-CONTROL ...\n    '...the content and deap properties ... are those of the version...'\n    consider '...are the samae as those of...'\n\n8.2 MERGE Method\n    Marshalling:\n    '<!ELEMENT merge ANY>'\n    '..., and at most one of any element that can occur in a DAV:checkout\nelement.'\n    This is too restrictive for future extensions, consider '..., and any\nlegal set of elements that can occur...'\n\n    (DAV:update-merge-set)\n    '...and if DAV:checked-out version...' --> '..and if the DAV:checked-out\nversion...'\n\n    Final two postconditions of this method do not have any advanced status\nelement defined.\n\n8.3 DAV:merge-preview REPORT\n    '<!ELEMENT merge-preview (update-preview-set, merge-preview-set,\nignore-preview-set)>'\n    Consider adding a '*' so that servers can generate these sets of XML on\nthe fly rather than having to compute the entire set of each before\nresponding.\n\n9 Label Option\n    para. 2\n    consider a forward reference to 9.3 Label Header\n\n    para. 3\n    consider striking this paragraph -- although an interesting footnote it\ndoesn't add anything and may even imply permission to create duplicate\nlabels.\n\n9.2.1 Example - Setting a label\n    >>Request\n    Why the change of XML layout?\n\n9.8 Additional CHECKOUT Semantics\n    postconditions\n    'If a version-controlled resource was checked out, ... the\nversion-controlled resource MUST remain checked in.'\n    Huh??\n\n9.9 Additional UPDATE Semantics\n    Presumably the response is Bad Request if a client attempts to specify a\ncontradictory Label and <DAV:apply-to-version/>.\n\n10 Baseline Option\n    The ascii art added nothing for me, consider striking it.\n\n10.1.1 DAV:baseline-controlled-collection\n    Consider (computed) -> (protected)\n\n10.2.2 DAV:subbaseline-set\n    '...a set of other baseline.'  --> '...a set of other baselines.'\n\n10.4 BASELINE-CONTROL Method\n    Consider adding some descriptive text regarding creating a new baseline\nselector on an existing baseline.\n\n    (DAV:must-have-no-version-controlled-members)\n    Hmm, don't get why this one is required.\n\n    postconditions:\n    Consider each occurrence of 'the collection' --> 'the target collection'\n\n    (DAV:select-existing-baseline)\n    '...each version in the baseline, where the version-controlled\nmember...'\n    consider '...the baseline, and the ...'\n\n10.5 DAV:baseline-comparison REPORT\n    Marshalling:\n    Why are the results not reported as sets in keeping with the other\nreports that respond with multiple URLs.\n\n    Postconditions:\n    This section still seems to be referring to marshalling rather than\npostconditions (of the repository) of the method as in other postcondition\nsections.\n\n10.7 Additional OPTIONS Semantics\n    Additional Preconditions:\n    '... the response body MUST contain a\nDAV:baseline-controlled-collection-set element identifying which collections\nare under baseline control.'\n    Eek, why would a client want this \"global\" information?  I think this is\ntoo difficult to require all servers to supply, and will potentially make\nthe OPTIONS request very expensive (IMHO clients presently consider OPTIONS\nto be cheap and send them frequently.)\n\n10.10 Additional CHECKIN Semantics\n    (DAV:create-baseline-version-set)\n    '...the DAV:baseline-version-set of the new baseline contains the ...'\n    consider '... of the new baseline version contains the ...'\n\n10.11 Additional UPDATE Semantics\n    (DAV:set-baseline-controlled-collection-members) last bullet point\n    'An UPDATE request MUST have been applied to each version-controlled\nmember whose DAV:checkin-set does not identify a version in the\nDAV:baseline-version-set of the baseline.'\n    consider '... whose DAV:checkin-set does not identify the same version\n...'\n\n10.12 Additional MERGE Semantics\n    'If the merge version is a baseline, the merge target is a baseline\nselector for the baseline history of that baseline, where the\nbaseline-controlled collection of that baseline selector is a member of the\nmerge destination of the request.'\n    That deserves an award for the greatest use of the word 'baseline' in\none sentence.  Just read it very slowly.\n\n11 Activity option\n    para. 3\n    'Activity semantics then ensures that ...' --> 'Activity semantics then\nensure that ...'\n\n11.2.1 DAV:activity-set\n    '...indicate to which logical changes this activity contributes, and on\nwhat lines of descent this version appears.'\n    Surely '.. this version contributes...'\n    what does 'and on what lines of descent this version appears.' mean?\n\n11.3.1 DAV:unreserved\n    all instances of 'checked-out resource' should read 'checked-out\nversion-controlled resource'.\n\n    para. 2\n    '... merge the latest version of that activity...'\n    consider '... of the version-controlled resource in that activity...'\n\n11.3.2 DAV:activity-set\n    '...checked-out resource...' --> '...checked-out version-controlled\nresource...'\n\n    Why not allow this property on checked-in and checked-out resources as a\nconvenience?  Just an idea.\n\n11.5 MKACTIVITY Method\n    (DAV:activity-lcoation-ok)\n    consider renaming to (DAV:activity-location-not-OK)\n\n    (DAV:create-activity) &\n    (DAV:initialize-activity-properties)\n    The corresponding postconditions for MKWORKSPACE do not distinguish\nthese as separate advances status codes, this should be consistent.\n\n11.7 Additional OPTIONS Semantics\n    'An activity collection MAY be the root collection of a tree of\ncollections, all of which may contain activities.'\n    I propose that this is true of all OPTIONS reported locations (e.g.,\nDAV:workspace-collection-set)\n\n11.10 Additional CHECKOUT Semantics\n    Additional Preconditions: (both)\n    'If there is a request activity set, ...'\n    consider clarifying with 'If the request body contains a\nDAV:activity-set element,...'\n\n11.10.1\n    >>RESPONSE\n    Does not contain a cache conrol header as required per 3.1.\n\n11.11 Additional CHECKIN Semantics\n    (DAV:linear-activity)\n    An example of a '...resource MUST be in the DAV:predecessor-set...'\n    (DAV:initialize-activity-version-set)\n    An example of a '...URL for the new version is added to the\nDAV:activity-version-set...'\n    Should be consistent about describing resources added to properties or\nURLs added to properties, otherwise the reader may think you are referring\nto differerent things.\n\n11.(13?)\n    Shouldn't there be Additional UNCHECKOUT Semantics to remove the\nchecked-out version-controlled resource URL from a\nDAV:activity-checkout-set?  If so, this is likely true for more methods that\nhave additional CHECKIN/CHECKOUT semantics.\n\n12.4 Additional PUT Semantics\n    I know that I've been banging this drum for 12+ months. but I don't like\nthe idea of <version URL>/member URLs.\n\n12.9 Additional CHECKIN Semantics\n    (DAV:no-eclipsed-baseline-controlled-collection-members)\n    I don't understand the rationale for this precondition.\n\n13.1.1 DAV:checkout-fork\n    '<!ELEMENT checkout-fork (ok | discouraged | forbidden )>'\n    Consider using ANY for future extensions.\n\n13.1.2 DAV:checkin-fork\n    '<!ELEMENT checkin-fork (ok | discouraged | forbidden )>'\n    Consider using ANY for future extensions.\n\n22 Authors' Addresses\n    Check Jim W's contact details.\n\n23.1.1 DAV:comment\n    Why do we have an extra DAV:string element?\n    Why can you have any number of them (how would a client choose which one\nto display)?\n\n23.2 Response Bodies ...\n    para. 2\n    '...each method precondition defined in this document...' -->\n    '...each method precondition and postcondition defined in this\ndocument...'\n\n    Should mention the purpose of the postcondition stati.\n\n    '...the appropriate XML element MUST be returned in the response\nbody.' -->\n    '... in the response body unless otherwise negotiated by the request.'\n\n23.3 Clarification of COPY ...\n    para. 4.\n    'Roy Fielding (an author..'\n    consider striking this paragraph (and moving it to the book of why)\n\n23.4 REPORT Method\n    Marshalling:\n        'The request body of a REPORT request...' -->\n        'The body of a REPORT request...'\n\n\nMinutae:\n(This stuff is way below trivia, but caught my eye when reading the\ndocument.  I'm almost embarrassed to send these in.)\n\nAbstract\n    Add comma after 'URL namespace versioning'\n\n2.10 Additional COPY semantics\n    Extra space before the text '(DAV:initialize-precursor)'\n\n5.8 Additional VERSION-CONTROL Semantics\n    (DAV:new-version-history)\n    double space in '..for that version history  that MUST NOT...'\n\n5.9 Additional CHECKIN Semantics\n    (DAV:preserve-version-history)\n    the document already uses (DAV:preserve-history) consider consistent\nnaming.\n\n8.2 MERGE method\n    para. 2\n    double space in '...the DAV:auto-merge-set property  of the...'\n\n10.11 Additional UPDATE Semantics\n    (DAV:set-baseline-controlled-collection-members)\n    double space in '... identifies a baseline,  then the\nversion-controlled...'\n\n11.11 Additional CHECKIN Semantics\n    (DAV:linear-activity)\n    double space in '...the DAV:predecessor-set of  the checked...'\n\n23.5.1 Example - DAV:property-report\n    >>REQUEST\n        last three lines have extra space '</D:property >' -->\n'</D:property>'\n\n\n\n", "id": "lists-006-4673576"}, {"subject": "DeltaV doesn't support a true client workspac", "content": "There seems to be an underlying assumption in DeltaV, even for parts of core\nversioning, that the server provides persistent storage of work-in-progress\non resources between checkout and checkin.  This is explicit in the optional\nVCR CHECKOUT-CHECKIN semantics, and in the Working Resource option.  It is\nalso implicit in core versioning when DAV:auto-version is set to\nDAV:when-locked:  between the LOCK and UNLOCK, the server is expected to\nprovide persistent working storage for intermediate updates via PUTs and\nPROPPATCHes from the client.\n\nUnfortunately, this assumption is not valid for some existing versioning\nsystems, including a FileNET content management product and one of the\nsoftware configuration management products we use internally.  These two\nversioning systems employ the concept of what I would call a *real* client\nworkspace, where *all* intermediate work-in-progress is stored on the client\nside between checkout and checkin.  A user may choose to store\nwork-in-progress on a file server for backup or access from other clients,\nbut in any case the versioning server software does not provide any\npersistent work-in-progress storage.\n\nSo DeltaV is not a great fit for these two existing systems.  (I won't argue\nthat their reliance on a client workspace is necessarily a better design\nthan DeltaV's server workspace.  Rather, I raise it as existing practice\nthat needs to be considered by DeltaV.)\n\nOne alternative is to build a core versioning layer for these two systems\nwhich would disallow the DAV:when-locked flavor of DAV:auto-version.  But\nthis would result in a new version for every PUT or PROPPATCH of dead\nproperties done by the client.  Arbitrary DeltaV clients are not likely to\nlimit themselves to one PUT between a LOCK and UNLOCK, so there would likely\nbe a proliferation of unwanted intermediate versions.  Scratch that\nalternative.\n\nAnother alternative would be to build a work-in-progress persistence layer\non top of these existing systems to accommodate DeltaV, but that is a costly\nand awkward choice.\n\nA third alternative would be to add a flavor of CHECKOUT-CHECKIN to core\nversioning in DeltaV that allows all changes to accompany the CHECKIN\nmethod.  This is the model used by the existing systems I mentioned.\n\nAre there other alternative solutions to this problem?\n\nDo others on the mailing list know of existing versioning systems with this\nsame problem with DeltaV?  Or is this problem limited to just these two\nsystems?\n\n--Chuck Fay \nFileNET Corporation, 3565 Harbor Blvd., Costa Mesa, CA 92626 \nphone:  (714) 327-3513, fax:  (714) 327-5076, email:  cfay@filenet.com\n\n\n\n", "id": "lists-006-4700199"}, {"subject": "Editorial suggestions for DeltaV 11.", "content": "Some minor editorial suggestions for DeltaV 11.2:\n\nSection 1, \"Introduction\", paragraph 1, 5th sentence:\n\"interesting\" -> \"interested\"\n\nSection 1.3, \"Terms\", \"Predecessor, Successor, Ancestor, Descendant\":\n\"When a version is related to another version by one or more predecessor\nrelations, it is called an 'ancestor' of that version.\"\nConsider clarifying which version in the sentence is the predecessor:\n\"When a version precedes another version by one or more predecessor\nrelations, it is called an 'ancestor' of that version.\"\n\nSection 1.3, \"Terms\", \"Version History Resource\" and \"Fork, Merge\":\nWhy aren't these defined in section 1.3.1, Optional Versioning Terms?\nVersion History and Merge are both optional.  By my reading, there is no\nrequirement to support fork/merge semantics or version history resources in\nCore Versioning.  If \"Fork, Merge\" definitions are moved to section 1.3.1,\nthe diagram following the definition should move with them.  While you're at\nit, why not label the first set of terms \"Core Versioning Terms\" and make\nthem a peer section to \"Optional Versioning Terms\"?\n\nSection 2.1.1, \"Creating a Version-Controlled Resource\", paragraph 1,\nsentence 1:\nAdd \"versionable\" as follows to make clear that VERSION-CONTROL can be\napplied only to versionable resources, not just any old resource:  \"In order\nto track the history of the content and dead properties of a versionable\nresource, an author can put the resource under version control with a\nVERSION-CONTROL request.\"\n\nSection 2.2.1, \"DAV:checked-in  (protected)\", sentence 2:\n\"This URL can be used to retrieve this particular state of the\nversion-controlled resource after the version-controlled resource itself has\nbeen modified.\"\nThis sentence should be moved to Section 2.2.2, \"DAV:checked-out ...\",\nbecause it's true there but incorrect here.\n\nSection 2.4, \"VERSION-CONTROL\", subsection \"Postconditions\", paragraph 1,\nsentence 5:\n\"chose\" -> \"choose\".\n\nSection 2.8, \"Additional PROPPATCH Semantics\", subsection \"Additional\nPreconditions\", last precondition:\n\"(DAV:cannot-modify-unsupported-property): An attempt to modify a property\ndefined by this document (either core or optional) whose semantics are not\nenforced by the server MUST fail.  This helps ensure that a client will be\nnotified when it is trying to use a property whose semantics are not\nsupported by the server.\"\nIt seems from RFC 2518 that all dead properties fall under the description\nof \"[a property] whose semantics are not enforced by the server\", but surely\nwe don't want to disallow modifying dead properties.  This should be\nreworded to say:  \"DAV:cannot-modify-unsupported-property): An attempt to\nmodify an optional property defined by this document but not supported by\nthe server MUST fail.  This helps ensure that a client will be notified when\nit is trying to use a property that is not supported by the server.\"\n\n--Chuck Fay \nFileNET Corporation, 3565 Harbor Blvd., Costa Mesa, CA 92626 \nphone:  (714) 327-3513, fax:  (714) 327-5076, email:  cfay@filenet.com\n\n\n\n", "id": "lists-006-4711155"}, {"subject": "Re: DeltaV Draf", "content": "Not all resources are in a workspace. Simple as that.\n\nCheers,\n-g\n\nOn Tue, Jan 16, 2001 at 10:16:04PM -0800, Mark A. Hale wrote:\n> I think that we have now strayed off from the original intention based on\n> the teleconference last Friday.  At that time, it was agreed that the\n> DAV:workspace property is a property of all resources that are in the\n> workspace.  A working resource is one such resource which can be in the\n> workspace.\n> \n> When reading section 6.1, it says that a \"working resource has all of the\n> properties of a checked-out version-controlled resource\".  I requested on\n> the teleconference for the simple addition to 6.1 specifically stating that\n> one of the properties can be DAV:workspace for clarity and it was agreed.\n> There are places throughout the draft in which clarifications are added and\n> I feel that this aids in clarity and fully conforms to the specification as\n> written.\n> \n> Thanks,\n> \n> Mark\n> \n> \n> \n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Geoffrey M.\n> > Clemm\n> > Sent: Tuesday, January 16, 2001 8:28 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: Re: DeltaV Draft\n> >\n> >\n> >\n> >    From: \"Mark A. Hale\" <mark.hale@interwoven.com>\n> >\n> >    > I agree that a server that supports both workspaces and working\n> >    > resources might reasonably make such an association, and a server is\n> >    > certainly allowed to set a DAV:workspace property on a working\n> >    > resource (since any resource can have a DAV:workspace property) but\n> >    > what would a client do with this property value (i.e. what\n> >    > interoperability would we get by highlighting this fact)?\n> >    > We've already got a complex spec, so I try to leave out anything\n> >    > that doesn't directly contribute to interoperability.\n> >\n> >    Per our telecon, it was non-obvious to an implementer that the\n> > properties\n> >    are inherited.\n> >\n> > As Tim pointed out, its probably best to avoid the term \"inherited\"\n> > here.  The protocol states what kind of resources have what kinds of\n> > properties.  It states that any resource can have a DAV:workspace\n> > property; therefore, since a working resource is a resource, a working\n> > resource can have a DAV:workspace property.\n> >\n> >    I feel that adding a sentence or two like the following:\n> >\n> >        A server may set a DAV:workspace property when a new\n> >        working resource is created.  The property is asserted\n> >        by servers that utilize server-managed workspaces for\n> >        resource management.\n> >\n> >    is clear as to what the property is and when it is set in the\n> >    context of the working resources creation.\n> >\n> > I don't see that this statement by itself would lead to any\n> > significant interoperability.  Although it hints at what this property\n> > could be used for, it doesn't provide anything that an interoperable\n> > client can count on for it to mean.\n> >\n> >    I feel that a client\n> >    usage discussion would actually make the Draft Specification harder\n> >    to read.\n> >\n> > I agree.  My request for a client usage scenario was for us to\n> > understand what you wanted it for, not for insertion in the protocol.\n> >\n> >    A client can use this property-value to its advantage for a number of\n> >    reasons: it can initiate a single cleanup instruction to the server by\n> >    asking for a workspace deletion, the client can decide to\n> > generate the next\n> >    working resource in the same workspace in order to due\n> > synchronization in\n> >    off-line editing, and others.\n> >\n> > An interoperable client can't do any of these things unless the\n> > protocol requires specific behavior that produces this result.  For\n> > example, we could add a postcondition to the DELETE method that says\n> > \"whenever a workspace is deleted, all working resource that identify\n> > that workspace in their DAV:workspace property MUST be deleted\".\n> >\n> > Perhaps that is the change you'd like to see in the protocol?\n> > Assuming it is, do people agree that this is something that should be\n> > in the protocol?  I'm a bit concerned about adding storage cleanup\n> > semantics into the protocol, since this tends to be a very\n> > implementation dependent area.\n> >\n> > Cheers,\n> > Geoff\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4721867"}, {"subject": "Re: DeltaV Draf", "content": "Let me clarify: workspaces are optional, and placing resources into a\nworkspace are optional. Therefore, a given resource on the server might not\nbe in a workspace.\n\nIf a resource is in a workspace, then yes: DAV:workspace will be set.\n\nHmm. Reading your message more closely... it seems that you're asking that\nwe call out that DAV:workspace *might* exist on different resources. That\nwould be a bit strange, as we don't do that with most other properties. Why\ntreat this one differently?\n\nCheers,\n-g\n\nOn Wed, Jan 17, 2001 at 05:54:54PM -0800, Greg Stein wrote:\n> Not all resources are in a workspace. Simple as that.\n> \n> Cheers,\n> -g\n> \n> On Tue, Jan 16, 2001 at 10:16:04PM -0800, Mark A. Hale wrote:\n> > I think that we have now strayed off from the original intention based on\n> > the teleconference last Friday.  At that time, it was agreed that the\n> > DAV:workspace property is a property of all resources that are in the\n> > workspace.  A working resource is one such resource which can be in the\n> > workspace.\n> > \n> > When reading section 6.1, it says that a \"working resource has all of the\n> > properties of a checked-out version-controlled resource\".  I requested on\n> > the teleconference for the simple addition to 6.1 specifically stating that\n> > one of the properties can be DAV:workspace for clarity and it was agreed.\n> > There are places throughout the draft in which clarifications are added and\n> > I feel that this aids in clarity and fully conforms to the specification as\n> > written.\n> > \n> > Thanks,\n> > \n> > Mark\n> > \n> > \n> > \n> > \n> > > -----Original Message-----\n> > > From: ietf-dav-versioning-request@w3.org\n> > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Geoffrey M.\n> > > Clemm\n> > > Sent: Tuesday, January 16, 2001 8:28 AM\n> > > To: ietf-dav-versioning@w3.org\n> > > Subject: Re: DeltaV Draft\n> > >\n> > >\n> > >\n> > >    From: \"Mark A. Hale\" <mark.hale@interwoven.com>\n> > >\n> > >    > I agree that a server that supports both workspaces and working\n> > >    > resources might reasonably make such an association, and a server is\n> > >    > certainly allowed to set a DAV:workspace property on a working\n> > >    > resource (since any resource can have a DAV:workspace property) but\n> > >    > what would a client do with this property value (i.e. what\n> > >    > interoperability would we get by highlighting this fact)?\n> > >    > We've already got a complex spec, so I try to leave out anything\n> > >    > that doesn't directly contribute to interoperability.\n> > >\n> > >    Per our telecon, it was non-obvious to an implementer that the\n> > > properties\n> > >    are inherited.\n> > >\n> > > As Tim pointed out, its probably best to avoid the term \"inherited\"\n> > > here.  The protocol states what kind of resources have what kinds of\n> > > properties.  It states that any resource can have a DAV:workspace\n> > > property; therefore, since a working resource is a resource, a working\n> > > resource can have a DAV:workspace property.\n> > >\n> > >    I feel that adding a sentence or two like the following:\n> > >\n> > >        A server may set a DAV:workspace property when a new\n> > >        working resource is created.  The property is asserted\n> > >        by servers that utilize server-managed workspaces for\n> > >        resource management.\n> > >\n> > >    is clear as to what the property is and when it is set in the\n> > >    context of the working resources creation.\n> > >\n> > > I don't see that this statement by itself would lead to any\n> > > significant interoperability.  Although it hints at what this property\n> > > could be used for, it doesn't provide anything that an interoperable\n> > > client can count on for it to mean.\n> > >\n> > >    I feel that a client\n> > >    usage discussion would actually make the Draft Specification harder\n> > >    to read.\n> > >\n> > > I agree.  My request for a client usage scenario was for us to\n> > > understand what you wanted it for, not for insertion in the protocol.\n> > >\n> > >    A client can use this property-value to its advantage for a number of\n> > >    reasons: it can initiate a single cleanup instruction to the server by\n> > >    asking for a workspace deletion, the client can decide to\n> > > generate the next\n> > >    working resource in the same workspace in order to due\n> > > synchronization in\n> > >    off-line editing, and others.\n> > >\n> > > An interoperable client can't do any of these things unless the\n> > > protocol requires specific behavior that produces this result.  For\n> > > example, we could add a postcondition to the DELETE method that says\n> > > \"whenever a workspace is deleted, all working resource that identify\n> > > that workspace in their DAV:workspace property MUST be deleted\".\n> > >\n> > > Perhaps that is the change you'd like to see in the protocol?\n> > > Assuming it is, do people agree that this is something that should be\n> > > in the protocol?  I'm a bit concerned about adding storage cleanup\n> > > semantics into the protocol, since this tends to be a very\n> > > implementation dependent area.\n> > >\n> > > Cheers,\n> > > Geoff\n> \n> -- \n> Greg Stein, http://www.lyra.org/\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4734643"}, {"subject": "Re: Editorial suggestions for DeltaV 11.", "content": "> Some minor editorial suggestions for DeltaV 11.2:\n\nI'm not an editor, but that didn't stop me making some comments, below.\np.s.? where there is no comment that means I agree.\n\n> Section 1, \"Introduction\", paragraph 1, 5th sentence:\n> \"interesting\" -> \"interested\"\n>\n> Section 1.3, \"Terms\", \"Predecessor, Successor, Ancestor, Descendant\":\n> \"When a version is related to another version by one or more predecessor\n> relations, it is called an 'ancestor' of that version.\"\n> Consider clarifying which version in the sentence is the predecessor:\n> \"When a version precedes another version by one or more predecessor\n> relations, it is called an 'ancestor' of that version.\"\n>\n> Section 1.3, \"Terms\", \"Version History Resource\" and \"Fork, Merge\":\n> Why aren't these defined in section 1.3.1, Optional Versioning Terms?\n> Version History and Merge are both optional.? By my reading, there is no\n> requirement to support fork/merge semantics or version history resources\nin\n> Core Versioning.? If \"Fork, Merge\" definitions are moved to section\n1.3.1,\n> the diagram following the definition should move with them.? While you're\n> at\n> it, why not label the first set of terms \"Core Versioning Terms\" and make\n> them a peer section to \"Optional Versioning Terms\"?\n\nThe terms are used in core versioning, even though the resources are not\nrequired to exist.? For example, see the definition for VERSION-CONTROL in\nsection 2.4.? It refers to a new history resource being created although\nther Version-History Option is not presented until section 5.\n\n> Section 2.1.1, \"Creating a Version-Controlled Resource\", paragraph 1,\n> sentence 1:\n> Add \"versionable\" as follows to make clear that VERSION-CONTROL can be\n> applied only to versionable resources, not just any old resource:? \"In\n> order\n> to track the history of the content and dead properties of a versionable\n> resource, an author can put the resource under version control with a\n> VERSION-CONTROL request.\"\n>\n> Section 2.2.1, \"DAV:checked-in? (protected)\", sentence 2:\n> \"This URL can be used to retrieve this particular state of the\n> version-controlled resource after the version-controlled resource itself\n> has\n> been modified.\"\n> This sentence should be moved to Section 2.2.2, \"DAV:checked-out ...\",\n> because it's true there but incorrect here.\n>\n> Section 2.4, \"VERSION-CONTROL\", subsection \"Postconditions\", paragraph 1,\n> sentence 5:\n> \"chose\" -> \"choose\".\n>\n> Section 2.8, \"Additional PROPPATCH Semantics\", subsection \"Additional\n> Preconditions\", last precondition:\n> \"(DAV:cannot-modify-unsupported-property): An attempt to modify a\nproperty\n> defined by this document (either core or optional) whose semantics are\nnot\n> enforced by the server MUST fail.? This helps ensure that a client will\nbe\n> notified when it is trying to use a property whose semantics are not\n> supported by the server.\"\n> It seems from RFC 2518 that all dead properties fall under the\ndescription\n> of \"[a property] whose semantics are not enforced by the server\", but\n> surely\n> we don't want to disallow modifying dead properties.\n\nThey key point seems to be \"defined by this document\" -- the document does\nnot define any dead properties.\n\n> This should be\n> reworded to say:? \"DAV:cannot-modify-unsupported-property): An attempt to\n> modify an optional property defined by this document but not supported by\n> the server MUST fail.? This helps ensure that a client will be notified\n> when\n> it is trying to use a property that is not supported by the server.\"\n\nThis is more succinct.\n\nTim\n\n\n\n", "id": "lists-006-4748548"}, {"subject": "Re: DeltaV doesn't support a true client workspac", "content": "   From: \"Fay, Chuck\" <CFay@filenet.com>\n\n   There seems to be an underlying assumption in DeltaV, even for parts of core\n   versioning, that the server provides persistent storage of work-in-progress\n   on resources between checkout and checkin.\n\nI don't believe that is the case.  As you point out below, core\nversioning allows a server to only support the DAV:when-unlocked\nmechanism, which creates a new version on every update.\n\n   This is explicit in the optional\n   VCR CHECKOUT-CHECKIN semantics, and in the Working Resource option.\n\nMany of the options are not supported by certain classes of servers,\nbut that doesn't mean those classes of servers violate underlying\nassumptions of DeltaV.\n\n   It is\n   also implicit in core versioning when DAV:auto-version is set to\n   DAV:when-locked:  between the LOCK and UNLOCK, the server is expected to\n   provide persistent working storage for intermediate updates via PUTs and\n   PROPPATCHes from the client.\n\nYes, but the protocol explicitly states that a client should be aware\nthat a server may not allow change to the DAV:auto-version values, which\nmeans that a server that only supports DAV:when-unlocked is fully\ncompliant, and should interoperate with core versioning clients.\n\n   Unfortunately, this assumption is not valid for some existing versioning\n   systems, including a FileNET content management product and one of the\n   software configuration management products we use internally.  These two\n   versioning systems employ the concept of what I would call a *real* client\n   workspace, where *all* intermediate work-in-progress is stored on the client\n   side between checkout and checkin.  A user may choose to store\n   work-in-progress on a file server for backup or access from other clients,\n   but in any case the versioning server software does not provide any\n   persistent work-in-progress storage.\n\nThat's OK.  Although the protocol defines how a client interoperates\nwith a server that provides storage for intermediate work-in-progress,\na variety of the options (e.g. baselines and activities) should work\njust fine for a server that does not support intermediate work-in-progress.\n\n   So DeltaV is not a great fit for these two existing systems.  (I won't argue\n   that their reliance on a client workspace is necessarily a better design\n   than DeltaV's server workspace.  Rather, I raise it as existing practice\n   that needs to be considered by DeltaV.)\n\nI agree.\n\n   One alternative is to build a core versioning layer for these two systems\n   which would disallow the DAV:when-locked flavor of DAV:auto-version.\n\nThat is already legal in the current core versioning definition.\n\n   But\n   this would result in a new version for every PUT or PROPPATCH of dead\n   properties done by the client.  Arbitrary DeltaV clients are not likely to\n   limit themselves to one PUT between a LOCK and UNLOCK, so there would likely\n   be a proliferation of unwanted intermediate versions.  Scratch that\n   alternative.\n\nWell, there is not much you can do about making a client that requires\nintermediate storage on the server (perhaps because it has none of its\nown) to interoperate with a server that does not provide intermediate\nstorage.  That's the same for many of the other options (i.e. they are\nserver options because clients want the servers to do that work).\n\n   Another alternative would be to build a work-in-progress persistence layer\n   on top of these existing systems to accommodate DeltaV, but that is a costly\n   and awkward choice.\n\nThat's your only choice if you want your server to interoperate with\nclients that assume functionality that your server does not currently\nprovide.  \n\n   A third alternative would be to add a flavor of CHECKOUT-CHECKIN to core\n   versioning in DeltaV that allows all changes to accompany the CHECKIN\n   method.  This is the model used by the existing systems I mentioned.\n\nThe only way that would help you is if we *required* this to be the\nonly way a client could interoperate with a versioning server.  That\nwould make the versioning protocol useless for a client that does\nnot have local persistent storage, so I find it very unlikely that\nmany would find this acceptable.\n\n   Are there other alternative solutions to this problem?\n\nIf the problem is \"how to make a client interoperate with a server\nthat does not provide the functionality required by that client\",\nthen I don't think there are *any* solutions to this problem.\n\n   Do others on the mailing list know of existing versioning systems with this\n   same problem with DeltaV?  Or is this problem limited to just these two\n   systems?\n\nAny server that only provides a subset of the defined functionality\nwill only support the subset of clients that only use that subset.\nThis is a problem for any server, but it is a logically unavoidable one.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4759693"}, {"subject": "Re: Editorial suggestions for DeltaV 11.", "content": "Thanks for finding these errors, Chuck!\n\n   From: \"Fay, Chuck\" <CFay@filenet.com>\n\n   Some minor editorial suggestions for DeltaV 11.2:\n\n   Section 1, \"Introduction\", paragraph 1, 5th sentence:\n   \"interesting\" -> \"interested\"\n\nDone. (oops :-).\n\n   Section 1.3, \"Terms\", \"Predecessor, Successor, Ancestor, Descendant\":\n   \"When a version is related to another version by one or more predecessor\n   relations, it is called an 'ancestor' of that version.\"\n   Consider clarifying which version in the sentence is the predecessor:\n   \"When a version precedes another version by one or more predecessor\n   relations, it is called an 'ancestor' of that version.\"\n\nI agree this needs improvement.  How about \"is connected to another version\nby traversing one or more predecessor relations\"?\n\n   Section 1.3, \"Terms\", \"Version History Resource\" and \"Fork, Merge\":\n   Why aren't these defined in section 1.3.1, Optional Versioning Terms?\n   Version History and Merge are both optional.  By my reading, there is no\n   requirement to support fork/merge semantics or version history resources in\n   Core Versioning.  If \"Fork, Merge\" definitions are moved to section 1.3.1,\n   the diagram following the definition should move with them.\n\nAs Tim pointed out, these concepts are present in core versioning.  In\nparticular, version history is explicitly mentioned, and the\nDAV:successor-set and DAV:predecessor-set can have multiple values in\ncore versioning.  So although a client may not create forks or merges,\nit needs to be prepared to deal with them in things like a version\ntree display.\n\n   While you're at\n   it, why not label the first set of terms \"Core Versioning Terms\" and make\n   them a peer section to \"Optional Versioning Terms\"?\n\nI believe \"Core Versioning Terms\" and \"Optional Versioning Terms\" are\nmore closely related to each other than they are to the other subsections\nof the introduction, and therefore it is better to group them together.\n\n   Section 2.1.1, \"Creating a Version-Controlled Resource\", paragraph 1,\n   sentence 1:\n   Add \"versionable\" as follows to make clear that VERSION-CONTROL can be\n   applied only to versionable resources, not just any old resource:  \"In order\n   to track the history of the content and dead properties of a versionable\n   resource, an author can put the resource under version control with a\n   VERSION-CONTROL request.\"\n\nDone.\n\n   Section 2.2.1, \"DAV:checked-in  (protected)\", sentence 2:\n   \"This URL can be used to retrieve this particular state of the\n   version-controlled resource after the version-controlled resource itself has\n   been modified.\"\n   This sentence should be moved to Section 2.2.2, \"DAV:checked-out ...\",\n   because it's true there but incorrect here.\n\n??  The DAV:checked-in property means that the vcr is checked in (thus\nthe name :-), and the DAV:checked-in version captures the current \nstate of the vcr.  This is not true for a checked out vcr.\n\n   Section 2.4, \"VERSION-CONTROL\", subsection \"Postconditions\", paragraph 1,\n   sentence 5:\n   \"chose\" -> \"choose\".\n\nOoops!  Several of those.  Thanks!\n\n   Section 2.8, \"Additional PROPPATCH Semantics\", subsection \"Additional\n   Preconditions\", last precondition:\n   \"(DAV:cannot-modify-unsupported-property): An attempt to modify a property\n   defined by this document (either core or optional) whose semantics are not\n   enforced by the server MUST fail.  This helps ensure that a client will be\n   notified when it is trying to use a property whose semantics are not\n   supported by the server.\"\n   It seems from RFC 2518 that all dead properties fall under the description\n   of \"[a property] whose semantics are not enforced by the server\", but surely\n   we don't want to disallow modifying dead properties.  This should be\n   reworded to say:  \"DAV:cannot-modify-unsupported-property): An attempt to\n   modify an optional property defined by this document but not supported by\n   the server MUST fail.  This helps ensure that a client will be notified when\n   it is trying to use a property that is not supported by the server.\"\n\nAs Tim mentioned, the document defines no dead properties, so this\nprecondition has no effect on any dead property.  I prefer the phrase\n\"whose semantics are not enforced\" over \"supported by the server\"\nbecause this emphasizes that it's not enough just to let that property\nexist on the resource, but that the semantics have to be enforced.\n\nThanks again for the review!\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4771959"}, {"subject": "New XML Media Types RF", "content": "An update to RFC 2376, \"XML Media Types\", has been developed.  This document\ndefines and registers the MIME types to be used when transmitting XML across\nemail, HTTP, and other MIME-using protocols.  Significantly, this is now a\nstandards-track document, so it can now be cited as a normative reference.\n\n- Jim\n\n-----------------\nFrom: RFC Editor [mailto:rfc-ed@ISI.EDU]\nSent: Wednesday, 2001-01-17 15:36\nTo: IETF-Announce:; IETF-Announce:; @loki.ietf.org\nCc: rfc-ed@ISI.EDU\nSubject: RFC 3023 on XML Media Types\n\n\n\nA new Request for Comments is now available in online RFC libraries.\n\n\n        RFC 3023\n\n        Title:    XML Media Types\n        Author(s):  M. Murata, S. St.Laurent, D. Kohn\n        Status:     Standards Track\nDate:       January 2001\n        Mailbox:    mmurata@trl.ibm.co.jp, simonstl@simonstl.com,\n                    dan@dankohn.com\n        Pages:      39\n        Characters: 86011\n        Updates:    2376\n\n        I-D Tag:    draft-murata-xml-09.txt\n\n        URL:        ftp://ftp.isi.edu/in-notes/rfc3023.txt\n\n\nThis document standardizes five new media types -- text/xml,\napplication/xml, text/xml-external-parsed-entity,\napplication/xml-external-parsed-entity, and application/xml-dtd --\nfor use in exchanging network entities that are related to the\nExtensible Markup Language (XML).  This document also standardizes a\nconvention (using the suffix '+xml') for naming media types outside\nof these five types when those media types represent XML MIME\n(Multipurpose Internet Mail Extensions) entities.  XML MIME entities\nare currently exchanged via the HyperText Transfer Protocol on the\nWorld Wide Web, are an integral part of the WebDAV protocol for remote\nweb authoring, and are expected to have utility in many domains.\n\nMajor differences from RFC 2376 are (1) the addition of\ntext/xml-external-parsed-entity,\napplication/xml-external-parsed-entity, and application/xml-dtd, (2)\nthe '+xml' suffix convention (which also updates the RFC 2048\nregistration process), and (3) the discussion of \"utf-16le\" and\n\"utf-16be\".\n\nThis is now a Proposed Standard Protocol.\n\nThis document specifies an Internet standards track protocol for\nthe Internet community, and requests discussion and suggestions\nfor improvements.  Please refer to the current edition of the\n\"Internet Official Protocol Standards\" (STD 1) for the\nstandardization state and status of this protocol.  Distribution\nof this memo is unlimited.\n\n\n\n", "id": "lists-006-4783995"}, {"subject": "Re: 11.1 revie", "content": "Tim: What an outstandingly thorough and insightful review!!!\n\nThe only criticism I'd make is that it kept me up all night making the\nsuggested corrections, so please forgive any incoherence in this\nmessage (:-).\n\n--------------------------\n\n   From: \"Tim Ellison\" <tim@peir.com>\n\n   General beefs:\n\n       There are a number of places where the text says a property must contain\n   a version etc.  when it means that the property must \"contain the URL of\" a\n   version etc.\n\nFixed.  (investigated all uses of the term \"contain\")\n\n       In the 'OPTIONS Additional Marshalling' sections there are DTDs for the\n   request and the response without any indication of which is which.  Either\n   some text, or a subheading would be useful.\n\nDone.\n\n   Trivia:\n\n   (Nothing of any significance here, just some things that I thought would add\n   a little more clarity or questions that came to mind as I was reading\n   through the document.)\n\nAlthough these changes do not change any semantics (good thing, given how\nclose we are to last call), the improved clarity resulting from the changes\nyou suggest are of *great* significance.\n\n   Authors list\n       Check Jim Whitehead's affiliation\n\nOK, maybe this one is only of significance to Jim, but *most* of your\nchanges significantly improve the clarity (:-).\n\n   1.3 Terms\n       'This draft' --> 'This document'\n\nDone.\n\n       'A \"version history\" is a resource that contains all the versions ...'\n       consider '... that references all the versions ...'\n\nWe've defined the deletion of a version history to result in the\ndeletion of all versions in that version history, so I think \"contains\"\nis better here.\n\n       'Root Version Resource'\n       consider renaming the term 'Initial Version Resource' as the term root\n   is used elsewhere in the document, as in a root collection.\n\nThe trouble with \"initial\" is that it doesn't capture the key semantic\nof this version, namely, that you can reach every other version from\nit.  Since we only use \"root\" as an adjective (i.e. \"root version\",\n\"root collection\"), I don't think any ambiguity arises.\n\n   1.5.2 Property Value Locking\n       This section is too general as it can be read to mean that requests\n   whose side-effects are a modification of another resource's (computed)\n   property MUST include the lock token of any resources that they affect.  I\n   do not believe that this is the intent.\n\nFixed (computed properties are now explicitly excluded).\n\n   2.1.1 Creating a Version-Controlled Resource\n       para. 1 '... and creates a version in this version history...'\n       consider '...of this version history...'  (that 'contains' thing again)\n\nFixed.\n\n       para. 3 '... the resource that is now under version control.'\n       consider '... under version control (the 'version-controlled resource).'\n   for clarification and definition of the term.\n\nThis ended up making the sentence read clumsily to me, so I switched it\nback.\n\n   2.1.2 Modifying a Version-Controlled Resource\n       para. 2 '... with the DAV:auto-version property set'\n       I'm assuming that this has been rewritten based on the value of the\n   property.\n\nYes.\n\n   2.2.1 DAV:checked-in\n       'This URL can be used to retrieve this particular state of the\n   version-controlled resource after the version-controlled resource itself has\n   been modified.'\n       Given that this is a property of a checked-in version-controlled\n   resource, I fail to see how the version-controlled resource itself can be\n   modified.\n\n??  By MERGE, by UPDATE, and by CHECKIN/PUT, for example.  (The last\nchanges it into a checked-out resource, but it is still the same resource).\n\n   2.2.3 DAV:predecessor-set\n       Should state that the predecessors MUST be part of the same history.\n\nThis restriction is not made until checkin time.\n\n   2.2.4 DAV:precursor-set\n       Should state that the predecessors MUST NOT be part of the same history.\n\nI assume you meant \"precursor\"?  As above, not checked until checkin time.\n\n       Why are we required to make this distinction between predecessors and\n   precursors?\n\nBecause it makes a big difference to the client whether a version is\nin the same history as another version, in terms of what you can do\n(for example, you cannot UPDATE a vcr to be a precursor of the checked-in\nversion, but you can UPDATE it to a predecessor).\n\n   2.2.5 DAV:auto-version\n       Assuming that the vallue of the property is being defined rather than\n   saying it is set.\n\nYes.\n\n       As it reads now, having it set to 'false' would cause auto-versioning to\n   take place.\n       Maybe clarify what happens when a write lock expires, presumably the\n   checkin attempt occurs, and errors are never reported to any client.\n\nI believe this is clear in the revised text.\n\n   2.3.5 DAV:checkin-date\n       'This property contains the date on the server when the version was\n   checked in.'\n       Consider '..when the version was created.' since the initial version is\n   not checked in.\n\nGood point!  This is just the DAV:creationdate of the version!\nSo why do we want a copy of this property with another name?\nSo my response to this point is to nuke the DAV:checkin-date\nproperty (clients should just look at the DAV:creationdate if\nthey want this information).  Any objections?\n\n   2.5 DAV:version-tree REPORT\n       Marshalling:\n       '...with at most one a DAV:prop...'  -> '..with at most one DAV:prop...'\n\n       <!ELEMENT version-tree (href, prop, version-tree*)\n       Why DAV:prop and not DAV:propstat? -- what about requests for\n   non-existant properties?\n\nGood point.\n\n       Why are the DAV:version-tree elements nested?  It does not convey \"true\"\n   structure, especially since 'A server MAY omit the DAV:prop and the\n   successor DAV:version-tree elements ...'  I don't see that the nesting is\n   helpful.\n\nAnother good point (and one that Lisa made as well).\nCurrently, we've defined to format of the DAV:version-tree-report\nto match just one of the many ways a client might want to\ndisplay this information.  A flat list is simpler and\nmore consistent - we can just use a DAV:multistatus response\nso clients can even re-use their multi-status parsing code.\nAny objections?\n\n   2.5.1 Example - DAV:version-tree-report\n       >>REQUEST\n       Last line of the XML has a gratuitous xmlns definition.\n\nFixed.\n\n   2.7 Additional PUT semantics\n       (DAV:cannot-modify-version-controlled-content) &\n       (DAV:auto-checkout)\n       Assume that the DAV:auto-version consideration is being re-written.\n\nYes.\n\n       (DAV:auto-checkout-checkin)\n       Uses the obsolete term 'revision' twice.\n\nFixed.\n\n   2.8 Additional PROPPATCH semantics\n       (DAV:cannot-modify-computed-property)\n       Consider removing this precondition and stating (earlier) that all\n   computed properties are protected.\n\nDone.\n\n       (DAV:auto-checkout) &\n       (DAV:auto-checkout-checkin)\n       Assume that the DAV:auto-version consideration is being re-written.\n\nYes.\n\n       (DAV:auto-checkout-checkin)\n       Uses the obsolete term 'revision' twice.\n\nFixed.\n\n   2.9 Additional DELETE semantics\n       (DAV:cannot-delete-root-version)\n       Why?  Consider that the value of DAV:root-version becomes undefined on\n   its deletion.\n\nThen you lose a key semantic of a version tree, namely it is connected\nand every version is reachable from the DAV:root-version.  I don't see\nthat the benefit of allowing deletion of the root version outweighs the\nbenefit of have the version tree be connected.\n\n       (DAV:no-version-delete)\n       Reads more like a precondition.\n\nYup.  Moved to precondition section.\n\n       (DAV:update-predecessor-set)\n       I presume this is to prevent \"holes\" in the history, but this won't work\n   in the face of merges.\n\nWhy not?\n\n   2.10 Additional COPY semantics\n       (DAV:auto-checkout)\n       Assume that the DAV:auto-version consideration is being re-written.\n\nYes.\n\n       Uses the obsolete term 'revision' twice.\n\nFixed.\n\n   3.1 CHECKOUT Method\n       What happened to the text that stated a lock token is required if the\n   resource is write locked?\n\nThis is required by the \"locked property\" semantics in the introduction.\n\n   3.2 CHECKIN Method\n       (DAV:initialize-version-content-and-properties)\n       'The DAV:checkin-date of the new version MUST be set...'\n       Should state where possible to be consistent with definition of property\n   (2.3.5).\n\nNot needed now that this is just the DAV:creationdate property.\n\n   4.1 UPDATE Method\n       Marshalling:\n       '...with at most one DAV:version element.'\n       So what would zero elements mean?\n\nZero DAV:version elements probably means that your server supports the\nlabel option, and you have a DAV:label-name element instead.\n\n       (DAV:must-select-version)\n       Consider renaming (DAV:must-select-version-in-same-version-history)\n\nDone.\n\n   4.1.1 Example - UPDATE\n       'In this example, the content and dead properties of http://... are\n   copied to the vesion-controlled resource /foo.html, ...'\n       Consider 'In this example, the version-controlled resource /foo.html is\n   updated with the content and dead properties of http://...,'\n\nI try not to use the term being defined (i.e. UPDATE) in its definition.\n\n   5.1.2 DAV:root-version\n       Consider renaming to DAV:initial-version\n\nSee earlier comments.\n\n   5.2.1 DAV:version-history\n       Consider changing from (computed) to (protected).\n\nDone.\n\n       Consider defining in terms of DAV:version-set (5.1.1).\n\nDone.\n\n   5.4 Additional OPTIONS Semantics\n       Is it required that the history for the resource reporting the OPTIONS\n   MUST be in the version-history-collection-set?  Probably unnecessary since\n   clients can get to the history via properties.\n\nNo, there is no such requirement, and yes, it would be unncessary to make\nthis requirement.\n\n       Consider an example.\n\nI think I'll leave that for the scenarios document.\n\n   6.1 Working Resource Properties\n       'The server allocates a distinct new URL for each new working resource.'\n       What does this imply?  That the server cannot reuse working resource\n   URLs once the working resource has been checked in or deleted?\n\nGood catch!  A server is allowed to reuse working resource URL's, so\nthis sentence is misleading.  I'll change this to just say that it\nhas a \"server allocated\" URL.\n\n   6.3 Additional COPY semantics\n       '...a new non-version-controlled resource at the destination...'\n       consider adding 'with the same content and dead properties...' as\n   written elsewhere in the document.\n\nI try to avoid repeating the base semantics in the \"additional semantics\"\nsections, and this is defined by the base semantics of the COPY operation.\n\n   6.5 Additional CHECKOUT Semantics\n       Additional Marshalling:\n       'The response MAY include a Location header.'\n       How else would you find a working resource URL?  Consider MUST.\n\n   6.6 Additional CHECKIN Semantics\n       '...new version whose contents and dead properties are those of the\n   working resource.'\n       consider '...and dead properties are the same as those of the..'\n\nDone.\n\n       (DAV:delete-working-resource)\n       '...if DAV:keep-checked-out is not specified, the'\n       consider '...is not specified in the request body'\n       (there are a number of places where it is confusing as to whether the\n   element name given in text is a property name or an element in the request\n   body.\n\nDone (scanned all occurrences of \"specified\").\n\n   7 Server-Workspace Option\n       para. 4\n       Unless the URLs are relative, the workspace name will get in the way of\n   testing.\n\nThis is probably more detail than is needed in that section.\n\n   7.2 Additional Resource Properties\n       '...for an HTTP resource.' --> 'for a WebDAV resource.' (it has to\n   support properties<g>).\n\nFixed.\n\n   7.2.1 DAV:workspace\n       'The DAV:workspace property of any other type of resource MUST be the\n   same as the DAV:workspace of its parent collection.'\n       But only when the immediate parent collection defines a workspace.\n\nActually, this is defined to work transitively (i.e. all members,\nnot just immediate members) of that workspace that are not in\nanother workspace have the DAV:workspace property.\n\n   7.3 DAV:version-controlled-resource-url REPORT\n       Consider moving this section after 7.4 MKWORKSPACE Method.\n\nDone.\n\n       Marshalling:\n       'The DAV:version-controlled-resource REPORT response body MUST be a\n   DAV:version-controlled-resource XML element' --> 'The\n   DAV:version-controlled-resource-url ...be a\n   DAV:version-controlled-resource-url ...' (two corrections)\n\nFixed.\n\n       What happens if the version-controlled resouce was deleted?\n\nThe report will return a 4xx (it doesn't know it was deleted,\nit just knows it can't find one).\n\n   7.3.1 Example - DAV:version-controlled-resource-url  REPORT\n       >> RESPONSE\n   xmlns definition should be moved out a level.\n\nFixed.\n\n   7.4 MKWORKSPACE Method\n       (DAV:workspace-location-ok)\n       Consider renaming to (DAV:workspace-lcoation-not-OK)\n       [All other OK's have been caps. ;-]\n\nDone.  (Actually, went the other way, and made them all consistently\nlower case.)\n\n       (DAV:initialize-workspace-properties)\n       'The DAV:resource type...' --> 'The DAV:resourcetype...'\n\nFixed.\n\n       (DAV:initialize-workspace-properties)\n       'The DAV:workspace of the workspace MUST contain the request-URL.'\n       consider 'The DAV:workspace property of the workspace MUST identify the\n   new workspace.' i.e., let servers put some alias in there if they choose.\n\nDone.\n\n   7.5 Additional OPTIONS Semantics\n       para.2\n       'If a server support the ...' --> 'If a server supports the ...'\n\nFixed.\n\n       Additional Marshalling:\n       How would a server indicate that workspaces can be created anywhere? or\n   here and below?\n\n\"Here and Below\" is what it always means.  In particular, it could just\nreturn \"/\" to mean \"anywhere\".\n\n   7.7 Additional VERSION-CONTROL Semantics\n       (DAV:one-version-controlled-resource-per-history-per-workspace)\n       '...there MUST NOT already be a version-controlled member of that\n   workspace ... identifies a different version from the version history...'\n       consider ' ... identifies any version from the version history...'\n\nDone.\n\n       (DAV:version-controlled-resource)\n       '...whose content and dead properties are initialized by those of...'\n       consider '...are the same as those of...'\n\nI wanted to emphasize that the content and dead properties can later\nbe changed, and was afraid that \"same\" might be incorrectly read as\n\"always are the same\".\n\n   7.7.1 Example VERSION-CONTROL ...\n       '...the content and deap properties ... are those of the version...'\n       consider '...are the samae as those of...'\n\nFixed (used \"initialized to be\" here as well).\n\n   8.2 MERGE Method\n       Marshalling:\n       '<!ELEMENT merge ANY>'\n       '..., and at most one of any element that can occur in a DAV:checkout\n   element.'\n       This is too restrictive for future extensions, consider '..., and any\n   legal set of elements that can occur...'\n\nDone.\n\n       (DAV:update-merge-set)\n       '...and if DAV:checked-out version...' --> '..and if the DAV:checked-out\n   version...'\n\nFixed.\n\n       Final two postconditions of this method do not have any advanced status\n   element defined.\n\nFixed.\n\n   8.3 DAV:merge-preview REPORT\n       '<!ELEMENT merge-preview (update-preview-set, merge-preview-set,\n   ignore-preview-set)>'\n       Consider adding a '*' so that servers can generate these sets of XML on\n   the fly rather than having to compute the entire set of each before\n   responding.\n\nDone.\n\n   9 Label Option\n       para. 2\n       consider a forward reference to 9.3 Label Header\n\nDone.\n\n       para. 3\n       consider striking this paragraph -- although an interesting footnote it\n   doesn't add anything and may even imply permission to create duplicate\n   labels.\n\nFixed so that it is clear that duplicate labels can never be assigned.\n\n   9.2.1 Example - Setting a label\n       >>Request\n       Why the change of XML layout?\n\nWhat was it before?  What don't you like?\n\n   9.8 Additional CHECKOUT Semantics\n       postconditions\n       'If a version-controlled resource was checked out, ... the\n   version-controlled resource MUST remain checked in.'\n       Huh??\n\nThe \"...\" (that you omitted :-) stated that this was the creation of\na working resource.  This leaves the vcr checked-in.\n\n   9.9 Additional UPDATE Semantics\n       Presumably the response is Bad Request if a client attempts to specify a\n   contradictory Label and <DAV:apply-to-version/>.\n\nYes.  Added this precondition.\n\n   10 Baseline Option\n       The ascii art added nothing for me, consider striking it.\n\nDone.\n\n   10.1.1 DAV:baseline-controlled-collection\n       Consider (computed) -> (protected)\n\nWhy?  It is the inverse of the DAV:baseline-selector property.\n\n   10.2.2 DAV:subbaseline-set\n       '...a set of other baseline.'  --> '...a set of other baselines.'\n\nFixed.\n\n   10.4 BASELINE-CONTROL Method\n       Consider adding some descriptive text regarding creating a new baseline\n   selector on an existing baseline.\n\nDone.\n\n       (DAV:must-have-no-version-controlled-members)\n       Hmm, don't get why this one is required.\n\nThis would effectively \"wipe out\" the current members, which could\nlose information if the member was a checked out vcr.\n\n       postconditions:\n       Consider each occurrence of 'the collection' --> 'the target collection'\n\nCurrently using \"target\" for \"merge target\".  Since there is only \none collection, isn't the term \"the collection\" unambiguous?\n\n       (DAV:select-existing-baseline)\n       '...each version in the baseline, where the version-controlled\n   member...'\n       consider '...the baseline, and the ...'\n\nI tried this replacement and the sentence no longer made sense to me.\nCan you elaborate?\n\n   10.5 DAV:baseline-comparison REPORT\n       Marshalling:\n       Why are the results not reported as sets in keeping with the other\n   reports that respond with multiple URLs.\n\nActually, I \"ungrouped\" the other results, so this is now consistent.\n\n       Postconditions:\n       This section still seems to be referring to marshalling rather than\n   postconditions (of the repository) of the method as in other postcondition\n   sections.\n\nOf course!  I always felt those \"postconditions\" didn't feel right.\nThanks catching that.\n\n   10.7 Additional OPTIONS Semantics\n       Additional Preconditions:\n       '... the response body MUST contain a\n   DAV:baseline-controlled-collection-set element identifying which collections\n   are under baseline control.'\n       Eek, why would a client want this \"global\" information?  I think this is\n   too difficult to require all servers to supply, and will potentially make\n   the OPTIONS request very expensive (IMHO clients presently consider OPTIONS\n   to be cheap and send them frequently.)\n\nFixed (moved it back to be a property on a workspace, where it makes\nsense).\n\n   10.10 Additional CHECKIN Semantics\n       (DAV:create-baseline-version-set)\n       '...the DAV:baseline-version-set of the new baseline contains the ...'\n       consider '... of the new baseline version contains the ...'\n\nA baseline *is* a version, so \"baseline version\" is redundant.\n\n   10.11 Additional UPDATE Semantics\n       (DAV:set-baseline-controlled-collection-members) last bullet point\n       'An UPDATE request MUST have been applied to each version-controlled\n   member whose DAV:checkin-set does not identify a version in the\n   DAV:baseline-version-set of the baseline.'\n       consider '... whose DAV:checkin-set does not identify the same version\n   ...'\n\nDone.\n\n   10.12 Additional MERGE Semantics\n       'If the merge version is a baseline, the merge target is a baseline\n   selector for the baseline history of that baseline, where the\n   baseline-controlled collection of that baseline selector is a member of the\n   merge destination of the request.'\n       That deserves an award for the greatest use of the word 'baseline' in\n   one sentence.  Just read it very slowly.\n\nThanks for the award ... we strive for greatness (:-).\n\n   11 Activity option\n       para. 3\n       'Activity semantics then ensures that ...' --> 'Activity semantics then\n   ensure that ...'\n\nFixed.\n\n   11.2.1 DAV:activity-set\n       '...indicate to which logical changes this activity contributes, and on\n   what lines of descent this version appears.'\n       Surely '.. this version contributes...'\n\nYup!  Fixed.\n\n       what does 'and on what lines of descent this version appears.' mean?\n\nThis emphasizes that an activity both defines a change set and a line\nof descent from the root version.\n\n   11.3.1 DAV:unreserved\n       all instances of 'checked-out resource' should read 'checked-out\n   version-controlled resource'.\n\nThey could be working resources (where a working resource\nis a kind of checked-out resource).\n\n       para. 2\n       '... merge the latest version of that activity...'\n       consider '... of the version-controlled resource in that activity...'\n\nI agree this needs to be fixed, but that didn't quite do it for me.\nI rewrote this sentence ... hopefully it is OK now.\n\n   11.3.2 DAV:activity-set\n       '...checked-out resource...' --> '...checked-out version-controlled\n   resource...'\n\nIt could be a working resource.\n\n       Why not allow this property on checked-in and checked-out resources as a\n   convenience?  Just an idea.\n\nWe wouldn't want a lock on the checked-in resource to imply a lock\non the checked-in version resource, but we'd have to do something like\nthat to keep those properties consistent (standard argument for not\nexposing version properties on checked-in vcr's).\n\n   11.5 MKACTIVITY Method\n       (DAV:activity-lcoation-ok)\n       consider renaming to (DAV:activity-location-not-OK)\n\nBut the precondition is that the location is \"ok\", not that it\nis \"not ok\".\n\n       (DAV:create-activity) &\n       (DAV:initialize-activity-properties)\n       The corresponding postconditions for MKWORKSPACE do not distinguish\n   these as separate advances status codes, this should be consistent.\n\nFixed.\n\n   11.7 Additional OPTIONS Semantics\n       'An activity collection MAY be the root collection of a tree of\n   collections, all of which may contain activities.'\n       I propose that this is true of all OPTIONS reported locations (e.g.,\n   DAV:workspace-collection-set)\n\nI believe that this statement appears in all of the OPTIONS that\nreport locations.  Did I miss one?\n\n   11.10 Additional CHECKOUT Semantics\n       Additional Preconditions: (both)\n       'If there is a request activity set, ...'\n       consider clarifying with 'If the request body contains a\n   DAV:activity-set element,...'\n\nThe activity set can come from other places (e.g. a workspace)\nthan the activity-set element.\n\n   11.10.1\n       >>RESPONSE\n       Does not contain a cache conrol header as required per 3.1.\n\nFixed.\n\n   11.11 Additional CHECKIN Semantics\n       (DAV:linear-activity)\n       An example of a '...resource MUST be in the DAV:predecessor-set...'\n       (DAV:initialize-activity-version-set)\n       An example of a '...URL for the new version is added to the\n   DAV:activity-version-set...'\n       Should be consistent about describing resources added to properties or\n   URLs added to properties, otherwise the reader may think you are referring\n   to differerent things.\n\nFixed.\n\n   11.(13?)\n       Shouldn't there be Additional UNCHECKOUT Semantics to remove the\n   checked-out version-controlled resource URL from a\n   DAV:activity-checkout-set?  If so, this is likely true for more methods that\n   have additional CHECKIN/CHECKOUT semantics.\n\nThe DAV:activity-checkout-set is a computed property, and those are\ndefined to change whenever the data upon which they are based changes\n(see section 1.5.3).\n\n   12.4 Additional PUT Semantics\n       I know that I've been banging this drum for 12+ months. but I don't like\n   the idea of <version URL>/member URLs.\n\nOK, I'll just add a DAV:version-controlled-bindings-set property to\na version, and get rid of collection version members.  It appears that\nyou, Greg, and I are the only ones that care deeply about this so far,\nand Greg said he's not supporting slashing through collection versions,\nirrespective of what the protocol says.  So you're against it, Greg's\nagainst it, and I don't care.\n\nI'll fire up a separate thread for this, so let me know if anyone has\nany objections to this change.\n\n   12.9 Additional CHECKIN Semantics\n       (DAV:no-eclipsed-baseline-controlled-collection-members)\n       I don't understand the rationale for this precondition.\n\nI agree that it is overkill.  It's enough for a client to be\nable to detect when eclipses happen.  I've added a DAV:eclipse-set\nproperty for collections, so that this can be discovered by a client.\n\n   13.1.1 DAV:checkout-fork\n       '<!ELEMENT checkout-fork (ok | discouraged | forbidden )>'\n       Consider using ANY for future extensions.\n\nDone.\n\n   13.1.2 DAV:checkin-fork\n       '<!ELEMENT checkin-fork (ok | discouraged | forbidden )>'\n       Consider using ANY for future extensions.\n\nDone.\n\n   22 Authors' Addresses\n       Check Jim W's contact details.\n\nFixed.\n\n   23.1.1 DAV:comment\n       Why do we have an extra DAV:string element?\n       Why can you have any number of them (how would a client choose which one\n   to display)?\n\nThis was a change requested by Yaron to support internationalization.\nYou can have the comment string in multiple languages this way.\n\n   23.2 Response Bodies ...\n       para. 2\n       '...each method precondition defined in this document...' -->\n       '...each method precondition and postcondition defined in this\n   document...'\n\nFixed.\n\n       Should mention the purpose of the postcondition stati.\n\nDone.\n\n       '...the appropriate XML element MUST be returned in the response\n   body.' -->\n       '... in the response body unless otherwise negotiated by the request.'\n\nFixed.\n\n   23.3 Clarification of COPY ...\n       para. 4.\n       'Roy Fielding (an author..'\n       consider striking this paragraph (and moving it to the book of why)\n\nDone.\n\n   23.4 REPORT Method\n       Marshalling:\n   'The request body of a REPORT request...' -->\n   'The body of a REPORT request...'\n\nFixed.\n\n   Minutae:\n   (This stuff is way below trivia, but caught my eye when reading the\n   document.  I'm almost embarrassed to send these in.)\n\nTrivia???!  After 182 versions, I want this document *perfect* (or at\nleast, typo free :-).  Thanks for finding these!\n\n   Abstract\n       Add comma after 'URL namespace versioning'\n\nDone.\n\n   2.10 Additional COPY semantics\n       Extra space before the text '(DAV:initialize-precursor)'\n\nFixed.   Word *insists* on doing that whenever I delete or move\nthe conditions around ... if anyone knows how to tell it to *stop*,\nplease let me know (:-).  I periodically scan for all occurrences\nof \"<lf><sp>(\" to fix this.\n\n   5.8 Additional VERSION-CONTROL Semantics\n       (DAV:new-version-history)\n       double space in '..for that version history  that MUST NOT...'\n\nFixed.\n\nScanned for all occurrences of two spaces not following a \".\"\n(and found several more).  And just to show how anal one can be,\nI also made sure that every new sentence was preceded by *exactly*\ntwo spaces (not one, not three ... :-).\n\n   5.9 Additional CHECKIN Semantics\n       (DAV:preserve-version-history)\n       the document already uses (DAV:preserve-history) consider consistent\n   naming.\n\nDone.\n\n   8.2 MERGE method\n       para. 2\n       double space in '...the DAV:auto-merge-set property  of the...'\n\nFixed.\n\n   10.11 Additional UPDATE Semantics\n       (DAV:set-baseline-controlled-collection-members)\n       double space in '... identifies a baseline,  then the\n   version-controlled...'\n\nFixed.\n\n   11.11 Additional CHECKIN Semantics\n       (DAV:linear-activity)\n       double space in '...the DAV:predecessor-set of  the checked...'\n\nFixed.\n\n   23.5.1 Example - DAV:property-report\n       >>REQUEST\n   last three lines have extra space '</D:property >' -->\n   '</D:property>'\n\nFixed.\n\n--------------------------\n\nAgain, Tim, thanks for the outstanding review!\n\nHopefully I didn't break more than I fixed in the process of making\nthese changes (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4794277"}, {"subject": "Re: fetching from a baseline on a readonly serve", "content": "On Wed, Jan 17, 2001 at 10:21:12AM -0500, Geoffrey M. Clemm wrote:\n> \n>    From: \"Boris Bokowski/OTT/OTI\" <Boris_Bokowski@oti.com>\n>    Date: Wed, 17 Jan 2001 09:40:18 -0500\n> \n>    > Add a DAV:baseline-collection property on a baseline, which holds\n>    > a DAV:href containing a server-defined URL.  This URL identifies\n>    > a read-only collection that exposes that baseline as a collection.\n>    > \n>    > ... \n>    > \n>    > So, everyone else: any objections?  (For Greg at least, I presume, no :-).\n\nNo objections here, boss. How'd you guess? :-)\n\n>...\n> Also note that this property allows us to get rid of the\n> DAV:baseline-version-set property, since you can get the same\n> information by doing a PROPFIND for the DAV:checked-in values in this\n> collection.\n\nYes, I'd prefer to see that nuked. As you point out later, it scales poorly\nand it has little utility anyways.\n\n\nSomebody mentioned \"four implementations\" of DeltaV that were occurring.\nHave we seen feature sets from any of these other three? I'd be interested\nin what others are implementing. (to consider interop)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4829880"}, {"subject": "Re: fetching from a baseline on a readonly serve", "content": "On Tue, Jan 16, 2001 at 10:09:41PM -0500, Geoffrey M. Clemm wrote:\n> \n>    From: Greg Stein <gstein@lyra.org>\n> \n>    As a variant of my previous question, how would I fetch a particular file\n>    from a particular baseline on a readonly server? Specifically, if I'm not\n>    allowed to do a MKCOL, a BASELINE-CONTROL, or an UPDATE (on an existing\n>    baseline selector), then how can I use a baseline?\n> \n> OK, I was wavering before, but now you've pushed me over the edge.  I\n\nhehe :-)\n\n>...\n> This is a burden on the server, but probably not an unreasonable one.\n> In particular, I don't think that Greg's will be the only server that\n> will have very different performance/implementation tradeoffs for a\n> read-only view of a baseline (what Greg wants) and a writeable view of\n> a baseline (aka a workspace).\n\nSpeaking for Subversion, this isn't actually a burden as we'll synthesize\nthe collection as the user requests it. (i.e. we don't have to worry about\nconstructing and tossing a set of baseline resources)\n\n[ well, asking for an old baseline will be a bit painful since we use a\n  reverse-delta storage system, but I believe the intent is to cache those\n  as part of normal operation (meaning the new baseline collection won't\n  burden us any more than we already had) ]\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4838064"}, {"subject": "Re: proppatch label-name-set", "content": "On Tue, Jan 16, 2001 at 12:49:01PM -0500, Geoffrey M. Clemm wrote:\n> \n>    From: Greg Stein <gstein@lyra.org>\n>...\n>    Specifically, the problem that I'm considering is how to label a baseline\n>    before checking it in. I think that I'm also okay with labelling via a\n>    second request (after the checkin/merge), but that does lead to a race\n>    between the checkin and label that I'd like to avoid if possible.\n> \n> With the current protocol, you would have to do the labeling in a\n> second request (after the version was created).  What is the race\n> condition you were concerned about?\n\nThe race between the creation of the baseline and the application of the\nlabel.\n\nHmm... but that probably doesn't matter that much. The baseline just isn't\naccessible by a label for that period.\n\n> And how would it be addressed\n> by allowing a label on a working baseline?\n\nYou could have the label for the baseline available at the moment the\nbaseline is created.\n\n\nHmm... but this wouldn't even solve the basic problem that I'm after: SVN\nwill automatically label a baseline for later access. The question is how\ncan the SVN client compensate for servers that *don't* auto-label baselines\nin some way?\n\nI have figured out, though, how to discover the auto-labels -- I'll just ask\nfor the DAV:label-name-set in the MERGE operation. It will be non-empty for\nthe new baseline resource, and empty for all the new version resources.\n\n[ it would be nice to return nothing at all (e.g. no <DAV:label-name-set/>\n  empty element) for the version resources, but that seems illegal ]\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4846729"}, {"subject": "replacing DAV:checkin-date with DAV:creationdat", "content": "In Tim Ellison's review, he pointed out that DAV:checkin-date is\njust the DAV:creationdate of the version.  I see no reason for\nus to support two properties that always contain the same value,\nso I propose that the current standard property (DAV:creationdate)\nshould prevail, and DAV:checkin-date should be removed from\nthe versioning protocol.\n\nAny objections?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4855623"}, {"subject": "DAV:version-controlled-binding-se", "content": "In Tim Ellison's review, he made one last plea to get rid of\n\"members\" (i.e. the ability to \"slash through\") collection\nversions (remember that the members of a collection version\nare required to be version history resources).\n\nSince Greg has indicated that although he will be supporting\nversion-controlled collections, he will not be supporting\nslashing through a collection version, and since I don't\nreally care, I propose we accept Tim's suggestion.\n\nThen instead of making version histories be members of\ncollection versions, we would have a DAV:versioned-controlled-binding-set,\n\n<!ELEMENT version-controlled-binding-set (version-controlled-binding*)>\n<!ELEMENT version-controlled-binding (binding-name, version-history)>\n<!ELEMENT binding-name (#PCDATA)>\nPCDATA value: URL segment\n<!ELEMENT version-history (href)>\n\nGreg: This means that you would edit the\nDAV:version-controlled-binding-set of a working collection to move\nexisting version-controlled-members into and out of that working\ncollection.  I assume that is fine with you?  You would\nstill add non-version-controlled members to that working collection\nif you wanted to create new version controlled resources.\n\nGreg, Tim (and anyone else who cares about vcc's): Please carefully\nreview the version-controlled-collection option in the soon to be\nposted new draft.\n\nDoes anyone object?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4863106"}, {"subject": "reformatting the DAV:version-tree repor", "content": "One last change from Tim's review that I felt deserved a separate thread:\n\nTim asked:\n\n       Why are the DAV:version-tree elements nested?  It does not convey \"true\"\n   structure, especially since 'A server MAY omit the DAV:prop and the\n   successor DAV:version-tree elements ...'  I don't see that the nesting is\n   helpful.\n\nAnd I responded:\n\n   Another good point (and one that Lisa made as well).\n   Currently, we've defined the format of the DAV:version-tree-report\n   to match just one of the many ways a client might want to\n   display this information.  A flat list is simpler and\n   more consistent - we can just use a DAV:multistatus response\n   so clients can even re-use their multi-status parsing code.\n\nAny objections?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4871328"}, {"subject": "Re: replacing DAV:checkin-date with DAV:creationdat", "content": "On Thu, Jan 18, 2001 at 04:11:02PM -0500, Geoffrey M. Clemm wrote:\n> \n> In Tim Ellison's review, he pointed out that DAV:checkin-date is\n> just the DAV:creationdate of the version.  I see no reason for\n> us to support two properties that always contain the same value,\n> so I propose that the current standard property (DAV:creationdate)\n> should prevail, and DAV:checkin-date should be removed from\n> the versioning protocol.\n> \n> Any objections?\n\nNo, sir.\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4879012"}, {"subject": "Re: DAV:version-controlled-binding-se", "content": "On Thu, Jan 18, 2001 at 04:22:47PM -0500, Geoffrey M. Clemm wrote:\n>...\n> Greg: This means that you would edit the\n> DAV:version-controlled-binding-set of a working collection to move\n> existing version-controlled-members into and out of that working\n> collection.  I assume that is fine with you?  You would\n> still add non-version-controlled members to that working collection\n> if you wanted to create new version controlled resources.\n>...\n\nHmm... I'm not too sure on this one. I don't do anything with collection\nversions themselves, but only with working collections. The operations there\nare:\n\n*) DELETE /working/collection/member\n*) MKCOL /working/collection/newcoll\n*) PUT /working/collection/newmember\n*) COPY /some/thing -> /working/collection/newmember\n\nThe COPY does the whole DAV:precursor-set thing.\n\nI never actually \"move\" something into a working collection, thus editing\nthe binding doesn't apply to me.\n\nBut! I get a sneaky feeling that the DELETE might not work properly. If the\nworking collection had no members, then I'm guessing that I'd get a 404 on\nthe delete. I'd be rather upset if I needed to PROPFIND/PROPPATCH to do a\nDELETE operation. (so consider that an objection if I'm correct in my\nthinking)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4886595"}, {"subject": "Re: DAV:version-controlled-binding-se", "content": "OK, Greg makes a good point that it is more convenient to do a DELETE\nthan to have to lock some property value and update it.\n\nSo I'll switch a working collection back to have history resources\nas members (which is probably better anyway, since it makes a\nworking collection act much more like a checked-out version-controlled\ncollection), but keep the DAV:version-controlled-binding-set for\nthe collection version.  I'll try to get this updated draft posted\nto the web site sometime late tonight.\n\nCheers,\nGeoff\n\n\n   From: Greg Stein <gstein@lyra.org>\n\n   On Thu, Jan 18, 2001 at 04:22:47PM -0500, Geoffrey M. Clemm wrote:\n   >...\n   > Greg: This means that you would edit the\n   > DAV:version-controlled-binding-set of a working collection to move\n   > existing version-controlled-members into and out of that working\n   > collection.  I assume that is fine with you?  You would\n   > still add non-version-controlled members to that working collection\n   > if you wanted to create new version controlled resources.\n   >...\n\n   Hmm... I'm not too sure on this one. I don't do anything with collection\n   versions themselves, but only with working collections. The operations there\n   are:\n\n   *) DELETE /working/collection/member\n   *) MKCOL /working/collection/newcoll\n   *) PUT /working/collection/newmember\n   *) COPY /some/thing -> /working/collection/newmember\n\n   The COPY does the whole DAV:precursor-set thing.\n\n   I never actually \"move\" something into a working collection, thus editing\n   the binding doesn't apply to me.\n\n   But! I get a sneaky feeling that the DELETE might not work properly. If the\n   working collection had no members, then I'm guessing that I'd get a 404 on\n   the delete. I'd be rather upset if I needed to PROPFIND/PROPPATCH to do a\n   DELETE operation. (so consider that an objection if I'm correct in my\n   thinking)\n\n   Cheers,\n   -g\n\n   -- \n   Greg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4895022"}, {"subject": "Re: proppatch label-name-set", "content": "   From: Greg Stein <gstein@lyra.org>\n\n   SVN will automatically label a baseline for later access. The\n   question is how can the SVN client compensate for servers that\n   *don't* auto-label baselines in some way?\n\nIf the SVN client depends on \"auto-label\"ing of any kind, then it\nis likely to have trouble with any non-SVN client, since even if\nit did auto-label, it is extremely unlikely that it will use the\nsame labeling scheme as SVN uses (increasing integers, as I recall).\n\nCan't you make the SVN client just use the baseline-URL, instead of\ndepending on a linear sequence of integers?  (Your answer to this\nmight point a way towards an interoperable approach).\n\n   I have figured out, though, how to discover the auto-labels -- I'll just ask\n   for the DAV:label-name-set in the MERGE operation. It will be non-empty for\n   the new baseline resource, and empty for all the new version resources.\n\nThat is true.  If you get back no auto-labels, will the SVN client\nstill be able to work?\n\n   [ it would be nice to return nothing at all (e.g. no <DAV:label-name-set/>\n     empty element) for the version resources, but that seems illegal ]\n\nI imagine most robust clients will treat nothing at all as equivalent\nto an empty property element, so I'd think either way would be OK.\n(Or is this distinction important to some clients?)\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4903840"}, {"subject": "RE: DeltaV Draf", "content": "I agree with your synopsis that the property may or may not be set for a\nworking resource depending whether or not the working resource was\ninstantiated in a workspace.  The complexity of the specification in its\ncurrent form makes it difficult to understand that this property will be set\nfor working resources created in a workspace.  I simply ask for the\nproperties to be better described.  In particular, I will be looking to see\nthat the DAV:workspace property is described.\n\nThanks,\n\nMark\n\n\n\n\n> -----Original Message-----\n> From: Greg Stein [mailto:gstein@lyra.org]\n> Sent: Wednesday, January 17, 2001 6:10 PM\n> To: Mark A. Hale; ietf-dav-versioning@w3.org\n> Subject: Re: DeltaV Draft\n>\n>\n> Let me clarify: workspaces are optional, and placing resources into a\n> workspace are optional. Therefore, a given resource on the server\n> might not\n> be in a workspace.\n>\n> If a resource is in a workspace, then yes: DAV:workspace will be set.\n>\n> Hmm. Reading your message more closely... it seems that you're asking that\n> we call out that DAV:workspace *might* exist on different resources. That\n> would be a bit strange, as we don't do that with most other\n> properties. Why\n> treat this one differently?\n>\n> Cheers,\n> -g\n>\n> On Wed, Jan 17, 2001 at 05:54:54PM -0800, Greg Stein wrote:\n> > Not all resources are in a workspace. Simple as that.\n> >\n> > Cheers,\n> > -g\n> >\n> > On Tue, Jan 16, 2001 at 10:16:04PM -0800, Mark A. Hale wrote:\n> > > I think that we have now strayed off from the original\n> intention based on\n> > > the teleconference last Friday.  At that time, it was agreed that the\n> > > DAV:workspace property is a property of all resources that are in the\n> > > workspace.  A working resource is one such resource which can\n> be in the\n> > > workspace.\n> > >\n> > > When reading section 6.1, it says that a \"working resource\n> has all of the\n> > > properties of a checked-out version-controlled resource\".  I\n> requested on\n> > > the teleconference for the simple addition to 6.1\n> specifically stating that\n> > > one of the properties can be DAV:workspace for clarity and it\n> was agreed.\n> > > There are places throughout the draft in which clarifications\n> are added and\n> > > I feel that this aids in clarity and fully conforms to the\n> specification as\n> > > written.\n> > >\n> > > Thanks,\n> > >\n> > > Mark\n> > >\n> > >\n> > >\n> > >\n> > > > -----Original Message-----\n> > > > From: ietf-dav-versioning-request@w3.org\n> > > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Geoffrey M.\n> > > > Clemm\n> > > > Sent: Tuesday, January 16, 2001 8:28 AM\n> > > > To: ietf-dav-versioning@w3.org\n> > > > Subject: Re: DeltaV Draft\n> > > >\n> > > >\n> > > >\n> > > >    From: \"Mark A. Hale\" <mark.hale@interwoven.com>\n> > > >\n> > > >    > I agree that a server that supports both workspaces and working\n> > > >    > resources might reasonably make such an association,\n> and a server is\n> > > >    > certainly allowed to set a DAV:workspace property on a working\n> > > >    > resource (since any resource can have a DAV:workspace\n> property) but\n> > > >    > what would a client do with this property value (i.e. what\n> > > >    > interoperability would we get by highlighting this fact)?\n> > > >    > We've already got a complex spec, so I try to leave\n> out anything\n> > > >    > that doesn't directly contribute to interoperability.\n> > > >\n> > > >    Per our telecon, it was non-obvious to an implementer that the\n> > > > properties\n> > > >    are inherited.\n> > > >\n> > > > As Tim pointed out, its probably best to avoid the term \"inherited\"\n> > > > here.  The protocol states what kind of resources have what kinds of\n> > > > properties.  It states that any resource can have a DAV:workspace\n> > > > property; therefore, since a working resource is a\n> resource, a working\n> > > > resource can have a DAV:workspace property.\n> > > >\n> > > >    I feel that adding a sentence or two like the following:\n> > > >\n> > > >        A server may set a DAV:workspace property when a new\n> > > >        working resource is created.  The property is asserted\n> > > >        by servers that utilize server-managed workspaces for\n> > > >        resource management.\n> > > >\n> > > >    is clear as to what the property is and when it is set in the\n> > > >    context of the working resources creation.\n> > > >\n> > > > I don't see that this statement by itself would lead to any\n> > > > significant interoperability.  Although it hints at what\n> this property\n> > > > could be used for, it doesn't provide anything that an interoperable\n> > > > client can count on for it to mean.\n> > > >\n> > > >    I feel that a client\n> > > >    usage discussion would actually make the Draft\n> Specification harder\n> > > >    to read.\n> > > >\n> > > > I agree.  My request for a client usage scenario was for us to\n> > > > understand what you wanted it for, not for insertion in the\n> protocol.\n> > > >\n> > > >    A client can use this property-value to its advantage\n> for a number of\n> > > >    reasons: it can initiate a single cleanup instruction to\n> the server by\n> > > >    asking for a workspace deletion, the client can decide to\n> > > > generate the next\n> > > >    working resource in the same workspace in order to due\n> > > > synchronization in\n> > > >    off-line editing, and others.\n> > > >\n> > > > An interoperable client can't do any of these things unless the\n> > > > protocol requires specific behavior that produces this result.  For\n> > > > example, we could add a postcondition to the DELETE method that says\n> > > > \"whenever a workspace is deleted, all working resource that identify\n> > > > that workspace in their DAV:workspace property MUST be deleted\".\n> > > >\n> > > > Perhaps that is the change you'd like to see in the protocol?\n> > > > Assuming it is, do people agree that this is something that\n> should be\n> > > > in the protocol?  I'm a bit concerned about adding storage cleanup\n> > > > semantics into the protocol, since this tends to be a very\n> > > > implementation dependent area.\n> > > >\n> > > > Cheers,\n> > > > Geoff\n> >\n> > --\n> > Greg Stein, http://www.lyra.org/\n>\n> --\n> Greg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-4911926"}, {"subject": "draft-ietf-deltav-versioning-11.3 now availabl", "content": "This draft contains the updates requested by Tim Ellison and\nChuck Fay.  All changes since the -11 draft are detailed in\n\"Appendix B: Changes Since Last Internet Draft\".\n\n<http://www.webdav.org/deltav/protocol/draft-ietf-deltav-versioning-11.htm>\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4928000"}, {"subject": "Versioning TeleConf Agenda, 1/19/00 (Friday) 12-1pm ES", "content": "phone: 888 819 8909  pass-code#97985\n\nAgenda:\n\n- Are we on for the planned working group last call?\n  With Tim's careful review, we now even have the spaces right (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4934801"}, {"subject": "DAV:checked-i", "content": "<tim>\n   2.2.1 DAV:checked-in\n     'This URL can be used to retrieve this particular\n     state of the version-controlled resource after the\n     version-controlled resource itself has been modified.'\n\n      Given that this is a property of a checked-in version-\n     controlled resource, I fail to see how the version-\n     controlled resource itself can be modified.\n</tim>\n\n<geoff>\n     ??  By MERGE, by UPDATE, and by CHECKIN/PUT, for example.\n     (The last changes it into a checked-out resource, but it\n     is still the same resource).\n</geoff>\n\n<tim_2>\n     ...but each of these change the DAV:checked-in value, so after the\nresource has been modified, that property cannot be used to retrieve the\nprevious state of the vcr (i.e., the previous state of the property can be\nused to retrieve the previous state of the vcr).\n\n\nand\n\n<chuck>\n     Section 2.2.1, \"DAV:checked-in  (protected)\", sentence 2:\n     \"This URL can be used to retrieve this particular state\n     of the version-controlled resource after the version-\n     controlled resource itself has been modified.\"\n\n     This sentence should be moved to Section 2.2.2, \"DAV:checked-\n     out ...\", because it's true there but incorrect here.\n</chuck>\n\n<geoff>\n     ??  The DAV:checked-in property means that the vcr is\n     checked in (thus the name :-), and the DAV:checked-in version\n     captures the current state of the vcr.  This is not true\n     for a checked out vcr.\n</geoff>\n\n\n<tim_2>\n     Well it seems that Chuck and I were equally confused by this sentence.\nIn Chuck's defense, the sentence he proposed moving *does* equally apply to\nDAV:checked-out (i.e., when refering to the DAV:checked-out property).\n\n     However, I think that I understand where you are coming from -- namely\nthat a client can take a copy of that DAV:checked-in URL and use it later\nto refer to the previous state of vcr when the DAV:checked-in value has\nbeen overwritten.\n</tim_2>\n\n\n\n", "id": "lists-006-4941860"}, {"subject": "Re: replacing DAV:checkin-date with DAV:creationdat", "content": "Nope.\n\n\n\"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com> on 2001-01-18 09:11:02 PM\n\nPlease respond to \"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com>\n\nTo:   ietf-dav-versioning@w3.org\ncc:\nSubject:  replacing DAV:checkin-date with DAV:creationdate\n\n\n\n\n\nIn Tim Ellison's review, he pointed out that DAV:checkin-date is\njust the DAV:creationdate of the version.  I see no reason for\nus to support two properties that always contain the same value,\nso I propose that the current standard property (DAV:creationdate)\nshould prevail, and DAV:checkin-date should be removed from\nthe versioning protocol.\n\nAny objections?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4950717"}, {"subject": "testing in a workspac", "content": "<tim>\n     7 Server-Workspace Option\n\n     para. 4\n     Unless the URLs are relative, the workspace name will get in the way\nof testing.\n</tim>\n\n</geoff>This is probably more detail than is needed in that section.\n\nThe how about we delete that paragraph?  Rationale has alredy been given\nearlier.\n\n\nTim\n\n\n\n", "id": "lists-006-4959165"}, {"subject": "Re: reformatting the DAV:version-tree repor", "content": "Nope.\n(oops, 'nope' as in 'no objections', not nope as in 'don't do it')\n\n\n\"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com> on 2001-01-18 09:27:23 PM\n\nPlease respond to \"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com>\n\nTo:   ietf-dav-versioning@w3.org\ncc:\nSubject:  reformatting the DAV:version-tree report\n\n\n\n\n\nOne last change from Tim's review that I felt deserved a separate thread:\n\nTim asked:\n\n       Why are the DAV:version-tree elements nested?  It does not convey\n\"true\"\n   structure, especially since 'A server MAY omit the DAV:prop and the\n   successor DAV:version-tree elements ...'  I don't see that the nesting\nis\n   helpful.\n\nAnd I responded:\n\n   Another good point (and one that Lisa made as well).\n   Currently, we've defined the format of the DAV:version-tree-report\n   to match just one of the many ways a client might want to\n   display this information.  A flat list is simpler and\n   more consistent - we can just use a DAV:multistatus response\n   so clients can even re-use their multi-status parsing code.\n\nAny objections?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-4965942"}, {"subject": "DELETE semantic", "content": "<tim>\n   2.9 Additional DELETE semantics\n\n       (DAV:update-predecessor-set)\n       I presume this is to prevent \"holes\" in the history, but this won't\nwork\n   in the face of merges.\n</tim>\n\n<geoff/>Why not?\n\nNow I've thought about it again, I retract this one.\n\nTim\n\n\n\n", "id": "lists-006-4974724"}, {"subject": "version-history-collection-se", "content": "<tim>\n   5.4 Additional OPTIONS Semantics\n       Is it required that the history for the resource reporting the\nOPTIONS\n   MUST be in the version-history-collection-set?  Probably unnecessary\nsince\n   clients can get to the history via properties.\n</tim>\n\n<geoff>\nNo, there is no such requirement, and yes, it would be unncessary to make\nthis requirement.\n</geoff>\n\nSo why would a client want to know where some (indeterminate) version\nhistories are stored?\n\nTim\n\n\n\n", "id": "lists-006-4981368"}, {"subject": "CHECKOUT Location heade", "content": "<tim>\n   6.5 Additional CHECKOUT Semantics\n       Additional Marshalling:\n       'The response MAY include a Location header.'\n       How else would you find a working resource URL?  Consider MUST.\n</tim>\n\nDidn't see your response to this one.\n\nTim\n\n\n\n", "id": "lists-006-4988239"}, {"subject": "Re: 11.1 revie", "content": "Thanks for the detailed response.  Where I felt there is follow-up required\nI have sent a separate post to the list.\n\n<geoff>\n     The only criticism I'd make is that it kept me\n     up all night making the suggested corrections,\n     so please forgive any incoherence in this\n     message (:-).\n</geoff>\n\nHey, don't blame me for your diligence ... <g>\n\n\n<<big snip>>\n\n\n<geoff>\n     Scanned for all occurrences of two spaces not\n     following a \".\" (and found several more).  And\n     just to show how anal one can be, I also made\n     sure that every new sentence was preceded by\n     *exactly* two spaces (not one, not three ... :-).\n</geoff>\n\nI can just picture the conversation in your house: \"Can't come to bed right\nnow I'm just ...\" <g>\n\nTim\n\n\n\n", "id": "lists-006-4994861"}, {"subject": "Re: DeltaV Draf", "content": "   From: \"Mark A. Hale\" <mark.hale@interwoven.com>\n\n   ... I will be looking to see\n   that the DAV:workspace property is described.\n\nOops ... I forgot to get the \"delete\" semantic we agreed on\n(i.e. deleting a workspace deletes all resources that identify\nthat workspace in their DAV:workspace property) into the 11.3\ndraft.  I'll make sure it gets into the next draft.\n\nI believe that's all we have as semantics for the DAV:workspace\nproperty.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5002185"}, {"subject": "Re: DAV:checked-i", "content": "   From: Tim_Ellison@uk.ibm.com\n\n\n   <tim>\n      2.2.1 DAV:checked-in\n'This URL can be used to retrieve this particular\nstate of the version-controlled resource after the\nversion-controlled resource itself has been modified.'\n\n Given that this is a property of a checked-in version-\ncontrolled resource, I fail to see how the version-\ncontrolled resource itself can be modified.\n   </tim>\n\n\n   <tim_2>\nWell it seems that Chuck and I were equally confused by this sentence.\n\nHowever, I think that I understand where you are coming from -- namely\n   that a client can take a copy of that DAV:checked-in URL and use it later\n   to refer to the previous state of vcr when the DAV:checked-in value has\n   been overwritten.\n   </tim_2>\n\nChanged the text so that it is less misleading.\n\n   From: Tim_Ellison@uk.ibm.com\n\n   <tim>\n7 Server-Workspace Option\n\npara. 4\nUnless the URLs are relative, the workspace name will get in the way\n   of testing.\n   </tim>\n\n   The how about we delete that paragraph?  Rationale has alredy been given\n   earlier.\n\nDone.\n\n   From: Tim_Ellison@uk.ibm.com\n\n\n   <tim>\n      5.4 Additional OPTIONS Semantics\n  Is it required that the history for the resource reporting the\n   OPTIONS\n      MUST be in the version-history-collection-set?  Probably unnecessary\n   since\n      clients can get to the history via properties.\n   </tim>\n\n   So why would a client want to know where some (indeterminate) version\n   histories are stored?\n\nSo that it can find version histories that no longer are referenced\nby any version-controlled resource.\n\n   From: Tim_Ellison@uk.ibm.com\n\n   <tim>\n      6.5 Additional CHECKOUT Semantics\n  Additional Marshalling:\n  'The response MAY include a Location header.'\n  How else would you find a working resource URL?  Consider MUST.\n   </tim>\n\nThe additional marshalling applies to all forms of CHECKOUT,\nincluding a CHECKOUT of a version-controlled resource, but the\nLocation header is only required if a version is being checked\nout.  The postcondition states that the Location header is\nrequired if a version is being checked out.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5009484"}, {"subject": "WebDAV Delta-V Working Group Last Cal", "content": "*** DeltaV WORKING GROUP LAST CALL FOR COMMENTS ***\n\nWeb Versioning and Configuration Management PROTOCOL SPECIFICATION\n\nWe are happy to announce the second working group last call for comments \nfrom the DeltaV working group on the Versioning Extensions to WebDAV \nSpecification, draft-ietf-deltav-versioning-12 available at \nhttp://www.ietf.org/ids.by.wg/deltav.html or \nhttp://www.webdav.org/deltav/.  This last call for comments period begins \nimmediately, and ends February 1, 2001, at midnight, US Eastern time. This \nallows sufficient time for review of the specification in time for the \nMarch IETF '50 meeting.\n\nAt the end of the last call review period, a new draft will be issued. \nDepending on the scope of changes introduced between the -12 and -13 \nversions, there will either be an immediate call for rough consensus (very \nfew changes), or a third last call review period (significant changes). \nOnce the document represents the rough consensus of the working group, I \nwill submit this document to the Internet Engineering Steering Group \n(IESG) for their approval.  IESG review involves a (minimum) two week \npublic last call for comments period.  This IESG-initiated last call \nperiod is in addition to the working group last call period.\n\nThis document is intended to be a \"Proposed Standard\".  Quoting from RFC \n2026, \"The Internet Standards Process -- Revision 3\":\n\n   The entry-level maturity for the standards track is \"Proposed \nStandard\".  A specific action by the IESG is required to move a \nspecification onto the standards track at the \"Proposed Standard\" level.\n\n   A Proposed Standard specification is generally stable, has resolved \nknown design choices, is believed to be well-understood, has received \nsignificant community review, and appears to enjoy enough community \ninterest to be considered valuable.  However, further experience might \nresult in a change or even retraction of the specification before it \nadvances.\n\n   Usually, neither implementation nor operational experience is required \nfor the designation of a specification as a Proposed Standard.  However, \nsuch experience is highly desirable, and will usually represent a strong \nargument in favor of a Proposed Standard designation.\n\nMany details on the procedures used to develop an IETF standard can be \nfound in RFC 2026, available at: http://www.ietf.org/rfc/rfc2026.txt\n\nIf there are any procedural questions or concerns, please do not hesitate \nto contact me, or raise an issue on the list.\n\nNotes:\n\n1) Issues raised during the last call period will be resolved \nindividually, rather than lumped together and dealt with as a whole.  This \nfollows the issue-resolution convention being followed in the HTTP WG.\n\n2) If you've been waiting for a \"stable\" version of the specification \nbefore performing a review, you need wait no longer.  This is it.  We \nvalue your input, but time is running out. So please review the \nspecification now in order to ensure your input gets included.\n\n- Jim Amsden\nChair, IETF DeltaV Working Group\n\n\n\n", "id": "lists-006-5018919"}, {"subject": "new deltav model availabl", "content": "I just uploaded a Rose-generated set of HTML pages that is the first\ndraft of a model of the WebDAV object model, including versioning, binding,\nand even a little ACL info.\n\nGo to http://www.webdav.org/deltav/ and follow the \"model\" link.\n\nSorry about the Rational add on the first page!  I don't know how to\nturn that off (no doubt, by design :-).\n\nI'll be iterating on this over the next few weeks (adding documentation,\nfor example :-), but several folks have asked for this, so I decided\nto post what I've got at the moment.\n\nThis is compatible with the last call (version-12) of the deltav protocol.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5029523"}, {"subject": "DELETE varian", "content": "The advanced status code in section 14.2 is the same for the pre- and\npostcondition (DAV:delete-variant-reference).\nIdeally the client should be able to distinguish these two cases.\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK.\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n\n", "id": "lists-006-5036394"}, {"subject": "I-D ACTION:draft-ietf-deltav-versioning-12.tx", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Web Versioning and Configuration Management Working Group of the IETF.\n\nTitle: Versioning Extensions to WebDAV\nAuthor(s): G. Clemm, J. Amsden, C. Kaler, J. Whitehead\nFilename: draft-ietf-deltav-versioning-12.txt\nPages: 95\nDate: 22-Jan-01\n\nThis document specifies a set of methods, headers, and resource-types \nthat define the WebDAV Versioning extensions to the HTTP/1.1 protocol. \nWebDAV Versioning will minimize the complexity of clients that are\ncapable of interoperating with a variety of versioning repository\nmanagers, to facilitate widespread deployment of applications capable of\nutilizing the WebDAV Versioning services.  WebDAV Versioning includes:\n- core versioning with automatic versioning for versioning-unaware\nclients,\n- workspace, activity and baseline management,\n- URL namespace versioning.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-12.txt\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-deltav-versioning-12.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-deltav-versioning-12.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n\n\n\nMessage/External-body attachment: stored\n\n\n\n\n", "id": "lists-006-5043505"}, {"subject": "Missing preconditions", "content": "I seem to recall that the document used to have the LABEL and CHECKOUT\nprecondition DAV:must-be-version-or-version-controlled-resource, and the\nVERSION-CONTROL precondition DAV:must-be-versionable.\n\nWhy have they been dropped?\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK.\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n\n", "id": "lists-006-5052471"}, {"subject": "[ANN] Delta-V FA", "content": "On my recent read through the protocol document, I found myself remembering\nconversations on this list and in working group meetings that had produced\nthe rationale for many of the decisions and designs.\n\nI would like to capture some of that in a FAQ (along the lines of the\nWebDAV 'Book of Why'), because it is useful background for a new reader\n(and will likely save me asking the same question umpteen times<g>).\nHowever, I don't want to be the author / originator of a large FAQ!\n\nGreg Stein has generously agreed to host a Delta-V FAQ-O-Matic on\nwebdav.org.  The FAQ-O-Matic shares the upkeep of the FAQ amongst everyone\nin the working group.  You can add a question & answer, and append to\nexisting answers to further clarify or share additional information.\n\nThe FAQ is not used to discuss or debate issues in the protocol, or raise\ninitial queries -- that remains the role of this list.  Questions that can\nbe answered by a careful reading of the protocol document are also\ndiscouraged.\n\nThe FAQ is empty at the moment.  I'll add a few Q&A as I think of them, and\nI encourage you to do so.  Remember, anyone can add a Q&A; an entry will\nonly be moderated if it is blantantly incorrect.  I'll try to organize\nsubcategories as requested/required.\n\nThe URL is  http://www.webdav.org/deltav/faq  (soon to be linked from the\nDelta-V homepage).\n\nHere are some questions that I would like to see answered.\n\nWhy is LABEL not in core?\nIs the server required to support...(some concept) ?\nAre there any implementations to play with yet?\nWhy is version history described in core and appears as an option?\nWhat combination of options are we likely to see?\nWhy are version-controlled collections, collection versions, and working\ncollections so different?\nWhy does the protocol not require case (in)sensitive label matching?\nIs there a method for performing numerous operations atomically?\nWhy are there so many new methods?\nWhy is the DAV:resourcetype of a workspace 'DAV:collection'?\n\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK.\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n\n", "id": "lists-006-5059793"}, {"subject": "DAV:commen", "content": ">   23.1.1 DAV:comment\n>     Why do we have an extra DAV:string element?\n>     Why can you have any number of them (how would a client\n>    choose which one to display)?\n>\n> This was a change requested by Yaron to support\n> internationalization.  You can have the comment\n> string in multiple languages this way.\n\nI'll defer to those who are much more HTTP/XML-versed than I am, but I\nwould imagine that this would be a matter of content negotiation between\nthe client and server.\n\nTim\n\n\n\n", "id": "lists-006-5068281"}, {"subject": "RE: commen", "content": "I've just been looking into how to handle content negotiation, and I \nhaven't seen any implementation where content identified by a single\nURL can handle multiple languages without redirection.  In other words,\nif my file has Dutch content, and I'm a French user, I need to be sent\nto another URL with the French version of that content (usually by the\nlanguage extension on the filename).  That other resource would have the\nproperty values (like DAV:comment) in the correct language, presumably.\n\nTherefore, I think there is no need to worry about internationalization\nof string properties of a resource--they're going to be localized.  This\nchange should be reversed.\n\n--Eric\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> Tim_Ellison@uk.ibm.com\n> Sent: Tuesday, January 23, 2001 5:17 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: DAV:comment\n> \n> \n> \n> \n> \n> >   23.1.1 DAV:comment\n> >     Why do we have an extra DAV:string element?\n> >     Why can you have any number of them (how would a client\n> >    choose which one to display)?\n> >\n> > This was a change requested by Yaron to support\n> > internationalization.  You can have the comment\n> > string in multiple languages this way.\n> \n> I'll defer to those who are much more HTTP/XML-versed than I am, but I\n> would imagine that this would be a matter of content negotiation between\n> the client and server.\n> \n> Tim\n> \n> \n> \n\n\n\n", "id": "lists-006-5075397"}, {"subject": "Re: commen", "content": "Apache does this all the time. Based on your Accept-Language request\nheader, Apache will return different content for a given URL. (assuming that\nyou enable the Multiviews option (on by default) and have mod_negotiation\nbuilt)\n\nGranted, it also returns a Location: header specifying the \"real\" URL.\n\nBut negotiation on XML properties seems practically impossible. Personally,\nI think that adding DAV:string into the comment is overdone. We don't do\nthat with our other properties. Why is this one so special? And I seriously\ndoubt that a comment is going to be entered in multiple languages when the\nversion is created.\n[ a version resource is immutable: you can't come back, translate the\n  bugger, and add them into the DAV:comment ]\n\nIt seems a gratuitous change to have DAV:string in there.\n\nCheers,\n-g\n\nOn Tue, Jan 23, 2001 at 09:25:58AM -0800, Eric Sedlar wrote:\n> I've just been looking into how to handle content negotiation, and I \n> haven't seen any implementation where content identified by a single\n> URL can handle multiple languages without redirection.  In other words,\n> if my file has Dutch content, and I'm a French user, I need to be sent\n> to another URL with the French version of that content (usually by the\n> language extension on the filename).  That other resource would have the\n> property values (like DAV:comment) in the correct language, presumably.\n> \n> Therefore, I think there is no need to worry about internationalization\n> of string properties of a resource--they're going to be localized.  This\n> change should be reversed.\n> \n> --Eric\n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> > Tim_Ellison@uk.ibm.com\n> > Sent: Tuesday, January 23, 2001 5:17 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: DAV:comment\n> > \n> > \n> > \n> > \n> > \n> > >   23.1.1 DAV:comment\n> > >     Why do we have an extra DAV:string element?\n> > >     Why can you have any number of them (how would a client\n> > >    choose which one to display)?\n> > >\n> > > This was a change requested by Yaron to support\n> > > internationalization.  You can have the comment\n> > > string in multiple languages this way.\n> > \n> > I'll defer to those who are much more HTTP/XML-versed than I am, but I\n> > would imagine that this would be a matter of content negotiation between\n> > the client and server.\n> > \n> > Tim\n> > \n> > \n> > \n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-5085459"}, {"subject": "Comment", "content": "Some additional comments:\n\n- Thank you for remembering to add Section 7.5.  I think \n  that \"is\" should be \"its\".\n\n- I disagree with the following statement in Section 1:  \n\n\"The exception is the working-resource and workspace \noptions.  These provide the same logical functionality \nbut with significantly different client/server \nperformance/complexity tradeoffs.  It is expected that \nonly a limited number of servers will support the \nworking-resource and the workspace options.\"   \n\n  Working-resources are created when versions are checked out.  \n  A workspace resource is a collection whose members are related\n  version-controlled and non-version-controlled resources.  These\n  are not the same logical functionality. \n\n  Also, a working-resource can have a workspace property which\n  does not make it logically orthogonal to a workspace in the\n  context of the discussion in section 1.\n\n  My suggestion is to end section 1 with the existing statement\n  that the specification options are designed to be logically \n  orthogonal.  \n  \n- Overall the specification has the necessary components and I \n  have provided input to ensure its completeness.  I do go back \n  to a comment posted on the list a week or two about the \n  specification's complexity.  As I review the specification \n  now, I do agree and feel that the specification is \n  complex.  I would like to see complexity revisited in \n  Minneapolis as an action item.\n\n\n\nThanks,\n\nMark\n\n\n\n", "id": "lists-006-5095561"}, {"subject": "Re: commen", "content": "I'm familiar with content negotiation, but I guess that negotiating on XML\nproperties would be 'practically impossible' given that WebDAV properties\nmatch on name alone (and not attributes), otherwise you could image\n\n(assuming xml:lang is the attribute for language tagging, I've no idea what\nit is)\n\nPROPPATCH /foo setting properties with language flags\n...\n...xmlns:D=\"...\"...\n<D:comment xml:lang=\"useng\">Very good</D:comment>\n<D:comment xml:lang=\"frfrench\"Tres bon</D:comment>\n\n\nThen a client could get the property value of choice in the language of\nchoice:\n\nPROPFIND /foo\nContent-Language: \"frfrench\"\n...\n</D:comment>\n\nor even specifying the language in the body of the XML request:\n\nPROPFIND /foo\n...\n</D:comment xml:lang=\"useng\">\n</D:author xml:lang=\"dutch\"\n\n\n(With big apologies to XML and HTTP syntax-ites.)\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK.\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\nGreg Stein <gstein@lyra.org> on 2001-01-23 10:55:51 PM\n\nPlease respond to Greg Stein <gstein@lyra.org>\n\nTo:   ietf-dav-versioning@w3.org\ncc:\nSubject:  Re: comment\n\n\n\n\nApache does this all the time. Based on your Accept-Language request\nheader, Apache will return different content for a given URL. (assuming\nthat\nyou enable the Multiviews option (on by default) and have mod_negotiation\nbuilt)\n\nGranted, it also returns a Location: header specifying the \"real\" URL.\n\nBut negotiation on XML properties seems practically impossible. Personally,\nI think that adding DAV:string into the comment is overdone. We don't do\nthat with our other properties. Why is this one so special? And I seriously\ndoubt that a comment is going to be entered in multiple languages when the\nversion is created.\n[ a version resource is immutable: you can't come back, translate the\n  bugger, and add them into the DAV:comment ]\n\nIt seems a gratuitous change to have DAV:string in there.\n\nCheers,\n-g\n\nOn Tue, Jan 23, 2001 at 09:25:58AM -0800, Eric Sedlar wrote:\n> I've just been looking into how to handle content negotiation, and I\n> haven't seen any implementation where content identified by a single\n> URL can handle multiple languages without redirection.  In other words,\n> if my file has Dutch content, and I'm a French user, I need to be sent\n> to another URL with the French version of that content (usually by the\n> language extension on the filename).  That other resource would have the\n> property values (like DAV:comment) in the correct language, presumably.\n>\n> Therefore, I think there is no need to worry about internationalization\n> of string properties of a resource--they're going to be localized.  This\n> change should be reversed.\n>\n> --Eric\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> > Tim_Ellison@uk.ibm.com\n> > Sent: Tuesday, January 23, 2001 5:17 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: DAV:comment\n> >\n> >\n> >\n> >\n> >\n> > >   23.1.1 DAV:comment\n> > >     Why do we have an extra DAV:string element?\n> > >     Why can you have any number of them (how would a client\n> > >    choose which one to display)?\n> > >\n> > > This was a change requested by Yaron to support\n> > > internationalization.  You can have the comment\n> > > string in multiple languages this way.\n> >\n> > I'll defer to those who are much more HTTP/XML-versed than I am, but I\n> > would imagine that this would be a matter of content negotiation\nbetween\n> > the client and server.\n> >\n> > Tim\n> >\n> >\n> >\n\n--\nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-5103980"}, {"subject": "RE: commen", "content": "I agree with Eric that this approach for internationalizing individual\nproperties is flawed, and that the change shoud be reversed.\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK.\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n\"Eric Sedlar\" <Eric.Sedlar@oracle.com> on 2001-01-23 05:25:58 PM\n\nPlease respond to \"Eric Sedlar\" <Eric.Sedlar@oracle.com>\n\nTo:   Tim Ellison/UK/IBM@IBMGB, ietf-dav-versioning@w3.org\ncc:\nSubject:  RE: comment\n\n\n\n\nI've just been looking into how to handle content negotiation, and I\nhaven't seen any implementation where content identified by a single\nURL can handle multiple languages without redirection.  In other words,\nif my file has Dutch content, and I'm a French user, I need to be sent\nto another URL with the French version of that content (usually by the\nlanguage extension on the filename).  That other resource would have the\nproperty values (like DAV:comment) in the correct language, presumably.\n\nTherefore, I think there is no need to worry about internationalization\nof string properties of a resource--they're going to be localized.  This\nchange should be reversed.\n\n--Eric\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> Tim_Ellison@uk.ibm.com\n> Sent: Tuesday, January 23, 2001 5:17 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: DAV:comment\n>\n>\n>\n>\n>\n> >   23.1.1 DAV:comment\n> >     Why do we have an extra DAV:string element?\n> >     Why can you have any number of them (how would a client\n> >    choose which one to display)?\n> >\n> > This was a change requested by Yaron to support\n> > internationalization.  You can have the comment\n> > string in multiple languages this way.\n>\n> I'll defer to those who are much more HTTP/XML-versed than I am, but I\n> would imagine that this would be a matter of content negotiation between\n> the client and server.\n>\n> Tim\n>\n>\n>\n\n\n\n", "id": "lists-006-5116243"}, {"subject": "RE: Missing preconditions", "content": "These are covered by the standard 405 (Method not allowed) status.\nIn addition, for future extensibility, I believe it is better\nnot to make these explicit preconditions.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Tuesday, January 23, 2001 8:01 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Missing preconditions?\n\n\n\n\nI seem to recall that the document used to have the LABEL and CHECKOUT\nprecondition DAV:must-be-version-or-version-controlled-resource, and the\nVERSION-CONTROL precondition DAV:must-be-versionable.\n\nWhy have they been dropped?\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK.\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n\n", "id": "lists-006-5126659"}, {"subject": "RE: commen", "content": "I don't believe that the multiple comment strings were intended\nfor property content negotiation, but rather to allow you\nto put comments in multiple languages on a resource which does\nnot have multiple language variants.  This could help support\nsearching for a document in multiple languages, even if the \ndocument itself is in only one language.\n\nI agree with Greg's point that a version is unlikely to have\ncomments in multiple languages, but this property is intended\nfor an arbitrary resource, not just for version resources.\n\nThe reason this property (and DAV:creator-displayname) are\nspecified this way is that they can take natural language\nvalues, which is not the case for the versioning specific\nproperties.\n\nSo I guess I see some benefit, with minimal cost.  To make\nsure I haven't missed anything, is there any cost to this\nextra layer of XML, other than a few extra bytes?\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Wednesday, January 24, 2001 9:38 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: comment\n\n\n\n\nI agree with Eric that this approach for internationalizing individual\nproperties is flawed, and that the change shoud be reversed.\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK.\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n\"Eric Sedlar\" <Eric.Sedlar@oracle.com> on 2001-01-23 05:25:58 PM\n\nPlease respond to \"Eric Sedlar\" <Eric.Sedlar@oracle.com>\n\nTo:   Tim Ellison/UK/IBM@IBMGB, ietf-dav-versioning@w3.org\ncc:\nSubject:  RE: comment\n\n\n\n\nI've just been looking into how to handle content negotiation, and I\nhaven't seen any implementation where content identified by a single\nURL can handle multiple languages without redirection.  In other words,\nif my file has Dutch content, and I'm a French user, I need to be sent\nto another URL with the French version of that content (usually by the\nlanguage extension on the filename).  That other resource would have the\nproperty values (like DAV:comment) in the correct language, presumably.\n\nTherefore, I think there is no need to worry about internationalization\nof string properties of a resource--they're going to be localized.  This\nchange should be reversed.\n\n--Eric\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> Tim_Ellison@uk.ibm.com\n> Sent: Tuesday, January 23, 2001 5:17 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: DAV:comment\n>\n>\n>\n>\n>\n> >   23.1.1 DAV:comment\n> >     Why do we have an extra DAV:string element?\n> >     Why can you have any number of them (how would a client\n> >    choose which one to display)?\n> >\n> > This was a change requested by Yaron to support\n> > internationalization.  You can have the comment\n> > string in multiple languages this way.\n>\n> I'll defer to those who are much more HTTP/XML-versed than I am, but I\n> would imagine that this would be a matter of content negotiation between\n> the client and server.\n>\n> Tim\n>\n>\n>\n\n\n\n", "id": "lists-006-5134655"}, {"subject": "RE: Comment", "content": "- Thanks for catching the 7.5 typo ... will fix.\n\n- Concerning the statement about working-resource and\nworkspace options, I'm happy to delete this sentence,\nsince I don't see that it improves interoperability,\nand could incorrectly lead a reader to believe that\nthe options are inconsistent.  So I'll delete this sentence\nunless anyone objects.\n\n- As for the complexity of the protocol, if there is\nsomething that you would like to see addressed before\nwe send the protocol to the IESG for \"proposed standard\"\nstatus, please identify the specific issue during the\nworking group last call period (i.e. before 2/1/01).\nIt is my belief that the complexity issues have been\nadequately addressed by clearly identifying the part\nof the document that should be read by those only \ninterested in \"core\" versioning functionality.  Each of\nthe options consist of functionality that is currently\nsupported by multiple versioning repositories, and\ntherefore it significantly contributes to interoperability\nto provide an option that standardizes access\nto that functionality.\n\nCheers,\nGeoff\n \n-----Original Message-----\nFrom: Mark A. Hale [mailto:mark.hale@interwoven.com]\nSent: Tuesday, January 23, 2001 8:21 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Comments\n\n\nSome additional comments:\n\n- Thank you for remembering to add Section 7.5.  I think \n  that \"is\" should be \"its\".\n\n- I disagree with the following statement in Section 1:  \n\n\"The exception is the working-resource and workspace \noptions.  These provide the same logical functionality \nbut with significantly different client/server \nperformance/complexity tradeoffs.  It is expected that \nonly a limited number of servers will support both the \nworking-resource and the workspace options.\"   \n\n  Working-resources are created when versions are checked out.  \n  A workspace resource is a collection whose members are related\n  version-controlled and non-version-controlled resources.  These\n  are not the same logical functionality. \n\n  Also, a working-resource can have a workspace property which\n  does not make it logically orthogonal to a workspace in the\n  context of the discussion in section 1.\n\n  My suggestion is to end section 1 with the existing statement\n  that the specification options are designed to be logically \n  orthogonal.  \n  \n- Overall the specification has the necessary components and I \n  have provided input to ensure its completeness.  I do go back \n  to a comment posted on the list a week or two about the \n  specification's complexity.  As I review the specification \n  now, I do agree and feel that the specification is \n  complex.  I would like to see complexity revisited in \n  Minneapolis as an action item.\n\n\n\nThanks,\n\nMark\n\n\n\n", "id": "lists-006-5146924"}, {"subject": "RE: DELETE varian", "content": "Ooops!  Cut/paste strikes again.  Will fix.\n\nThanks,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Tuesday, January 23, 2001 5:19 AM\nTo: ietf-dav-versioning@w3.org\nSubject: DELETE variant\n\n\n\n\nThe advanced status code in section 14.2 is the same for the pre- and\npostcondition (DAV:delete-variant-reference).\nIdeally the client should be able to distinguish these two cases.\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK.\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n\n", "id": "lists-006-5156880"}, {"subject": "RE: commen", "content": "More reasons to avoid multilingual properties on monolingual documents:\n\nThere's always a big cost in making data an array from a scalar\nunnecessarily.  Queries (in general) against this data will be\nmore expensive, and your example usage postulates using this data\nfor that purpose.\n\nSecondly, the logical model is weaker.  If you only want to look\nat the German text in a resource, you must examine each natural\nlanguage property separately to see what language it is, rather\nthan looking in one place.  Not only is this a query speed problem,\nbut it also allows the case where none of the property values matches\nthe language or charset of the resource's contents.\n\nThirdly, this is inconsistent usage with DAV:display-name, and I\nthink you need a compelling reason to introduce this type of\ndiscrepancy.\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Wednesday, January 24, 2001 9:45 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: comment\n>\n>\n> I don't believe that the multiple comment strings were intended\n> for property content negotiation, but rather to allow you\n> to put comments in multiple languages on a resource which does\n> not have multiple language variants.  This could help support\n> searching for a document in multiple languages, even if the\n> document itself is in only one language.\n>\n> I agree with Greg's point that a version is unlikely to have\n> comments in multiple languages, but this property is intended\n> for an arbitrary resource, not just for version resources.\n>\n> The reason this property (and DAV:creator-displayname) are\n> specified this way is that they can take natural language\n> values, which is not the case for the versioning specific\n> properties.\n>\n> So I guess I see some benefit, with minimal cost.  To make\n> sure I haven't missed anything, is there any cost to this\n> extra layer of XML, other than a few extra bytes?\n>\n> Cheers,\n> Geoff\n>\n> -----Original Message-----\n> From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n> Sent: Wednesday, January 24, 2001 9:38 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: comment\n>\n>\n>\n>\n> I agree with Eric that this approach for internationalizing individual\n> properties is flawed, and that the change shoud be reversed.\n>\n> Regards,\n>\n> Tim Ellison\n> Java Technology Centre, MP146\n> IBM UK Laboratory, Hursley Park, Winchester, UK.\n> tel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n>\n>\n> \"Eric Sedlar\" <Eric.Sedlar@oracle.com> on 2001-01-23 05:25:58 PM\n>\n> Please respond to \"Eric Sedlar\" <Eric.Sedlar@oracle.com>\n>\n> To:   Tim Ellison/UK/IBM@IBMGB, ietf-dav-versioning@w3.org\n> cc:\n> Subject:  RE: comment\n>\n>\n>\n>\n> I've just been looking into how to handle content negotiation, and I\n> haven't seen any implementation where content identified by a single\n> URL can handle multiple languages without redirection.  In other words,\n> if my file has Dutch content, and I'm a French user, I need to be sent\n> to another URL with the French version of that content (usually by the\n> language extension on the filename).  That other resource would have the\n> property values (like DAV:comment) in the correct language, presumably.\n>\n> Therefore, I think there is no need to worry about internationalization\n> of string properties of a resource--they're going to be localized.  This\n> change should be reversed.\n>\n> --Eric\n>\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> > Tim_Ellison@uk.ibm.com\n> > Sent: Tuesday, January 23, 2001 5:17 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: DAV:comment\n> >\n> >\n> >\n> >\n> >\n> > >   23.1.1 DAV:comment\n> > >     Why do we have an extra DAV:string element?\n> > >     Why can you have any number of them (how would a client\n> > >    choose which one to display)?\n> > >\n> > > This was a change requested by Yaron to support\n> > > internationalization.  You can have the comment\n> > > string in multiple languages this way.\n> >\n> > I'll defer to those who are much more HTTP/XML-versed than I am, but I\n> > would imagine that this would be a matter of content negotiation between\n> > the client and server.\n> >\n> > Tim\n> >\n> >\n> >\n>\n>\n>\n\n\n\n", "id": "lists-006-5164564"}, {"subject": "Re: commen", "content": "I think it is clear that the consensus is in favor of going back\nto \"string\", so I will make that change.  I just gave Yaron a call,\nand he agreed that the query arguments are sound, so he can live\nwith changing it back to \"string\".\n\nCheers,\nGeoff\n\n   From: \"Eric Sedlar\" <Eric.Sedlar@oracle.com>\n   Date: Wed, 24 Jan 2001 22:35:33 -0800\n\n   More reasons to avoid multilingual properties on monolingual documents:\n\n   There's always a big cost in making data an array from a scalar\n   unnecessarily.  Queries (in general) against this data will be\n   more expensive, and your example usage postulates using this data\n   for that purpose.\n\n   Secondly, the logical model is weaker.  If you only want to look\n   at the German text in a resource, you must examine each natural\n   language property separately to see what language it is, rather\n   than looking in one place.  Not only is this a query speed problem,\n   but it also allows the case where none of the property values matches\n   the language or charset of the resource's contents.\n\n   Thirdly, this is inconsistent usage with DAV:display-name, and I\n   think you need a compelling reason to introduce this type of\n   discrepancy.\n\n   > -----Original Message-----\n   > From: ietf-dav-versioning-request@w3.org\n   > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n   > Sent: Wednesday, January 24, 2001 9:45 PM\n   > To: ietf-dav-versioning@w3.org\n   > Subject: RE: comment\n   >\n   >\n   > I don't believe that the multiple comment strings were intended\n   > for property content negotiation, but rather to allow you\n   > to put comments in multiple languages on a resource which does\n   > not have multiple language variants.  This could help support\n   > searching for a document in multiple languages, even if the\n   > document itself is in only one language.\n   >\n   > I agree with Greg's point that a version is unlikely to have\n   > comments in multiple languages, but this property is intended\n   > for an arbitrary resource, not just for version resources.\n   >\n   > The reason this property (and DAV:creator-displayname) are\n   > specified this way is that they can take natural language\n   > values, which is not the case for the versioning specific\n   > properties.\n   >\n   > So I guess I see some benefit, with minimal cost.  To make\n   > sure I haven't missed anything, is there any cost to this\n   > extra layer of XML, other than a few extra bytes?\n   >\n   > Cheers,\n   > Geoff\n   >\n   > -----Original Message-----\n   > From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n   > Sent: Wednesday, January 24, 2001 9:38 AM\n   > To: ietf-dav-versioning@w3.org\n   > Subject: RE: comment\n   >\n   >\n   >\n   >\n   > I agree with Eric that this approach for internationalizing individual\n   > properties is flawed, and that the change shoud be reversed.\n   >\n   > Regards,\n   >\n   > Tim Ellison\n   > Java Technology Centre, MP146\n   > IBM UK Laboratory, Hursley Park, Winchester, UK.\n   > tel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n   >\n   >\n   > \"Eric Sedlar\" <Eric.Sedlar@oracle.com> on 2001-01-23 05:25:58 PM\n   >\n   > Please respond to \"Eric Sedlar\" <Eric.Sedlar@oracle.com>\n   >\n   > To:   Tim Ellison/UK/IBM@IBMGB, ietf-dav-versioning@w3.org\n   > cc:\n   > Subject:  RE: comment\n   >\n   >\n   >\n   >\n   > I've just been looking into how to handle content negotiation, and I\n   > haven't seen any implementation where content identified by a single\n   > URL can handle multiple languages without redirection.  In other words,\n   > if my file has Dutch content, and I'm a French user, I need to be sent\n   > to another URL with the French version of that content (usually by the\n   > language extension on the filename).  That other resource would have the\n   > property values (like DAV:comment) in the correct language, presumably.\n   >\n   > Therefore, I think there is no need to worry about internationalization\n   > of string properties of a resource--they're going to be localized.  This\n   > change should be reversed.\n   >\n   > --Eric\n   >\n   > > -----Original Message-----\n   > > From: ietf-dav-versioning-request@w3.org\n   > > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n   > > Tim_Ellison@uk.ibm.com\n   > > Sent: Tuesday, January 23, 2001 5:17 AM\n   > > To: ietf-dav-versioning@w3.org\n   > > Subject: DAV:comment\n   > >\n   > >\n   > >\n   > >\n   > >\n   > > >   23.1.1 DAV:comment\n   > > >     Why do we have an extra DAV:string element?\n   > > >     Why can you have any number of them (how would a client\n   > > >    choose which one to display)?\n   > > >\n   > > > This was a change requested by Yaron to support\n   > > > internationalization.  You can have the comment\n   > > > string in multiple languages this way.\n   > >\n   > > I'll defer to those who are much more HTTP/XML-versed than I am, but I\n   > > would imagine that this would be a matter of content negotiation between\n   > > the client and server.\n   > >\n   > > Tim\n   > >\n   > >\n   > >\n   >\n   >\n   >\n\n\n\n", "id": "lists-006-5179525"}, {"subject": "Re: commen", "content": "Just to be clear, you mean \"string\" as in 1.5.6, right?\n\n[ confused since we talking about removing DAV:string, yet you bring it up\n  again :-) ]\n\nCheers,\n-g\n\nOn Thu, Jan 25, 2001 at 02:38:59PM -0500, Geoffrey M. Clemm wrote:\n> \n> I think it is clear that the consensus is in favor of going back\n> to \"string\", so I will make that change.  I just gave Yaron a call,\n> and he agreed that the query arguments are sound, so he can live\n> with changing it back to \"string\".\n> \n> Cheers,\n> Geoff\n>...\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-5194648"}, {"subject": "&quot;baseline selector&quot; =&gt; &quot;version-controlled configuration&quot", "content": "As I was preparing the recently posted \"visual model\" of the WebDAV\nprotocol, it occurred to me that a more consistent name for a\n\"baseline selector\" would be a \"version-controlled configuration\"\n(since that is what it actually is).\n\nSo I propose that we get rid of the last remnant of the old \"selector\"\nterminology, and use \"version-controlled configuration\" instead.\nAny objections?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5201801"}, {"subject": "remove DAV:version property", "content": "Since you cannot access a version without using the URL for that\nversion, the DAV:version property appears to be redundant (you\ncouldn't find that property unless you already knew the value of\nthat property).\n\nSo I propose that we remove this property.  Any objections?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5209783"}, {"subject": "Re: &quot;baseline selector&quot; =&gt; &quot;version-controlled configuration&quot", "content": "On Thu, Jan 25, 2001 at 03:01:31PM -0500, Geoffrey M. Clemm wrote:\n> \n> As I was preparing the recently posted \"visual model\" of the WebDAV\n> protocol, it occurred to me that a more consistent name for a\n> \"baseline selector\" would be a \"version-controlled configuration\"\n> (since that is what it actually is).\n> \n> So I propose that we get rid of the last remnant of the old \"selector\"\n> terminology, and use \"version-controlled configuration\" instead.\n> Any objections?\n\nNo, sir.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-5217418"}, {"subject": "Re: remove DAV:version property", "content": "On Thu, Jan 25, 2001 at 03:06:04PM -0500, Geoffrey M. Clemm wrote:\n> \n> Since you cannot access a version without using the URL for that\n> version, the DAV:version property appears to be redundant (you\n> couldn't find that property unless you already knew the value of\n> that property).\n\nIs it possible to get at the property through an expand-property report?\nHmm. No... that always has an HREF associated with all prop listings.\n\nSeems fine to me. I can't think of a way to get information *about* a\nversion resource without also being told is URL somewhere.\n\n\nbtw, I just noticed: the expand-property example has an error: the\nactivity-set for .../ver/1 is missing <href> tags.\n\n[ also note that expand-property \"violates\" DTDs for properties. cool with\n  me, but some DTD fanatics will be up in arms. (e.g. version-history isn't\n  defined to contains a DAV:response element) ]\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-5225514"}, {"subject": "RE: commen", "content": "Yes, we are bring back \"string\" as in 1.5.6 and getting rid of DAV:string\n(sorry about the ambiguity :-).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Greg Stein [mailto:gstein@lyra.org]\nSent: Thursday, January 25, 2001 3:02 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: comment\n\n\nJust to be clear, you mean \"string\" as in 1.5.6, right?\n\n[ confused since we talking about removing DAV:string, yet you bring it up\n  again :-) ]\n\nCheers,\n-g\n\nOn Thu, Jan 25, 2001 at 02:38:59PM -0500, Geoffrey M. Clemm wrote:\n> \n> I think it is clear that the consensus is in favor of going back\n> to \"string\", so I will make that change.  I just gave Yaron a call,\n> and he agreed that the query arguments are sound, so he can live\n> with changing it back to \"string\".\n> \n> Cheers,\n> Geoff\n>...\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-5233515"}, {"subject": "Re: remove DAV:version property", "content": "What if you got to the version through a version controlled resource and \nwanted to get the persistent version URL for some reason. Or what if you \nwanted to keep a  dictionary of version controlled resource URL and \nversion URLs?\n\nJim Amsden\n919-543-3511\n\n\n\n\n\n\nSince you cannot access a version without using the URL for that\nversion, the DAV:version property appears to be redundant (you\ncouldn't find that property unless you already knew the value of\nthat property).\n\nSo I propose that we remove this property.  Any objections?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5241246"}, {"subject": "Re: remove DAV:version property", "content": "Use the DAV:checked-in property on the VCR URL to get the version resource\nURL.\n\nOnce you have the version resource URL, why do you need a property on that\nobject to tell you what you already know?\n\nCheers,\n-g\n\nOn Thu, Jan 25, 2001 at 04:01:26PM -0500, Jim Amsden wrote:\n> What if you got to the version through a version controlled resource and \n> wanted to get the persistent version URL for some reason. Or what if you \n> wanted to keep a  dictionary of version controlled resource URL and \n> version URLs?\n> \n> Jim Amsden\n> 919-543-3511\n> \n> \n> \n> \n> \n> \n> Since you cannot access a version without using the URL for that\n> version, the DAV:version property appears to be redundant (you\n> couldn't find that property unless you already knew the value of\n> that property).\n> \n> So I propose that we remove this property.  Any objections?\n> \n> Cheers,\n> Geoff\n> \n> \n> \n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-5249637"}, {"subject": "Re: remove DAV:version property", "content": "   From: Greg Stein <gstein@lyra.org>\n\n   btw, I just noticed: the expand-property example has an error: the\n   activity-set for .../ver/1 is missing <href> tags.\n\nThanks for noticing that!  Will fix.\n\n   [ also note that expand-property \"violates\" DTDs for properties. cool with\n     me, but some DTD fanatics will be up in arms. (e.g. version-history isn't\n     defined to contains a DAV:response element) ]\n\nGood point.\n\nThe only alternative I can see is to replace every occurrence of\n\"href\" in property definitions with \"href|response\", but that seems to\nme that it would cause more confusion than benefit to the reader.\n\nSince the DAV:response value will only come back in the\nDAV:expand-property report, only clients that understand this extended\nbehavior will encounter it.  So unless the working group feels\notherwise, I will address this point by adding some appropriate text\nto the DAV:expand-property section describing this DTD-extending\nimpact, and not by modifying the DTD's.  Is this OK?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5257389"}, {"subject": "Only one more week for the DeltaV Working Group last call", "content": "If there are any changes you would like made before the WebDAV\nversioning protocol is sent to the IESG for proposed standard status,\nnow's the time to suggest them!\n\n<http://www.webdav.org/deltav/protocol/draft-ietf-deltav-versioning-12.htm>\nor\n<http://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-12.txt>\n\nHere are the current set of proposed changes to the last call version\nof the WebDAV versioning protocol:\n\n- Section 1: Delete 2 sentences about working resource and workspace\n  options (Mark).\n\n- Section 2.3: Remove the DAV:version property (Geoff).\n\n- Section 7.5: Fix typo: is -> its (Mark).\n\n- Section 10: Rename \"baseline selector\" to be \"version-controlled\n  configuration\" (Geoff).\n\n- Section 10.6: Rename DAV:baseline-comparison to be\n  DAV:compare-baseline (Geoff).\n\n- Section 14.2: Fix precondition name to be\n  DAV:cannot-delete-default-variant (Tim).\n\n- Section 23.1: Make DAV:comment and DAV:creator-displayname value a\n  string (Eric).\n\n- Section 23.5: Add a note that the DAV:expand-property report\n  extends the property DTD's by allowing a DAV:response node wherever\n  a DAV:href can appear (Greg).\n\n- Section 23.5.1: Add missing DAV:href tags (Greg).\n\nThe results of these changes can be seen in:\n<http://www.webdav.org/deltav/protocol/draft-ietf-deltav-versioning-12.1.htm>\n\n\n\n", "id": "lists-006-5265840"}, {"subject": "RE: remove DAV:version property", "content": "What about getting the DAV:version property for the base resource, which\nif pass-through is working to the current target, should result in\ngetting the DAV:version for the current target?\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Geoffrey M.\n> Clemm\n> Sent: Thursday, January 25, 2001 12:06 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: remove DAV:version property?\n>\n>\n>\n> Since you cannot access a version without using the URL for that\n> version, the DAV:version property appears to be redundant (you\n> couldn't find that property unless you already knew the value of\n> that property).\n>\n> So I propose that we remove this property.  Any objections?\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-5274288"}, {"subject": "expand-property report (was: Re: remove DAV:version property?", "content": "On Thu, Jan 25, 2001 at 05:45:31PM -0500, Geoffrey M. Clemm wrote:\n>...\n>    [ also note that expand-property \"violates\" DTDs for properties. cool with\n>      me, but some DTD fanatics will be up in arms. (e.g. version-history isn't\n>      defined to contains a DAV:response element) ]\n> \n> Good point.\n> \n> The only alternative I can see is to replace every occurrence of\n> \"href\" in property definitions with \"href|response\", but that seems to\n> me that it would cause more confusion than benefit to the reader.\n> \n> Since the DAV:response value will only come back in the\n> DAV:expand-property report, only clients that understand this extended\n> behavior will encounter it.  So unless the working group feels\n> otherwise, I will address this point by adding some appropriate text\n> to the DAV:expand-property section describing this DTD-extending\n> impact, and not by modifying the DTD's.  Is this OK?\n\nDon't bother. I only mentioned it to tweak the DTD purists :-)\n\nDAV has the overall design point of \"other elements may appear within DAV:\nelements; ignore those that you don't understand.\" This is a simple case of\nthat.\n\nHowever, now that I'm thinking about it... it *is* important to note that\nany DAV:response embedded within the \"property value\" is not actually part\nof that value.\n\nHmm... Normally, we have a value such as:\n\n  <D:version-history>\n    <D:href>value</D:href>\n  </D:version-history>\n\nIn the expand-property report, the D:href is moved:\n\n  <D:version-history>\n    <D:response>\n      <D:href>value</D:href>\n      <D:propstat>...</D:propstat>\n    </D:response>\n  </D:version-history>\n\nPersonally, I think that is fine, but maybe it needs a bit of clarification.\nEspecially from that standpoint of \"what if other value(s) are in that\nproperty?\" For example:\n\n  <D:version-history>\n    <D:href>value</D:href>\n    <SVN:extension>something</SVN:extension>\n  </D:version-history>\n\nWhere does the SVN:extension go? Using the \"href -> response\" rewrite angle,\nthe result would be:\n\n  <D:version-history>\n    <D:response>\n      <D:href>value</D:href>\n      <D:propstat>...</D:propstat>\n    </D:response>\n    <SVN:extension>something</SVN:extension>\n  </D:version-history>\n\nGiven the above, clarification might be essential :-)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-5283429"}, {"subject": "Re: remove DAV:version property", "content": "   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   What about getting the DAV:version property for the base resource, which\n   if pass-through is working to the current target, should result in\n   getting the DAV:version for the current target?\n\nI'm not sure what you mean by \"if pass-through is working to the\ncurrent target\",  but in any case, as Greg pointed out, if you\nwant the version URL for the DAV:checked-in or DAV:checked-out\nversion of a version-controlled resource, you get that from the\nDAV:checked-in and DAV:checked-out property value.  There's no\nneed to have a second way of getting the same information.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5293406"}, {"subject": "Re: expand-property report (was: Re: remove DAV:version property?", "content": "   From: Greg Stein <gstein@lyra.org>\n\n   On Thu, Jan 25, 2001 at 05:45:31PM -0500, Geoffrey M. Clemm wrote:\n\n   >    ...  [ also note that expand-property \"violates\" DTDs for\n   >    properties. cool with me, but some DTD fanatics will be up in\n   >    arms. (e.g. version-history isn't defined to contains a\n   >    DAV:response element) ]\n   >\n   > ... I will address this point by adding some appropriate text\n   > to the DAV:expand-property section describing this DTD-extending\n   > impact, and not by modifying the DTD's.  Is this OK?\n\n   Don't bother. I only mentioned it to tweak the DTD purists :-)\n\nI added a sentence in the 12.1 draft, but could just take it back out\nif folks think it is unnecessary.  Any preferences?\n\n   DAV has the overall design point of \"other elements may appear within DAV:\n   elements; ignore those that you don't understand.\" This is a simple case of\n   that.\n\nWell ... I'd maintain that a client that issues the\nDAV:expand-property request MUST understand that DAV:response nodes\ncan replace DAV:href nodes, so I don't think it falls under the\n\"ignore those that you don't understand\" case, but rather the\n\"know the semantics of the request you just made\" case (:-).\n\n   However, now that I'm thinking about it... it *is* important to note that\n   any DAV:response embedded within the \"property value\" is not actually part\n   of that value.\n\nI believe that should be clear from the fact that you are not getting\na property value back, but rather an \"expanded\" property value.  So\nalthough the DAV:response is not part of the value, it is part of the\nDAV:expanded-property report.  But if you think that might be unclear,\nI'd be happy to add a sentence to that effect (unless you are going to\nhave me just take it out again :-).\n\n   Hmm... Normally, we have a value such as:\n\n     <D:version-history>\n       <D:href>value</D:href>\n     </D:version-history>\n\n   In the expand-property report, the D:href is moved:\n\n     <D:version-history>\n       <D:response>\n <D:href>value</D:href>\n <D:propstat>...</D:propstat>\n       </D:response>\n     </D:version-history>\n\nWell, I think it's simpler to just think of the DAV:href as being\nreplaced by a DAV:response node (which just so happens to have\na nested DAV:href node), rather than thinking about the DAV:href\nnode being moved somewhere.\n\n   Personally, I think that is fine, but maybe it needs a bit of clarification.\n   Especially from that standpoint of \"what if other value(s) are in that\n   property?\" For example:\n\n     <D:version-history>\n       <D:href>value</D:href>\n       <SVN:extension>something</SVN:extension>\n     </D:version-history>\n\n   Where does the SVN:extension go? Using the \"href -> response\" rewrite angle,\n   the result would be:\n\n     <D:version-history>\n       <D:response>\n <D:href>value</D:href>\n <D:propstat>...</D:propstat>\n       </D:response>\n       <SVN:extension>something</SVN:extension>\n     </D:version-history>\n\n   Given the above, clarification might be essential :-)\n\nIs there any other possible interpretation, given that the report is\ndefined as \"replacing the DAV:href node with a DAV:response node\"?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5301257"}, {"subject": "Re: &quot;baseline selector&quot; =&gt; &quot;version-controlled configuration&quot", "content": "Sure.\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK.\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n\"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com> on 2001-01-25 08:01:31 PM\n\nPlease respond to \"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com>\n\nTo:   ietf-dav-versioning@w3.org\ncc:\nSubject:  \"baseline selector\" => \"version-controlled configuration\"\n\n\n\n\n\nAs I was preparing the recently posted \"visual model\" of the WebDAV\nprotocol, it occurred to me that a more consistent name for a\n\"baseline selector\" would be a \"version-controlled configuration\"\n(since that is what it actually is).\n\nSo I propose that we get rid of the last remnant of the old \"selector\"\nterminology, and use \"version-controlled configuration\" instead.\nAny objections?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5312582"}, {"subject": "Re: expand-property report (was: Re: remove DAV:version property?", "content": "On Thu, Jan 25, 2001 at 10:31:32PM -0500, Geoffrey M. Clemm wrote:\n>...\n> Is there any other possible interpretation, given that the report is\n> defined as \"replacing the DAV:href node with a DAV:response node\"?\n\nNot that I can think of. I didn't think the report definition was as clear\nas that quote you just wrote, so maybe it *does* say that in there :-)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-5322055"}, {"subject": "Edgar`s comments to 12.", "content": "Hi,\nI finally managed to get some time (refusing to go for a walk with the rest of the family :-)\nto give some last comments to 12.1. Because I didn't have much time lately I couldn't make\na full review of even my pet themes but will again present a scenario I would like to able\nto realize with WebDAV and DELTA-V. \nI understand that even if some things I would like to do won't be possible with DELTA-V\nnevertheless it will be a fine foundation to build \"my goodies\" on. \n\nThanks Geoff, for posting the model. I couldn't view it at work (Too many ActiveX stuff which\nprobably was blocked by our company firewall. The navigation frame to the left didn't work)\nbut did so at home.\n\nI agree to the the sentiment somebody raised that DELTA-V is rather complex. So I also\nwould like to see a companion document (E.g. the FAQ mentioned in a recent posting).\nVariants e.g. would need an entry there in the context of solving the \"meaningful URL\"\nscenario discussed in the mailing list.\n\nNow my model and scenario for an application. I tried to make the example it as small as possible but still\nmeaningful enough.\nThe complete application has several variants. So a variant consists of of common and special components, \nwhere a component is defined by the members (not shown below) of a collection.\nNow let's have a look at the version history world and the newest version of the component.\nRemember that the hierarchy of the version histories doesn't imply that a baseline (what I would have called\njust a version)  of a collection belongs to a baseline of a parent collection. This relation could probably be\nrealized by a subbaseline. For components I added a version number.\napp#1 \ndoc\ncommon#1\nsun#1\nwin#1\ngui\nsun#1\nwin#1\ncode\ncommon#1\nsun#1\nwin#1\nsun#1\nwin#1\n\nFor the complete project with all components I say:\n app#1 = app/sun#1,app/win#1\n \nThe variants would be defined like this:\napp/win#1 = app/doc/common#1,app/doc/win#1,app/gui/win#1,app/code/common#1,app/code/win#1\napp/sun#1 = app/doc/common#1,app/doc/sun#1,app/gui/sun#1,app/code/common#1,app/code/sun#1\n\nNow somebody wants to work on the win part of the stuff (needs more bugfixes than SUN I guess :-)\nHe is creating a workspace containing the stuff he needs (Mapping collections to the workspace according to\ndevelopers taste. This feature avoids lenghty discussions on code structuring :-)\nwinbugws\ndoc\ncommon (app/doc/common)\nwin (app/doc/win)\ngui (app/gui/win)\ncode\ncommon (app/code/common)\nwin (app/code/win)\napp (app/win)\nSuppose he changes some stuff in the win gui. This will mean there is a app/gui/win#2.\nNow he would create an new win baseline:\napp/win#2 = app/doc/common#1,app/doc/win#1,app/gui/win#2,app/code/common#1,app/code/win#1\nIf somebody creates a new baseline of the complete project later only the win version number needs updating:\napp#2 = app/sun#1,app/win#2\n\nThat describes  in short what I built with RCS and Unix scripts. The implementation isn't very efficient and\nrestricted to one site. But the concept worked for a couple of thousand files, some dozens of developers and a lot of\nvariants over a couple of years.\nI guess I can realize this concept with DELTA-V following the way Geoff described in an earlier reply. Geoff, perhaps\nyou could add this scenario and it's tranlation to DELTA-V to the FAQ document ? Just a question. Sorry, that I want\nyou to do additional work but you are the person who could do it best I think.\n\nNow finally some comments to the draft:\nAs I understand it at the moment subbaselines are very important to port my model to DELTA-V.  So I'm not happy\nto read  in 10.2.2: \"A server that supports the baseline option MAY choose to not support the DAV:subbaseline-set\nproperty\". I would like to drop this sentence or at least change \"MAY choose to not support\" to \"SHOULD support\".\nSo the question is, do others also think my model makes sense and should be available to clients if the server supports\nbaselines ? Or are subbaselines a heavy burden on servers or server writers, so they want to avoid them ?\n\n1.3.1 Configuration\n\"Note that a collection (which is a single resource) is very different from a configuration (which is a set of resources)\"\nIn \"Collection Resource\" you state that \"A collection ... consists of ..., a set of named bindings ... . Note that a binding\nis not a resource ...\". Nevertheless this set of binding logically is equivalent to a set of resources. So I'm not sure I\nsee the big difference between collection and configuration.\n\n10 Baseline Option\n\"... A Configuration that contains a large number of resources can consume a large amount of space. This can make\nit prohibitively expensive to remember the state of an existing configuration by creating a copy of it's root collection.\nA 'Baseline' is ...\"\nIt doesn't sound good to me to create a new term based on assuming a dumb implementation (Naively creating a copy).\nWhy not just use a \"version of a collection\" ? Efficient implementation is the task of the implementation, not the\nprotocol.\n\nSo my main problem left with the latest draft is that I see two similar concepts: Configurations and Baselines to\ncapture their state versus Version-Controlled-Collections and their versions. I admit that there are differences\nbut nevertheless my feeling is that these two concepts should be merged somehow.\nI fear they will confuse future users of DELTA-V. So at least I would like to have the rationale to make them different\nmade clear in the aforementioned FAQ.\nAnother alternative perhaps would be 12. You describe some reasons for version controlled collections (Mentioning\nactivities, workspaces and merging. So it seems there is some entanglement between options. Which probably is\nunavoidable I fear). Could you also mention the difference to configurations and baselines here ? \n\nCheers, Edgar  \n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Native Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-5329732"}, {"subject": "Re: Edgar`s comments to 12.", "content": "   From: Edgar@EdgarSchwarz.de\n\n   I agree to the the sentiment somebody raised that DELTA-V is rather\n   complex. So I also would like to see a companion document (E.g. the\n   FAQ mentioned in a recent posting).  Variants e.g. would need an\n   entry there in the context of solving the \"meaningful URL\" scenario\n   discussed in the mailing list.\n\nWill do.  If you can add these as \"questions\" in the auto-faq that\nwas recently put up on the deltav site, that would be great, and\nI'll get \"answers\" posted.\n\n   Now my model and scenario for an application. I tried to make the\n   example it as small as possible but still meaningful enough.\n\n   The complete application has several variants. So a variant\n   consists of of common and special components, where a component is\n   defined by the members (not shown below) of a collection.\n\nThe versioning protocol uses the term \"configuration\" for what\nyou are calling a \"component\".  So if you want to track \"configuration\nversions\" (i.e. \"baselines\"), you would put the appropriate\ncollections under baseline control.  In the deltav, we use the\nterm \"variant\" for a set of version-controlled resources whose names\nare chosen by the server, whereas in your example below, your\nvariants (app/sun and app/win) have been named by the client,\nso to avoid confusion with the deltav use of the term, it's best\nnot to use the term \"variant\" to describe them.\n\n   Now let's have a look at the version history world and the newest\n   version of the component.\n\nTo avoid any misunderstanding, DeltaV would say \"the newest baseline\nof the baseline-controlled collection\".\n\n   Remember that the hierarchy of the version histories doesn't imply\n   that a baseline (what I would have called just a version) of a\n   collection belongs to a baseline of a parent collection.\n   This relation could probably be realized by a subbaseline.\n\nActually, what you have below is what deltav would call a hierarchy of\n\"version-controlled resources\" ... the version histories have\nrandom server assigned (non-human-meaningful) names.\n\nBut I agree that the version-controlled resource hierarchy does not\nimply that a baseline of a baseline-controlled collection \"belongs\" to\na baseline of a parent baseline-controlled collection, and I also\nagree that this relation is realized by the subbaseline relation.\n\n   For components I added a version number.\n\n   app#1 \n   doc\n   common#1\n   sun#1\n   win#1\n   gui\n   sun#1\n   win#1\n   code\n   common#1\n   sun#1\n   win#1\n   sun#1\n   win#1\n\nThe versioning protocol would call this a version-controlled resource\nhierarchy, with baseline-controlled collections annotated by the\nDAV:checked-out baseline of their version-controlled configuration.\n\n   For the complete project with all components I say:\n\n    app#1 = app/sun#1,app/win#1\n\nWhich is to say, baseline \"app#1\" has subbaselines \"app/sun#1\" and\n\"app/win#1\".\n\n   The variants would be defined like this:\n   app/win#1 = app/doc/common#1,app/doc/win#1,app/gui/win#1,\n                       app/code/common#1,app/code/win#1\n   app/sun#1 = app/doc/common#1,app/doc/sun#1,app/gui/sun#1,\n                       app/code/common#1,app/code/sun#1\n\nI.e. the baselines app/win#1 and app/sun#1 have the specified\nsubbaselines.\n\n   Now somebody wants to work on the win part of the stuff (needs more\n   bugfixes than SUN I guess :-).  He is creating a workspace containing\n   the stuff he needs (Mapping collections to the workspace according\n   to developers taste. This feature avoids lenghty discussions on\n   code structuring :-).\n\nAs a side note, having the developers making up names for the\ncomponents would make me worry about breakage of the inter-component\n#include and Makefile references, but maybe I just worry too much (:-).\n\n   winbugws\n   doc\n   common (app/doc/common)\n   win (app/doc/win)\n   gui (app/gui/win)\n   code\n   common (app/code/common)\n   win (app/code/win)\n   app (app/win)\n\nSo the developer has created a workspace called \"winbugws\",\nand has put the winbugws/doc/comm, winbugws/doc/win,\nwinbugws/gui, winbugws/code/common, winbugws/code/win,\nand winbugws/app collections under baseline control,\nusing the DAV:checked-in baseline from the specified\nbaseline-controlled collections in the \"team\" tree of\nversion-controlled resources described above.\n\n   Suppose he changes some stuff in the win gui. This will mean there\n   is a app/gui/win#2.\n\nSo that must mean he made changes in winbugws/gui, checked out the\nversion-controlled configuration of winbugws/gui, and then checked\nit back in to create the new baseline (i.e. app/gui/win#2).\n\n  Now he would create an new win baseline:\n\n   app/win#2 = app/doc/common#1,app/doc/win#1,app/gui/win#2,\n                       app/code/common#1,app/code/win#1\n\nSo that meant that he checked out the version-controlled configuration\nof winbugws/app, PROPPATCH'ed its DAV:subbaseline property to replace\napp/gui/win#1 with app/gui/win#2, and then checked\nit back in to create the new baseline, app/win#2.\n\n   If somebody creates a new baseline of the complete project later\n   only the win version number needs updating:\n\n   app#2 = app/sun#1,app/win#2\n\nWhich means that he checked out the version controlled configuration\nof app, and PROPPATCH'ed its DAV:subbaseline property to replace\napp/win#1 with app/win#2, and then checked it back in to create\nthe baseline app#2.\n\n   That describes in short what I built with RCS and Unix scripts. The\n   implementation isn't very efficient and restricted to one site. But\n   the concept worked for a couple of thousand files, some dozens of\n   developers and a lot of variants over a couple of years.\n\nLooks fine to me.\n\n   I guess I can realize this concept with DELTA-V following the way\n   Geoff described in an earlier reply. Geoff, perhaps you could add\n   this scenario and it's tranlation to DELTA-V to the FAQ document ?\n   Just a question. Sorry, that I want you to do additional work but\n   you are the person who could do it best I think.\n\nThis scenario is probably better located in the \"scenario's\" document\nrather than the FAQ, but I agree that this is a good scenario to\ndocument.\n\n   Now finally some comments to the draft:\n\n   As I understand it at the moment subbaselines are very important to\n   port my model to DELTA-V.  So I'm not happy to read in 10.2.2: \"A\n   server that supports the baseline option MAY choose to not support\n   the DAV:subbaseline-set property\". I would like to drop this\n   sentence or at least change \"MAY choose to not support\" to \"SHOULD\n   support\".\n\nPractically speaking, there isn't much difference between \"MAY choose\nto not support\" and \"SHOULD support\", but I'd be happy to make this\nchange if nobody objects.\n\nDoes anybody object?\n\n   So the question is, do others also think my model makes sense and\n   should be available to clients if the server supports baselines ?\n   Or are subbaselines a heavy burden on servers or server writers, so\n   they want to avoid them ?\n\nI don't think anyone disagrees with the concept of a sub-baseline.\nBut I believe that there are a number of versioning systems that support\nbaselines but that do not (yet) support sub-baselines, and so a client\nneeds to be prepared for that situation (producing efficient, reliable,\nscalable subbaseline support is actually not that easy).\n\n   1.3.1 Configuration\n\n   \"Note that a collection (which is a single resource) is very\n   different from a configuration (which is a set of resources)\" In\n   \"Collection Resource\" you state that \"A collection ... consists of\n   ..., a set of named bindings ... . Note that a binding is not a\n   resource ...\". Nevertheless this set of binding logically is\n   equivalent to a set of resources.\n\nI disagree.  Suppose we're at a family reunion and I ask you to give\nmy grandmother a ride home.  She has \"bindings\" to all of her\nchildren.  Giving just my grandmother a ride home is very different\nfrom giving her, her four children, and her 28 grand-children a ride\nhome (:-).\n\n   So I'm not sure I see the big\n   difference between collection and configuration.\n\nThe difference is critical when apply an operation.  Basically,\nit's the difference between a \"Depth:0\" operation and a \"Depth:infinity\"\noperation.  In versioning, this is the difference between a\n\"version\" and a \"baseline\" of a collection.\n\n   10 Baseline Option\n\n   \"... A Configuration that contains a large number of resources can\n   consume a large amount of space. This can make it prohibitively\n   expensive to remember the state of an existing configuration by\n   creating a copy of it's root collection.  A 'Baseline' is ...\"  It\n   doesn't sound good to me to create a new term based on assuming a\n   dumb implementation (Naively creating a copy).  Why not just use a\n   \"version of a collection\"?\n\nThis was just intended to provide motivation for why you need a\n\"version\" of a collection at all.  Some reasons for distinguishing\nbetween a (depth:0) version of a collection and a (depth:infinity)\nbaseline of a collection are given in the version-controlled\ncollection section.\n\n   Efficient implementation is the task of the implementation, not the\n   protocol.\n\nBut it is the task of the protocol to allow for efficient\nimplementations, and to allow for a variety of implementations.\n\n   So my main problem left with the latest draft is that I see two\n   similar concepts: Configurations and Baselines to capture their\n   state versus Version-Controlled-Collections and their versions.\n\nYes, it's the difference between capturing the Depth:infinity state of\na collection and the Depth:0 state of a collection.\n\n   I admit that there are differences but nevertheless my feeling is\n   that these two concepts should be merged somehow.  I fear they will\n   confuse future users of DELTA-V. So at least I would like to have\n   the rationale to make them different made clear in the\n   aforementioned FAQ.\n\nFair enough.\n\n   Another alternative perhaps would be 12. You describe some reasons\n   for version controlled collections (Mentioning activities,\n   workspaces and merging. So it seems there is some entanglement\n   between options. Which probably is unavoidable I fear). Could you\n   also mention the difference to configurations and baselines here ?\n\nThat's a good suggestion.  I'll see if I can reword section 12\nto make that point there.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5342832"}, {"subject": "RE: Comment", "content": "> - Thanks for catching the 7.5 typo ... will fix.\n\nThanks.\n\n> - Concerning the statement about working-resource and\n> workspace options, I'm happy to delete this sentence,\n> since I don't see that it improves interoperability,\n> and could incorrectly lead a reader to believe that\n> the options are inconsistent.  So I'll delete this sentence\n> unless anyone objects.\n\nThanks.\n\n> - As for the complexity of the protocol, if there is\n> something that you would like to see addressed before\n> we send the protocol to the IESG for \"proposed standard\"\n> status, please identify the specific issue during the\n> working group last call period (i.e. before 2/1/01).\n> It is my belief that the complexity issues have been\n> adequately addressed by clearly identifying the part\n> of the document that should be read by those only\n> interested in \"core\" versioning functionality.  Each of\n> the options consist of functionality that is currently\n> supported by multiple versioning repositories, and\n> therefore it significantly contributes to interoperability\n> to provide an option that standardizes access\n> to that functionality.\n\nI agree with what you've stated here in the segregation of the functionality\nto aid in understanding and implementation of the current specification.\n\nMy thoughts about complexity are in two areas.\n\n1)  HTTP\n\nThe marshalling in DeltaV is designed around WebDAV's premise as an HTTP\nextension.  This was a design decision for WebDAV and I am not going to\nargue on way or the other on this issue.  My only comment is that there may\nbe people that want to implement the WebDAV+DeltaV specification that\nparticipate in other transport agnostic standards.  In that case, DeltaV is\na very specific implementation and may appear complex relative to the other\nagnostic activities.\n\n2)   Marshalling\n\nIMHO, the marshalling in the current version of the specification is very\nfine grained.  The number of properties is large and the number of\nclient-server transactions to accomplish a specific activity can be\npotentially as large.\n\nMy experiences have shown that fine grained specifications can also result\nin less interoperability.  In this case, I speculate that disparate client\nand server vendors will need to work closely to insure that the\nimplementations are consistent and function as expected on either end.\nThis may result in one-off client-server implementations.  Again, this is\nspeculative and does not specifically address items in the proposal.\n\nA number of others have also commented on complexity.  I am interested in\nseeing how they describe their thoughts.\n\n\nOverall, the team had worked hard to develop a specification on a very\ndifficult subject  and I for one appreciate the efforts that have gone into\nthis.\n\nThank you and have a good day,\n\nMark\n\n\n\n", "id": "lists-006-5360236"}, {"subject": "Re (2): Edgar`s comments to 12.", "content": ">    FAQ mentioned in a recent posting).  Variants e.g. would need an\n>    entry there in the context of solving the \"meaningful URL\" scenario\n>    discussed in the mailing list.\n> \n> Will do.  If you can add these as \"questions\" in the auto-faq that\n> was recently put up on the deltav site, that would be great, and\n> I'll get \"answers\" posted.\nI will think about that.\n\n> As a side note, having the developers making up names for the\n> components would make me worry about breakage of the inter-component\n> #include and Makefile references, but maybe I just worry too much (:-).\nI see your concerns :-) But for that there are some Makefiletemplates\nand conventions which are used projectwide.\n\n>    the DAV:subbaseline-set property\". I would like to drop this\n>    sentence or at least change \"MAY choose to not support\" to \"SHOULD\n>    support\".\n> \n> Practically speaking, there isn't much difference between \"MAY choose\n> to not support\" and \"SHOULD support\", but I'd be happy to make this\n> change if nobody objects.\nI guess you are right but nevertheless a SHOULD shows that the RFC authors\ngive it some value. MAY feels a little bit indifferent :-)\nSo to get some data. Somebody out there who already made up his mind about\nsupporting baselines ? With or without subbaselines ?\n\n>    So I'm not sure I see the big\n>    difference between collection and configuration.\n> \n> The difference is critical when apply an operation.  Basically,\n> it's the difference between a \"Depth:0\" operation and a \"Depth:infinity\"\n> operation.  In versioning, this is the difference between a\n> \"version\" and a \"baseline\" of a collection.\nOK, that's a description I understand and agree with. I guessed so much but\ndidn't find is so clearly stated yet.\n\nSo I think we are clean enough for going to IETF !\n\nCheers, Edgar\n\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Native Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-5369930"}, {"subject": "Patche", "content": "What's the best way to model a patch set in deltaV?  (Let's say I want to\ncreate a\nconfiguration including only the files in a collection, recursively, that\nhave changed since\na particular baseline.)\n\n--Eric\n\n\n\n", "id": "lists-006-5378526"}, {"subject": "RE: Patche", "content": "You can create a new baseline in the collection,\nand then use the DAV:compare-baseline report\nto describe the differences.\n\nCreating a collection that just contains the\n\"changed files\" doesn't really capture the change,\nsince it can only capture additions, and not\nmoves or deletions.\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\nSent: Wednesday, January 31, 2001 2:43 PM\nTo: DeltaV (E-mail)\nSubject: Patches\n\n\nWhat's the best way to model a patch set in deltaV?  (Let's say I want to\ncreate a\nconfiguration including only the files in a collection, recursively, that\nhave changed since\na particular baseline.)\n \n--Eric\n\n\n\n", "id": "lists-006-5385365"}, {"subject": "Comments on -12: properties, REPORT, OPTION", "content": "Properties:\n\nIn Section 1.5.2:\n\n1) \"A protected property cannot be updated with a PROPPATCH request.\"\n\nThis this is a requirement, I recommend changing the \"cannot\" to a \"MUST\nNOT\" since that is the intent of the text, and \"MUST NOT\" has a specific\nmeaning according to RFC 2119.\n\n2) On the flip side, if a DeltaV property is not protected, is it the case\nthat it MUST be writable using PROPPATCH, unless the property definition\nexplicitly states otherwise (of course, writable assuming you have write\naccess permissions).  In particular, does a client have a guarantee that it\nwill always be able to write to, say, DAV:comment, and\nDAV:creator-displayname?\n\n3) \"Note that a given property can be protected on one kind of resource, but\nnot protected on another kind of resource.\"\n\nThis sounds a bit odd to me.  What examples do we have of this?\n\nREPORT:\n\nREPORT doesn't fit in Section 23.  REPORT is a new, complex method that\npredominantly extends the capabilities of RFC 2518, rather than clarifying\nexisting capabilities in 2518. So far, REPORT is only used in this draft,\nhence though it may have utility broader than just the DeltaV draft, so far\nthere aren't any additional users.  It may make sense, at some point in the\nfuture, to include this in the Distributed Authoring specification.  But for\nnow, having it in a section titled \"Clarifications and Extensions to RFC\n2518\" is a bit strange -- the *entire* specification could be labeled\nextensions to 2518.  Additionally, sometimes people view appendicies as\nbeing non-normative -- do you want to send the message that you can safely\nignore implementing REPORT?  The definition of REPORT can be placed\nelsewhere in the specification, and just note that the authors recommend it\nbe incorporated into a revision of RFC 2518, due to its potentially broad\nutility.\n\nOPTIONS:\n\nSection 23.6:\n\n1) I think it makes sense to keep things open for additional OPTIONS\nextensions.  So, I would rephrase this as, if you include an XML request\nbody with OPTIONS, here is what it means, and it must include the following\nXML element.  Right now you're cutting off all possible future extension to\nOPTIONS that doesn't use XML, and that is overcontraining.\n\n2) I'm not sure why the \"supported-method-set\" capability is present, since\nit duplicates the existing functionality of OPTIONS, specifically the Allow\nheader.  If the example in 23.6.1 were correct, it would highlight this.\nThe correct *response* for the example in 23.6.1 is:\n\nHTTP/1.1 200 OK\nDAV: 1, 2, version-control\nAllow: GET, HEAD, PUT, OPTIONS, DELETE, TRACE, PROPFIND, PROPPATCH, LOCK,\nUNLOCK, COPY, MOVE, VERSION-CONTROL, CHECKOUT, CHECKIN\nContent-Type: text/xml; charset=\"utf-8\"\nContent-Length: xxxx\n\n<?xml version=\"1.0\" encoding=\"uft-8\"?>\n<D:options-response xmlns:D=\"DAV:\">\n  <D:supported-method-set>\n     <D:supported-method D:name=\"VERSION-CONTROL\" />\n  <D:supported-method-set>\n...\n\nSo, the same information is in the Allow header, and the supported-method\nelement.  IMO, there is no clear advantage to duplicating this capability.\n\n3) Within supported-live-property-set, and supported-report-set, why not\nmarshall the live properties, and reports, as comma separated lists?  It has\nthe dual advantage of being more compact, and easier to read. DeltaV clients\nmust have the ability to parse comma separated lists, so it's not like this\nis a huge imposition.\n\n4) What are the semantics if there is an XML request body for OPTIONS, and\nthis request body does not include a DAV:supported-method-set,\nDAV:supported-live-property-set, or DAV:supported-report-set at all (i.e.,\nwhat happens if one or more are just plain omitted)?\n\n- Jim\n\n\n\n", "id": "lists-006-5393150"}, {"subject": "Section 2.1.1 comment", "content": "Section 2.1.1:\n\nIt took me a long time to figure out exactly what was being described here.\nI think my confusion derived from not understanding that there were three\nseparate entities being discussed:\n\n- version-controlled resource\n- version resource\n- version history\n\nI think my confusion would be eased by changing the second, third, and\nfourth sentences of the first paragraph of Section 2.1.1 to more clearly\nidentify the three resources, and the fact that the unversioned resource is\nbeing converted into a new type of resource, the version-controlled\nresource.\n\n----------\n\nVERSION-CONTROL, when invoked on a resource with URL U, performs three\ndistinct operations:\n\n1) It creates a new \"version resource\" whose body and dead properties are a\ncopy of the original, unversioned resource. The server assigns this resource\na new URL, VR, which is different from the original URL U.\n2) It converts the unversioned resource into a \"version-controlled\nresource\". The version-controlled resource keeps the original URL U. As part\nof this conversion, it adds the DAV:checked-in property, whose value is the\nURL of the version resource created in step #1.\n3) It creates a new \"version history resource\" whose state initially just\ncontains URL VR, since that is, at present, the only version in the version\nhistory.\n\nThus, whereas before VERSION-CONTROL, there was only one, unversioned\nresource, after VERSION-CONTROL there are three separate, distinct\nresources, each containing their own state and properties: the\nversion-controlled resource, the version resource, and the version history\nresource. In core versioning, a version history resource is not assigned a\nURL, and hence is not visible in the http scheme URL space. However, when\nthe version-history option (Section 5) is supported, this changes, and the\nversion history resource does have a URL.\n\n----------\n\nWith this change, the first sentence of the second paragraph is no longer\nneeded.\n\nI recommend moving the third paragraph, and the figure following, to\nimmediately after the second paragraph. Plus, I recommend labeling all of\nthe boxes in the figure, as follows:\n\n\n          ===VERSION-CONTROL==>\n\n                    |                       +----+\n                    |                       |    | version history\n                    |                       +----+\n                    |                         |\n        /foo.html   |   /foo.html             |\n                    |                         v\n         +----+     |     +----+ checked-in +----+\n         | S1 |     |     | S1 | ---------->| S1 | version resource\n         +----+     |     +----+            +----+ URL: /hist/73/v1\n      unversioned   | version-controlled\n        resource    |     resource\n\nAdding an arrowhead to the lines between the version-controlled resource and\nthe version resource, and the version history and the version resource,\nwould also be helpful, since this is fairly conventional for pointers.\n\nIn the third paragraph, the third sentence (\"The new version resource is\nidentified...\") should be changed to:\n\n\"The original unversioned resource is converted into a version-controlled\nresource, whose DAV:checked-in property identifies the version resource.\"\n\nUsing \"version-controlled resource\" is more clear than using the elliptical\n\"resource that is now under version control.\" (The artist formerly known as\nPrince... ;-)\n\n\nIn the second paragraph, I recommend changing the second sentence \"When a\nmethod is applied...\" to:\n\nSince the version-controlled resource and version resources are separate,\ndistinct resources, when a method is applied to the version-controlled\nresource, it only applies to the version-controlled resource, and does not\napply to the version resource that is currently identified by the\nDAV:checked-in property.\n\n- Jim\n\n\n\n", "id": "lists-006-5404095"}, {"subject": "CHECKIN and propertie", "content": "Section 2.2 and Section 2.3:\n\nIs it a MUST level requirement that a core versioning server support all of\nthe properties in sections 2.2 and 2.3?  I.e., MUST a version-controlled\nresource have all of the Section 2.2 properties defined upon it (well,\nreally, all that are appropriate for its checked out/checked in state), and\nMUST a version resource have all of the Section 2.3 properties defined on\nit?  If so, I couldn't find a place that explicitly states this.\n\nSection 2.2.3:\n\nIt seems like, most of the time, the server will be setting the value of\nDAV:predecessor-set, and except for merges, or adding to the server-computed\nvalue, the client shouldn't try to write to this property.  Is this correct?\nIf so, it would be nice to capture this in Section 2.2.3, so client writers\nhave a better expectation about how this property works.\n\nSection 2.2.5:\n\nThis seems underspecified to me. There are really two parameters here,\nresource is write-locked/unlocked, and autoversion status of when-unlocked,\nand when-locked.  We can make a table, and indicate areas that are specified\nin this section\n\n                      write-locked                      unlocked\n(non-write-locked)\n\nwhen-unlocked                                      A modification request is\nautomatically\n                          ???                      preceded by a checkout\noperation, and\n                    (same as unlocked?)            automatically followed by\na checkin.\n\nwhen-locked       A modification request is\n                  automatically preceded by a\n                  checkout operation, and an                     ???\n                  automatic checkin operation is    (same as above?\n(when-unlocked, unlocked))\n                  applied when the applied when\n                  the write lock is removed.\n\nAlso, what happens when the resource is write-locked, and the value of\nDAV:auto-version is changed from when-locked to when-unlocked?  Is a version\nautomatically created upon successful completion of the PROPPATCH (because\nthere would already be an active CHECKOUT due to the lock, and the\nwhen-locked condition)?\n\nSection 3.2:\n\nCHECKIN takes a version-controlled resource, and turns it into a version\nresource which is a copy of its body and dead properties.  Properties that\nmust exist on a checked-out version-controlled resource are:\n\nDAV:checked-out\nDAV:predecessor-set\nDAV:precursor-set\nDAV:auto-version\n\nWhich of these properties should be transferred over to the version resource\ncreated by CHECKIN?  My guess is:\n\nDAV:checked-out: no\nDAV:predecessor-set: yes\nDAV:precursor-set: yes\nDAV:auto-version: no\n\nAt the very least, this issue is not currently addressed in the\nspecification (except for DAV:predecessor-set).  DAV:precursor-set behavior\nis described implicitly (by the existence of the property on a version\nresource) -- I think it should be made more explicit, in the description of\nCHECKIN.\n\nThe text describing the (DAV:checked-in) postcondition should explicitly\nnote that the properties being discussed are on the version-controlled\nresource, and not the version resource.\n\n- Jim\n\n\n\n", "id": "lists-006-5414741"}, {"subject": "PROPFIND, VCRs, Label, Depth, href ... oh my", "content": "I've been thinking a bit about PROPFIND and the Label: header. Let's say\nthat I do a PROPFIND against a VCR using a Label header:\n\nPROPFIND /some/vcr\nLabel: foo\n\nresponse...\n<D:multistatus ...>\n  <D:response>\n    <D:href>/the/version/resource</D:href>\n...\n\nThe DAV:href element presumably has the version resource URI because you did\na PROPFIND against that resource (effectively).\n\n\nNow, let's throw the Depth: header into the mix. What does it apply to? The\nVCR or the Version? It is murky with the Label: header in there.\n\nDepth applies to the VCR:\n    The PROPFIND will return DAV:response elements for version resources\n    corresponding to those selected by the label, from each of the VCRs\n    according to the Depth.\n    \n    DAV:href returns Version Resource URIs. How do we match them up against\n    the hierarchy defined by the VCRs?\n\nDepth applies to the Version Resource:\n    Presumably, you're selecting a collection version. Its children are\n    version histories, so you're going to get back whacky properties or\n    nothing at all for the children.\n\n    The DAV:href probably would exist here, too: which DAV:response is for\n    the collection version, and which for the members?\n    [ you could tell by looking for errors :-) ]\n\n\nOkay... let's try to fix the DAV:href thingy by saying you apply the Depth:\nheader to the VCRs (i.e. apply Depth to the VCR before linking thru to the\nversion resources) and the DAV:href returns the VCRs' URIs. That makes some\nsense, but now we have a problem: how do we get the version resource URI? We\ncan't use DAV:checked-in because that is a VCR prop. And, oh darn! We just\nnuked DAV:version.\n\n\nMy suggestion:\n\n*) define Depth: on a PROPFIND of a VCR to apply to the VCR hierarchy rather\n   than the version resource (lack of) hierarchy\n\n*) the DAV:href returns the VCR's URI\n   [ I'm not sure that I like this, though :-( ]\n\n*) bring back DAV:version\n\n\nHmm. I'm thinking that the use of a Label: header is rather spurious to the\nabove issue. It does make it a bit harder to figure out the version resource\nURI (without the Label:, you could ask for the VCR's DAV:checked-in; there\nisn't an easy equivalent to find the V.R. when you're trying to use a label)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-5424717"}, {"subject": "Re: Comments on -12: properties, REPORT, OPTION", "content": "> Properties:\n>\n> In Section 1.5.2:\n>\n> 1) \"A protected property cannot be updated with a PROPPATCH\n> request.\"\n>\n> This this is a requirement, I recommend changing the \"cannot\"\n> to a \"MUST NOT\" since that is the intent of the text, and \"MUST\n> NOT\" has a specific meaning according to RFC 2119.\n\nI agree.\n\n> 2) On the flip side, if a DeltaV property is not protected, is\n> it the case that it MUST be writable using PROPPATCH, unless\n> the property definition explicitly states otherwise (of course,\n> writable assuming you have write access permissions).  In\n> particular, does a client have a guarantee that it will always\n> be able to write to, say, DAV:comment, and DAV:creator-displayname?\n\nIf there is an unprotected property defined it is not the case that a\nclient can always PROPPATCH it, since that property may not be supported by\nthe server.  For example, if the server does not support the activity\noption it MUST fail an attempt to PROPPATCH the unprotected workspace\nproperty DAV:current-activity-set.\n\n> 3) \"Note that a given property can be protected on one kind of\n> resource, but not protected on another kind of resource.\"\n>\n> This sounds a bit odd to me.  What examples do we have of this?\n\nI'm surprised that you find this odd<g>.  An example is DAV:predecessor-set\nwhich is protected on a version, and unprotected on a version-controlled\nresource.  It seems no more odd to me than the content of a resource being\nimmutable on a version and mutable on a versionable resource.\n\n> REPORT:\n>\n> REPORT doesn't fit in Section 23.  REPORT is a new, complex\n> method that predominantly extends the capabilities of RFC 2518,\n> rather than clarifying existing capabilities in 2518. So far,\n> REPORT is only used in this draft, hence though it may have\n> utility broader than just the DeltaV draft, so far there aren't\n> any additional users.  It may make sense, at some point in the\n> future, to include this in the Distributed Authoring specification.\n> But for now, having it in a section titled \"Clarifications and\n> Extensions to RFC 2518\" is a bit strange -- the *entire*\n> specification could be labeled extensions to 2518.  Additionally,\n> sometimes people view appendicies as being non-normative -- do\n> you want to send the message that you can safely ignore\n> implementing REPORT?  The definition of REPORT can be placed\n> elsewhere in the specification, and just note that the authors\n> recommend it be incorporated into a revision of RFC 2518, due\n> to its potentially broad utility.\n\nI agree with your observations for this editorial change that I'll leave up\nto the authors to resolve.\n\n> OPTIONS:\n>\n> Section 23.6:\n>\n> 1) I think it makes sense to keep things open for additional\n> OPTIONS extensions.  So, I would rephrase this as, if you\n> include an XML request body with OPTIONS, here is what it means,\n> and it must include the following XML element.  Right now\n> you're cutting off all possible future extension to OPTIONS\n> that doesn't use XML, and that is overcontraining.\n\nAgreed.\n\n> 2) I'm not sure why the \"supported-method-set\" capability\n> is present, since it duplicates the existing functionality\n> of OPTIONS, specifically the Allow header.  If the example\n> in 23.6.1 were correct, it would highlight this.\n>\n> The correct *response* for the example in 23.6.1 is:\n\n<<snip>>\n\n> So, the same information is in the Allow header, and the\n> supported-method element.  IMO, there is no clear advantage\n> to duplicating this capability.\n\nAgreed.\n\n> 3) Within supported-live-property-set, and supported-report-set,\n> why not marshall the live properties, and reports, as comma\n> separated lists?  It has the dual advantage of being more compact,\n> and easier to read. DeltaV clients must have the ability to\n> parse comma separated lists, so it's not like this is a huge\n> imposition.\n\nThe values used to be comma separated lists, and I don't remember why\nsomebody asked for the change.\n\n> 4) What are the semantics if there is an XML request body\n> for OPTIONS, and this request body does not include a\n> DAV:supported-method-set, DAV:supported-live-property-set,\n> or DAV:supported-report-set at all (i.e., what happens if\n> one or more are just plain omitted)?\n\nThen the corresponding response elements are 'just plain omitted'.\n\n\nTim\n\n\n\n", "id": "lists-006-5433921"}, {"subject": "Extensibility for all DeltaV method", "content": "DeltaV methods which take request bodies are extensible, in that the DTDs\nfor the top-level element in the body are all declared to allow ANY\nsub-elements. However, there are three methods which are not defined to take\nrequest bodies: MKACTIVITY, MKWORKSPACE, and UNCHECKOUT. Should the protocol\nexplicitly declare that they can be extended by defining request bodies for\nthem?\n\nJohn\n\n\n\n", "id": "lists-006-5446145"}, {"subject": "Re: Patche", "content": "(Question 1) I agree that moves and deletions make the\nDAV:baseline-comparison REPORT more expressive than a sparse\nconfiguration concept would be. But I'm concerned whether\nthis lends itself to efficient implementation for release\nmanagement purposes. For large products, baselines are big,\nand patch deltas between them might often be small. Would\ntime and space efficiency suffer because the only way to\nname the (small) patch is to compare two (big) baselines?\n\nOf course, a release management system could cache the\nresults of the DAV:baseline-comparison REPORT, but this\nwould not be a namable WebDAV resource in the URL namespace.\n\n\n(Question 2) Suppose an author wanted to define a patch as\nthe set of merge target versions from a patch activity into\nthe mainline activity, where the reference baseline was the\nbaseline defining the initial release. How could the patched\nbaseline be computed?\n\nRoy\n\n\"Clemm, Geoff\" wrote:\n> \n> You can create a new baseline in the collection,\n> and then use the DAV:compare-baseline report\n> to describe the differences.\n> \n> Creating a collection that just contains the\n> \"changed files\" doesn't really capture the change,\n> since it can only capture additions, and not\n> moves or deletions.\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\n> Sent: Wednesday, January 31, 2001 2:43 PM\n> To: DeltaV (E-mail)\n> Subject: Patches\n> \n> What's the best way to model a patch set in deltaV?  (Let's say I want to\n> create a\n> configuration including only the files in a collection, recursively, that\n> have changed since\n> a particular baseline.)\n> \n> --Eric\n\n\n\n", "id": "lists-006-5454129"}, {"subject": "RE: Comments on -12: properties, REPORT, OPTION", "content": "Tim Ellison writes:\n> > 2) On the flip side, if a DeltaV property is not protected, is\n> > it the case that it MUST be writable using PROPPATCH, unless\n> > the property definition explicitly states otherwise (of course,\n> > writable assuming you have write access permissions).  In\n> > particular, does a client have a guarantee that it will always\n> > be able to write to, say, DAV:comment, and DAV:creator-displayname?\n>\n> If there is an unprotected property defined it is not the case that a\n> client can always PROPPATCH it, since that property may not be\n> supported by the server.  For example, if the server does not support\n> the activity option it MUST fail an attempt to PROPPATCH the unprotected\n> workspace property DAV:current-activity-set.\n\nSure, I agree completely.  What I was driving at was, if the server\nsignals that it does support the activity option, does that then\nmean the server MUST allow writing to DAV:current-activity-set via\nPROPPATCH?\n\n> > 3) \"Note that a given property can be protected on one kind of\n> > resource, but not protected on another kind of resource.\"\n> >\n> > This sounds a bit odd to me.  What examples do we have of this?\n>\n> I'm surprised that you find this odd<g>.  An example is\n> DAV:predecessor-set\n> which is protected on a version, and unprotected on a version-controlled\n> resource.  It seems no more odd to me than the content of a resource being\n> immutable on a version and mutable on a versionable resource.\n\nAh, OK, this does seem reasonable.  The text just hit me the wrong way.\n\n> > 4) What are the semantics if there is an XML request body\n> > for OPTIONS, and this request body does not include a\n> > DAV:supported-method-set, DAV:supported-live-property-set,\n> > or DAV:supported-report-set at all (i.e., what happens if\n> > one or more are just plain omitted)?\n>\n> Then the corresponding response elements are 'just plain omitted'.\n\nThat makes sense, but it should be specified.  Another perfectly\nreasonable response is to flag the input as a syntax error, since\nit's missing an expected XML element, and this could cause\ninteroperability problems.\n\n- Jim\n\n\n\n", "id": "lists-006-5462775"}, {"subject": "Comments on VERSION-CONTRO", "content": "1) Section 2.4 states:\n\n> If the request-URL identifies a version-controlled resource,\n> the request is ignored.  This allows a client to be unaware\n> of whether or not a server automatically puts a resource under\n> version control when it is created.\n\nThis is good -- it allows a client to apply VERSION-CONTROL to an entire\ndirectory without having to first check and see if all resources are under\nversion control.\n\nBut then in the Postconditions section it states:\n\n> (DAV:already-under-version-control): If the request-URL identified\n> a resource already under version control at the time of the request,\n> the VERSION-CONTROL request MUST NOT change the state of that\n> version-controlled resource, and the DAV:checkout-response body MUST\n> contain a DAV:already-version-controlled element.\n\nSince it is my understanding that invoking VERSION-CONTROL on a resource\nwith URL U has the effect of converting the resource at URL U into a\nversion-controlled resource (as well as creating a new version resource, and\na new version history resource), this appears to contradict the ignore rule\ngiven at the beginning of Section 2.4.  I can see flagging an error if\nVERSION-CONTROL is invokved on a version resource, or a version history\nresource, so perhaps that was the intent of this postcondition.\n\nOr maybe the intent is that no action will be taken, but a\nDAV:already-under-version-control element will be present (with a 200 OK\nresponse code? -- this too is unclear).\n\n2) It was unclear to me why VERSION-CONTROL departed from the standard\nconvention concerning reporting of postcondition errors by requiring that\nthe response body begin with a DAV:version-control XML element.  As\ndescribed in Section 23.2, the postcondition element is typically reported\nwith a 403 or 409, and is the first XML element after the <?xml\nversion=\"1.0\" encoding=\"utf-8\"?> preamble.  This is being changed by\nVERSION-CONTROL's requirement that the DAV:version-control element must come\nbefore the DAV:already-version-controlled element.  But, since there is the\nadditional postcondition of DAV:put-under-version-control, it is also\npossible to have a response that doesn't fit the XML specification under\n\"Marshalling\" in Section 2.4 (or at least makes this slightly\nunderspecified), since there can be an element that doesn't have\nDAV:version-control before it.\n\n3) In addition to DAV:checked-in, VERSION-CONTROL MUST also set the values\nof other properties on the version-controlled resource, and the version\nresource -- more is happening with properties than just setting the value of\nDAV:checked-in. Other properties that need to be addressed:\n\nOn the version-controlled resource:\nDAV:auto-version:\na) It seems to me the server MAY set a default value for this if it supports\nauto-versioning. This depends on the meaning of DAV:auto-version not being\npresent at all, and the meaning of DAV:auto-version being an empty property.\nWe coudl either require DAV:auto-version to always be present, but it might\nbe empty, or we could have it not be there, and have that signal no\nauto-versioning.\n\n*) This certainly raises the issue that, at present, the value of an empty\nDAV:auto-version property is not specified, and should be.\n\nOn the version resource:\n\nDAV:version :: The server MUST set the value of this.\nDAV:predecessor-set :: The server MUST set the value of this, to empty.\nDAV:successor-set :: The server MUST set the value of this, to empty.\nDAV:version-name :: The server MUST set the value of this.\n\n*) Additionally, in Section 5.9, the additional semantics should include\nadding the version-history specific properties in 5.2 and 5.3 to the\nversion-controlled resource, and the version resource.\n\n- Jim\n\n\n\n", "id": "lists-006-5472388"}, {"subject": "Re: Patche", "content": "   From: Roy Seto <Roy.Seto@oracle.com>\n\n   (Question 1) I agree that moves and deletions make the\n   DAV:baseline-comparison REPORT more expressive than a sparse\n   configuration concept would be. But I'm concerned whether\n   this lends itself to efficient implementation for release\n   management purposes. For large products, baselines are big,\n   and patch deltas between them might often be small. Would\n   time and space efficiency suffer because the only way to\n   name the (small) patch is to compare two (big) baselines?\n\nThe DeltaV baseline mechanism was carefully designed to allow\nfor efficient implementation of large baselines.  In particular,\na baseline is a version, so unless it is the (empty) root baseline,\nit will have at least one predecessor baseline, and therefore\ncan be implemented as a delta from that predecessor.  This means\nthat the cost of a baseline can be proportional to the changes\nfrom its predecessor, rather than to the number of versions in it.\n\n   Of course, a release management system could cache the\n   results of the DAV:baseline-comparison REPORT, but this\n   would not be a namable WebDAV resource in the URL namespace.\n\nThere is no need to make this be a namable resource, since it\nis just an implementation mechanism.  The baseline is all that\nneeds to be named.\n\n   (Question 2) Suppose an author wanted to define a patch as\n   the set of merge target versions from a patch activity into\n   the mainline activity, where the reference baseline was the\n   baseline defining the initial release. How could the patched\n   baseline be computed?\n\nNot quite sure what you mean here.  By \"merge target version\",\nI assume you mean the DAV:checked-in or DAV:checked-out version\nof the merge target?  (The merge target is a version-controlled\nresource, not a version).  I'm not sure what you mean by\n\"from a patch activity into the mainline activity\" (you merge\ninto a collection or a version-controlled resource, not into\nanother activity).  Also, what do you mean by the \"reference\nbaseline\"?  And what is the \"patched baseline\"?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5482968"}, {"subject": "Re: Extensibility for all DeltaV method", "content": "   From: \"Vasta, John\" <jvasta@rational.com>\n\n   DeltaV methods which take request bodies are extensible, in that the DTDs\n   for the top-level element in the body are all declared to allow ANY\n   sub-elements. However, there are three methods which are not defined to take\n   request bodies: MKACTIVITY, MKWORKSPACE, and UNCHECKOUT. Should the protocol\n   explicitly declare that they can be extended by defining request bodies for\n   them?\n\nSounds reasonable to me.  Any objections?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5492037"}, {"subject": "Core versioning issues and nit", "content": "I've had a fresh pair of eyes (thanks Barry!) look at the core\nversioning sections of\nhttp://www.webdav.org/deltav/protocol/draft-ietf-deltav-versioning-12.ht\nm, and here is the list of issues -- often things which a pair of\nreasonably intelligent folks couldn't reliably infer from the draft, or\nthings in core which refer to or require things outside of core.\n\n1) URLs\n\nOne fact: The draft currently defines versions, version histories, and\nversion-controlled \"things\" as resources (not, for example, as URLs).\nOne more fact: The definiton of resources in 2518 states that a URLs\nwhich differ only in their parameter set MUST refer to the same\nresource.  When I add one and one together, my value for \"two\" is that\nit's illegal to take a base URL to refer to a VCR, and add parameters to\nget individual versions and VHRs.\n\nThat would mean we cannot have URLs of the form (partial URLs shown\nonly):\nVCR:/lisa/index.html\nVR:/lisa/index.html?version=1203987150\nVHR:/lisa/index.html?version=version-history\n\nThat would mean we must use URLs like:\nVCR:/lisa/index.html now\nVR:/__versions/lisa/index.html__1203987150\nVHR:/__vh/lisa/index.html\n\nThe draft ought to state clearly whether parameterized URLs are\nacceptable or not as URLs for VRs, VHRs.  IMHO, it would be perfectly\nfine to use parameterized URLs to refer to versions and VHRs.  Yes, it's\nugly, but it's less ugly than the alternative.\n\n(BTW, he second class of URLs above is clearly only suitable for\nautomated access in some fashion, not by somebody typing in the URL.  I\ncan't think of a good way to make them prettier without using up\nvaluable URLs that users might want for other purposes.  I know I've\ncovered this in earlier mails, but I'll repeat: I'm unhappy with that,\nit would be nasty to force all implementations to have rather ugly URLs,\nby the combination of requiring non-reusable version URLs and not\nallowing parameterized URLs.  Failing changes along those lines, does\nsomebody have a better legal suggestion for pretty URLs?)\n\n2) Versioning of Properties\n\nWe need a kind of property that applies to all versions, or to put\nanother way, properties that apply to the version-controlled resource\nitself.  For example, the \"owner\" property maybe ought to apply to the\nwhole shebang:  when you change the owner, the new owner has to be\nresponsible for everything, from the first version to the last and\nincluding the version-controlled resource and version history.\n\nOther properties might change every day, and we don't necessarily want\nto create a new version of the document (a copy of the body??!!) every\ntime that property changes.  One way of dealing with this is to make the\nfrequently-changed properties apply to the VCR.\n\nThis doesn't seem possible with the current draft, because PROPFIND and\nPROPPATCH methods applied to the VCR's URL are interpreted with respect\nto the default version.  This is related to \"passthrough\" issue which\nI'll bring up in another email.\n\n3) Definiton of Version History Resource\n\nThe draft states 'A \"version history\" is a resource that contains all\nthe versions of a particular version-controlled resource.'\n\n - What does 'contains' mean?\n - How does this mesh with later implications, that there can be more\nthan one version history resource for a VCR?  This may be a\nmisunderstanding however please clarify.\n\n\n4) The existence of version history resources\n\nSection 2.1.1 \"In core versioning, a version is exposed as an HTTP\nresource with a server-defined URL, but a version history is exposed as\nan HTTP resource only when the server supports the version-history\noption (see Section 5).\"\n\nSection 2.4: \"If the request-URL identifies a versionable resource, a\nnew version history resource is created.\"\n\nDo core versioning servers need to create VHRs and not expose them, or\nnot create them at all?  Please clarify that core need not create new\nversion history resources at all :)\n\n\n5) Definitions of precursor-set and predecessor-set\n\nThese definitions are circular.  The predecessor set is defined as\ncontaining the set of predecessors.  This does not define what a\npredecessor is, or how it is different from a precursor (aren't they\nmore or less synonyms?).  Also, what's the meaning of these on the VCR,\nvs the same properties on the version?  Why do you need these properties\non a VCR when they're already on the version?\n(Do these belong in CORE at all?)\n\n6) DAV:version\n\nI think somebody already pointed out that the DAV:version property was\nredundant since it only contained the URL for the version it was on...\n\n7) How do you distinguish between:\n - A versionable resource\n - A non-versionable resource\n - A version-controlled resource\n\nLet's say the client wishes to present a simple UI which lists all the\nresources in a collection, and can tell what each resource is, allowing\noperations like \"show me the version history\" or \"turn versioning on\" to\nbe available only when appropriate.  How, exactly, is this accomplished?\nWhat property is retrieved?\n\n8) Clarify status reporting functionality early\n\nThe document uses the headers \"Postconditions\" and shows strings like\n\"DAV:put-under-version-control\", throughout the document.  However, the\nway status reporting is handled is only explained very late in the\ndocument.  Please explain this early on.\n\nAlso the draft MUST define for each response string, what numerical HTTP\nresponse code MUST be used in the response header.  Don't leave this up\nto variation among implementations.\n\n9) What is DAV:checkout-response\n\nThe definition of the \"DAV:already-under-version-control\" status message\n(er, I mean 'postcondition') uses the \"DAV:checkout-response\" element.\nThat's not part of core.\n\n10) Interactions between LOCK and VERSION-CONTROL\n\nState whether a locked resource can be placed under version-control, and\nwhether the lock-token must be supplied with the VERSION-CONTROL method.\n\n11) Interaction between existing headers and new methods\n\nWhat happens when Depth is applied to the VERSION-CONTROL method?  It\nseems that this is being addressed in a mail thread, but the\nspecification must define the behaviour.  What exactly happens if\nanything in the scope can't be turned into a VCR?\n\nOr Depth and the REPORT method?  Is Overwrite header ignored on REPORT?\nFOrbidden?\n\nWhat about existing HTTP headers such as Chunked-encoding and MD5?  Do\nany of them apply?  Are they ignored? Forbidden?\n\n12) Version-tree report\n\nIn 2.5, the version-tree report is required to be a \"DAV:multistatus\".\nThe response could for that could reasonably be 200 Success or 207\nmultistatus.  Your example shows 200.  Please state normatively, which\nresponse code is required.\n\n13) Root versions\n\nIn 2.9, the root version of a version history \"must not be deleted\".\nWhy is that?  This seems like an implementation issue, not a\nprotocol/interoperability issue.  Please leave this issue up to the\nimplementation to decide whether or not to allow deletion of old\nversions, and how to deal with any subsequent rearrangements that might\nbe necessary.\n\n14) (DAV:initialize-precursor)\n\n\"(DAV:initialize-precursor): If the source of the COPY was a version and\nif the destination of the COPY supports the DAV:precursor-set property,\nthe DAV:precursor-set of the destination MUST identify that version.  If\nthe source of the COPY was a version-controlled resource, the\nDAV:precursor-set MUST identify the DAV:checked-in or DAV:checked-out\nversion of that resource.\"\n\nWe don't understand this paragraph at all.  We don't know what a\nprecursor is, or what to identify, or what this is doing in CORE.\nPlease move this entirely out of CORE.\n\n15) Version-history-is-tree\n\n\"(DAV:version-history-is-tree): If the request-URL identifies a\nversion-controlled resource that was automatically checked out because\nDAV:auto-version was DAV:when-locked, then the versions identified by\nthe DAV:predecessor-set of the checked-out resource MUST be descendants\nof the root version of the version history for the DAV:checked-out\nversion.\"\n\nWhat does locking have to do with whether the versions must be\ndescendants of the root version?  Wouldn't this also apply when doing\nautoversioning when unlocked?  We don't really understand this\nparagraph.  Again, we wonder what this is doing in core.\n\n16) New definition of Overwrite\n\nPlease clarify the new definition of Overwrite.\n\nIf you COPY directory 'mydir' with 'mydir/foo' and 'mydir/bar' to a\ndirectory elsewhere with 'mydir/baz', do you end up with a directory at\nthe destination with TWO children, or THREE children?  In other words,\ndo resources at the destination which do not overlap resources from the\nsource get deleted?\n\nI prefer 'no', btw.\n\n17) OPTIONS supported-method-set\n\nSection 23.6:  this defines 'supported-method-set', but in fact there's\nalready a header that expresses this.  How are you dealing with that\nredundancy?\n\n\nLisa\n\n\n\n", "id": "lists-006-5499729"}, {"subject": "Comment on Version 12.1 of the DeltaV Protoco", "content": "Dear Colleagues,\n\nPlease for give the lateness of my response.  I have finally managed to\nset aside enough time to read through the protocol and discuss it here\nwith J?rgen Reuter.  We have a number of comment and requests. In order\nto keeps some structure in the responses, I will send each topic as a\nseparate message.\n\nSincerely,\nJames J. Hunt\n\n\n\n", "id": "lists-006-5515738"}, {"subject": "Term", "content": "Dear Colleagues,\n\nWe would like to make the following points with respect to section 1.3\nTerms.\n\n1.  Can section 1.4 Notational Convention be placed before Terms?\n      This would eliminate some forward references, thus making the\ndocument easier to read.\n\n2. Can the following sentence be added just after the first sentence in\nsection 1.3?\n     \"Note that RFC 2518 uses terms from RFC 2068 which is superseded by\nRFC 2616.\"\n      This would make it easier for someone who starts with this\ndocument (RFC 2518).\n       He or she would know immediately that RFC 2068 can be ignored.\n\n3. The difference between \"Version-Controlled Resource\" and \"Working\nResource\" is not clear.\n      In some sense, they are both working resources.  The only\ndifference is that\n      \"Working Resources\" disappear after check-in and\n\"Version-Controlled Resources\" do not.\n      Confusingly,  workspaces contain version-controlled resources and\nnormally not working\n      resources.  Can we change \"Working Resource\" to something like\n\"Client-Managed\n      Resource\" or \"Client-Workspace Resource\".  After all, the main\ndifference is that \"Working\n      Resources\" are there to support client managed workspaces.  In any\nevent, a bit more\n      description would help.  How would the following be?\n\n      Client-workspace Resource\n\n      A \"client-workspace resource\" is a modifiable copy of a version\nresource used to support\n      client managed workspaces.  It is similar to a\nversioned-controlled resource, except that it is\n      transient.  It is created by a check-out request against a version\nresource and it is normally\n      deleted by a check-in request.\n\n4. The definitions of activity resource, variant resource, and\nvariant-controlled resource are not\n    clear.  I discussions with Geoff and Jim the line was that an\nactivity represents both a branch\n    and a change set.  That functionally they are the same.  A variant\nseems to also represent a\n     branch, or at least the end of one.  Actually, it seem set of\nbranches is a better description.\n    The division does not seem very clear to us.  Can someone enlighten\nme?\n\nThanks,\nJames J. Hunt\nJ?rgen Reuter\n\n\n\n", "id": "lists-006-5522351"}, {"subject": "Re: PROPFIND, VCRs, Label, Depth, href ... oh my", "content": "   From: Greg Stein <gstein@lyra.org>\n\n   I've been thinking a bit about PROPFIND and the Label: header. Let's say\n   that I do a PROPFIND against a VCR using a Label header:\n\n   PROPFIND /some/vcr\n   Label: foo\n\n   response...\n   <D:multistatus ...>\n     <D:response>\n       <D:href>/the/version/resource</D:href>\n   ...\n\n   The DAV:href element presumably has the version resource URI because you did\n   a PROPFIND against that resource (effectively).\n\nSounds right.\n\n   Now, let's throw the Depth: header into the mix. What does it apply to? The\n   VCR or the Version? It is murky with the Label: header in there.\n\nIt wouldn't make any sense to apply it to the version, because a\nversion is never a collection, but we should make that clear.\n\n   Depth applies to the VCR:\n       The PROPFIND will return DAV:response elements for version resources\n       corresponding to those selected by the label, from each of the VCRs\n       according to the Depth.\n\nYes.\n\n       DAV:href returns Version Resource URIs. How do we match them up against\n       the hierarchy defined by the VCRs?\n\nWell, if your server supports the version history option (which it\nshould :-), you can do a Depth PROPFIND (without the label header) for the\nDAV:version-history property, which would pretty much get you what you need.\n\n   Depth applies to the Version Resource:\n       Presumably, you're selecting a collection version. Its children are\n       version histories, so you're going to get back whacky properties or\n       nothing at all for the children.\n\nActually, collection versions are no longer collections (they just\nhave the DAV:version-controlled-binding-set property), so you'd\nget back nothing at all, which makes this a not very useful\ninterpretation.\n\n       The DAV:href probably would exist here, too: which DAV:response is for\n       the collection version, and which for the members?\n       [ you could tell by looking for errors :-) ]\n\nYeah, don't go there.\n\n   Okay... let's try to fix the DAV:href thingy by saying you apply the Depth:\n   header to the VCRs (i.e. apply Depth to the VCR before linking thru to the\n   version resources) and the DAV:href returns the VCRs' URIs. That makes some\n   sense, but now we have a problem: how do we get the version resource URI? We\n   can't use DAV:checked-in because that is a VCR prop. And, oh darn! We just\n   nuked DAV:version.\n\nI think returning the VCR URL in the href would be very misleading.\nThose aren't the properties of the VCR, they are the properties\nof some totally different version resource.  I'd much rather say\nthat servers that care about this should implement the DAV:version-history\noption.\n\n   My suggestion:\n\n   *) define Depth: on a PROPFIND of a VCR to apply to the VCR hierarchy rather\n      than the version resource (lack of) hierarchy\n\nDefinitely.\n\n   *) the DAV:href returns the VCR's URI\n      [ I'm not sure that I like this, though :-( ]\n\nI'm *sure* I don't like it (:-).\n\n   *) bring back DAV:version\n\nI think the fact that we would need to bring it back is an\nindication that putting the VCR's URI in the href was a\nbad/misleading thing to do.\n\n   Hmm. I'm thinking that the use of a Label: header is rather spurious to the\n   above issue. It does make it a bit harder to figure out the version resource\n   URI (without the Label:, you could ask for the VCR's DAV:checked-in; there\n   isn't an easy equivalent to find the V.R. when you're trying to use a label)\n\nNote that using the Label header with Depth is basically bogus anyway\nwhen you have versioned collections, because you won't be traversing\nthe collections that are selected by the label, but rather the\ncollections that correspond to the current target of the\nversion-controlled collections.  So I wouldn't torque the protocol\naround at all for this.\n\nBottom line: Labels are for giving a version a human meaningful\nname.  Baselines are for capturing a set of versions.  A server can\nimplement baselines with labels, but a client can't, and shouldn't\ntry to.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5531066"}, {"subject": "Introductio", "content": "Dear Colleagues,\n\nThe introduction is a bit short.  In particular, no mention is made of\nthe different operating modes that\nthis protocol is designed to support.  That makes it a bit difficult for\nsomeone who has not sat in on\nseveral committee meetings to understand why the protocol is \"so\ncomplicated\".  Can a new paragraph\nafter the second paragraph in the introduction as follows be added?\n\nThe extensions to WebDAV described here are designed to support three\ndifferent client/server\ninteraction scenarios: versioning unaware clients, server managed\nworkspaces, and client managed\nworkspace.  In core versioning a compliant server provides a single\naccess point for each resource.\nIn essence, this is a default server side workspace.  A server may allow\nversioning unaware clients\nto modify resources in this workspace though normal WebDAV requests.\nThis allows sequential\nmodification of resources.  In order to support parallel modification of\nresources, there needs to be\na method to create new workspaces.  To possibilities are supported:\nserver side workspaces via the\nworkspace option and client side workspace through the <client-workspace\nresource> option.\n\nSincerely,\nJames J. Hunt\nJ?rgen Reuter\n\n\n\n", "id": "lists-006-5542544"}, {"subject": "Move and copy,  versioning and overwrite interaction", "content": "The latest versioning draft made some improvements in specifying how\nMOVE and COPY behave in all the possible combinations of whether the\nsource is versioned, whether the destination is versioned, whether the\ndestination exists, and whether the overwrite header is present.\nHowever, it wasn't sufficient for me to determine what every combination\nwould produce.  I had to make some assumptions, such as assuming that\nwhen overwrite is False the client wants the method not to be performed\nif the destination exists (rather than create a new version).\n\nIn doing this work, I built a set of tables, to make sure I captured\nevery option and combination and could compare them.\nhttp://www.sharemation.com/~milele/public/Versioned-MOVE-COPY3.htm\n\nAuthors, please review every cell in the tables and make sure this is\nwhat you intended.  Also please review my stated assumptions.  It's\nnecessary to do both, because there may be assumptions that I was not\naware of and could not state; or misunderstandings.\n\nOther DeltaV-ers, please glance at it and make sure your assumptions\ncorrespond with mine!\n\nLisa\n\n\n\n", "id": "lists-006-5550321"}, {"subject": "Re: PROPFIND, VCRs, Label, Depth, href ... oh my", "content": "On Fri, Feb 02, 2001 at 12:03:04AM -0500, Geoffrey M. Clemm wrote:\n>    From: Greg Stein <gstein@lyra.org>\n>...\n>    Now, let's throw the Depth: header into the mix. What does it apply to? The\n>    VCR or the Version? It is murky with the Label: header in there.\n> \n> It wouldn't make any sense to apply it to the version, because a\n> version is never a collection, but we should make that clear.\n\nYup. I read up on the Depth: header from RFC 2518, and it seems to indicate\nthat the processing of the Depth: header is method-specific. Meaning we can\ndefine the meaning of the (PROPFIND, Depth:) tuple, rather than having to\nfit into a generic interpretation of Depth:.\n\n[ in short: it appears we can make Depth do what we'd like ]\n\n>...\n>        DAV:href returns Version Resource URIs. How do we match them up against\n>        the hierarchy defined by the VCRs?\n> \n> Well, if your server supports the version history option (which it\n> should :-), you can do a Depth PROPFIND (without the label header) for the\n> DAV:version-history property, which would pretty much get you what you need.\n\nHmm. By matching up the version-history properties, I presume?\n\n>    Depth applies to the Version Resource:\n>        Presumably, you're selecting a collection version. Its children are\n>        version histories, so you're going to get back whacky properties or\n>        nothing at all for the children.\n> \n> Actually, collection versions are no longer collections (they just\n\nAh. Right.\n\n>...\n>    Okay... let's try to fix the DAV:href thingy by saying you apply the Depth:\n>    header to the VCRs (i.e. apply Depth to the VCR before linking thru to the\n>    version resources) and the DAV:href returns the VCRs' URIs. That makes some\n>    sense, but now we have a problem: how do we get the version resource URI? We\n>    can't use DAV:checked-in because that is a VCR prop. And, oh darn! We just\n>    nuked DAV:version.\n> \n> I think returning the VCR URL in the href would be very misleading.\n> Those aren't the properties of the VCR, they are the properties\n> of some totally different version resource.\n\nAh. Good point... PROPFIND on a VCR with and without the Label always\nreturning the VCR URL... yah... confusing.\n\n>...\n>    *) bring back DAV:version\n> \n> I think the fact that we would need to bring it back is an\n> indication that putting the VCR's URI in the href was a\n> bad/misleading thing to do.\n\nOkay.\n\n>    Hmm. I'm thinking that the use of a Label: header is rather spurious to the\n>    above issue. It does make it a bit harder to figure out the version resource\n>    URI (without the Label:, you could ask for the VCR's DAV:checked-in; there\n>    isn't an easy equivalent to find the V.R. when you're trying to use a label)\n> \n> Note that using the Label header with Depth is basically bogus anyway\n> when you have versioned collections, because you won't be traversing\n> the collections that are selected by the label, but rather the\n> collections that correspond to the current target of the\n> version-controlled collections.  So I wouldn't torque the protocol\n> around at all for this.\n\nHmm. True...\n\n> Bottom line: Labels are for giving a version a human meaningful\n> name.  Baselines are for capturing a set of versions.  A server can\n> implement baselines with labels, but a client can't, and shouldn't\n> try to.\n\nAll righty.\n\n\nThe basis for my query here was how to access a baseline by (label) name,\nvia a version-controlled configuration. I believe the sequence will be:\n\nPROPFIND /some/collection\nask for: DAV:version-controlled-configuration\n\nPROPFIND /the/version/controlled/configuration\nLabel: the-label-goes-here\nask for: DAV:baseline-collection\n\nfurther operations on /the/baseline/collection\n\nIt would be nice to collapse these via a DAV:expand-property report, but the\nLabel: in the second request nixes that.\n\nIn any case, while thinking about PROPFIND and Label, I was thinking about\nthe other issues above. (I won't be using a Depth: header, but considering\nit threw a wrench into the mix)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-5558632"}, {"subject": "Re: Extensibility for all DeltaV method", "content": "Sounds gratuitous to me, but I don't object.\n\nRegards,\n\nTim\n\n\n\"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com> on 2001-02-02 03:59:24 AM\n\nPlease respond to \"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com>\n\nTo:   ietf-dav-versioning@w3.org\ncc:\nSubject:  Re: Extensibility for all DeltaV methods\n\n\n\n\n\n   From: \"Vasta, John\" <jvasta@rational.com>\n\n   DeltaV methods which take request bodies are extensible, in that the\nDTDs\n   for the top-level element in the body are all declared to allow ANY\n   sub-elements. However, there are three methods which are not defined to\ntake\n   request bodies: MKACTIVITY, MKWORKSPACE, and UNCHECKOUT. Should the\nprotocol\n   explicitly declare that they can be extended by defining request bodies\nfor\n   them?\n\nSounds reasonable to me.  Any objections?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5569897"}, {"subject": "Re: Comments on VERSION-CONTRO", "content": "> 1) Section 2.4 states:\n> >\n> > If the request-URL identifies a version-controlled resource,\n> > the request is ignored.  This allows a client to be unaware\n> > of whether or not a server automatically puts a resource under\n> > version control when it is created.\n>\n> This is good -- it allows a client to apply VERSION-CONTROL\n> to an entire directory without having to first check and see\n> if all resources are under version control.\n\nThere is no defined interaction between VERSION-CONTROL and the Depth:\nheader (if that's what you meant).\n\n> But then in the Postconditions section it states:\n>\n> > (DAV:already-under-version-control): If the request-URL identified\n> > a resource already under version control at the time of the request,\n> > the VERSION-CONTROL request MUST NOT change the state of that\n> > version-controlled resource, and the DAV:checkout-response body MUST\n> > contain a DAV:already-version-controlled element.\n>\n> Since it is my understanding that invoking VERSION-CONTROL\n> on a resource with URL U has the effect of converting the\n> resource at URL U into a version-controlled resource (as\n> well as creating a new version resource, and a new version\n> history resource), this appears to contradict the ignore rule\n> given at the beginning of Section 2.4.  I can see flagging\n> an error if VERSION-CONTROL is invokved on a version resource,\n> or a version history resource, so perhaps that was the intent\n> of this postcondition.\n\nGood point, stating that the request is ignored but produces a prescribed\nresponse seems counterintuative.\n\n> Or maybe the intent is that no action will be taken, but a\n> DAV:already-under-version-control element will be present\n> (with a 200 OK response code? -- this too is unclear).\n\nThis was my understanding\n\n> 2) It was unclear to me why VERSION-CONTROL departed from\n> the standard convention concerning reporting of postcondition\n> errors by requiring that the response body begin with a\n> DAV:version-control XML element.  As described in Section\n> 23.2, the postcondition element is typically reported\n> with a 403 or 409, and is the first XML element after the\n> <?xml version=\"1.0\" encoding=\"utf-8\"?> preamble.  This is\n> being changed by VERSION-CONTROL's requirement that the\n> DAV:version-control element must come before the\n> DAV:already-version-controlled element.  But, since there\n> is the additional postcondition of DAV:put-under-version-control,\n> it is also possible to have a response that doesn't fit\n> the XML specification under \"Marshalling\" in Section 2.4\n> (or at least makes this slightly underspecified), since\n> there can be an element that doesn't have DAV:version-control\n> before it.\n\nFirstly, I'm unsure why we need to respond with\n<DAV:version-control></DAV:already-version-controlled></DAV:version-control>,\n\nI'd be happy to drop this from the protocol.\n\nSecondly, I agree that there are a number of places where the marshaling is\nunderspecified with respect to (usually) error conditions (though in this\ncase it is a 200 OK response).\nFor example, in REPORT \"the response body MUST contain the requested\nreport\" and \"The DAV:version-tree REPORT response body MUST be a\nDAV:multistatus XML element.\"\n\n> 3) In addition to DAV:checked-in, VERSION-CONTROL MUST also\n> set the values of other properties on the version-controlled\n> resource, and the version resource -- more is happening with\n> properties than just setting the value of DAV:checked-in.\n> Other properties that need to be addressed:\n\nThis is described in the semantics section and in the postconditions for\nVERSION-CONTROL.  Maybe calling out DAV:checked-in explicitly here was\nunfair.\n\n> On the version-controlled resource:\n> DAV:auto-version:\n> a) It seems to me the server MAY set a default value for\n> this if it supports auto-versioning.\n\nIt would be implementation dependent as per Section 1.5.1.\n\n> This depends on the\n> meaning of DAV:auto-version not being present at all, and\n> the meaning of DAV:auto-version being an empty property.\n\nThe DAV:auto-version property MUST be present.\n\"All methods, properties, and behaviour defined in core versioning MUST be\nsupported by a versioning server.\"\nIf the property value is empty then auto-versioning will not occur.  If the\nvalue is one of the given values then the behavior is defined, if the value\nis an undefined value then the behavior is undefined.\n\n> We coudl either require DAV:auto-version to always be present,\n> but it might be empty, or we could have it not be there,\n> and have that signal no auto-versioning.\n\nEmpty means no auto-versioning occurs.\n\n> *) This certainly raises the issue that, at present, the\n> value of an empty DAV:auto-version property is not specified,\n> and should be.\n\nAgreed.  A quick check reveals that this is the only property value\ndeclared as ANY.\n\n> On the version resource:\n>\n> DAV:version :: The server MUST set the value of this.\n> DAV:predecessor-set :: The server MUST set the value of this, to empty.\n> DAV:successor-set :: The server MUST set the value of this, to empty.\n> DAV:version-name :: The server MUST set the value of this.\n\nThe DAV:predecessor-set is initialized to be the href of the checked-out\nversion.\n\n> *) Additionally, in Section 5.9, the additional semantics\n> should include adding the version-history specific properties\n> in 5.2 and 5.3 to the version-controlled resource, and the\n> version resource.\n\nThis is covered by the definitions of those resources (i.e., that they have\nthose properties and how they are initialized), it would be redundant to\nrestate it here.\n\nTim\n\n\n\n", "id": "lists-006-5578691"}, {"subject": "Re: Core versioning issues and nit", "content": "> I've had a fresh pair of eyes (thanks Barry!) look at\n> the core versioning sections of\n> http://www.webdav.org/deltav/protocol/draft-ietf-deltav-versioning-12.ht\nm,\n> and here is the list of issues -- often things which a\n> pair of reasonably intelligent folks couldn't reliably\n> infer from the draft, or things in core which refer to\n> or require things outside of core.\n\nAlways good to get fresh eyes looking at it, ... but only 'reasonably'\nintelligent<g>.\n\n> 1) URLs\n>\n> One fact: The draft currently defines versions, version\n> histories, and version-controlled \"things\" as resources (not,\n> for example, as URLs).\n\nAgreed. As resources they can have properties etc.\n\n> One more fact: The definiton of resources in 2518 states\n> that a URLs which differ only in their parameter set MUST\n> refer to the same resource.\n\nThis is reasonable.\n\n> When I add one and one together,\n> my value for \"two\" is that it's illegal to take a base\n> URL to refer to a VCR, and add parameters to get individual\n> versions and VHRs.\n\nMy 2 equals your 2<g>.\n\n> That would mean we cannot have URLs of the form (partial\n> URLs shown only):\n> VCR:    /lisa/index.html\n> VR:     /lisa/index.html?version=1203987150\n> VHR:    /lisa/index.html?version=version-history\n\nI agree with your observation.\n\n> That would mean we must use URLs like:\n> VCR:    /lisa/index.html now\n> VR:     /__versions/lisa/index.html__1203987150\n> VHR:    /__vh/lisa/index.html\n>\n> The draft ought to state clearly whether parameterized\n> URLs are acceptable or not as URLs for VRs, VHRs.\n\nThe draft typically will not restate information that is already in other\nstandards, but will refer to them, rely upon them, or extend them where\nnecessary.\n\n> IMHO, it would be perfectly fine to use parameterized URLs\n> to refer to versions and VHRs.  Yes, it's ugly, but it's\n> less ugly than the alternative.\n\nIMHO it would not be fine to break the semantics of existing standards\n(people rely on this stuff).  Beauty is in the eye of the beholder.\n\n> (BTW, he second class of URLs above is clearly only\n> suitable for automated access in some fashion, not by\n> somebody typing in the URL.  I\n\nI would no more like to type\n     /lisa/index.html?version=1203987150\nthan\n      /his/23/ver/42\n\nthe version URLs are not meant to be human readable.\n\n> can't think of a good way to make them prettier without\n> using up valuable URLs that users might want for other\n> purposes.\n\nI guess that I'm of a different opinion -- namely that URLs are cheap and\nnot in danger of being all 'used up'.  The spec. explicitly allows\nversioning metadata to reside on other hosts, so you can (dare I say,\neasily) virtually host the metadata in it's own URL namespace without\nimpinging on the creativity of clients.\n\n> I know I've covered this in earlier mails, but I'll\n> repeat: I'm unhappy with that, it would be nasty to\n> force all implementations to have rather ugly URLs,\n> by the combination of requiring non-reusable version\n> URLs and not allowing parameterized URLs.  Failing\n> changes along those lines, does somebody have a\n> better legal suggestion for pretty URLs?)\n\nI'm out of the competition because I don't want pretty URLs.  My clients\nwill ultimately identify versions by their version names, comments and\ncontents not by URL.  (They will typically get to the versions via a VCR\nwith a meaningful name.)\n\n> 2) Versioning of Properties\n>\n> We need a kind of property that applies to all versions,\n> or to put another way, properties that apply to the\n> version-controlled resource itself.  For example, the\n> \"owner\" property maybe ought to apply to the whole shebang:\n> when you change the owner, the new owner has to be responsible\n> for everything, from the first version to the last and\n> including the version-controlled resource and version history.\n\nThe version history refers to all the versions, and so that would be the\nnatural place to put the creator display name of the 'component' owner.\n\nWhat would be the meaning/role of a resource that refers to all the version\nhistory and all the version-controlled resources?\n\n> Other properties might change every day, and we don't\n> necessarily want to create a new version of the document (a\n> copy of the body??!!) every time that property changes.  One\n> way of dealing with this is to make the frequently-changed\n> properties apply to the VCR.\n\nAgreed.  If you don't want to capture these properties in a version then\nthey are better placed on a version-controlled resource.\n\n> This doesn't seem possible with the current draft, because\n> PROPFIND and PROPPATCH methods applied to the VCR's URL are\n> interpreted with respect to the default version.  This is\n> related to \"passthrough\" issue which I'll bring up in another\n> email.\n\nI don't understand this comment.  PROPFIND and PROPPATCH applied to a\nversion-controlled resource get/set properties on the VCR directly (the\nexception to this being if a Label: header is specified).\n\nI'm eager to see the \"pasthrough\" issue...\n\n> 3) Definiton of Version History Resource\n>\n> The draft states 'A \"version history\" is a resource that\n> contains all the versions of a particular version-controlled\n> resource.'\n>\n>  - What does 'contains' mean?\n\nGood question, I also raised this because I also dislike the word\n'contains' here.\nGeoff's answer was \"We've defined the deletion of a version history to\nresult in the\ndeletion of all versions in that version history, so I think \"contains\" is\nbetter here.\".\n\n>  - How does this mesh with later implications, that there can\n> be more than one version history resource for a VCR?  This\n> may be a misunderstanding however please clarify.\n\nA version-controlled resource can only be associated with a single version\nhistory.  If there is something that implies otherwise please call it out.\n\n> 4) The existence of version history resources\n>\n> Section 2.1.1 \"In core versioning, a version is exposed\n> as an HTTP resource with a server-defined URL, but a\n> version history is exposed as an HTTP resource only when\n> the server supports the version-history option (see Section 5).\"\n>\n> Section 2.4: \"If the request-URL identifies a versionable\n> resource, a new version history resource is created.\"\n>\n> Do core versioning servers need to create VHRs and not\n> expose them, or not create them at all?  Please clarify\n> that core need not create new version history resources\n> at all :)\n\n<g>  If a core versioning server created/did not create a version history\nresource and didn't expose it, how would you know?  If a tree falls in a\nwood ...<g>\n\n> 5) Definitions of precursor-set and predecessor-set\n>\n> These definitions are circular.  The predecessor set is\n> defined as containing the set of predecessors.  This\n> does not define what a predecessor is, or how it is\n> different from a precursor (aren't they more or less\n> synonyms?).\n\nThe terms \"predecessor\" and \"precursor\" are defined in Section 1.3 Terms.\nThey are semantically very similar.\n\n> Also, what's the meaning of these on the VCR, vs the\n> same properties on the version?  Why do you need these\n> properties on a VCR when they're already on the version?\n> (Do these belong in CORE at all?)\n\nOn the version-controlled resource they are essentially properties\n'in-waiting', their true value is apparent when they are applied to the\nversion created by checking in the VCR.  (Though the predecessor/precursor\nis still valid on the VCR itself, just that the values may be modified by\nthe client to reflect their view of the resource's history.)\n\nIn as much as the concept of version history belongs in core, these\nproperties are correctly defined there.\n\n> 6) DAV:version\n>\n> I think somebody already pointed out that the DAV:version\n> property was redundant since it only contained the URL for\n> the version it was on...\n\nYep.\n\n> 7) How do you distinguish between:\n>  - A versionable resource\n>  - A non-versionable resource\n>  - A version-controlled resource\n>\n> Let's say the client wishes to present a simple UI which\n> lists all the resources in a collection, and can tell\n> what each resource is, allowing operations like \"show me\n> the version history\" or \"turn versioning on\" to be\n> available only when appropriate.  How, exactly, is this\n> accomplished?  What property is retrieved?\n\nGood question.\nA versionable resource will answer with (at least) Allow: VERSION-CONTROL\nto an OPTIONS request, a non-versionable resource will not.  A\nversion-controlled resource is the only resource with a DAV:checked-in or\nDAV:checked-out property.\n\nThere was some debate a while ago about making the resource types explicit,\nwith various methods sugested.  I have to say that determining type by the\npresence or absence of properties is sub-optimal since, among other things,\nit makes for careful consideration when defining new resources with\noverlapping property names.\n\n> 8) Clarify status reporting functionality early\n>\n> The document uses the headers \"Postconditions\" and shows\n> strings like \"DAV:put-under-version-control\", throughout\n> the document.  However, the way status reporting is handled\n> is only explained very late in the document.  Please explain\n> this early on.\n\nIt is defined in Section 1.4 Notational Conventions before any\npre/postconditions are defined.\n\n> Also the draft MUST define for each response string, what\n> numerical HTTP response code MUST be used in the response\n> header.  Don't leave this up to variation among implementations.\n\nHey, I thought of that too!\nSee\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0142.html\nfor the put-down (only kidding!)\n\n> 9) What is DAV:checkout-response\n>\n> The definition of the \"DAV:already-under-version-control\"\n> status message (er, I mean 'postcondition') uses the\n> \"DAV:checkout-response\" element.\n> That's not part of core.\n\nGood catch, I suspect that is a typo. -- it should of course be\n<DAV:version-control>.\n\np.s., the postconditions are not equivalent to status messages, they are\nstatements that MUST hold true after the method has ben applied to the\nresource.  If the postcondition cannot be met then the corresponding status\ncode is reported as an indication of the cause of failure.\n\n> 10) Interactions between LOCK and VERSION-CONTROL\n>\n> State whether a locked resource can be placed under\n> version-control, and whether the lock-token must be supplied\n> with the VERSION-CONTROL method.\n\nSounds reasonable.\n\n> 11) Interaction between existing headers and new methods\n>\n> What happens when Depth is applied to the VERSION-CONTROL\n> method?  It seems that this is being addressed in a mail\n> thread, but the specification must define the behaviour.\n> What exactly happens if anything in the scope can't be\n> turned into a VCR?\n\nMy vote is for Depth: to be ignored for VERSION-CONTROL, but as you say\nthis is being debated on a separate thread.\n\n> Or Depth and the REPORT method?  Is Overwrite header\n> ignored on REPORT?\n> FOrbidden?\n\nDepth and report is defined in Section 23.4 (in revision -12).\nSince REPORT is defined as read-only Overwrite: will have no effect.\n\n> What about existing HTTP headers such as Chunked-encoding\n> and MD5?  Do any of them apply?  Are they ignored? Forbidden?\n\nThey will all retain their defined meaning without modification.\n\n> 12) Version-tree report\n>\n> In 2.5, the version-tree report is required to be a\n> \"DAV:multistatus\".  The response could for that could\n> reasonably be 200 Success or 207 multistatus.  Your\n> example shows 200.  Please state normatively, which\n> response code is required.\n\nAnother good one, I think that should be 207 Multistatus.\n\n> 13) Root versions\n>\n> In 2.9, the root version of a version history \"must\n> not be deleted\".  Why is that?  This seems like an\n> implementation issue, not a protocol/interoperability\n> issue.  Please leave this issue up to the implementation\n> to decide whether or not to allow deletion of old versions,\n> and how to deal with any subsequent rearrangements that\n> might be necessary.\n\nI queried this one too\n\nThe principal author writes:\n\"Then you lose a key semantic of a version tree, namely it is connected\nand every version is reachable from the DAV:root-version.  I don't see\nthat the benefit of allowing deletion of the root version outweighs the\nbenefit of have the version tree be connected.\"\n\n> 14) (DAV:initialize-precursor)\n>\n> \"(DAV:initialize-precursor): If the source of the COPY\n> was a version and if the destination of the COPY supports\n> the DAV:precursor-set property, the DAV:precursor-set of\n> the destination MUST identify that version.  If the source\n> of the COPY was a version-controlled resource, the\n> DAV:precursor-set MUST identify the DAV:checked-in or\n> DAV:checked-out version of that resource.\"\n>\n> We don't understand this paragraph at all.  We don't know\n> what a precursor is, or what to identify, or what this\n> is doing in CORE.\n> Please move this entirely out of CORE.\n\nIf I can answer by referring to my question...\n\nMy question was:\n    \"Why are we required to make this distinction between predecessors and\nprecursors?\"\n\nThe answer was:\n    \"Because it makes a big difference to the client whether a version is\nin the same history as another version, in terms of what you can do (for\nexample, you cannot UPDATE a vcr to be a precursor of the checked-in\nversion, but you can UPDATE it to a predecessor).\"\n\n> 15) Version-history-is-tree\n>\n> \"(DAV:version-history-is-tree): If the request-URL\n> identifies a version-controlled resource that was\n> automatically checked out because DAV:auto-version was\n> DAV:when-locked, then the versions identified by the\n> DAV:predecessor-set of the checked-out resource MUST\n> be descendants of the root version of the version\n> history for the DAV:checked-out version.\"\n>\n> What does locking have to do with whether the versions\n> must be descendants of the root version?  Wouldn't\n> this also apply when doing autoversioning when unlocked?\n> We don't really understand this paragraph.  Again, we\n> wonder what this is doing in core.\n\nI don't understand this either.  Given that the root version cannot be\ndeleted to maintain connectivity, surely all versions are descendants of\nthe root version.\n\n> 16) New definition of Overwrite\n>\n> Please clarify the new definition of Overwrite.\n>\n> If you COPY directory 'mydir' with 'mydir/foo' and\n> 'mydir/bar' to a directory elsewhere with 'mydir/baz',\n> do you end up with a directory at the destination with\n> TWO children, or THREE children?  In other words, do\n> resources at the destination which do not overlap\n> resources from the source get deleted?\n>\n> I prefer 'no', btw.\n\nNo, they do not get deleted.\n\n> 17) OPTIONS supported-method-set\n>\n> Section 23.6:  this defines 'supported-method-set',\n> but in fact there's already a header that expresses this.\n> How are you dealing with that redundancy?\n\nIn a separate mail thread!\n\nThanks for the comments, I hope my answers were not too flippant -- I'm\njust in that kind of mood today.\nFor those points where I was able to give a satisfactory answer I strongly\nencourage you to add a Q&A to the Delta-V FAQ\n(http://www.webdav.org/deltav/faq); where I didn't please set me right, on\nthe list.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-5591856"}, {"subject": "RE: Comments on -12: properties, REPORT, OPTION", "content": "> > > 2) On the flip side, if a DeltaV property is not protected, is\n> > > it the case that it MUST be writable using PROPPATCH, unless\n> > > the property definition explicitly states otherwise (of course,\n> > > writable assuming you have write access permissions).  In\n> > > particular, does a client have a guarantee that it will always\n> > > be able to write to, say, DAV:comment, and DAV:creator-displayname?\n> >\n> > If there is an unprotected property defined it is not the case that a\n> > client can always PROPPATCH it, since that property may not be\n> > supported by the server.  For example, if the server does not support\n> > the activity option it MUST fail an attempt to PROPPATCH the\nunprotected\n> > workspace property DAV:current-activity-set.\n>\n> Sure, I agree completely.  What I was driving at was, if the server\n> signals that it does support the activity option, does that then\n> mean the server MUST allow writing to DAV:current-activity-set via\n> PROPPATCH?\n\nI claim \"yes\" -- that's what supporting the activity option means (plus the\nother stuff<g>).\n\nTim\n\n\n\n", "id": "lists-006-5616704"}, {"subject": "Re: Term", "content": "> 1.  Can section 1.4 Notational Convention be placed\n> before Terms? This would eliminate some forward\n> references, thus making the document easier to read.\n\nReally, I don't recall any notational conventions used in terms (besides\nthe occasional MUST or MUST NOT<g>).\n\n> 2. Can the following sentence be added just after the\n> first sentence in section 1.3?\n> \"Note that RFC 2518 uses terms from RFC 2068 which\n> is superseded by RFC 2616.\"\n> This would make it easier for someone who starts\n> with this document (RFC 2518).\n> He or she would know immediately that RFC 2068 can\n> be ignored.\n\nI agree.\n\n> 3. The difference between \"Version-Controlled Resource\"\n> and \"Working Resource\" is not clear.\n> In some sense, they are both working resources.\n> The only difference is that \"Working Resources\" disappear\n> after check-in and \"Version-Controlled Resources\" do not.\n\nI'd say that was quite a significant difference.\n\n> Confusingly,  workspaces contain version-controlled\n> resources and normally not working resources.\n\nConfusing by the semantics or the name ('work...').\n\n> Can we change \"Working Resource\" to something like\n> \"Client-Managed Resource\" or \"Client-Workspace Resource\".\n> After all, the main difference is that \"Working Resources\"\n> are there to support client managed workspaces. In any\n> event, a bit more description would help.  How would\n> the following be?\n\nI think Mark made the case quite clearly that such a distinction is\nunwarranted as they imply a particular use case that the protocol is not\nrestricted to support.\n\n> Client-workspace Resource\n>\n> A \"client-workspace resource\" is a modifiable copy of\n> a version resource used to support client managed\n> workspaces.  It is similar to a versioned-controlled\n> resource, except that it is transient.  It is created\n> by a check-out request against a version resource and\n> it is normally deleted by a check-in request.\n\nSee answer above.\n\n> 4. The definitions of activity resource, variant resource,\n> and variant-controlled resource are not clear.  I\n> discussions with Geoff and Jim the line was that an\n> activity represents both a branch and a change set.\n> That functionally they are the same.  A variant seems\n> to also represent a branch, or at least the end of one.\n> Actually, it seem set of branches is a better description.\n> The division does not seem very clear to us.  Can\n> someone enlighten me?\n\nNot sure how to enlighten you other than recommending a re-read of RFC2616\nvariants which is what it took for me to 'get it'.  I'm sure others can\ngive more constructive suggestions.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-5625371"}, {"subject": "Re: Introductio", "content": "Hmm, this feels like you are leading the reader down a certain path -- I\nsuggest this is better covered in a scenarios doc.\n\nRegards,\n\nTim\n\n\n\"James J. Hunt\" <jjh@allerton.de> on 2001-02-02 06:11:50 AM\n\nPlease respond to jjh@ira.uka.de\n\nTo:   ietf-dav-versioning@w3.org\ncc:\nSubject:  Introduction\n\n\n\n\n\n\nDear Colleagues,\n\nThe introduction is a bit short.  In particular, no mention is made of\nthe different operating modes that\nthis protocol is designed to support.  That makes it a bit difficult for\nsomeone who has not sat in on\nseveral committee meetings to understand why the protocol is \"so\ncomplicated\".  Can a new paragraph\nafter the second paragraph in the introduction as follows be added?\n\nThe extensions to WebDAV described here are designed to support three\ndifferent client/server\ninteraction scenarios: versioning unaware clients, server managed\nworkspaces, and client managed\nworkspace.  In core versioning a compliant server provides a single\naccess point for each resource.\nIn essence, this is a default server side workspace.  A server may allow\nversioning unaware clients\nto modify resources in this workspace though normal WebDAV requests.\nThis allows sequential\nmodification of resources.  In order to support parallel modification of\nresources, there needs to be\na method to create new workspaces.  To possibilities are supported:\nserver side workspaces via the\nworkspace option and client side workspace through the <client-workspace\nresource> option.\n\nSincerely,\nJames J. Hunt\nJ?rgen Reuter\n\n\n\n", "id": "lists-006-5635117"}, {"subject": "Re: remove DAV:version property", "content": "Dear Geoff,\n\nHere is another alternative that does not break XML validity.\n\nSincerely,\nJames J. Hunt\nJ?rgen Reuter\n\nDTD\n\n<!ELEMENT DAV:expand-property (DAV:prop-apply*)>\n<!ELEMENT DAV:prop-apply ((DAV:prop-apply | DAV:prop-key)*)>\n<!ATTLIST DAV:prop-apply name ENTITY #REQUIRED>\n<!ELEMENT DAV:prop-key EMPTY>\n<!ATTLIST DAV:prop-key name ENTITY #REQUIRED>\n\n<!ELEMENT DAV:prop-value ANY>\n<!ATTLIST DAV:prop-value name ENTITY #REQUIRED>\n<!ELEMENT DAV:prop-multivalue (DAV:response*)>\n<!ATTLIST DAV:prop-multivalue name ENTITY #REQUIRED>\n\nREQUEST\n\nREPORT /foo.html HTTP/1.1\nHOST: www.webdav.org\nContent-Type: text/xml; charset=\"utf-8\"\nContent-Lenght: ????\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE DAV:webdav-1.0 SYSTEM \"http://www.webdav.org/dtd/deltav-0.12.dtd\" !>\n<D:webdav-1.0 xmlns:D=\"DAV\">\n <D:expand-property>\n  <D:prop-apply name=\"DAV:version-history\">\n   <D:prop-apply name=\"DAV:version-set\">\n    <D:prop-key name=\"DAV:creator-displayname\"/>\n    <D:prop-key name=\"DAV:activity-set\"/>\n   </D:prop-apply>\n  </D:prop-apply>\n </D:expand-property>\n</D:webdav-1.0>\n\nRESPONSE\n\nHTTP/1.1 207 Mutli-Status\nContent-Type: text/xml; charset=\"utf-8\"\nContent-Lenght: ????\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE DAV:webdav-1.0 SYSTEM \"http://www.webdav.org/dtd/deltav-0.12.dtd\" !>\n<webdav-1.0 xmlns=\"DAV\">\n <multistatus>\n  <response>\n   <href>http://www.webdav.org/foo.html</href>\n   <propstat>\n    <prop>\n     <prop-multivalue name=\"DAV:version-history\">\n      <response>\n       <href>http://repo.webdav.org/his/23</href>\n       <propstat>\n        <prop>\n         <prop-multivalue name=\"DAV:version-set\">\n          <response>\n           <href>http://repo.webdav.org/his/23/ver/1</href>\n           <propstat>\n            <prop>\n             <prop-value name=\"DAV:creator-displayname\"/>Fred</prop-value>\n             <prop-value name=\"DAV:activity-set\"/>\n              <href>http://www.webdav.org/ws/dev/surely</href>\n              <href>http://www.webdav.org/ws/dev/jest</href>\n             </prop-value>\n            </prop>\n            <status>HTTP/1.1 200 OK</status>\n           </propstat>\n          </response>\n          <response>\n           <href>http://repo.webdav.org/his/23/ver/2</href>\n           <propstat>\n            <prop>\n             <prop-value name=\"DAV:creator-displayname\"/>Sally</prop-value>\n             <prop-value name=\"DAV:activity-set\"/>\n              <href>http://repo.webdav.org/act/add-refresh-cmd</href>\n             </prop-value>\n            </prop>\n            <status>HTTP/1.1 200 OK</status>\n           </propstat>\n          </response>\n         </prop-multivalue>\n        </prop>\n        <status>HTTP/1.1 200 OK</status>\n       </propstat>\n      </response>\n     </prop-multivalue>\n    </prop>\n    <status>HTTP/1.1 200 OK</status>\n   </propstat>\n  </response>\n </multistatus>\n</webdav-1.0>\n\n\n\"Geoffrey M. Clemm\" wrote:\n\n>    From: Greg Stein <gstein@lyra.org>\n>\n>    btw, I just noticed: the expand-property example has an error: the\n>    activity-set for .../ver/1 is missing <href> tags.\n>\n> Thanks for noticing that!  Will fix.\n>\n>    [ also note that expand-property \"violates\" DTDs for properties. cool with\n>      me, but some DTD fanatics will be up in arms. (e.g. version-history isn't\n>      defined to contains a DAV:response element) ]\n>\n> Good point.\n>\n> The only alternative I can see is to replace every occurrence of\n> \"href\" in property definitions with \"href|response\", but that seems to\n> me that it would cause more confusion than benefit to the reader.\n>\n> Since the DAV:response value will only come back in the\n> DAV:expand-property report, only clients that understand this extended\n> behavior will encounter it.  So unless the working group feels\n> otherwise, I will address this point by adding some appropriate text\n> to the DAV:expand-property section describing this DTD-extending\n> impact, and not by modifying the DTD's.  Is this OK?\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-5644315"}, {"subject": "Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm ES", "content": "phone: 888 819 8909  pass-code#97985\n\nAgenda:\n\nFollowing standard operating procedure, we've received a flood\nof last-call comments on the very last day of last call (:-),\nbut better a flood on the last day, than not getting the \ncomments at all, so thankyou to all the reviewers!\n\nI've read all the comments, and I believe they primarily consist\nof clarifications of semantics and suggestions for improving\nthe readability of the document.  I will go through them all\ncarefully, and make the suggested changes, and post the result\nas a new internet draft by early next week.  I will also produce\na list of all the changes since the last internet draft,\nso we can review the changes and confirm that there are none\nsubstantive enough to require another last call period.\n\nSo there is no agenda this week, but I will be on the phone line\nfrom 12:00 to say, 12:15, to see if anyone has any comments\nthat they might not have had a chance to send via email\nduring the last call period.\n\nThe agenda for next weeks TeleConf will be to determine whether\nanother working group last call is required.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5656607"}, {"subject": "Labels and Statu", "content": "Dear Colleagues,\n\nThere seem to be some confusion in the protocol description as to for\nwhat Labels are good.  At least the example is misleading.  A label with\nthe name released is in general not useful, because released has the\ncharacter of status and a file may have only one revision with the label\nreleased.  Over the course of time several versions will be \"released\".\nA better example would be the label release_3.1.\n\nSince there are revision control systems that support a status\nproperty, it would make sense to support it explicitly as an option.\nStatus can not be implemented as a dead property for two reason:\n  1) a versioned resource or working resource that is updated or created\n     by a check-out request should NOT inherit the value of the status\n     of the version being checked out, instead it should be set to a\n     server defined base value or left empty; and\n  2) status should be changeable on a version without creating a new\n     version, similar to label.\nSystems that implement both base-lines and status should provide a status\nfor base-lines.  The value of status should be an NMTOKEN.\n\nSincerely,\nJames J. Hunt\nJ?rgen Reuter\n\n\n\n", "id": "lists-006-5665463"}, {"subject": "Re: Labels and Statu", "content": "Introducing server-defined status properties is starting down the slippery \nslope of document management. We intentionally kept this out of Delta-V \nbecause it didn't seem essential for versioning support, and would \nseriously delay its introduction. I suggest we may want to start another \nworking group soon that address Delta-V extensions for interoperable \ndocument management. I would be happy to be involved.\n\n\n\n\n\n\"James J. Hunt\" <jjh@ira.uka.de>\nSent by: ietf-dav-versioning-request@w3.org\n02/02/2001 09:55 AM\nPlease respond to jjh\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        Labels and Status\n\n \n\n\n\nDear Colleagues,\n\nThere seem to be some confusion in the protocol description as to for\nwhat Labels are good.  At least the example is misleading.  A label with\nthe name released is in general not useful, because released has the\ncharacter of status and a file may have only one revision with the label\nreleased.  Over the course of time several versions will be \"released\".\nA better example would be the label release_3.1.\n\nSince there are revision control systems that support a status\nproperty, it would make sense to support it explicitly as an option.\nStatus can not be implemented as a dead property for two reason:\n  1) a versioned resource or working resource that is updated or created\n     by a check-out request should NOT inherit the value of the status\n     of the version being checked out, instead it should be set to a\n     server defined base value or left empty; and\n  2) status should be changeable on a version without creating a new\n     version, similar to label.\nSystems that implement both base-lines and status should provide a status\nfor base-lines.  The value of status should be an NMTOKEN.\n\nSincerely,\nJames J. Hunt\nJ?rgen Reuter\n\n\n\n", "id": "lists-006-5673677"}, {"subject": "RE: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm ES", "content": "Geoff,\n\nI have some comments on the DeltaV spec based on an\ninternal review that I haven't been able to send\nin on time. The major issue, though, is the\nstructure of the document:\n\nChanges to WebDAV should be processed as a separate\ndocument which updates WebDAV, with or without versioning.\nIt is unreasonable to attempt to \"clarify\" WebDAV\nin the same spec that introduces versioning. The\nWebDAV updates need to be reviewed by the entire\nWebDAV community, and not just those people who are\ninterested in versioning.\n\nCore versioning should be split into a separate spec.\nEverything outside of core versioning is much less\nlikely to progress along standards track at the same\nrate as core versioning (more time to get independent\ninteroperable implementations of every feature); by\nlinking \"core versioning\" with \"non-core\" in the\ninitial spec, you're setting yourself up for having\nto split the documents later. Much of non-core is\ncontroversial.\n\nI'd dropped out of the delta-V mailing list for a while,\nbut I've just re-joined.\n\nI've been searching through the email archive and can't\nsee where these structural issues are addressed.\n\n\n\n", "id": "lists-006-5683350"}, {"subject": "Re: Labels and Statu", "content": "   Introducing server-defined status properties is starting down the slippery\n   slope of document management. We intentionally kept this out of Delta-V\n   because it didn't seem essential for versioning support, and would\n   seriously delay its introduction. I suggest we may want to start another\n   working group soon that address Delta-V extensions for interoperable\n   document management. I would be happy to be involved.\n\nDear Jim,\n\nWhen that is the general consensus, than I would also like to be\ninvolved, but than it real does need to happen soon.  I would still\nchange the example.\n\nSincerely,\nJames J. Hunt\n\n\n\n", "id": "lists-006-5692146"}, {"subject": "Re: Labels and Statu", "content": "> There seem to be some confusion in the protocol\n> description as to for what Labels are good.  At\n> least the example is misleading.  A label with\n> the name released is in general not useful, because\n> released has the character of status and a file\n> may have only one revision with the label released.\n> Over the course of time several versions will be\n> \"released\".  A better example would be the label\n> release_3.1.\n\nAgreed.\n\n> Since there are revision control systems that support\n> a status property, it would make sense to support\n> it explicitly as an option.\n> Status can not be implemented as a dead property for\n> two reason:\n>   1) a versioned resource or working resource that\n>      is updated or created by a check-out request\n>      should NOT inherit the value of the status\n>      of the version being checked out, instead it\n>      should be set to a server defined base value\n>      or left empty; and\n>   2) status should be changeable on a version without\n>      creating a new version, similar to label.\n\nFunctionaly, labels will do it for you.\n1) They are not 'inherited' by (i.e., moved to) new versions.\n2) They do not require creating a new version to set or remove.\n\n> Systems that implement both base-lines and status\n> should provide a status for base-lines.  The value\n> of status should be an NMTOKEN.\n\nBaselines are versions, so they will support labels too.\n\nTim\n\n\n\n", "id": "lists-006-5700206"}, {"subject": "Re: Labels and Statu", "content": "   > Since there are revision control systems that support\n   > a status property, it would make sense to support\n   > it explicitly as an option.\n   > Status can not be implemented as a dead property for\n   > two reason:\n   >   1) a versioned resource or working resource that\n   >      is updated or created by a check-out request\n   >      should NOT inherit the value of the status\n   >      of the version being checked out, instead it\n   >      should be set to a server defined base value\n   >      or left empty; and\n   >   2) status should be changeable on a version without\n   >      creating a new version, similar to label.\n\n   Functionaly, labels will do it for you.\n   1) They are not 'inherited' by (i.e., moved to) new versions.\n   2) They do not require creating a new version to set or remove.\n\nLabels will not \"do it for me\" because they are exclusive.  I can not\nhave two version in the same revision history with the label tested!\nLabel is a unique identifier and status denotes the current state of a\nrevision in regards to it processing.\n\nJames\n\n\n\n", "id": "lists-006-5708706"}, {"subject": "From Juergen Reute", "content": "Juergen has been having some difficulty sending mail to the list -- here is\nan email he asked me to forward for him.\n\n- Jim\n\n\nTo: ietf-dav-versioning@w3.org\ncc: reuter@ira.uka.de, jjh@ira.uka.de\nSubject: DAV:checkout-set property for version histories\nDate: Wed, 31 Jan 2001 18:06:07 +0100\nFrom: Juergen Reuter <reuter@ira.uka.de>\nMessage-ID: <\"iraun1.ira.0085101:010131.170625\"@ira.uka.de>\n\nIn earlier versions of DeltaV, there was a computed property that listed\nall checked-out working resources associated with a single versioned\nresource.  In combination with the DAV:expand-property REPORT, you could\nfetch properties of all working resources with a single request.\nSimilarly, you could (and still can) fetch properties of all version\nresources using the DAV:version-set property in a single request.\nSo, with only two requests, I could fetch all properties that are needed\nfor displaying a revision graph that includes working resources and/or\nchecked out version-controlled resources.\n\nFor this purpose, I would have expected to see a DAV:checkout-set\n(<!ELEMENT checkout-set (href*)>) property on version history resources\nthat identifies each checked-out resource whose DAV:checked-out property\nidentifies any version in the version history.  But I can not find such a\nproperty.\n\nAlternatively, I would be satisfied with some kind of DAV:version-tree\nREPORT that applies on checked-out resources rather than versions, or a\nDAV:version-tree REPORT that includes checked-out resources.\n\nIs there some other way to retrieve properties from all working resources\nassociated with a versioned resource in a single request that I\noverlooked?\n\nBye,\n     Juergen\n\n\n\n", "id": "lists-006-5716995"}, {"subject": "RE: Labels and Statu", "content": "I'd second what James says, only make it even more general.\n\nYes, many versioning systems have \"status\" properties on versions, and\nthe \"status\" property should be mutable, i.e. should be writable without\ncreating a new version.  (Immutable properties never change on old\nversions; changing an immutable property creates a new version).\n\nHowever, there are also publishing or workflow processes which require\ntheir own mutable properties.  For example, \"publishing-status\" or\n\"editing-status\" or \"approval-status\" or \"invoice-status\"...  We can't\nbe expected to predict all these, however it's a common need, and\ndefining only 'status' would not solve the general problem.\n\nThus, versioning needs a general way to allow creation of custom\nproperties which are mutable, AND custom properties which are immutable.\nThe server would of course reject requests for mutable properties if it\ndoes not support mutability, but we need a standard way for clients to\nask for this.\n\nLisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of James J. Hunt\n> Sent: Friday, February 02, 2001 6:56 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Labels and Status\n>\n>\n>\n> Dear Colleagues,\n>\n> There seem to be some confusion in the protocol description as to for\n> what Labels are good.  At least the example is misleading.  A\n> label with\n> the name released is in general not useful, because released has the\n> character of status and a file may have only one revision\n> with the label\n> released.  Over the course of time several versions will be\n> \"released\".\n> A better example would be the label release_3.1.\n>\n> Since there are revision control systems that support a status\n> property, it would make sense to support it explicitly as an option.\n> Status can not be implemented as a dead property for two reason:\n>   1) a versioned resource or working resource that is updated\n> or created\n>      by a check-out request should NOT inherit the value of the status\n>      of the version being checked out, instead it should be set to a\n>      server defined base value or left empty; and\n>   2) status should be changeable on a version without creating a new\n>      version, similar to label.\n> Systems that implement both base-lines and status should\n> provide a status\n> for base-lines.  The value of status should be an NMTOKEN.\n>\n> Sincerely,\n> James J. Hunt\n> J?rgen Reuter\n\n\n\n", "id": "lists-006-5726272"}, {"subject": "RE: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm ES", "content": "Larry,\nWelcome back! Excellent questions. Let me take a crack at them too. I \nshare your concern that changes to WebDAV that are unrelated to versioning \nshould be done by submitting separate Internet Drafts to the WebDAV \nworking group. That is why I brought this subject up at IETF '49 WebDAV \nworking group meeting. The sense of that meeting was that there were no \nsignificant issues, and in the interest of expedience, we could continue \ncoupling the small changes and clarifications in the Delta-V spec which of \ncourse ends up being extensions to WebDAV anyway. There didn't seem to be \nany strong desire to address the issues separately. In any case, the end \nresult would likely be the same. We will however consider doing a couple \nof things to help. We can make the REPORT method a versioning option \nrather than a new WebDAV method and move it out of the appendix. We will \nalso copy the remaining items in section appendix A to a separate post to \nthe WebDAV mailing list to make sure everyone there has a chance to review \nthem, even if they don't review the whole versioning spec.\n\nWe have struggled with how to handle core vs. advanced vs. options since \nthe beginning of Delta-V. In fact, there is a recent thread on this \nsubject that suggests splitting them into separate documents. The \ncompromise we came up with was to have core contain the minimal, essential \nsupport for versioning semantics that we expected every server vendor \nwould implement. That is, core represents the common functions provided by \nall versioning repository vendors while the extensions represent the \nvariability. However, we don't expect any server to just implement core \nbecause by itself, core isn't that interesting. Even the document \nmanagement vendors have expressed interest in a number of the extensions. \nWe just couldn't get any agreement on common subsets. This has been the \ngreatest source of controversy, not the semantics of the specific \nextensions themselves. \n\nI agree that some of the extensions have not received the same level of \nworking group scrutiny as core, but the overall semantics of these \nextensions have been under consideration and stable for quite some time. \nThere are also a  number of implementations in progress that have not \nraised significant issues. So although I share your concerns about \nsplitting core and extensions into separate documents, there are also \nforces encouraging us to keep them together. Until specific controversies \narise that require them to be split, I'm inclined to keep them together in \norder to encourage implementation of more options by more server vendors. \nThis will lead to better interoperability and more function to clients \nsooner.\n\n\n\n\n\n\n\"Larry Masinter\" <lmnet@attglobal.net>\nSent by: ietf-dav-versioning-request@w3.org\n02/02/2001 10:26 AM\n\n \n        To:     \"Clemm, Geoff\" <gclemm@rational.com>\n        cc:     <ietf-dav-versioning@w3.org>\n        Subject:        RE: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm EST\n\n \n\n\nGeoff,\n\nI have some comments on the DeltaV spec based on an\ninternal review that I haven't been able to send\nin on time. The major issue, though, is the\nstructure of the document:\n\nChanges to WebDAV should be processed as a separate\ndocument which updates WebDAV, with or without versioning.\nIt is unreasonable to attempt to \"clarify\" WebDAV\nin the same spec that introduces versioning. The\nWebDAV updates need to be reviewed by the entire\nWebDAV community, and not just those people who are\ninterested in versioning.\n\nCore versioning should be split into a separate spec.\nEverything outside of core versioning is much less\nlikely to progress along standards track at the same\nrate as core versioning (more time to get independent\ninteroperable implementations of every feature); by\nlinking \"core versioning\" with \"non-core\" in the\ninitial spec, you're setting yourself up for having\nto split the documents later. Much of non-core is\ncontroversial.\n\nI'd dropped out of the delta-V mailing list for a while,\nbut I've just re-joined.\n\nI've been searching through the email archive and can't\nsee where these structural issues are addressed.\n\n\n\n", "id": "lists-006-5736883"}, {"subject": "Re: Patche", "content": "\"Geoffrey M. Clemm\" wrote:\n> \n> The DeltaV baseline mechanism was carefully designed to allow\n> for efficient implementation of large baselines.  In particular,\n> a baseline is a version, so unless it is the (empty) root baseline,\n> it will have at least one predecessor baseline, and therefore\n> can be implemented as a delta from that predecessor.  This means\n> that the cost of a baseline can be proportional to the changes\n> from its predecessor, rather than to the number of versions in it.\n\nThanks. I understand now.\n\n>    (Question 2) Suppose an author wanted to define a patch as\n>    the set of merge target versions from a patch activity into\n>    the mainline activity, where the reference baseline was the\n>    baseline defining the initial release. How could the patched\n>    baseline be computed?\n> \n> Not quite sure what you mean here.  By \"merge target version\",\n> I assume you mean the DAV:checked-in or DAV:checked-out version\n> of the merge target?  (The merge target is a version-controlled\n> resource, not a version).  I'm not sure what you mean by\n> \"from a patch activity into the mainline activity\" (you merge\n> into a collection or a version-controlled resource, not into\n> another activity).  Also, what do you mean by the \"reference\n> baseline\"?  And what is the \"patched baseline\"?\n\nSorry, my question was not well formed because I did not\nconsistently use the DeltaV terminology. Here's the scenario\nI'm trying to understand:\n\nAn author uses what many existing versioning systems call a\nsubbranch to develop a logical change. Then that author\nmerges the subbranch into what many versioning systems would\ncall its parent branch (perhaps by using a workspace defined\nin terms of the parent branch as the merge target). The\nauthor would like to identify the versions on the parent\nbranch created by the merge process (marked as \"O\" in the\ndiagram below).\n\n     ----------------------O---- parent branch\n       \\                  /\n        \\                /\n         ---------------- subbranch\n\n    <--- ancestors   descendants ---> \n\nThanks,\nRoy\n\n\n\n", "id": "lists-006-5749824"}, {"subject": "RE: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm ES", "content": "> We have struggled with how to handle core vs. advanced\n> vs. options since the beginning of Delta-V. In fact,\n> there is a recent thread on this subject that suggests\n> splitting them into separate documents. The compromise\n> we came up with was to have core contain the minimal,\n> essential support for versioning semantics that we\n> expected every server vendor would implement. That is,\n> core represents the common functions provided by all\n> versioning repository vendors while the extensions\n> represent the variability. However, we don't expect any\n> server to just implement core because by itself, core\n> isn't that interesting. Even the document management\n> vendors have expressed interest in a number of the\n> extensions. We just couldn't get any agreement on common\n> subsets. This has been the greatest source of\n> controversy, not the semantics of the specific\n> extensions themselves.\n\nXythos is planning to implement core and only core, unless and until\nsome interoperable DAV clients also implement some of the more generally\nuseful extensions such as checkin/checkout, baselines, variants or\nlabels, or until a customer requires such options.\n\n\"Expressed interest\" is a vague statement, you could say that Xythos has\nexpressed interest in various extensions, however as I've stated we may\nnot implement any extensions anytime soon.\n\nAny other document management vendors care to discuss what options they\nplan to implement?\n\nLisa\n\n\n\n", "id": "lists-006-5758805"}, {"subject": "RE: Core versioning issues and nit", "content": "> > Also, what's the meaning of these on the VCR, vs the\n> > same properties on the version?  Why do you need these\n> > properties on a VCR when they're already on the version?\n> > (Do these belong in CORE at all?)\n>\n> On the version-controlled resource they are essentially properties\n> 'in-waiting', their true value is apparent when they are\n> applied to the\n> version created by checking in the VCR.  (Though the\n> predecessor/precursor\n> is still valid on the VCR itself, just that the values may be\n> modified by\n> the client to reflect their view of the resource's history.)\n\n\"Predecessor-set\" makes decent sense.  Of course for simple versioning\nservers this will be a protected and computed property, single-valued\n(that value being the URL of the previous version).\n\nHowever \"precursor-set\" doesn't make sense in core, if it in fact makes\nsense anywhere.  Why is the client supposed to put values in\nprecursor-set?  Is the server expected to validate those values?  What\nuse is supposed to be made of this value?   If the client isn't forced\nto fill in this property when copying content, how are other clients\nexpected to be able to rely on the property being meaningful?  I don't\nsee that the server is expected to calculate a value either, although\ntheoretically it could if a COPY was performed.\n\nBasically, if the \"precursor-set\" property can be empty either if there\nwere no precursors OR if the client ommitted to correctly set this\nproperty, then it's not useful -- other clients can't tell if the empty\nproperty is meaningful or not.\n\nIsn't this just a dead/custom property, therefore no need to\nstandardize?\n\nIf it's legal for \"precursor-set\" to be unused, then I predict it will\nremain unused on many systems.\n\nlisa\n\n\n\n", "id": "lists-006-5768087"}, {"subject": "RE: Core versioning issues and nit", "content": "> > Section 2.4: \"If the request-URL identifies a versionable\n> > resource, a new version history resource is created.\"\n> >\n> > Do core versioning servers need to create VHRs and not\n> > expose them, or not create them at all?  Please clarify\n> > that core need not create new version history resources\n> > at all :)\n>\n> <g>  If a core versioning server created/did not create a\n> version history\n> resource and didn't expose it, how would you know?  If a tree\n> falls in a\n> wood ...<g>\n\nIt's nice to have this understanding in email, but please modify section\n2.4 to read something like:\n\n\"If the request-URL identifies a versionable resource, a new version\nhistory resource MAY be created.\"\n\nLisa\n\n\n\n", "id": "lists-006-5777239"}, {"subject": "RE: Core versioning issues and nit", "content": "> > 2) Versioning of Properties\n> >\n> > We need a kind of property that applies to all versions,\n> > or to put another way, properties that apply to the\n> > version-controlled resource itself.  For example, the\n> > \"owner\" property maybe ought to apply to the whole shebang:\n> > when you change the owner, the new owner has to be responsible\n> > for everything, from the first version to the last and\n> > including the version-controlled resource and version history.\n>\n> The version history refers to all the versions, and so that\n> would be the\n> natural place to put the creator display name of the\n> 'component' owner.\n>\n> What would be the meaning/role of a resource that refers to\n> all the version\n> history and all the version-controlled resources?\n\nI didn't mean to imply that there would be a kind of resource that\nrefers to all the version history and the associated VCR.  I think there\nare enough new resources already :)\n\nWhat I'd like is a straightforward statement (in the spec, not just in\nmail!) that the VCR can have all sorts of properties, including custom\n(dead) properties, that can be considered to apply to document as a\nwhole, including all its versions.  I've given examples of the need for\nsuch properties.\n\nWhat that kind of statement requires is a way to PROPPATCH a VCR without\ncreating a new version.  The spec specifically states in 2.1.2: \"A PUT\nor PROPPATCH to a version-controlled resource with the DAV:auto-version\nproperty set will automatically check out that resource prior to\nexecuting the PUT or PROPPATCH... a new version is created in the\nversion history of that resource.\"  This makes it impossible to have\ncustom properties on the VCR.\n\nPlease resolve this.  Placing custom properties on the VHR is\nunacceptable, because a VHR doesn't appear in regular collections the\nway a VCR does.  You would have to make one request to collection\n'/lisa/' to find all the VCRs and all the URLs to the VHRs, then make\n'n' requests to all the VHR URLs to find the values of the custom\nproperty.\n\nLisa\n\n\n\n", "id": "lists-006-5785542"}, {"subject": "RE: Core versioning issues and nit", "content": "> > 7) How do you distinguish between:\n> >  - A versionable resource\n> >  - A non-versionable resource\n> >  - A version-controlled resource\n> >\n> > Let's say the client wishes to present a simple UI which\n> > lists all the resources in a collection, and can tell\n> > what each resource is, allowing operations like \"show me\n> > the version history\" or \"turn versioning on\" to be\n> > available only when appropriate.  How, exactly, is this\n> > accomplished?  What property is retrieved?\n>\n> Good question.\n> A versionable resource will answer with (at least) Allow:\n> VERSION-CONTROL\n> to an OPTIONS request, a non-versionable resource will not.  A\n> version-controlled resource is the only resource with a\n> DAV:checked-in or\n> DAV:checked-out property.\n>\n> There was some debate a while ago about making the resource\n> types explicit,\n> with various methods sugested.  I have to say that\n> determining type by the\n> presence or absence of properties is sub-optimal since, among\n> other things,\n> it makes for careful consideration when defining new resources with\n> overlapping property names.\n\nI agree that determining type by the absence of properties is\nsub-optimal; I'd say it's not very reliable.  I'd point out another\nproblem:  in order to create the kind of GUI I described, the client\nwould have to:\n - Issue a depth:1 PROPFIND request to find all the resources that have\na DAV:checked-in (or checked-out) property.  If they do, consider them\nVCRs.\n - Issue an OPTIONS request to every non-VCR, to find out whether it can\nbe versioned or not.\n\nThis is an order(N) operation, just to show a decent directory listing.\nDepth is not supported on OPTIONS requests, according to RFC2518: \"The\nDepth header is only supported if a method's definition explicitly\nprovides for such support.\"\n\nThis is a serious client issue.  Please address...\n\nLisa\n\n\n\n", "id": "lists-006-5795185"}, {"subject": "RE: Core versioning issues and nit", "content": "> > 13) Root versions\n> >\n> > In 2.9, the root version of a version history \"must\n> > not be deleted\".  Why is that?  This seems like an\n> > implementation issue, not a protocol/interoperability\n> > issue.  Please leave this issue up to the implementation\n> > to decide whether or not to allow deletion of old versions,\n> > and how to deal with any subsequent rearrangements that\n> > might be necessary.\n>\n> I queried this one too\n>\n> The principal author writes:\n> \"Then you lose a key semantic of a version tree, namely it is\n> connected\n> and every version is reachable from the DAV:root-version.  I don't see\n> that the benefit of allowing deletion of the root version\n> outweighs the\n> benefit of have the version tree be connected.\"\n\nThen make the requirement that the version tree be connected.  It's\nquite possible for implementations to meet the requirement that the\nversion tree be connected, and provide this valuable functionality for\nclients.\n\nOn the other hand, if you do not require that the version tree be\nconnected, then it's quite possible for implementations to end up with\nan unconnected version tree even without deleting the root version.\n\nI think the point here is to make the requirement state what the client\nneeds, rather than what you think is needed in order to get what the\nclient needs.\n\nLisa\n\n\n\n", "id": "lists-006-5804693"}, {"subject": "RE: Core versioning issues and nit", "content": "> > 16) New definition of Overwrite\n> >\n> > Please clarify the new definition of Overwrite.\n> >\n> > If you COPY directory 'mydir' with 'mydir/foo' and\n> > 'mydir/bar' to a directory elsewhere with 'mydir/baz',\n> > do you end up with a directory at the destination with\n> > TWO children, or THREE children?  In other words, do\n> > resources at the destination which do not overlap\n> > resources from the source get deleted?\n> >\n> > I prefer 'no', btw.\n>\n> No, they do not get deleted.\n\nCan this get clarified in the spec?  This must be normative; it's not\nenough to explain in the FAQ that the non-overlapping resources do not\nget deleted.  It must be a requirement, or servers may behave\ndifferently.\n\nLisa\n\n\n\n", "id": "lists-006-5813632"}, {"subject": "RE: Core versioning issues and nit", "content": "> > 14) (DAV:initialize-precursor)\n> >\n> > \"(DAV:initialize-precursor): If the source of the COPY\n> > was a version and if the destination of the COPY supports\n> > the DAV:precursor-set property, the DAV:precursor-set of\n> > the destination MUST identify that version.  If the source\n> > of the COPY was a version-controlled resource, the\n> > DAV:precursor-set MUST identify the DAV:checked-in or\n> > DAV:checked-out version of that resource.\"\n> >\n> > We don't understand this paragraph at all.  We don't know\n> > what a precursor is, or what to identify, or what this\n> > is doing in CORE.\n> > Please move this entirely out of CORE.\n>\n> If I can answer by referring to my question...\n>\n> My question was:\n>     \"Why are we required to make this distinction between\n> predecessors and\n> precursors?\"\n>\n> The answer was:\n>     \"Because it makes a big difference to the client whether\n> a version is\n> in the same history as another version, in terms of what you\n> can do (for\n> example, you cannot UPDATE a vcr to be a precursor of the checked-in\n> version, but you can UPDATE it to a predecessor).\"\n\nBut the Core versioning section is supposed to be features that MUST be\nsupported by all versioning servers.  Yet, the original paragraph\nimplies that \"precursor-set\" and the \"initialize-precursor\" condition\naren't required to be implemented because it says \"if the destionation\nof the COPY supports the DAV:precursor-set property\".\n\nAlso, your explanation refers to UPDATE, which is not part of core.\n\nFrankly, it looks like \"precursor\" support is yet another option, or\npart of the UPDATE option.  It's important for the client to know if\nit's supported or not (to know whether an missing/empty value of\nprecursor-set is meaningful or not) but it's optional.  Thus, it's an\noption.\n\nLisa\n\n\n\n", "id": "lists-006-5821927"}, {"subject": "RE: Core versioning issues and nit", "content": "> I guess that I'm of a different opinion -- namely that URLs\n> are cheap and\n> not in danger of being all 'used up'.\n\nIn fact, it's not so much that that URLs are scarce, but that good user\ninterfaces are difficult.  How do I explain what URL namespaces are\nreserved for special-purpose resources like VRs, VHRs, or (to take an\nexample from another realm) principals?  At least you could give me a\ngood error message to return when users try to create new resources or\ncollections in reserved namespaces!\n\n> The spec. explicitly allows\n> versioning metadata to reside on other hosts, so you can (dare I say,\n> easily) virtually host the metadata in it's own URL namespace without\n> impinging on the creativity of clients.\n\nHow, then, can the client be expected to COPY where the source is a\nversion URL, and the destination is a working resource?  To the client\nit \"looks like\" the source and destination are on different hosts, and\nthe client might reasonably expect this not to work, since most servers\ndon't implement server-to-server copy.\n\nLisa\n\n\n\n", "id": "lists-006-5831426"}, {"subject": "RE: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm ES", "content": "I thought you were planning on supporting the variant\noption?  (And if not, why did we spend all that time\nworking it out ... :-).  \n\nCheers,\nGeoff\n\np.s.  Seriously, I think the variant\noption is a valuable addition to the protocol, whether\nor not you intend on implementing it in your server (:-)\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Friday, February 02, 2001 2:50 PM\nTo: Jim Amsden; ietf-dav-versioning@w3.org\nSubject: RE: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm EST\n\n\n> We have struggled with how to handle core vs. advanced\n> vs. options since the beginning of Delta-V. In fact,\n> there is a recent thread on this subject that suggests\n> splitting them into separate documents. The compromise\n> we came up with was to have core contain the minimal,\n> essential support for versioning semantics that we\n> expected every server vendor would implement. That is,\n> core represents the common functions provided by all\n> versioning repository vendors while the extensions\n> represent the variability. However, we don't expect any\n> server to just implement core because by itself, core\n> isn't that interesting. Even the document management\n> vendors have expressed interest in a number of the\n> extensions. We just couldn't get any agreement on common\n> subsets. This has been the greatest source of\n> controversy, not the semantics of the specific\n> extensions themselves.\n\nXythos is planning to implement core and only core, unless and until\nsome interoperable DAV clients also implement some of the more generally\nuseful extensions such as checkin/checkout, baselines, variants or\nlabels, or until a customer requires such options.\n\n\"Expressed interest\" is a vague statement, you could say that Xythos has\nexpressed interest in various extensions, however as I've stated we may\nnot implement any extensions anytime soon.\n\nAny other document management vendors care to discuss what options they\nplan to implement?\n\nLisa\n\n\n\n", "id": "lists-006-5840060"}, {"subject": "RE: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm ES", "content": "Oracle plans on implementing most of the DeltaV options,\nwith the notable exception of Variants.  \n\nIn addition to end-user clients, we may also be using DeltaV\ninternally to communicate between middle tier and data servers.\n\n--Eric\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\nSent: Friday, February 02, 2001 11:50 AM\nTo: Jim Amsden; ietf-dav-versioning@w3.org\nSubject: RE: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm EST\n\n\n> We have struggled with how to handle core vs. advanced\n> vs. options since the beginning of Delta-V. In fact,\n> there is a recent thread on this subject that suggests\n> splitting them into separate documents. The compromise\n> we came up with was to have core contain the minimal,\n> essential support for versioning semantics that we\n> expected every server vendor would implement. That is,\n> core represents the common functions provided by all\n> versioning repository vendors while the extensions\n> represent the variability. However, we don't expect any\n> server to just implement core because by itself, core\n> isn't that interesting. Even the document management\n> vendors have expressed interest in a number of the\n> extensions. We just couldn't get any agreement on common\n> subsets. This has been the greatest source of\n> controversy, not the semantics of the specific\n> extensions themselves.\n\nXythos is planning to implement core and only core, unless and until\nsome interoperable DAV clients also implement some of the more generally\nuseful extensions such as checkin/checkout, baselines, variants or\nlabels, or until a customer requires such options.\n\n\"Expressed interest\" is a vague statement, you could say that Xythos has\nexpressed interest in various extensions, however as I've stated we may\nnot implement any extensions anytime soon.\n\nAny other document management vendors care to discuss what options they\nplan to implement?\n\nLisa\n\n\n\n", "id": "lists-006-5850217"}, {"subject": "RE: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm ES", "content": "Oops, I was working on an email to you separately about that, but it's\nstill sitting in my drafts folder.\n\nI was excited about the possibilities of variants, but when Barry\nreviewed the draft, he brought me back down to earth.  It's the problem\nof being a small company without in-house client development.  Sure, we\ncould implement variants in our server, but if no client did, what's the\npoint -- our versioning support would be useless.\n\nYou may want to leave it in, because if one of our customers ever asks\nfor the functionality provided by variants, we can recommend that.\nEazel might someday look at it.  Or if Microsoft or Adobe or another of\nthe big WebDAV client companies ever implements variants, then great,\nwe're there.  But until then, we really can't afford to implement\nsomething that doesn't interoperate with anything.\n\nI still agree that the variant stuff is valuable, but *sigh*...\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Friday, February 02, 2001 2:17 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm EST\n>\n>\n> I thought you were planning on supporting the variant\n> option?  (And if not, why did we spend all that time\n> working it out ... :-).\n>\n> Cheers,\n> Geoff\n>\n> p.s.  Seriously, I think the variant\n> option is a valuable addition to the protocol, whether\n> or not you intend on implementing it in your server (:-)\n>\n> -----Original Message-----\n> From: Lisa Dusseault [mailto:lisa@xythos.com]\n> Sent: Friday, February 02, 2001 2:50 PM\n> To: Jim Amsden; ietf-dav-versioning@w3.org\n> Subject: RE: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm EST\n>\n>\n> > We have struggled with how to handle core vs. advanced\n> > vs. options since the beginning of Delta-V. In fact,\n> > there is a recent thread on this subject that suggests\n> > splitting them into separate documents. The compromise\n> > we came up with was to have core contain the minimal,\n> > essential support for versioning semantics that we\n> > expected every server vendor would implement. That is,\n> > core represents the common functions provided by all\n> > versioning repository vendors while the extensions\n> > represent the variability. However, we don't expect any\n> > server to just implement core because by itself, core\n> > isn't that interesting. Even the document management\n> > vendors have expressed interest in a number of the\n> > extensions. We just couldn't get any agreement on common\n> > subsets. This has been the greatest source of\n> > controversy, not the semantics of the specific\n> > extensions themselves.\n>\n> Xythos is planning to implement core and only core, unless and until\n> some interoperable DAV clients also implement some of the\n> more generally\n> useful extensions such as checkin/checkout, baselines, variants or\n> labels, or until a customer requires such options.\n>\n> \"Expressed interest\" is a vague statement, you could say that\n> Xythos has\n> expressed interest in various extensions, however as I've\n> stated we may\n> not implement any extensions anytime soon.\n>\n> Any other document management vendors care to discuss what\n> options they\n> plan to implement?\n>\n> Lisa\n\n\n\n", "id": "lists-006-5861049"}, {"subject": "RE: CHECKIN and propertie", "content": "Jim Whitehead wrote on Wednesday, January 31, 2001 5:42 PM:\n> Section 2.2.5:\n> \n> This seems underspecified to me. There are really two parameters here,\n> resource is write-locked/unlocked, and autoversion status of \n> when-unlocked, and when-locked.\n\nI agree that all the combinations need to be covered by the spec.  Moreover,\nsection 2.1.2 only talks about auto-version being \"set\" and doesn't\ndifferentiate among the possible settings of auto-version.  Both problems\nneed to be fixed.\n\nGeoff Clemm's 1/13/01 email sketched out his intent for the semantics of the\nfour possible settings for auto-version:\n\n> nothing (no auto-versioning)\n> DAV:when-locked (auto-checkout when locked)\n> DAV:when-unlocked (new version when unlocked)\n> DAV:when-locked, DAV:when-unlocked (both)\n\nIn an attempt to fill in Jim's table, I have tried to expand Geoff's sketch,\nbased on Geoff's other messages around the same time.  It's useful to recall\nthat if the VCR is checked out at the time of the PUT or PROPPATCH, the\nauto-version property is ignored, and there is no auto-versioning.  That\nleaves the case when the VCR is checked-in at the time of the PUT or\nPROPPATCH, with the following interpretation of the value of auto-version:\n\n  nothing\n    - no auto-versioning\n  DAV:when-locked\n    - auto-checkout when write-locked, buffer changes until\n      unlock request, then auto-checkin\n    - error when unlocked (at time of PUT or PROPPATCH)\n  DAV:when-unlocked\n    - create new version; i.e., auto-checkout, modify,\n      auto-checkin (must supply lock header if VCR\n      write-locked)\n  DAV:when-locked, DAV:when-unlocked\n    - auto-checkout when write-locked, buffer changes until\n      unlock request, then auto-checkin\n    - create new version when unlocked; i.e., auto-checkout,\n      modify, auto-checkin\n\nNote that when-unlocked does *not* mean auto-version only when the VCR is\nunlocked, whereas when-locked does in fact mean auto-version only when the\nVCR is write-locked.  This inconsistency makes the naming somewhat\nmisleading, but I haven't come up with anything better that also works in\ncombination in the fourth case.\n\nThis interpretation of when-unlocked is critical for versioning systems that\nrequire all versionable resources to be under version control, but don't\nsupport storing intermediate state on the server between checkout and\ncheckin.  Such systems cannot support the CHECKOUT option, because it\nrequires storage of intermediate state.  Nor can they support the\nwhen-locked flavor of auto-versioning, for the same reason.  So they are\nreduced to depending on  the when-unlocked flavor of auto-versioning in core\nversioning, with the above interpretation covering all VCRs, regardless of\nlock state.\n\n--Chuck Fay \nFileNET Corporation, 3565 Harbor Blvd., Costa Mesa, CA 92626 \nphone:  (714) 327-3513, fax:  (714) 327-5076, email:  cfay@filenet.com\n\n\n\n", "id": "lists-006-5873257"}, {"subject": "FW: DeltaV Passthrough issue", "content": "In an earlier mail, Geoff said:\n\"   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   What about getting the DAV:version property for the base resource,\nwhich\n   if pass-through is working to the current target, should result in\n   getting the DAV:version for the current target?\n\nI'm not sure what you mean by \"if pass-through is working to the\ncurrent target\",  but in any case, as Greg pointed out, if you\nwant the version URL for the DAV:checked-in or DAV:checked-out\nversion of a version-controlled resource, you get that from the\nDAV:checked-in and DAV:checked-out property value.  There's no\nneed to have a second way of getting the same information.\"\n\nWhat I meant by \"passthrough\" is what has been talked about before in\nthe context of redirect resources, and now seems to be a feature of\nversioning.  To recap:  When new kinds of resources that have targets,\nlike \"Direct Reference Resources\" or \"Version controlled Resources\"\n(DRR/VCR), are exposed to clients that are not familiar with the new\nkinds of resources, it's often beneficial to allow some of the methods\nthe client may send to \"pass through\" to the target of DRR/VCR.  Also,\nwhen RR/VCRs exist in collections along with ordinary resources,\nPROPFIND can usefully show properties of the target resources, along\nwith properties of the DRR/VCR itself. So when I do a PROPFIND depth 1\non a directory asking for the \"DAV:content-length\" property, it would be\nuseful for me to see the content-length of ordinary resources, the\ncontent-length of the targets of links, and the content-length of the\ntarget version of each VCR.  I thought this was called \"passthrough\"\nwhen bindings were being discussed, but apparently is no longer refered\nto in this way.\n\nAnyway, the idea for bindings at one time was to allow some kind of\nreference resource to exist, which when queried, would respond \"as if\"\nit was the target resource.  However, sometimes the client wants to\naddress the reference resource directly.  The server needs to know if\nthe client is addressing the reference resource, or the target of the\nreference resource.  Thus, the \"Apply-To-Redirect-Ref\" header was\ndefined.  If the client includes this header, e.g. with a DELETE, the\nserver can understand this to mean that the client wishes to delete the\nredirect reference itself, rather than get redirected to the target\nreference.\n\nAll of this applies to versioning, because with the current state of the\ndraft, it's clear that a VCR is a kind of reference resource.  I quote:\n\n\"A PUT or PROPPATCH to a version-controlled resource with the\nDAV:auto-version property set will automatically check out that resource\nprior to executing the PUT or PROPPATCH.  If that resource is\nwrite-locked, the resource remains checked-out until the resource is\nunlocked, at which time the resource is checked in and a new version is\ncreated in the version history of that resource.\"\n\n\"For certain methods (e.g. GET, PROPFIND), if the request-URL identifies\na version-controlled resource, a label can be specified in a Label\nrequest header to cause the method to be applied to the version selected\nby that label from the version history of that version-controlled\nresource.\"\n\nThis means that PUT and PROPPATCH are ALWAYS parsed as applying to the\nversion (passthrough), even though the URL was to the VCR.   It also\nmeans that GET and PROPFIND _sometimes_ apply to the version\n(passthrough).\n\nIt's not as clear what other methods are applied to.  It seems MOVE\nsource is defined as the VCR (no passthrough), but the COPY source is\nthe defined as the default version.  The language all seems to imply\nthat a COPY when the source URL is a VCR should be interpreted as\ncopying the latest version from the source, to the destination.\n\nThe consequence of a model that supports \"pass through\" to the target of\na reference resource is that the model must specify clearly when\npassthrough occurs, and when it doesn't.  In addition:\n - What methods the Label: header can apply to (and what it _can't_)\n - When the label header is absent, for each method, what does it apply\nto -- the VCR or the target version?\n - Whether there is a way of overriding the default assumption of what\nthe method applies to\n\nSome of the specific questions that came up when I was reading the spec:\n - If any PROPPATCH to a VCR actually creates a new version; how does\none proppatch the properties actually on a VCR, such as\nDAV:auto-version, DAV:predecessor-set and DAV:precursor-set, which\naren't protected?\n - If a PROPFIND with a Label: header is applied to a non\nversion-controlled resource, what does \"no effect\" mean?  What happens\nif the specified label wasn't found -- does PROPFIND then return the\nproperties of the target version?  Or the VCR?\n - Does a PROPFIND to a VCR result ever result in a merge of the\nproperties of the VCR and its target version?\n - Since COPY seems to always get its content from a single version, I\nwould say that \"passthrough\" always seems to be on for COPY.  Is there\nany way of NOT doing passthrough with COPY?  I.e, is there any way of\ncopying a VCR along with its VHR and VRs?  This would result in two\nVCRs, two VHs and 2*n VRs, which would be the same initially, but could\ndiverge after.\n\nA related issue is one I brought up in a separate mail, but I'll explain\nthe relationship here too:  how does one define properties which apply\nnot to an individual version, but to the whole shebang -- to the VCR,\nVHR and all VRs?  An example is \"owner\", which in its meaning of \"the\nperson responsible for this resource\", can be taken to mean that when\nownership of a VCR is transferred the new owner becomes responsible for\nall old versions related to the VCR.  No?  But we can't go about\nchanging properties of old versions...\n\nLisa\n\n\n\n", "id": "lists-006-5883646"}, {"subject": "Complexity and Core Consideration", "content": "As a result of discussions in this morning's teleconference, I would like to\nformally pose two questions to all members of the list and solicit your\nresponses and opinions.\n\n\n1) Is the current form of the specification too complex?  Yes/No/Maybe.\nWhy?\n\n\n2) Does there remain sufficient discussion going on surrounding the OPTIONS\nthat the draft should be split into two documents, CORE and OPTIONS, so that\nwe can move CORE forward?  Yes/No/Maybe.  Why?\n\n\n\nThanks,\n\nMark\n\n\n\n", "id": "lists-006-5896967"}, {"subject": "RE: DeltaV doesn't support a true client workspac", "content": "See my proposal for CHECKOUT/CHECKIN enhancements below in support of a true\nclient workspace, along with interspersed responses to Geoff's reply.\n\n> From: Geoffrey M. Clemm [mailto:geoffrey.clemm@rational.com]\n> Sent: Thursday, January 18, 2001 10:05 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: DeltaV doesn't support a true client workspace\n> \n>    From: \"Fay, Chuck\" <CFay@filenet.com>\n> \n>    There seems to be an underlying assumption in DeltaV,\n>    even for parts of core versioning, that the server\n>    provides persistent storage of work-in-progress\n>    on resources between checkout and checkin.\n> \n> I don't believe that is the case.  As you point out below, core\n> versioning allows a server to only support the DAV:when-unlocked\n> mechanism, which creates a new version on every update.\n\nRight, but it's still true that some of the key options, in particular\nCHECKOUT, and even a core versioning feature like the DAV:when-locked flavor\nof auto-versioning, make this underlying assumption.\n\n>    Unfortunately, this assumption is not valid for some \n>    existing versioning systems, including a FileNET\n>    content management product and one of the software\n>    configuration management products we use internally.\n>    These two versioning systems employ the concept of\n>    what I would call a *real* client workspace, where\n>    *all* intermediate work-in-progress is stored on the\n>    client side between checkout and checkin...\n> \n> That's OK.  Although the protocol defines how a client interoperates\n> with a server that provides storage for intermediate work-in-progress,\n> a variety of the options (e.g. baselines and activities) should work\n> just fine for a server that does not support intermediate \n> work-in-progress.\n\nOkay, but wouldn't it be better if a key option like CHECKOUT worked as\nwell?\n\n>    One alternative is to build a core versioning layer for \n>    these two systems which would disallow the\n>    DAV:when-locked flavor of DAV:auto-version.\n> \n> That is already legal in the current core versioning definition.\n\nRight.\n\n>    But this would result in a new version for every\n>    PUT or PROPPATCH of dead properties done by the\n>    client.  Arbitrary DeltaV clients are not likely to\n>    limit themselves to one PUT between a LOCK and\n>    UNLOCK, so there would likely be a proliferation\n>    of unwanted intermediate versions.  Scratch that\n>    alternative.\n> \n> Well, there is not much you can do about making a client that requires\n> intermediate storage on the server (perhaps because it has none of its\n> own) to interoperate with a server that does not provide intermediate\n> storage.  That's the same for many of the other options (i.e. they are\n> server options because clients want the servers to do that work).\n\nYes, but my point is to allow a client that is willing to accommodate a\nserver with no support for intermediate storage.  Sure, clients that depend\non features not supported by a particular server won't work with that\nserver.  (As an aside, that's the danger of having lots of options that\nwon't necessarily be supported by all the server implementations.  That's my\nmain concern with the baroque set of options currently in DeltaV.)\n\nSkipping to the third alternative...\n\n>    A third alternative would be to add a flavor of \n>    CHECKOUT-CHECKIN to core versioning in DeltaV\n>    that allows all changes to accompany the CHECKIN\n>    method.  This is the model used by the existing\n>    systems I mentioned.\n> \n> The only way that would help you is if we *required* this to be the\n> only way a client could interoperate with a versioning server.  That\n> would make the versioning protocol useless for a client that does\n> not have local persistent storage, so I find it very unlikely that\n> many would find this acceptable.\n\nI disagree.  Let's say that we shifted the keep-checked-out option from the\nCHECKIN request body to a header, and instead allowed an optional CHECKIN\nrequest body containing new contents for the resource.  That is, the\noptional request body would be the same as a PUT request body.  That allows\na client that is storing all intermediate state locally to do a single\ncheckin with the new content bundled with the CHECKIN request.  This would\nnot force all clients to do so, however.  Clients depending on working\nresources or checked-out mutable VCRs could choose not to supply a CHECKIN\nbody and would work just fine with servers supporting those optional\nfeatures.  As always, independent of this proposed change, they would fail\nto work with servers implementing only core versioning.\n\nBesides the change to CHECKIN, clients will need a means to determine if the\nserver supports storage of intermediate state.  I propose creating a new\noption called \"Mutable Checked-out Version-Controlled Resource Option\" to\nreplace the current CHECKOUT option.  Mutable checked-out VCRs would be\ndefined to accept PUTs and PROPPATCHes between checkout and checkin and\npersistently store the resulting modifications during that period.  CHECKOUT\n(and CHECKIN as modified here) would move back into core versioning, but\nwould not support mutable checked-out VCRs without the mutable checked-out\nVCR option.  Thus any client storing all intermediate state locally and\nusing this CHECKIN feature would work with any server supporting core\nversioning.\n\n(Aside:  I'm not proposing a solution for checking in changes to dead\nproperties coincident with content changes on a CHECKIN, but I suppose that\ncould be done with a structured request body with both properties in\nPROPPATCH form and content in PUT form.  That's not a priority, though,\nbecause the systems I'm familiar with don't support dead properties.)\n\n>    Are there other alternative solutions to this problem?\n> \n> If the problem is \"how to make a client interoperate with a server\n> that does not provide the functionality required by that client\",\n> then I don't think there are *any* solutions to this problem.\n\nCan't disagree with the conclusion, but I'm not trying to solve that\nparticular problem (:-).  I would say the problem is \"how to make DeltaV fit\nexisting practice better, in the area of products that don't provide for\nserver-side storage of intermediate state between checkout and checkin\".\n\n>    Do others on the mailing list know of existing\n>    versioning systems with this same problem with\n>    DeltaV?  Or is this problem limited to just\n>    these two systems?\n\nI'm still interested in hearing about other versioning servers that don't\nsupport intermediate storage of work-in-progress on checked-out objects.  I\nsuspect this is a common trait of existing versioning systems.\n\n--Chuck Fay \nFileNET Corporation, 3565 Harbor Blvd., Costa Mesa, CA 92626 \nphone:  (714) 327-3513, fax:  (714) 327-5076, email:  cfay@filenet.com\n\n\n\n", "id": "lists-006-5905133"}, {"subject": "Clarification of working-resource option descriptio", "content": "Section 6, first paragraph says this about the working-resource option:\n\n\"In order to allow two users to work concurrently on making changes to the\nsame resource, it is necessary to provide multiple checked out resources for\nthe same version history.  Even if only one user is making changes to a\nresource, it is sometimes desirable to be able to make those changes (new\nversions) \"in private\" and then expose that work at an appropriate later\ntime.  One way to provide this functionality depends on maintaining the\ndesired configuration of resources in persistent state on the client\n(usually a copy of the content and dead properties of each resource in the\nconfiguration, but minimally a URL list).  This is the working-resource\noption...\"\n\nWhile this is all true, shouldn't it be clearly stated here that the\nworking-resource option provides for a mutable, persistent working resource\non the server, no matter what persistent state might also be kept on the\nclient?  A reader could easily come away from that first paragraph not\nrealizing that this option calls for the server-resident working resource,\nbecause it focuses only on client-resident persistent state that may include\ncontent and dead properties of each of those same resources.\n\n--Chuck Fay \nFileNET Corporation, 3565 Harbor Blvd., Costa Mesa, CA 92626 \nphone:  (714) 327-3513, fax:  (714) 327-5076, email:  cfay@filenet.com\n\n\n\n", "id": "lists-006-5921234"}, {"subject": "Re: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm ES", "content": "Rational intends on implementing most of the DeltaV options,\nexcept for working resources and variants.  We will probably\nimplement those options as well if there is sufficient client demand\nfor them.\n\nCheers,\nGeoff\n\n   From: \"Eric Sedlar\" <eric.sedlar@oracle.com>\n   Date: Fri, 2 Feb 2001 15:03:31 -0800\n\n   Oracle plans on implementing most of the DeltaV options,\n   with the notable exception of Variants.  \n\n   In addition to end-user clients, we may also be using DeltaV\n   internally to communicate between middle tier and data servers.\n\n   --Eric\n\n   -----Original Message-----\n   From: ietf-dav-versioning-request@w3.org\n   [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n   Sent: Friday, February 02, 2001 11:50 AM\n   To: Jim Amsden; ietf-dav-versioning@w3.org\n   Subject: RE: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm EST\n\n\n   > We have struggled with how to handle core vs. advanced\n   > vs. options since the beginning of Delta-V. In fact,\n   > there is a recent thread on this subject that suggests\n   > splitting them into separate documents. The compromise\n   > we came up with was to have core contain the minimal,\n   > essential support for versioning semantics that we\n   > expected every server vendor would implement. That is,\n   > core represents the common functions provided by all\n   > versioning repository vendors while the extensions\n   > represent the variability. However, we don't expect any\n   > server to just implement core because by itself, core\n   > isn't that interesting. Even the document management\n   > vendors have expressed interest in a number of the\n   > extensions. We just couldn't get any agreement on common\n   > subsets. This has been the greatest source of\n   > controversy, not the semantics of the specific\n   > extensions themselves.\n\n   Xythos is planning to implement core and only core, unless and until\n   some interoperable DAV clients also implement some of the more generally\n   useful extensions such as checkin/checkout, baselines, variants or\n   labels, or until a customer requires such options.\n\n   \"Expressed interest\" is a vague statement, you could say that Xythos has\n   expressed interest in various extensions, however as I've stated we may\n   not implement any extensions anytime soon.\n\n   Any other document management vendors care to discuss what options they\n   plan to implement?\n\n   Lisa\n\n\n\n", "id": "lists-006-5930155"}, {"subject": "RE: Complexity and Core Consideration", "content": "> 1) Is the current form of the specification too complex?  Yes/No/Maybe.\n> Why?\n\nNo.  Complexity is in the eye of the beholder -- this specification seems as\ncomplex as needed to specify the included functionality.  This specification\nis actually smaller than the *user's* manual for most CM systems.\n\n> 2) Does there remain sufficient discussion going on surrounding\n> the OPTIONS that the draft should be split into two documents, CORE and\n> OPTIONS, so that we can move CORE forward?  Yes/No/Maybe.  Why?\n\nI'm in favor of splitting the document, since I think that will make it\ncrystal clear exactly what constitutes core versioning.  Thus, I'm in favor\nof splitting, even if all the parts are submitted at once.  Document\nsplitting doesn't imply lack of adoption -- we've seen messages on this list\nin the past few days from major vendors indicating they will implement broad\nswathes of the specification.\n\n- Jim\n\n\n\n", "id": "lists-006-5940995"}, {"subject": "Re: Complexity and Core Consideration", "content": "   From: \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n\n   > 1) Is the current form of the specification too complex?  Yes/No/Maybe.\n   > Why?\n\n   No.  Complexity is in the eye of the beholder -- this specification seems as\n   complex as needed to specify the included functionality.  This specification\n   is actually smaller than the *user's* manual for most CM systems.\n\nI agree with Jim.  If someone has a specific, concrete suggestion for\nhow to make it simpler without damaging interoperability, we'd love to\nhear it.  Over the last 2.5 years, we have proposed removing every\noption that currently is defined (often trying more than once), and\nonly vocal and energetic support from multiple client or server\nimplementors for that option in its current form has kept any given\noption alive.  In other words, these implementors are counting on\nthat option to serve as the basis for interoperation.\n\n   > 2) Does there remain sufficient discussion going on surrounding\n   > the OPTIONS that the draft should be split into two documents, CORE and\n   > OPTIONS, so that we can move CORE forward?  Yes/No/Maybe.  Why?\n\n   I'm in favor of splitting the document, since I think that will make it\n   crystal clear exactly what constitutes core versioning.  Thus, I'm in favor\n   of splitting, even if all the parts are submitted at once.  Document\n   splitting doesn't imply lack of adoption -- we've seen messages on this list\n   in the past few days from major vendors indicating they will implement broad\n   swathes of the specification.\n\nJim makes an important distinction here.  One question is whether we\nsubmit the versioning protocol as two documents or as one.  A follow-on\nquestion is if we do split the document, do we submit them at the same\ntime, or do we submit versioning core first and then versioning options\nat some indeterminate time in the future.\n\nThe first question is just an editorial question.  I would prefer to\nkeep the versioning protocol as one document -- after all, when the\nfirst paragraph of the introductions says:\n\n  \"An implementor that is only interested in core versioning should read\n   Section I (Introduction), Section II (Core Versioning), and Section\n   15 (Report Option).\"\n\nis a reader really all that likely to be confused?  But here I'm happy\nto do whatever (heck, I can cut'n'paste with the best of them :-), so\nI'd like to just pass this decision over to Jim Amsden, our working\ngroup chair (and he can pass it on to whoever he wants, just so it\nisn't back to me :-).\n\nBut I am strongly opposed to delaying the submission of the versioning\noptions for \"proposed standard\" status, since after 2.5 years of work\nby numerous members of this working group, with 12 internet drafts and\nover 50 working drafts, we have reached significant consensus on the\nsuitability of the current versioning options for providing a basis\nfor interoperable implementations.\n\nI have personal experience with the requirement of many implementers\n(or at least, those implementers bosses :-) that the protocol reach\n\"proposed standard\" status before significant implementation\ncommitments will be made, and it is my strongly held belief that we\nhave gotten as close as we are going to get by \"talking about it\", and\nthat the remaining interoperability issues will now only be uncovered\nby those implementation efforts that currently are waiting for the\nprotocol reaching \"proposed standard\" status.\n\nI believe it is virtually certain that there will be significant\nchanges to the protocol between \"proposed standard\" and \"draft\nstandard\", but I also strongly believe that these changes will only be\nidentified through attempts to achieve interoperability through a\nstable (initial) version of the protocol.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5949288"}, {"subject": "Re: Clarification of working-resource option descriptio", "content": "   From: \"Fay, Chuck\" <CFay@filenet.com>\n\n   ... shouldn't it be clearly stated here that the\n   working-resource option provides for a mutable, persistent working resource\n   on the server, no matter what persistent state might also be kept on the\n   client?  A reader could easily come away from that first paragraph not\n   realizing that this option calls for the server-resident working resource,\n   because it focuses only on client-resident persistent state that may include\n   content and dead properties of each of those same resources.\n\nI agree that is worth clarifying.  I'll add some words in the option\ndefinition to that effect.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5960563"}, {"subject": "RE: Complexity and Core Consideration", "content": "I second this.\n\n-----Original Message-----\nFrom: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\nSent: Saturday, February 03, 2001 11:01 AM\nTo: Ietf-Dav-Versioning@W3. Org\nSubject: RE: Complexity and Core Considerations\n\n\n\n> 1) Is the current form of the specification too complex?  Yes/No/Maybe.\n> Why?\n\nNo.  Complexity is in the eye of the beholder -- this specification seems as\ncomplex as needed to specify the included functionality.  This specification\nis actually smaller than the *user's* manual for most CM systems.\n\n> 2) Does there remain sufficient discussion going on surrounding\n> the OPTIONS that the draft should be split into two documents, CORE and\n> OPTIONS, so that we can move CORE forward?  Yes/No/Maybe.  Why?\n\nI'm in favor of splitting the document, since I think that will make it\ncrystal clear exactly what constitutes core versioning.  Thus, I'm in favor\nof splitting, even if all the parts are submitted at once.  Document\nsplitting doesn't imply lack of adoption -- we've seen messages on this list\nin the past few days from major vendors indicating they will implement broad\nswathes of the specification.\n\n- Jim\n\n\n\n", "id": "lists-006-5968340"}, {"subject": "Re: DeltaV doesn't support a true client workspac", "content": "   From: \"Fay, Chuck\" <CFay@filenet.com>\n\n   > ... Well, there is not much you can do about making a client that\n   > requires intermediate storage on the server (perhaps because it\n   > has none of its own) to interoperate with a server that does not\n   > provide intermediate storage.  That's the same for many of the\n   > other options (i.e. they are server options because clients want\n   > the servers to do that work).\n\n   Sure, clients that depend on features not supported by a particular\n   server won't work with that server.  (As an aside, that's the\n   danger of having lots of options that won't necessarily be\n   supported by all the server implementations.  That's my main\n   concern with the baroque set of options currently in DeltaV.)\n\nThe alternative is either having no way for clients and servers that\nrequire that functionality to interoperate, or requiring that your\nserver support something that you clearly don't want to support.  If\nwe are forced to chose between \"requiring intermediate server state\"\nand \"disallowing intermediate server state\", I can confidently predict\nthat the consensus will be \"requiring server state\".  If so, your\nserver will have no way of advertising that it has any versioning\nsupport.\n\nEvery other \"baroque\" option has exactly this characteristic ... there are\na significant number of implementors that are depending on that option\nto achieve interoperability, but there are also several implementors\nthat insist that they will not support that option, but do want to\nadvertise that they support some other versioning capabilities.\n\n   >    A third alternative would be to add a flavor of \n   >    CHECKOUT-CHECKIN to core versioning in DeltaV\n   >    that allows all changes to accompany the CHECKIN\n   >    method.  This is the model used by the existing\n   >    systems I mentioned.\n\n   Let's say that we shifted the keep-checked-out option from the\n   CHECKIN request body to a header, and instead allowed an optional\n   CHECKIN request body containing new contents for the resource.\n   That is, the optional request body would be the same as a PUT\n   request body.  That allows a client that is storing all\n   intermediate state locally to do a single checkin with the new\n   content bundled with the CHECKIN request.  This would not force all\n   clients to do so, however.\n\nCurrently, the protocol already provides an interoperable way of\nachieving this result with the PUT method applied to a\nversion-controlled resource with DAV:auto-version set to\nDAV:when-unlocked.  \n\nPerhaps your intent here is to provide a way for a client to get\nauto-version behavior from PUT only when it explicitly asks for it?\nI.e. you only want clients to create new versions if they know\nthat they are doing so?  If so, I believe a simpler way to\nachieve your goal would be to add an Autoversion header to PUT.\nThis would tell PUT to have autoversioning behavior for just\nthat request.\n\nThis not only is far more consistent with the current pre-conditions\nof CHECKIN (i.e. that it is only applied to a checked-out resource),\nbut also allows you to have just one new header, instead of requiring\na new header for every parameter to CHECKIN.\n\n   Besides the change to CHECKIN, clients will need a means to determine if the\n   server supports storage of intermediate state.  I propose creating a new\n   option called \"Mutable Checked-out Version-Controlled Resource Option\" to\n   replace the current CHECKOUT option.\n\nWell, that is a really catchy name (:-), but if we just add an\nAutoversion header for PUT, we can leave it as the \"checkout option\".\n\nSo I have two questions:\n\nChuck: Does the Autoversion header for PUT get you what you need?\nNote that to be interoperable with versioning unaware clients,\nyou'll have to set DAV:auto-version anyway, so are you sure that existing\nDAV:auto-version and PUT behavior isn't sufficient?\n\nEveryone else: Do you think that the Autoversion header for PUT is\nof sufficient value to be worth putting into core?  It is a way\nfor a versioning client to interact with a server like Chuck's\nwithout forcing his server to have every PUT to a version-controlled\nresource result in a new version.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-5977545"}, {"subject": "Re (2): Labels and Statu", "content": "\"Lisa Dusseault\" <lisa@xythos.com> wrote:\n> Yes, many versioning systems have \"status\" properties on versions, and\n> the \"status\" property should be mutable, i.e. should be writable without\n> creating a new version.\nsnip\n> Thus, versioning needs a general way to allow creation of custom\n> properties which are mutable, AND custom properties which are immutable.\n> The server would of course reject requests for mutable properties if it\n> does not support mutability, but we need a standard way for clients to\n> ask for this.\nI saw no reply to that yet so I will give my $0.02.\nI think a mutable status property is essential if I want to do some\ndocument management.\nTo be more flexible I also would want to to have at least arbitrary\nmutable properties to add to a version.\nOr can I mimic that by adding multiple labels to a version ? E.g.\ndoc#1 status_accepted, author_edgar\ndoc#2 status_working, author_lisa (sometimes authors of documents change)\n\nCheers, Edgar\n\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Native Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-5989433"}, {"subject": "Re (2): Complexity and Core Consideration", "content": "> But I am strongly opposed to delaying the submission of the versioning\n> options for \"proposed standard\" status, since after 2.5 years of work\n> by numerous members of this working group, with 12 internet drafts and\n> over 50 working drafts, we have reached significant consensus on the\n> suitability of the current versioning options for providing a basis\n> for interoperable implementations.\n\n> I have personal experience with the requirement of many implementers\n> (or at least, those implementers bosses :-) that the protocol reach\n> \"proposed standard\" status before significant implementation\n> commitments will be made, and it is my strongly held belief that we\n> have gotten as close as we are going to get by \"talking about it\", and\n> that the remaining interoperability issues will now only be uncovered\n> by those implementation efforts that currently are waiting for the\n> protocol reaching \"proposed standard\" status.\n\n> I believe it is virtually certain that there will be significant\n> changes to the protocol between \"proposed standard\" and \"draft\n> standard\", but I also strongly believe that these changes will only be\n> identified through attempts to achieve interoperability through a\n> stable (initial) version of the protocol.\nI normally avoid to cite too much but nevertheless do it to emphasize what\nGeoff said. I couldn't have said it better.\n\nCore versioning is agreed I suppose. And the fate of options will be\ndecided on the marketplace by their value to the customers. So let's\nfinally go on to proposed standard so that implementation can start in\nearnest. And please don't give versioning in two pieces to IETF.\nIMHO core versioning doesn't have the functionality I need. So proposing\ncore and postphoning options would prolong options still longer.\nAs I said before. Let the users requirements decide on the fate of the\noptions.\n\nRegards, Edgar\n\n\n\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Native Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-5997853"}, {"subject": "RE: Re (2): Complexity and Core Consideration", "content": "From: Geoffrey M. Clemm [geoffrey.clemm@rational.com]\n> > But I am strongly opposed to delaying the submission of the versioning\n> > options for \"proposed standard\" status, since after 2.5 years of work\n> > by numerous members of this working group, with 12 internet drafts and\n> > over 50 working drafts, we have reached significant consensus on the\n> > suitability of the current versioning options for providing a basis\n> > for interoperable implementations.\n[snip]\n> > I believe it is virtually certain that there will be significant\n> > changes to the protocol between \"proposed standard\" and \"draft\n> > standard\", but I also strongly believe that these changes will only be\n> > identified through attempts to achieve interoperability through a\n> > stable (initial) version of the protocol.\n\nFrom: Edgar@EdgarSchwarz.de\n> I normally avoid to cite too much but nevertheless do it to emphasize what\n> Geoff said. I couldn't have said it better.\n[snip]\n> As I said before. Let the users requirements decide on the fate of the\n> options.\n\nFor what it is worth, I agree with both Edgar and Geoffery.\n\nThe complexity of the protocol may be a concern, but only if this\ncauses a real problem with interoperability.  After 2.5 years it is\ntime to move on to the next phase.  The first real implementations\nwill illuminate most clearly where any misunderstandings may lie.\n\n--\nPreston L. Bannister\npreston@home.com\nhttp://members.home.com/preston/\n\n\n\n", "id": "lists-006-6007231"}, {"subject": "RE: Re (2): Labels and Statu", "content": "Labels won't solve the problem, for us and I suspect also for you,\nbecause you can't have more than one version in a version history have\nthe same label.\n\nSo although you could mark one version with the label \"author_edgar\",\nyou could only do that to one version.  I think by the very example you\nchose you want to be need to have custom mutable properties.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> Edgar@EdgarSchwarz.de\n> Sent: Saturday, February 03, 2001 2:21 PM\n> To: ietf-dav-versioning@w3.org\n> Cc: Edgar@EdgarSchwarz.de\n> Subject: Re (2): Labels and Status\n>\n>\n> \"Lisa Dusseault\" <lisa@xythos.com> wrote:\n> > Yes, many versioning systems have \"status\" properties on\n> versions, and\n> > the \"status\" property should be mutable, i.e. should be\n> writable without\n> > creating a new version.\n> snip\n> > Thus, versioning needs a general way to allow creation of custom\n> > properties which are mutable, AND custom properties which\n> are immutable.\n> > The server would of course reject requests for mutable\n> properties if it\n> > does not support mutability, but we need a standard way for\n> clients to\n> > ask for this.\n> I saw no reply to that yet so I will give my $0.02.\n> I think a mutable status property is essential if I want to do some\n> document management.\n> To be more flexible I also would want to to have at least arbitrary\n> mutable properties to add to a version.\n> Or can I mimic that by adding multiple labels to a version ? E.g.\n> doc#1 status_accepted, author_edgar\n> doc#2 status_working, author_lisa (sometimes authors of\n> documents change)\n>\n> Cheers, Edgar\n>\n>\n> --\n> edgar@edgarschwarz.de                    http://www.edgarschwarz.de\n> *          DOSenfreie Zone.        Running Native Oberon.         *\n> Make it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-6016488"}, {"subject": "RE: DeltaV doesn't support a true client workspac", "content": "> Everyone else: Do you think that the Autoversion header for PUT is\n> of sufficient value to be worth putting into core?  It is a way\n> for a versioning client to interact with a server like Chuck's\n> without forcing his server to have every PUT to a version-controlled\n> resource result in a new version.\n\nI think this header could be extremely valuable, particularly if it\ncould indicate either T or F.\n\nExample: if the DAV:auto-version property indicates that auto-versioning\nis off, the presence of an \"Auto-version: T\" header would override and\ncreate a new version.  Also, if the DAV:auto-version property indicates\nthat auto-versioning is on, but the client sends \"Auto-version: F\"\nheader in the request, then the server can know it's a work-in-progress\nand just modify the latest version, without requiring a checkout/checkin\nor changing the version URL.\n\nWould it be less confusing to have the header called\n\"Create-new-version\" or some such?\n\nlisa\n\n\n\n", "id": "lists-006-6027560"}, {"subject": "DTD Confusio", "content": "Dear Colleagues,\n\nThere seem to be some confusion as to how DTD work.  The tendency of the\nauthors of the DeltaV document to write ANY in every place that one\nwould like to be able to the protocol is both unnecessary and unhelpful.\nIn particular, a DTD is similar to a BNF for a language: a parser need\nnot use the BNF directly to parse the language, but It still gives\nimplementers a way of precisely describing the language.\n\nThis conception seems to be in the manner that validation is\ninterpreted. There seems to be the view that if a server validates its\ninput and a client makes a request with an extended DTD,the server will\nnot recognize some new tag and thus reject the request. Of course, this\nwould be contrary to the spirit of this protocol.  However, validation\ndoes not work this way.  If a client sends a message based on a new DTD,\nit causes no problem.  The client must send a copy or a reference of the\nnew DTD with its message.  The server has two choices: it may fetch the\nnew DTD and validate against that DTD, or the server may simply check\nfor well-formedness. In both cases, the server need not and should not\nreject the request, so long as the request matches the given DTD.  If it\ndoes not match, however, something is in fact wrong with the request. \nEven in this case, the server is still permitted to recover from the\nerror.  The same applies in reverse for responses from the client.\n\nWe opine that a client or a server should be able to send messages that\nconform to the DTD that it uses.   This does not inhibit communication\nwith peers that use another version of the protocol. Each new version\nmust have its own DTD, but this should be a good basis for understanding\nwhat the protocol actually is in any given version and how it changes\nfrom one version to the next.  A well designed DTD should also help\ninsure that new version are, in fact, upwardly compatible.\n\nSincerely,\nJames J. Hunt\nJ?rgen Reuter\n\n\n\n", "id": "lists-006-6036019"}, {"subject": "WebDAV/DeltaV Interoperability and XML Validatio", "content": "Dear Colleagues,\n\nAfter much thought, we have finally devised a way to provide for XML\nvalidation in DeltaV without breaking existing WebDAV clients.  There\nare only two points where the DTD given in WebDAV is not validatable: \nproperty tags occur both as empty-element tags and as begin/end tag\npairs, and though the DTD is named webdav-1.0, it gives no definition\nfor that tag.   Two small changes would make the DTD usable.\n\nThe problem is that to do this, an incompatibility would be introduced\nbetween current implementations and ones based on the new DTD.  The\nsolution to this problem is to define a full validatable DTD for DeltaV\nincluding the modifications to webdav,then provide for two modes of\noperation.\n\nSince a server can only react to a client request, it can send a\nresponse in the correct mode based on the HTTP header sent by the\nclient.  A server MUST send an old style WebDAV response if the option\n\"valid=true\" is not listed in the Content-Type header entry.  However,\nif the media type contains \"valid=true\" as follows, the server MUST send\nvalid XML:\n\n    Content-Type: application/xml; charset=\"utf-8\"; valid=true\n\nThe presence of the valid=true option means that the XML being sent is\nvalid, but it does not mean that the receiver must check that validity. \nValidation is done at the receivers discretion.  Note, that application\nis used here instead of text. Though WebDAV specifies either text or\napplication, text is not really appropriate, because text is meant for\ndocuments designed for display to a user.  Here, XML is intended for\ninformation exchange between programs.\n\nA client must ask the server if it supports valid XML.  If a server\nreturns a DAV responseheader containing version-control, then the server\nMUST support valid XML.  The client can then send the appropriate XML\nmessage.  Non valid XML messages are limited to those used by WebDAV.\n\nThese rules insure that all old clients will work with new\nversion-control servers and all new client will work with old WebDAV\nservers.  Since the changes to the WebDAV part of the protocol are\nsmall, supporting both forms of WebDAV messages is not much of a burden\non either clients or servers. The use of valid XML is then an extension\nto WebDAV, that is introduced by DeltaV.  WebDAV could use the same\nmethod to add valid-xml as a general option in its next draft.\n\nSincerely,\nJames J. Hunt\nJ?rgen Reuter\n\n\n\n", "id": "lists-006-6045285"}, {"subject": "Option abus", "content": "Dear Colleagues,\n\nSeveral extension define a root set for their resources.  In the current\nversion, these are obtained via the options request, however this is not\nthe intent of options.  Options should be just tags that identify what\ncapabilities a server offers.\n\nHTTP defines a special request URI---\"*\"---for making request of a\nserver instead of a particular resource.  By defining the following\nresources as properties of a server, propfind could be used to query\ntheir values:\n\n    DAV:versionable-resource-collection-set\n    DAV:version-history-collection-set\n    DAV:workspace-collection-set\n    DAV:activity-collection-set\n\nFor servers that do not allow new message to reference \"*\", then any\nresource collection directly or indirectly contained in any of the above\nvariables should respond to the request.  I beleive there was some\nobject based on this kind of restriction. This solution does not have\nany disadvantage that OPTIONS does not also have.\n\nHere is an example.\n\n>>Request\n\nPROPFIND * HTTP/1.1\nHost: www.webdav.org\nContent-type: text/xml; charset=\"utf-8\"\nContent-Length: xxxx\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE DAV:webdav-1.0 SYSTEM\n\"http://www.webdav.org/dtd/deltav-0.12.dtd\" !>\n<D:webdav xmlns:D=\"DAV:\">\n <D:propfind>\n  <D:prop>\n   <D:prop-key name=\"DAV:versionable-resource-collection-set\"/>\n   <D:prop-key name=\"DAV:version-history-collection-set\"/>\n  </D:prop>\n </D:propfind>\n</D:webdav>\n\n>>Response\n\nHTTP/1.1 207 Multi-Status\nContent-Type: text/xml; charset=\"utf-8\"\nContent-Length: xxxx\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE DAV:webdav-1.0 SYSTEM\n\"http://www.webdav.org/dtd/deltav-0.12.dtd\" !>\n<D:webdav xmlns:D=\"DAV:\">\n <D:multistatus>\n  <D:response>\n   <D:href>http://www.webdav.org</D:href>\n    <D:propstat>\n     <D:prop>\n      <D:prop-value name=\"DAV:versionable-resource-collection-set\">\n       <D:href>http://www.webdav.org/public/projects</D:href>\n       <D:href>http://www.webdav.org/users/projects</D:href>\n      </D:prop-value>\n      <D:prop-value name=\"DAV:version-history-collection-set\">\n       <D:href>http://www.webdav.org/public/archive</D:href>\n       <D:href>http://www.webdav.org/users/archive</D:href>\n      </D:prop-value>\n     </D:prop>\n     <D:status>HTTP/1.1 200 OK</D:status>\n    </D:propstat>\n  </D:response>\n </D:multistatus>\n</D:webdav>\n\nSincerely,\nJames J. Hunt\nJ?rgen Reuter\n\n\n\n", "id": "lists-006-6054810"}, {"subject": "Compatibilit", "content": "Dear Colleagues,\n\nWill sending an XML message body to a WebDAV client or server that\nincludes a DOCTYPE declaration break the client or server?   Lisa, can\nyou give an answer?  I your answer is negative, i.e. it will not break\neither client or server, I would like to hear from any contrary\nopinions.  For the WebDAV specification, I would expect this to be\nokay.  I think I have found a way to write a valid\nDTD for WebDAV as is.\n\nSincerely,\nJames J. Hunt\n\n\n\n", "id": "lists-006-6064800"}, {"subject": "Re: FW: DeltaV Passthrough issue", "content": "Note: Lisa asks a bunch of great questions here.  They are all\ngood candidates for FAQ entries.  For the moment, I'll just\ndo the easy thing and answer them in email.  I'll try to get\nthis info transcribed to the FAQ.  If anyone else has a chance\nto enter this information in the FAQ, that would be greatly\nappreciated!\n\n   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   In an earlier mail, Geoff said:\n\n      From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n      What about getting the DAV:version property for the base\n      resource, which if pass-through is working to the current\n      target, should result in getting the DAV:version for the current\n      target?\n\n   > I'm not sure what you mean by \"if pass-through is working to the\n   > current target\", but in any case, as Greg pointed out, if you\n   > want the version URL for the DAV:checked-in or DAV:checked-out\n   > version of a version-controlled resource, you get that from the\n   > DAV:checked-in and DAV:checked-out property value.  There's no\n   > need to have a second way of getting the same information.\"\n\n   What I meant by \"passthrough\" is what has been talked about before in\n   the context of redirect resources, and now seems to be a feature of\n   versioning.\n\nIn the versioning protocol, \"passthrough\" behavior is a characteristic\nof a particular method or header, not a characteristic of a resource.\nEach method or header that has some form of \"passthrough\" behavior\nstates explicitly what this behavior is.  For example, the LABEL\nmethod is defined as redirecting to the DAV:checked-in version when it\nis applied to a version-controlled resource.\n\nBut there is no \"implicit\" pass through by a version-controlled\nresource.  This is explicitly stated in section 2.1.\n\n   To recap:  When new kinds of resources that have targets,\n   like \"Direct Reference Resources\" or \"Version controlled Resources\"\n   (DRR/VCR), are exposed to clients that are not familiar with the new\n   kinds of resources, it's often beneficial to allow some of the methods\n   the client may send to \"pass through\" to the target of DRR/VCR.\n\nA version-controlled resource does not have a \"target\".  We\nexplicitly got rid of this term because it was misleading people\ninto thinking just what you describe above.  Pass through behavior\nonly occurs when explicitly requested by a header, or when\nexplicitly defined in the semantics of a new method.\n\nThis has allowed us to avoid all of the complexity that caused\nthe WebDAV working group to give up on defining a \"direct reference\nresource\" (i.e. no need to make the same mistake twice :-).\n\n   Also,\n   when RR/VCRs exist in collections along with ordinary resources,\n   PROPFIND can usefully show properties of the target resources, along\n   with properties of the DRR/VCR itself.\n\nThe DAV:expand-property report has been defined to allow a client to\nget this result under explicit client control.  One of the reasons\nthis has to be explicit is that there are many properties\n(modification date, locking, comment) that have different values on\nthe version-controlled resource and the DAV:checked-in version,\nand it is important that a client not confuse the two values\nor the two resources.\n\n   So when I do a PROPFIND depth 1\n   on a directory asking for the \"DAV:content-length\" property, it would be\n   useful for me to see the content-length of ordinary resources, the\n   content-length of the targets of links, and the content-length of the\n   target version of each VCR.  I thought this was called \"passthrough\"\n   when bindings were being discussed, but apparently is no longer refered\n   to in this way.\n\nThere is explicit client requested \"pass through\" for properties via\nthe DAV:expand-property report.  This avoids the complexity and\npotential confusion that results from \"implicit pass through\".\n\n   Anyway, the idea for bindings at one time was to allow some kind of\n   reference resource to exist, which when queried, would respond \"as if\"\n   it was the target resource.\n\nBindings (as they are currently defined in the Binding internet\ndraft) explicitly are not a redirect resource, but are a way to\ngive two different names to the same resource.  The key difference\nhere is that there are not two resources, but rather just one\nresource with two names.  This avoids all the confusion related\nto \"which resource the method gets applied to\".\n\n   However, sometimes the client wants to\n   address the reference resource directly.  The server needs to know if\n   the client is addressing the reference resource, or the target of the\n   reference resource.  Thus, the \"Apply-To-Redirect-Ref\" header was\n   defined.  If the client includes this header, e.g. with a DELETE, the\n   server can understand this to mean that the client wishes to delete the\n   redirect reference itself, rather than get redirected to the target\n   reference.\n\nThis \"apply-to-redirect-ref\" approach always produced confusing\nor counter-intuitive behavior in some cases (especially in conjunction\nwith a Depth header), which was a significant factor in the\nabandonment of the direct reference resource effort.\n\n   All of this applies to versioning, because with the current state of the\n   draft, it's clear that a VCR is a kind of reference resource.\n\nWell, let's see what the first section of the core versioning semantics\nsection has to say:\n\n       Note that a version-controlled resource and the current\n       DAV:checked-in version of that version-controlled resource are two\n       distinct resources, with their own content and properties.  When a\n       method is applied to a version-controlled resource, it is applied\n       to that version-controlled resource and not to the DAV:checked-in\n       version of that version-controlled resource.  Although the content\n       and dead properties of a checked-in version-controlled resource are\n       required to be the same as those of its current DAV:checked-in\n       version, its live properties may differ.  An implementation may\n       optimize storage by retrieving the content and dead properties of a\n       checked-in version-controlled resource from its current\n       DAV:checked-in version rather than storing them in the version-\n       controlled resource, but this is just an implementation\n       optimization.\n\nI'm not sure how we could be clearer that a version-controlled resource is\nnot a reference to a version, and there is no implicit passthrough.\n\n   I quote:\n\n   \"A PUT or PROPPATCH to a version-controlled resource with the\n   DAV:auto-version property set will automatically check out that resource\n   prior to executing the PUT or PROPPATCH.  If that resource is\n   write-locked, the resource remains checked-out until the resource is\n   unlocked, at which time the resource is checked in and a new version is\n   created in the version history of that resource.\"\n\nI don't see any pass-through behavior here.  All operations\nare on the version-controlled resource.  A new \"version\" resource\nis created, but the operations are on the version-controlled resource.\n\n   \"For certain methods (e.g. GET, PROPFIND), if the request-URL identifies\n   a version-controlled resource, a label can be specified in a Label\n   request header to cause the method to be applied to the version selected\n   by that label from the version history of that version-controlled\n   resource.\"\n\nYes, a Label header is one of the ways that a user can explicitly ask\nthat a method be applied to a resource related to the request resource,\nbut that is a case of explicitly requested pass through behavior\n(via the Label header).\n\n   This means that PUT and PROPPATCH are ALWAYS parsed as applying to the\n   version (passthrough), even though the URL was to the VCR.\n\nPUT and PROPPATCH are redirected only when the client explicitly\nrequests it with the Label header.\n\n   It also\n   means that GET and PROPFIND _sometimes_ apply to the version\n   (passthrough).\n\nOnly when explicitly requested via the Label header.\n\n   It's not as clear what other methods are applied to.  It seems MOVE\n   source is defined as the VCR (no passthrough), but the COPY source is\n   the defined as the default version.\n\nNo, the COPY source is not the \"default version\" because there is no\ndefault version.  There is the content and dead properties of the\nversion-controlled resource.  It is true that when a\nversion-controlled resource is checked-in, that there is a version\nresource that has the same content and dead properties as that\nversion-controlled resource, but that has no effect on the semantics\nof the COPY operation, which always applies to the version-controlled\nresource.  When a version-controlled resource is checked-out, it\ndoesn't even have a DAV:checked-in version.\n\n   The language all seems to imply\n   that a COPY when the source URL is a VCR should be interpreted as\n   copying the latest version from the source, to the destination.\n\nSection 2.1 explicitly states that this is not the case, to avoid\nanyone making such an interpretation.\n\n   The consequence of a model that supports \"pass through\" to the target of\n   a reference resource is that the model must specify clearly when\n   passthrough occurs, and when it doesn't.\n\nThat is correct.  Happily, the versioning model explicitly states that\nimplicit pass through does not occur, so there is no need to deal with\nthis issue.\n\n  In addition:\n    - What methods the Label: header can apply to (and what it _can't_)\n\nAn interoperable client can count on the Label header applying to a\nmethod only when the protocol explicitly says it applies to that\nmethod.  Some future extension of the protocol may want to extend the\nnumber of methods that a header applies to, so we deliberately never\nsay that a method MUST NOT have a given header.\n\n    - When the label header is absent, for each method, what does it apply\n   to -- the VCR or the target version?\n\nThere is no implicit pass-through behavior, so this question does not\narise.  If a particular method has some kind of pass-through behavior,\nit will be explicitly stated in the semantics of that method.\n\n    - Whether there is a way of overriding the default assumption of what\n   the method applies to\n\nThe default assumption is the same default assumption of HTTP, namely\nthat the method applies to the resource identified by the request-URL.\nThe only way to override this assumption is to use a method or header\nthat explicitly specifies some redirecting behavior.\n\n   Some of the specific questions that came up when I was reading the spec:\n    - If any PROPPATCH to a VCR actually creates a new version; how does\n   one proppatch the properties actually on a VCR, such as\n   DAV:auto-version, DAV:predecessor-set and DAV:precursor-set, which\n   aren't protected?\n\nThe only time a PROPPATCH to a VCR creates a new version is when it is\na dead property.  None of these properties are dead properties, so they\nnever create a new version when they are modified.\n\n    - If a PROPFIND with a Label: header is applied to a non\n   version-controlled resource, what does \"no effect\" mean?  What happens\n   if the specified label wasn't found -- does PROPFIND then return the\n   properties of the target version?  Or the VCR?\n\n\"No effect\" means that the result is the same as if the request did\nnot include the Label header.\n\n    - Does a PROPFIND to a VCR result ever result in a merge of the\n   properties of the VCR and its target version?\n\nNo.  In general, if the protocol doesn't say it happens, it doesn't\nhappen.  Note that we reserve this kind of information is appropriate\nfor the FAQ, because the protocol would get a bit long if we had\nto define in the protocol everything that doesn't happen (:-).\n\n    - Since COPY seems to always get its content from a single version, I\n   would say that \"passthrough\" always seems to be on for COPY.  Is there\n   any way of NOT doing passthrough with COPY?  I.e, is there any way of\n   copying a VCR along with its VHR and VRs?\n\nCOPY only is guaranteed to copy dead properties.  The versioning\nprotocol explicitly states that a COPY MUST NOT copy the versioning\nproperties.  If you want to create another version-controlled\nresource for the same version history, you must use the VERSION-CONTROL\nrequest.  If you want to create another version-controlled resource\nwith a new version history, your server may do this for you\nautomatically (by placing every new resource under version control),\nor you can do it explicitly with the VERSION-CONTROL request.\n\n   This would result in two\n   VCRs, two VHs and 2*n VRs, which would be the same initially, but could\n   diverge after.\n\nBy \"the same\", I assume you mean \"there is a version in one version\nhistory with the same content and dead properties as a particular version\nin the other version history\".  If so, yes.\n\n   A related issue is one I brought up in a separate mail, but I'll explain\n   the relationship here too:  how does one define properties which apply\n   not to an individual version, but to the whole shebang -- to the VCR,\n   VHR and all VRs?  An example is \"owner\", which in its meaning of \"the\n   person responsible for this resource\", can be taken to mean that when\n   ownership of a VCR is transferred the new owner becomes responsible for\n   all old versions related to the VCR.  No?  But we can't go about\n   changing properties of old versions...\n\nIt sounds like you're talking about properties on the version history\nresource.  Your server of course must then support the version history\noption, but then you PROPPATCH the version history resource just as you\nwould PROPPATCH any other resource.\n\nAgain, great set of questions, Lisa!  Now if you could transcribe this\ninformation to the FAQ ... (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6071221"}, {"subject": "Re: DTD Confusio", "content": "   There seem to be some confusion as to how DTD work.\n\nI don't think there is any confusion about how DTD's work,\nbut rather a disagreement about the value provided by a DTD.\n\n   The tendency of the\n   authors of the DeltaV document to write ANY in every place that one\n   would like to be able to the protocol is both unnecessary and unhelpful.\n\nThe purpose of ANY in the protocol usually indicates that there is\nno DTD construct that usefully describes the syntactic constraints\non what elements can appear, and therefore those constraints are\ndescribed in English text.\n\n   In particular, a DTD is similar to a BNF for a language: a parser need\n   not use the BNF directly to parse the language, but It still gives\n   implementers a way of precisely describing the language.\n\nDTD's provide a very limited vocabulary for describing the syntax.\nIn the case of the versioning protocol, we mostly need the ability\nto say \"at most one of each of the following element types can\nappear, in any order\".  Unfortunately, there is no DTD construct\nto express this, so we use (very) simple English text to describe\nthis constraint.\n\n   This conception seems to be in the manner that validation is\n   interpreted. There seems to be the view that if a server validates its\n   input and a client makes a request with an extended DTD,the server will\n   not recognize some new tag and thus reject the request.\n\nIf someone thought that, I agree they would be confused.\n\n   Of course, this\n   would be contrary to the spirit of this protocol.  However, validation\n   does not work this way.  If a client sends a message based on a new DTD,\n   it causes no problem.  The client must send a copy or a reference of the\n   new DTD with its message.  The server has two choices: it may fetch the\n   new DTD and validate against that DTD, or the server may simply check\n   for well-formedness. In both cases, the server need not and should not\n   reject the request, so long as the request matches the given DTD.  If it\n   does not match, however, something is in fact wrong with the request.=20\n   Even in this case, the server is still permitted to recover from the\n   error.  The same applies in reverse for responses from the client.\n\nYes, and this illustrates the very limited value of including a DTD\n(or a reference to a DTD) in a message.  If the message is valid (wrt\nthe DTD), the DTD has no effect on how the message is processed.  If\nthe message isn't something the receiver can process, it will be\nrejected whether it is valid or not.  So the only case where a DTD\nmatters is where the client can process the message, but it doesn't\nmatch the DTD that was sent.  As you state above, the recipient may\nwell want to process the message anyway in this case, and ignore the\nfact that the message didn't match the DTD that it came with.\n\nBecause of this, our implementations will not send DTD's (or references\nto DTD's) with our messages, nor will we process any DTD's (or references\nto DTD's) that are included.  What matters to us is whether we can\nprocess the message, not whether it matches some DTD.\n\n   We opine that a client or a server should be able to send messages that\n   conform to the DTD that it uses.   This does not inhibit communication\n   with peers that use another version of the protocol.\n\nI agree, as long as we do not require that a DTD (or a reference to a DTD)\nbe sent, and we do not require that a DTD (or a reference to a DTD) be\nprocessed by the receiver of the message.\n\n   Each new version\n   must have its own DTD, but this should be a good basis for understanding\n   what the protocol actually is in any given version and how it changes\n   from one version to the next.  A well designed DTD should also help\n   insure that new version are, in fact, upwardly compatible.\n\nThe fact that new variants are syntactically compatible with old\nvariants is rather trivial to verify, with or without the use of\nDTD's.  The hard part is making sure that the semantics is upwardly\ncompatible.  But in any case, DTD's do not help when they do not have\nthe capability of describing the syntactic constraints of a particular\ntype of message (as is the case for the versioning messages).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6092722"}, {"subject": "Re: WebDAV/DeltaV Interoperability and XML Validatio", "content": "Rather than define a variant of the WebDAV XML, and negotiate\nfor different variant of the XML with the Content-Type header,\nwouldn't it be much simpler just to allow property tags to be empty\nin the DTD?\n\nCheers,\nGeoff\n\n   Date: Sun, 04 Feb 2001 02:56:27 +0000\n   From: \"James J. Hunt\" <jjh@allerton.de>\n\n   Dear Colleagues,\n\n   After much thought, we have finally devised a way to provide for XML\n   validation in DeltaV without breaking existing WebDAV clients.  There\n   are only two points where the DTD given in WebDAV is not validatable:=20\n   property tags occur both as empty-element tags and as begin/end tag\n   pairs, and though the DTD is named webdav-1.0, it gives no definition\n   for that tag.   Two small changes would make the DTD usable.\n\n   The problem is that to do this, an incompatibility would be introduced\n   between current implementations and ones based on the new DTD.  The\n   solution to this problem is to define a full validatable DTD for DeltaV\n   including the modifications to webdav,then provide for two modes of\n   operation.\n\n   Since a server can only react to a client request, it can send a\n   response in the correct mode based on the HTTP header sent by the\n   client.  A server MUST send an old style WebDAV response if the option\n   \"valid=3Dtrue\" is not listed in the Content-Type header entry.  =\n   However,\n   if the media type contains \"valid=3Dtrue\" as follows, the server MUST =\n   send\n   valid XML:\n\n       Content-Type: application/xml; charset=3D\"utf-8\"; valid=3Dtrue\n\n   The presence of the valid=3Dtrue option means that the XML being sent =\n   is\n   valid, but it does not mean that the receiver must check that validity. =\n\n   Validation is done at the receivers discretion.  Note, that application\n   is used here instead of text. Though WebDAV specifies either text or\n   application, text is not really appropriate, because text is meant for\n   documents designed for display to a user.  Here, XML is intended for\n   information exchange between programs.\n\n   A client must ask the server if it supports valid XML.  If a server\n   returns a DAV responseheader containing version-control, then the =\n   server\n   MUST support valid XML.  The client can then send the appropriate XML\n   message.  Non valid XML messages are limited to those used by WebDAV.\n\n   These rules insure that all old clients will work with new\n   version-control servers and all new client will work with old WebDAV\n   servers.  Since the changes to the WebDAV part of the protocol are\n   small, supporting both forms of WebDAV messages is not much of a burden\n   on either clients or servers. The use of valid XML is then an extension\n   to WebDAV, that is introduced by DeltaV.  WebDAV could use the same\n   method to add valid-xml as a general option in its next draft.\n\n   Sincerely,\n   James J. Hunt\n   J=FCrgen Reuter\n\n\n\n", "id": "lists-006-6103948"}, {"subject": "Re: Option abus", "content": "   From: \"James J. Hunt\" <jjh@allerton.de>\n\n   Several extension define a root set for their resources.  In the current\n   version, these are obtained via the options request, however this is not\n   the intent of options.  Options should be just tags that identify what\n   capabilities a server offers.\n\nWhere in RFC 2616 does it limit the response from an OPTIONS\nrequest to be \"tags\"?\n\n   HTTP defines a special request URI---\"*\"---for making request of a\n   server instead of a particular resource.\n\nThe problem with this approach is that different servers can manage\ndifferent parts of the URL space at a given server, while '*\" will\nalways refer to just one of these servers (probably the one that\nmanages \"/\").  So you need to tell the server what part of the URL\nspace you're interested in.  \n\n   By defining the following\n   resources as properties of a server, propfind could be used to query\n   their values:\n\n       DAV:versionable-resource-collection-set\n       DAV:version-history-collection-set\n       DAV:workspace-collection-set\n       DAV:activity-collection-set\n\n   For servers that do not allow new message to reference \"*\", then any\n   resource collection directly or indirectly contained in any of the above\n   variables should respond to the request.  I beleive there was some\n   object based on this kind of restriction. This solution does not have\n   any disadvantage that OPTIONS does not also have.\n\nIt really doesn't matter whether we marshall this as an OPTIONS call\nor as a PROPFIND for a property.  This used to be marshalled as a\nproperty but a reviewer pointed out that this information seemed more\nlike an option than a property.\n\nCan you give some motivation for switching this back to being a property?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6114374"}, {"subject": "Re: DTD Confusio", "content": "On Sun, Feb 04, 2001 at 02:17:39PM -0500, Geoffrey M. Clemm wrote:\n> \n>    There seem to be some confusion as to how DTD work.\n> \n> I don't think there is any confusion about how DTD's work,\n> but rather a disagreement about the value provided by a DTD.\n\nI \"vehemently agree\" with Geoff and the rest of his mail. Consider this a\nvote for avoiding the additional semantic complexity of bringing DTDs into\nthe protocol definition and processing.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-6123218"}, {"subject": "Re: Re (2): Labels and Statu", "content": "Adding new properties with no semantics is a slippery slope\nthat I am reluctant to travel any further than absolutely\nnecessary.  Currently, we just have two: \"comment\" and\n\"creator-displayname\".  \"Creator-displayname\" is relatively\nwell understood, and \"comment\" is for anything else with\nno semantics.\n\nSo until we define some interoperable semantics for \"status\", I\nbelieve this is much better left to a separate document describing\n\"interesting properties with no interoperable semantics\".\n\nCheers,\nGeoff\n\n   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   Labels won't solve the problem, for us and I suspect also for you,\n   because you can't have more than one version in a version history have\n   the same label.\n\n   So although you could mark one version with the label \"author_edgar\",\n   you could only do that to one version.  I think by the very example you\n   chose you want to be need to have custom mutable properties.\n\n   > From: ietf-dav-versioning-request@w3.org\n   >\n   > \"Lisa Dusseault\" <lisa@xythos.com> wrote:\n   > > Yes, many versioning systems have \"status\" properties on\n   > versions, and\n   > > the \"status\" property should be mutable, i.e. should be\n   > writable without\n   > > creating a new version.\n   > snip\n   > > Thus, versioning needs a general way to allow creation of custom\n   > > properties which are mutable, AND custom properties which\n   > are immutable.\n   > > The server would of course reject requests for mutable\n   > properties if it\n   > > does not support mutability, but we need a standard way for\n   > clients to\n   > > ask for this.\n   > I saw no reply to that yet so I will give my $0.02.\n   > I think a mutable status property is essential if I want to do some\n   > document management.\n   > To be more flexible I also would want to to have at least arbitrary\n   > mutable properties to add to a version.\n   > Or can I mimic that by adding multiple labels to a version ? E.g.\n   > doc#1 status_accepted, author_edgar\n   > doc#2 status_working, author_lisa (sometimes authors of\n   > documents change)\n\n\n\n", "id": "lists-006-6130307"}, {"subject": "RE: Complexity and Core Consideration", "content": "> The first question is just an editorial question.  I would prefer to\n> keep the versioning protocol as one document -- after all, when the\n> first paragraph of the introductions says:\n>\n>   \"An implementor that is only interested in core versioning should read\n>    Section I (Introduction), Section II (Core Versioning), and Section\n>    15 (Report Option).\"\n>\n> is a reader really all that likely to be confused?\n\nYes, because in order to implement core, you also need to read, understand,\nand subset the information in the security considerations, i18n, IANA\nconsiderations, references, as well as understand and implement the error\nreporting extensions listed in the appendix, so you can properly report\nerrors from VERSION-CONTROL.  And these are just the ones I can list from\nmemory.\n\nPlus, a core-only document would have a shorter introduction, and a shorter\ndefinitions section, making it ever so easier to understand.  A core-only\ndocument would also appear much less intimidating, since, if printed\ndouble-sided, you could make a working paper airplane out the stack of\npapers. :-)\n\n- Jim\n\n\n\n", "id": "lists-006-6139808"}, {"subject": "Re: Core versioning issues and nit", "content": "   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   > I guess that I'm of a different opinion -- namely that URLs are\n   > cheap and not in danger of being all 'used up'.\n\n   In fact, it's not so much that that URLs are scarce, but that good user\n   interfaces are difficult.  How do I explain what URL namespaces are\n   reserved for special-purpose resources like VRs, VHRs, or (to take an\n   example from another realm) principals?  At least you could give me a\n   good error message to return when users try to create new resources or\n   collections in reserved namespaces!\n\nI think that a 405 status return, along with an Allow header indicating\nwhat MKxxx method would succeed in this space (if any) gives you\nall the information you can really use.\n\n   > The spec. explicitly allows\n   > versioning metadata to reside on other hosts, so you can (dare I say,\n   > easily) virtually host the metadata in it's own URL namespace without\n   > impinging on the creativity of clients.\n\n   How, then, can the client be expected to COPY where the source is a\n   version URL, and the destination is a working resource?  To the client\n   it \"looks like\" the source and destination are on different hosts, and\n   the client might reasonably expect this not to work, since most servers\n   don't implement server-to-server copy.\n\nIt seems like a sensible client should try the COPY first rather than\nguessing it will fail.  And if it fails, a client can just do the\nappropriate  GET/PUT/PROPFIND/PROPPATCH.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6148204"}, {"subject": "Re: Core versioning issues and nit", "content": "   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   > \"Why are we required to make this distinction between\n   > predecessors and precursors?\"\n\n   > \"Because it makes a big difference to the client whether a\n   > version is in the same history as another version, in terms of\n   > what you can do (for example, you cannot UPDATE a vcr to be a\n   > precursor of the checked-in version, but you can UPDATE it to a\n   > predecessor).\"\n\n   But the Core versioning section is supposed to be features that MUST be\n   supported by all versioning servers.\n\nThere are a variety of conditionals in core.  For example,\nauto-versioning behavior happens only if the DAV:auto-version\nproperty is set, and a server is allowed to refuse to let\na client modify the value of DAV:auto-version.\n\n   Yet, the original paragraph implies that \"precursor-set\" and the\n   \"initialize-precursor\" condition aren't required to be implemented\n   because it says \"if the destionation of the COPY supports the\n   DAV:precursor-set property\".\n\nYes, but having certain behavior (i.e. setting the DAV:precursor-set)\nhappen only if the resource supports it is consistent with the\nway the rest of core is defined (i.e. auto-versioning happens only\nif DAV:auto-version is set).\n\n   Also, your explanation refers to UPDATE, which is not part of core.\n\nOK, so another difference is \"the DAV:predecessor-set versions\nof a version MUST show up in a DAV:version-history report containing that\nversion, while the DAV:precursor-set versions MUST NOT show up\nin a DAV:version-history report containing that version.\n\n   Frankly, it looks like \"precursor\" support is yet another option, or\n   part of the UPDATE option.  It's important for the client to know if\n   it's supported or not (to know whether an missing/empty value of\n   precursor-set is meaningful or not) but it's optional.  Thus, it's an\n   option.\n\nIf you want to know whether the property is supported by a given\nresource, you can use the DAV:supported-live-property OPTIONS\nrequest.  If it is supported, then a core versioning server\nMUST set it whenever there is a copy into that resource.\n\nAgain, this is no different from auto-versioning behavior.  You\nhave to check the DAV:auto-version property of a resource to\nknow whether or not it will have the auto-versioning behavior\ndefined in core.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6157126"}, {"subject": "Re: Core versioning issues and nit", "content": "   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   > > 16) New definition of Overwrite\n   > >\n   > > Please clarify the new definition of Overwrite.\n   > >\n   > > If you COPY directory 'mydir' with 'mydir/foo' and\n   > > 'mydir/bar' to a directory elsewhere with 'mydir/baz',\n   > > do you end up with a directory at the destination with\n   > > TWO children, or THREE children?  In other words, do\n   > > resources at the destination which do not overlap\n   > > resources from the source get deleted?\n   > >\n   > > I prefer 'no', btw.\n   >\n   > No, they do not get deleted.\n\n   Can this get clarified in the spec?  This must be normative; it's not\n   enough to explain in the FAQ that the non-overlapping resources do not\n   get deleted.  It must be a requirement, or servers may behave\n   differently.\n\nHere I have to disagree with Tim.  The specification says that a\nresource at the Destination has to have the same dead properties and\ncontent as the corresponding resource in the source of the COPY.  This\nmeans that if the corresponding resource is null, the Destination\nresource MUST be null as well (i.e. deleted).  Note: this MUST be\nthe case in order to be compatible with 2518, which defines the\nsemantics in terms of first deleting *all* the resources at the\ndestination, and then recreating the ones that have corresponding\nresources in the source of the COPY.\n\nI'll clarify this in the spec.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6166704"}, {"subject": "Re: WebDAV/DeltaV Interoperability and XML Validatio", "content": "Dear Geoff,\n\nThe reasons for the concern  over tags that are used both as empty tags and as\ntag pairs (with or without content) were problems with a earlier version of an\nXML parser that had problems with combining both form and the following quote\nfrom the XML specification.\n\nFor interoperability, the empty-element tag should be used, and should only be\nused, for elements which are declared EMPTY.\n\nAdditionally, using tags both requires the use of ANY for dead properties.  The\ncurrent XML parser from sun can handle them, so I can live with them.\n\nSincerely,\nJames J. Hunt\n\nP.S. I have yet to find a good solution for the display of version graphs.  I\nhave a few ideas.  Could we telephone?\n\n\"Geoffrey M. Clemm\" wrote:\n\n> Rather than define a variant of the WebDAV XML, and negotiate\n> for different variant of the XML with the Content-Type header,\n> wouldn't it be much simpler just to allow property tags to be empty\n> in the DTD?\n\n\n\n", "id": "lists-006-6175389"}, {"subject": "DAV Versioning DTD", "content": "Dear Geoff,\n\nAfter sacrificing three nights, J?rgen and I have put together a DTD for\nDAV versioning.  This version is based on prop-key and prop-value tags,\nwere properties names are given as parameters.  I will rewrite the DTD\nto pass properties as tags in prop and prop-apply.  Then it should be\ncompletely WebDAV compatible.  Please give me a couple of days to finish\nit.\n\nThe current definition of how errors are returned in DAV versioning is\nincompatible with WebDAV.  I have made a change that should be help\nthere.  The \"at most one of .... in any order \"is defined with an\narbitrary order here.  I will fix that as well, though it will not\npretty be pretty.   Please let me know if I have forgotten anything.\nThe DTD and two examples, which validate against the DTD using Sun's\nlatest XML parser, are included.   Can you easily send me the all\nexamples from the current draft or at least the draft as text?\n\nThe tags add, set, and remove as used in labels, must be renamed because\nset and remove are\nalready defined differently for propertyupdate.\n\nI still believe that a complete DTD is helpful for people who have not\nhad a chance to sit in on all the DAV versioning discussions.  I find\nthe document to be too dependent on examples.  A DTD that is consistent\nwith the examples would help.\n\nSincerely,\nJames J. Hunt\n\nP.S. An example of  our new proposal for expand-property with properties\nas tags instead of attributes will be as follows:\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE DAV:webdav-1.0 SYSTEM\n\"http://www.webdav.org/dtd/deltav-0.12.1.1.dtd\" !>\n<expand-property xmlns=\"DAV:\">\n  <prop-apply>\n    <version-history/>\n    <prop-apply>\n      <version-set/>\n      <prop>\n        <creator-displayname/>\n        <activity-set/>\n      </prop>\n    </prop-apply>\n  </prop-apply>\n</expand-property>\n\n\n<!--============ Root Elements ==================\n                  propfind\n                  propertyupdate\n                  propertybehavior\n                  multistatus\n                  prop\n                  lockinfo\n                  version-tree\n                  expand-property\n                  options\n                  options-response\n                  options-value\n                  collection-set-value\n                  checkout\n                  checkin\n                  update\n                  locate-history\n                  version-control\n                  merge\n                  merge-preview\n                  label\n                  baseline-control\n                  baseline\n                  baseline-comparision\n                  latest-activity-version\n                  checkout-fork\n                  checkin-fork\n                  merge-response\n                  merge-preview-response\n                  baseline-comparision-report\n                  latest-activity-version-report\n                  error\n    ============ End Root Elements ==================-->\n\n<!--============ Top Level DAV Requests ==================-->\n<!ELEMENT propfind (allprop | propname | prop)>\n<!ATTLIST propfind xmlns CDATA #IMPLIED\n                   xmlns:DAV CDATA #IMPLIED>\n<!ELEMENT allprop EMPTY>\n<!ATTLIST allprop xmlns CDATA #IMPLIED>\n<!ELEMENT propname EMPTY>\n<!ATTLIST propname xmlns CDATA #IMPLIED>\n\n<!ELEMENT propertyupdate (remove | set)+>\n<!ATTLIST propertyupdate xmlns CDATA #IMPLIED>\n<!ELEMENT remove (prop)>\n<!ELEMENT set (prop)>\n\n<!ELEMENT propertybehavior (omit | keepalive)>\n<!ATTLIST propertybehavior xmlns CDATA #IMPLIED>\n<!ELEMENT omit EMPTY>\n<!ELEMENT keepalive (#PCDATA | href)*>\n\n<!--============ Top Level DAV Responses ==================-->\n\n<!ELEMENT multistatus (response+,\n                           (responsedescription |\n                            error)?)>\n<!ATTLIST multistatus xmlns CDATA #IMPLIED>\n                    <!-- added! -->\n<!ELEMENT response (href, ((href*, status)|(propstat+)),\n                        (responsedescription |\n                         error)?)>                       <!-- added! -->\n<!ELEMENT propstat (prop, status,\n                        (responsedescription |\n                         error)?)>                       <!-- added! -->\n<!ELEMENT status (#PCDATA)>\n<!ELEMENT responsedescription (#PCDATA)>\n\n<!ELEMENT prop\n (prop-key* | (prop-value | prop-multivalue)*)>    <!--- modified! -->\n<!ATTLIST prop xmlns CDATA #IMPLIED>\n<!ATTLIST prop xmlns:DAV CDATA #IMPLIED>\n<!ELEMENT prop-key EMPTY>                               <!-- new! -->\n<!ATTLIST prop-key name CDATA #REQUIRED>                <!-- new! -->\n<!ELEMENT prop-value ANY>                               <!-- new! -->\n<!ATTLIST prop-value name CDATA #REQUIRED>              <!-- new! -->\n\n<!ELEMENT lockinfo (lockscope, locktype, owner?)>\n<!ATTLIST lockinfo xmlns CDATA #IMPLIED>\n<!ELEMENT locktype (write)>\n<!ELEMENT write EMPTY>\n\n<!--============ Additional XML Elements from Section 12 ==================-->\n\n<!ELEMENT lockscope (exclusive | shared)>\n<!ELEMENT exclusive EMPTY>\n<!ELEMENT shared EMPTY>\n\n<!ELEMENT owner ANY>\n\n<!ELEMENT href (#PCDATA)>\n\n<!--=========== Property Values ===============-->\n<!--=========== Value for DAV:resourcetype ===============-->\n<!ELEMENT collection EMPTY>\n\n<!--=========== Value for DAV:lockdiscovery ===============-->\n<!ELEMENT activelock (lockscope, locktype, depth,\n                          owner?, timeout?, locktoken?)>\n<!ELEMENT depth (#PCDATA)>\n<!ELEMENT timeout (#PCDATA)>\n<!ELEMENT locktoken (href+)>\n\n<!--=========== Value for DAV:source ===============-->\n<!ELEMENT link (src+, dst+)>\n<!ELEMENT dst (#PCDATA)>\n<!ELEMENT src (#PCDATA)>\n\n<!--=========== Value for DAV:supportedlocks ===============-->\n<!ELEMENT lockentry (lockscope, locktype)>\n\n<!--=========== WebDAV defined properties ===============\n name                           value\n DAV:creationdate               (#PCDATA)\n DAV:displayname                (#PCDATA)\n DAV:getcontentlanguage         (#PCDATA)\n DAV:getcontentlength           (#PCDATA)\n DAV:getcontenttype             (#PCDATA)\n DAV:getetag                    (#PCDATA)\n DAV:getlastmodified            (#PCDATA)\n DAV:lockdiscovery              (DAV:activelock)*\n DAV:resourcetype               ANY\n DAV:source                     (link)*\n DAV:supportedlock              (lockentry)*\n    ====================================================-->\n\n<!--=========== Top Level DeltaV core Requests ===============-->\n<!ELEMENT version-tree (prop?)>\n<!ATTLIST version-tree xmlns CDATA #IMPLIED>\n\n<!ELEMENT expand-property (prop-apply*)>\n<!ATTLIST expand-property xmlns CDATA #IMPLIED>\n<!ELEMENT prop-apply ((prop-apply | prop-key)*)>\n<!ATTLIST prop-apply name CDATA #REQUIRED>\n\n<!ELEMENT options ((option-key | server-prop-key)*)>\n<!ATTLIST options xmlns CDATA #IMPLIED>\n<!ELEMENT options-key EMPTY>\n<!ATTLIST options-key name \n (DAV:supported-methods-set |\n  DAV:supported-live-property-set) #REQUIRED> <!-- May be extended here -->\n<!ELEMENT server-prop-key EMPTY>\n<!ATTLIST server-prop-key name \n (DAV:version-history-collection-set |\n  DAV:workspace-collection-set |\n  DAV:activity-collection-set) #REQUIRED>   <!-- May be extended here -->\n\n<!--=========== Top Level DeltaV core Responses ===============-->\n\n<!ELEMENT options-response\n ((option-value | collection-set-value)*)>\n<!ATTLIST options-response xmlns CDATA #IMPLIED>\n\n<!ELEMENT options-value (option-descriptor*)>\n<!ATTLIST options-value xmlns CDATA #IMPLIED>\n<!ATTLIST options-value name \n (DAV:supported-methods-set |\n  DAV:supported-live-property-set) #REQUIRED> <!-- May be extended here -->\n<!ELEMENT option-descriptor (suboption*)>\n<!ATTLIST option-descriptor name CDATA #REQUIRED>\n<!ELEMENT suboption (suboption*)>\n<!ATTLIST suboption name CDATA #REQUIRED><!-- suboptions can be nested -->\n\n<!ELEMENT collection-set-value (href*)>\n<!ATTLIST collection-set-value xmlns CDATA #IMPLIED>\n<!ATTLIST collection-set-value name \n (DAV:version-history-collection-set |\n  DAV:workspace-collection-set |\n  DAV:activity-collection-set) #REQUIRED>   <!-- May be extended here -->\n\n<!--=========== WebDAV defined core properties ===============\n name                        value\n DAV:checked-in                  (DAV:href)\n DAV:checked-out                 (DAV:href)\n DAV:predecessor-set             (DAV:href+)\n DAV:precursor-set               (DAV:href*)\n DAV:auto-version                (DAV:when-unlocked?, DAV:when-locked?)\n DAV:predecessor-set             (DAV:href*)\n DAV:successor-set               (DAV:href*)\n DAV:checkout-set                (DAV:href*)\n DAV:version-name                (#PCDATA)\n DAV:precursor-set               (DAV:href*)\n DAV:version-control             (DAV:already-version-controlled?)\n\n    ====================================================-->\n<!ELEMENT when-unlocked EMPTY>\n<!ELEMENT when-locked EMPTY>\n<!ELEMENT already-version-controlled EMPTY>\n\n<!--=========== Top Level DeltaV optional Requests ===============-->\n<!ELEMENT checkout\n (activity-set? | apply-to-version? |\n  unreserved? | fork-ok?)>           <!-- May be extended here -->\n<!ATTLIST checkout xmlns CDATA #IMPLIED>\n<!ELEMENT avtivity-set (href+|new)>\n<!ELEMENT new EMPTY>\n<!ELEMENT unreserved EMPTY>\n\n<!ELEMENT checkin (keep-check-out?)> <!-- May be extended here -->\n<!ATTLIST checkin xmlns CDATA #IMPLIED>\n<!ELEMENT keep-checked-out EMPTY>\n\n<!ELEMENT update\n ((version? | label-name? | variant?),\n  fork-ok?)>                            <!-- May be extended here -->\n<!ATTLIST update xmlns CDATA #IMPLIED>\n<!ELEMENT variant (href)>\n\n<!ELEMENT locate-history (version-history-set, prop)>\n<!ATTLIST locate-history xmlns CDATA #IMPLIED>\n<!ELEMENT version-history-set (href+)>\n\n<!ELEMENT version-control\n (version?, variant-control?)>           <!-- May be extended here -->\n<!ATTLIST version-control xmlns CDATA #IMPLIED>\n<!ELEMENT variant-control EMPTY>\n\n<!ELEMENT merge (source, no-auto-merge?, no-checkout?,\n                     apply-to-version?, fork-ok?,\n                     prop?)>              <!-- May be extended here -->\n<!ATTLIST merge xmlns CDATA #IMPLIED>\n<!ELEMENT no-auto-merge EMPTY>\n<!ELEMENT no-checkout EMPTY>\n\n<!ELEMENT merge-preview (source)>\n<!ATTLIST merge-preview xmlns CDATA #IMPLIED>\n\n<!ELEMENT label (add-label | set-label | remove-label)>\n<!ATTLIST label xmlns CDATA #IMPLIED>\n<!ELEMENT add-label (label-name)>     <!-- Renamed from add -->\n<!ELEMENT set-label (label-name)>     <!-- Renamed from set -->\n<!ELEMENT remove-label (label-name)>  <!-- Renamed from remove -->\n\n<!ELEMENT baseline-control (baseline?)><!-- May be extended here -->\n<!ATTLIST baseline-control xmlns CDATA #IMPLIED>\n\n<!ELEMENT baseline (href)>\n<!ATTLIST baseline xmlns CDATA #IMPLIED>\n\n<!ELEMENT baseline-comparision (href)>\n<!ATTLIST baseline-comparision xmlns CDATA #IMPLIED>\n\n<!ELEMENT latest-activity-version (href)>\n<!ATTLIST latest-activity-version xmlns CDATA #IMPLIED>\n\n<!ELEMENT checkout-fork\n (ok | discouraged | forbidden)?> <!-- May be extended here -->\n<!ATTLIST checkout-fork xmlns CDATA #IMPLIED>\n\n<!ELEMENT checkin-fork\n (ok | discouraged | forbidden)?> <!-- May be extended here -->\n<!ATTLIST checkin-fork xmlns CDATA #IMPLIED>\n\n<!--=========== Top Level DeltaV optional Responses ===============-->\n<!ELEMENT merge-response\n (update-set?, merged-set?,\n  ignored-set)?>                          <!-- May be extended here -->\n<!ATTLIST merge-response xmlns CDATA #IMPLIED>\n<!ELEMENT updated-set (response+)>\n<!ELEMENT merged-set (response+)>\n<!ELEMENT ignored-set (href+)>\n\n<!ELEMENT merge-preview-response\n (update-preview | conflict |\n  ignored-preview)*>                      <!-- was ignore-preview -->\n<!ATTLIST merge-preview-response xmlns CDATA #IMPLIED>\n<!ELEMENT update-preview (target, version)>\n<!ELEMENT conflict (target, common-ancestor, version)>\n<!ELEMENT target (href)>\n<!ELEMENT common-ancestor (href)>\n<!ELEMENT ignored-preview (version)>  <!-- should be DAV:href -->\n\n<!ELEMENT baseline-comparision-report\n (added-version | deleted-version | changed-version)*>\n<!ATTLIST baseline-comparision-report xmlns CDATA #IMPLIED>\n<!ELEMENT added-version (href)>\n<!ELEMENT deleted-version (href)>\n<!ELEMENT changed-version (href, href)>\n\n<!ELEMENT latest-activity-version-report (href)>\n<!ATTLIST latest-activity-version-report xmlns CDATA #IMPLIED>\n\n<!--=========== DeltaV Optional Extensions ===============-->\n<!ELEMENT apply-to-version EMPTY>\n\n<!--=========== DeltaV Common Elements ===============-->\n<!ELEMENT version (href)>\n\n<!ELEMENT label-name (#PCDATA)>\n\n<!ELEMENT fork-ok EMPTY>\n\n<!ELEMENT source (href)>\n\n<!ELEMENT ok EMPTY>\n<!ELEMENT discouraged EMPTY>\n<!ELEMENT forbidden EMPTY>\n\n<!--=========== DeltaV Extensions to DAV:Prop ===============-->\n<!ELEMENT prop-multivalue (response*)>  <!--- new!! -->\n<!ATTLIST prop-multivalue name CDATA #REQUIRED>\n\n<!--=========== Property Values ===============-->\n<!--=========== Value for DAV:resourcetype ===============-->\n<!ELEMENT history EMPTY>\n\n<!ELEMENT version-controlled-binding\n (binding-name, version-history)>\n<!ELEMENT binding-name (#PCDATA)>\n<!ELEMENT version-history (href)>\n\n<!ELEMENT string (#PCDATA)>\n<!ELEMENT name (#PCDATA)>\n\n<!--=========== WebDAV defined optional properties ===============\n name                           value\n DAV:version-set                        (DAV:href+)\n DAV:root-version                       (DAV:href)\n DAV:version-history                    (DAV:href)\n DAV:workspace-checkout-set             (DAV:href*)\n DAV:workspace                          (DAV:href)\n DAV:merge-set                          (DAV:href*)\n DAV:auto-merge-set                     (DAV:href*)\n DAV:baseline-controlled-collection     (DAV:href)\n DAV:subbaseline-set                    (DAV:href*)\n DAV:baseline-collection                (DAV:href)\n DAV:baseline-selector                  (DAV:href)\n DAV:baseline-controlled-collection-set (DAV:href*)\n DAV:activity-version-set               (DAV:href*)\n DAV:activity-checkout-set              (DAV:href*)\n DAV:subactivity-set                    (DAV:href*)\n DAV:current-workspace-set              (DAV:href*)\n DAV:activity-set                       (DAV:href*)\n DAV:reserved                           (#PCDATA)    was unreserved\n DAV:current-activity-set               (DAV:href*)\n DAV:version-controlled-binding-set     (version-controlled-binding*)\n DAV:eclipse-set                        (DAV:href*)\n DAV:variant-set                        (DAV:href*)\n DAV:default-variant                    (DAV:href)\n DAV:comment                            (DAV:string*)\n DAV:creator-displayname                (DAV:name*)\n    ====================================================-->\n<!--================ DeltaV errors =====================-->\n<!--- new!! -->\n<!ELEMENT error (user-defined-error |\n  put-under-version-control-error |\n  already-under-version-control-error |\n  cannot-modify-version-controlled-content-error |\n  cannot-modify-version-error |\n  cannot-modify-version-controlled-property-error |\n  cannot-modify-protected-property-error |\n  cannot-modify-unsupported-property-error |\n  auto-version-when-unlocked-error |\n  cannot-delete-root-version-error |\n  cannot-delete-referenced-version-error |\n  no-version-delete-error |\n  update-predecessor-set-error |\n  initialize-precursor-error |\n  auto-checkout-when-locked-error |\n  cannot-rename-resource-error |\n  preserve-history-error |\n  must-be-checked-in-error |\n  is-checked-out-error |\n  initialize-predecessor-set-error |\n  must-be-checked-out-error |\n  version-history-is-tree-error |\n  create-version-error |\n  initialize-version-content-and-properties-error |\n  checked-in-error |\n  keep-checked-out-error |\n  must-be-checked-out-version-controlled-resource-error |\n  cancel-checked-out-error |\n  restore-content-and-dead-properties-error |\n  must-be-checked-in-version-controlled-resource-error |\n  must-select-version-in-same-history-error |\n  update-content-and-dead-properties-error |\n  update-checked-in-property-error |\n  must-be-version-history-error |\n  delete-version-set-error |\n  cannot-copy-history-error |\n  new-version-history-error |\n  add-to-history-error |\n  create-working-resource-error |\n  create-working-resource-from-checked-in-version-error |\n  delete-working-resource-error |\n  resource-must-be-null-error |\n  workspace-location-ok-error |\n  initialize-workspace-error |\n  delete-workspace-members-error |\n  workspace-member-moved-error |\n  workspace-moved-error |\n  cannot-add-to-existing-history-error |\n  must-be-version-error |\n  one-version-controlled-resource-per-history-per-workspace-error |\n  new-version-controlled-resource-error |\n  cannot-merge-checked-out-resource-error |\n  checkout-not-allowed-error |\n  ancestor-version-error |\n  descendant-version-error |\n  checked-out-for-merge-error |\n  update-merge-set-error |\n  report-ignored-set-error |\n  report-properties-error |\n  delete-version-reference-error |\n  merge-must-be-complete-error |\n  must-not-be-checked-out-error |\n  must-be-new-label-error |\n  label-must-exist-error |\n  add-label-error |\n  remove-label-error |\n  must-not-have-label-and-apply-to-version-error |\n  depth-update-error |\n  version-controlled-configuration-must-be-empty-error |\n  must-be-baseline-error |\n  must-have-no-version-controlled-members-error |\n  one-baseline-controlled-collection-per-history-per-workspace-error |\n  create-version-controlled-configuration-error |\n  reference-version-controlled-configuration-error |\n  select-existing-baseline-error |\n  create-empty-baseline-error |\n  baselines-from-same-history-error |\n  no-checked-out-baseline-controlled-collection-members-error |\n  create-baseline-collection-error |\n  auto-baseline-error |\n  baseline-controlled-members-must-be-checked-in-error |\n  set-baseline-controlled-collection-members-error |\n  merge-baseline-error |\n  activity-location-ok-error |\n  initialize-activity-error |\n  must-be-activity-error |\n  delete-activity-reference-error |\n  update-checked-out-reference-error |\n  update-activity-reference-error |\n  update-workspace-reference-error |\n  one-checkout-per-activity-per-history-error |\n  linear-activity-error |\n  initialize-activity-set-error |\n  initialize-unreserved-error |\n  atomic-activity-checkin-error |\n  checkin-activity-error |\n  cannot-modify-checked-in-parent-error |\n  cannot-modify-destination-checked-in-parent-error |\n  initialize-version-history-bindings-error |\n  initialize-version-controlled-bindings-error |\n  version-control-working-collection-members-error |\n  update-version-controlled-collection-members-error |\n  checkout-of-version-with-descendant-is-forbidden-error |\n  checkout-of-version-with-descendant-is-discouraged-error |\n  checkout-of-checked-out-version-is-forbidden-error |\n  checkout-of-checked-out-version-is-discouraged-error |\n  checkin-fork-forbidden-error |\n  checkin-fork-discouraged-error |\n  cannot-delete-default-variant-error |\n  delete-variant-reference-error |\n  cannot-rename-variant-error |\n  variant-control-error |\n  create-new-variant-error |\n  delete-variant-predecessor-error |\n  must-select-variant-error |\n  update-default-variant-error |\n  update-variant-controlled-resource-error)> <!-- May be extended here -->\n\n<!ELEMENT user-defined-error ANY>            <!--- new!! -->\n\n<!ELEMENT put-under-version-control-error EMPTY>\n<!ELEMENT already-under-version-control-error EMPTY>\n<!ELEMENT cannot-modify-version-controlled-content-error EMPTY>\n<!ELEMENT auto-version-when-unlocked-error EMPTY>\n<!ELEMENT cannot-modify-version-controlled-property-error EMPTY>\n<!ELEMENT cannot-modify-version-error EMPTY>\n<!ELEMENT cannot-modify-protected-property-error EMPTY>\n<!ELEMENT cannot-modify-unsupported-property-error EMPTY>\n<!ELEMENT cannot-delete-root-version-error EMPTY>\n<!ELEMENT cannot-delete-referenced-version-error EMPTY>\n<!ELEMENT no-version-delete-error EMPTY>\n<!ELEMENT update-predecessor-set-error EMPTY>\n<!ELEMENT initialize-precursor-error EMPTY>\n<!ELEMENT auto-checkout-when-locked-error EMPTY>\n<!ELEMENT cannot-rename-resource-error EMPTY>\n<!ELEMENT preserve-history-error EMPTY>\n<!ELEMENT version-history-is-tree-error EMPTY>\n<!ELEMENT create-version-error EMPTY>\n<!ELEMENT must-be-checked-in-error EMPTY>\n<!ELEMENT is-checked-out-error EMPTY>\n<!ELEMENT initialize-predecessor-set-error EMPTY>\n<!ELEMENT must-be-checked-out-error EMPTY>\n<!ELEMENT initialize-version-content-and-properties-error EMPTY>\n<!ELEMENT checked-in-error EMPTY>\n<!ELEMENT keep-checked-out-error EMPTY>\n<!ELEMENT must-be-checked-out-version-controlled-resource-error EMPTY>\n<!ELEMENT cancel-checked-out-error EMPTY>\n<!ELEMENT restore-content-and-dead-properties-error EMPTY>\n<!ELEMENT must-be-checked-in-version-controlled-resource-error EMPTY>\n<!ELEMENT must-select-version-in-same-history-error EMPTY>\n<!ELEMENT update-content-and-dead-properties-error EMPTY>\n<!ELEMENT update-checked-in-property-error EMPTY>\n<!ELEMENT must-be-version-history-error EMPTY>\n<!ELEMENT delete-version-set-error EMPTY>\n<!ELEMENT cannot-copy-history-error EMPTY>\n<!ELEMENT new-version-history-error EMPTY>\n<!ELEMENT add-to-history-error EMPTY>\n<!ELEMENT create-working-resource-error EMPTY>\n<!ELEMENT create-working-resource-from-checked-in-version-error EMPTY>\n<!ELEMENT delete-working-resource-error EMPTY>\n<!ELEMENT resource-must-be-null-error EMPTY>\n<!ELEMENT workspace-location-ok-error EMPTY>\n<!ELEMENT initialize-workspace-error EMPTY>\n<!ELEMENT delete-workspace-members-error EMPTY>\n<!ELEMENT workspace-member-moved-error EMPTY>\n<!ELEMENT workspace-moved-error EMPTY>\n<!ELEMENT cannot-add-to-existing-history-error EMPTY>\n<!ELEMENT must-be-version-error EMPTY>\n<!ELEMENT\n one-version-controlled-resource-per-history-per-workspace-error EMPTY>\n<!ELEMENT new-version-controlled-resource-error EMPTY>\n<!ELEMENT cannot-merge-checked-out-resource-error EMPTY>\n<!ELEMENT checkout-not-allowed-error EMPTY>\n<!ELEMENT ancestor-version-error EMPTY>\n<!ELEMENT descendant-version-error EMPTY>\n<!ELEMENT checked-out-for-merge-error EMPTY>\n<!ELEMENT update-merge-set-error EMPTY>\n<!ELEMENT report-ignored-set-error EMPTY>\n<!ELEMENT report-properties-error EMPTY>\n<!ELEMENT delete-version-reference-error EMPTY>\n<!ELEMENT merge-must-be-complete-error EMPTY>\n<!ELEMENT must-not-be-checked-out-error EMPTY>\n<!ELEMENT must-be-new-label-error EMPTY>\n<!ELEMENT label-must-exist-error EMPTY>\n<!ELEMENT add-label-error EMPTY>\n<!ELEMENT remove-label-error EMPTY>\n<!ELEMENT must-not-have-label-and-apply-to-version-error EMPTY>\n<!ELEMENT depth-update-error EMPTY>\n<!ELEMENT version-controlled-configuration-must-be-empty-error EMPTY>\n<!ELEMENT must-be-baseline-error EMPTY>\n<!ELEMENT must-have-no-version-controlled-members-error EMPTY>\n<!ELEMENT one-baseline-controlled-collection-per-history-per-workspace-error\n EMPTY>\n<!ELEMENT create-version-controlled-configuration-error EMPTY>\n<!ELEMENT reference-version-controlled-configuration-error EMPTY>\n<!ELEMENT select-existing-baseline-error EMPTY>\n<!ELEMENT create-empty-baseline-error EMPTY>\n<!ELEMENT baselines-from-same-history-error EMPTY>\n<!ELEMENT no-checked-out-baseline-controlled-collection-members-error EMPTY>\n<!ELEMENT create-baseline-collection-error EMPTY>\n<!ELEMENT auto-baseline-error EMPTY>\n<!ELEMENT baseline-controlled-members-must-be-checked-in-error EMPTY>\n<!ELEMENT set-baseline-controlled-collection-members-error EMPTY>\n<!ELEMENT merge-baseline-error EMPTY>\n<!ELEMENT activity-location-ok-error EMPTY>\n<!ELEMENT initialize-activity-error EMPTY>\n<!ELEMENT must-be-activity-error EMPTY>\n<!ELEMENT delete-activity-reference-error EMPTY>\n<!ELEMENT update-checked-out-reference-error EMPTY>\n<!ELEMENT update-activity-reference-error EMPTY>\n<!ELEMENT update-workspace-reference-error EMPTY>\n<!ELEMENT one-checkout-per-activity-per-history-error EMPTY>\n<!ELEMENT linear-activity-error EMPTY>\n<!ELEMENT initialize-activity-set-error EMPTY>\n<!ELEMENT initialize-unreserved-error EMPTY>\n<!ELEMENT atomic-activity-checkin-error EMPTY>\n<!ELEMENT checkin-activity-error EMPTY>\n<!ELEMENT cannot-modify-checked-in-parent-error EMPTY>\n<!ELEMENT cannot-modify-destination-checked-in-parent-error EMPTY>\n<!ELEMENT initialize-version-history-bindings-error EMPTY>\n<!ELEMENT initialize-version-controlled-bindings-error EMPTY>\n<!ELEMENT version-control-working-collection-members-error EMPTY>\n<!ELEMENT update-version-controlled-collection-members-error EMPTY>\n<!ELEMENT checkout-of-version-with-descendant-is-forbidden-error EMPTY>\n<!ELEMENT checkout-of-version-with-descendant-is-discouraged-error EMPTY>\n<!ELEMENT checkout-of-checked-out-version-is-forbidden-error EMPTY>\n<!ELEMENT checkout-of-checked-out-version-is-discouraged-error EMPTY>\n<!ELEMENT checkin-fork-forbidden-error EMPTY>\n<!ELEMENT checkin-fork-discouraged-error EMPTY>\n<!ELEMENT cannot-delete-default-variant-error EMPTY>\n<!ELEMENT delete-variant-reference-error EMPTY>\n<!ELEMENT cannot-rename-variant-error EMPTY>\n<!ELEMENT variant-control-error EMPTY>\n<!ELEMENT create-new-variant-error EMPTY>\n<!ELEMENT delete-variant-predecessor-error EMPTY>\n<!ELEMENT must-select-variant-error EMPTY>\n<!ELEMENT update-default-variant-error EMPTY>\n<!ELEMENT update-variant-controlled-resource-error EMPTY>\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE DAV:propfind SYSTEM \"http://www.webdav.org/dtd/deltav-0.12.1.0.dtd\">\n<propfind xmlns=\"DAV:\">\n <prop>\n  <prop-key name=\"DAV:versionable-resource-collection-set\"/>\n  <prop-key name=\"DAV:version-history-collection-set\"/>\n </prop>\n</propfind>\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE multistatus SYSTEM \"http://www.webdav.org/dtd/deltav-0.12.1.0.dtd\">\n<multistatus xmlns=\"DAV:\">\n <response>\n  <href>http://www.webdav.org</href>\n   <propstat>\n    <prop>\n     <prop-value name=\"DAV:versionable-resource-collection-set\">\n      <href>http://www.webdav.org/public/projects</href>\n      <href>http://www.webdav.org/users/projects</href>\n     </prop-value>\n     <prop-value name=\"DAV:version-history-collection-set\">\n      <href>http://www.webdav.org/public/archive</href>\n      <href>http://www.webdav.org/users/archive</href>\n     </prop-value>\n    </prop>\n    <status>HTTP/1.1 200 OK</status>\n   </propstat>\n </response>\n</multistatus>\n\n\n\n", "id": "lists-006-6183956"}, {"subject": "Re: Core versioning issues and nit", "content": "   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   > > In 2.9, the root version of a version history \"must\n   > > not be deleted\".  Why is that?\n\n   > \"Otherwise you lose a key semantic of a version tree, namely it\n   > is connected and every version is reachable from the\n   > DAV:root-version.  I don't see that the benefit of allowing\n   > deletion of the root version outweighs the benefit of have the\n   > version tree be connected.\"\n\n   Then make the requirement that the version tree be connected.  It's\n   quite possible for implementations to meet the requirement that the\n   version tree be connected, and provide this valuable functionality\n   for clients.\n\n   On the other hand, if you do not require that the version tree be\n   connected, then it's quite possible for implementations to end up with\n   an unconnected version tree even without deleting the root version.\n\n   I think the point here is to make the requirement state what the client\n   needs, rather than what you think is needed in order to get what the\n   client needs.\n\nGood point.  I'll delete the precondition and add a postcondition that\nsays: \"following the deletion, there must be a root version that is a\npredecessor of all other versions in that version history\".  In particular,\nthis is trivially satisfiable for linear version histories (which I'm\nguessing is what Lisa had in mind :-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6219361"}, {"subject": "Re: Core versioning issues and nit", "content": "   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   > > 2) Versioning of Properties\n   > >\n   > > We need a kind of property that applies to all versions,\n   > > or to put another way, properties that apply to the\n   > > version-controlled resource itself.  For example, the\n   > > \"owner\" property maybe ought to apply to the whole shebang:\n   > > when you change the owner, the new owner has to be responsible\n   > > for everything, from the first version to the last and\n   > > including the version-controlled resource and version history.\n\n   > The version history refers to all the versions, and so that would\n   > be the natural place to put the creator display name of the\n   > 'component' owner.\n\n   What I'd like is a straightforward statement (in the spec, not just in\n   mail!) that the VCR can have all sorts of properties, including custom\n   (dead) properties, that can be considered to apply to document as a\n   whole, including all its versions.  I've given examples of the need for\n   such properties.\n\nThis has probably been covered in the previous message on \"pass\nthrough\" behavior, but just to make sure, if by a \"property that can\nbe considered to apply to the document as a whole, including all its\nversions\" you mean a property that \"passes through\" to all its\nversions, then, no, the protocol provides no such capability, in order\nto prevent the complexities that caused us to give up on a direct\nreference resource.\n\n   Please resolve this.  Placing custom properties on the VHR is\n   unacceptable, because a VHR doesn't appear in regular collections the\n   way a VCR does.  You would have to make one request to collection\n   '/lisa/' to find all the VCRs and all the URLs to the VHRs, then make\n   'n' requests to all the VHR URLs to find the values of the custom\n   property.\n\nYou can use the DAV:expand-property report if you want to obtain\nall this information in one request.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6227927"}, {"subject": "Re: Core versioning issues and nit", "content": "   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   > > 7) How do you distinguish between:\n   > >  - A versionable resource\n   > >  - A non-versionable resource\n   > >  - A version-controlled resource\n\n   > A versionable resource will answer with (at least) Allow:\n   > VERSION-CONTROL to an OPTIONS request, a non-versionable resource\n   > will not.  A version-controlled resource is the only resource\n   > with a DAV:checked-in or DAV:checked-out property.\n\n   > There was some debate a while ago about making the resource types\n   > explicit, with various methods sugested.  I have to say that\n   > determining type by the presence or absence of properties is\n   > sub-optimal since, among other things, it makes for careful\n   > consideration when defining new resources with overlapping\n   > property names.\n\nOne person's \"resource type\" is another persons \"resource state\".\nIs \"checked-out\" a resource type or a resource state?  Is \"locked\"\na resource type or a resource state.  Is \"under version control\"\na resource type or a resource state. ...\n\nSo either you need to carefully consider your choice of property\nnames (which you should do anyway), or carefully consider your\nchoice of \"resource type names\".\n\n   I agree that determining type by the absence of properties is\n   sub-optimal; I'd say it's not very reliable.\n\nHow is it any less reliable than looking for a particular value\nin a \"resourcetype\" property?\n\n   I'd point out another\n   problem:  in order to create the kind of GUI I described, the client\n   would have to:\n    - Issue a depth:1 PROPFIND request to find all the resources that have\n   a DAV:checked-in (or checked-out) property.  If they do, consider them\n   VCRs.\n    - Issue an OPTIONS request to every non-VCR, to find out whether it can\n   be versioned or not.\n\nNow this is a good argument for turning the DAV:supported-method-set\nback into a property!  Which is what James Hunt has just asked us\nto do.  I asked him \"why\".  I think this is a pretty good answer.\nSo I'd propose that we switch them back, based on this point that\nLisa has made.\n\nAny objections? (I assume that at least James will be in favor :-).\n\n   This is an order(N) operation, just to show a decent directory listing.\n   Depth is not supported on OPTIONS requests, according to RFC2518: \"The\n   Depth header is only supported if a method's definition explicitly\n   provides for such support.\"\n\n   This is a serious client issue.  Please address...\n\nI assume turning the supported-xxx information back into a property\naddresses this concern?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6237591"}, {"subject": "Re: Core versioning issues and nit", "content": "   From: \"Lisa Dusseault\" <lisa@xythos.com>\n   Date: Fri, 2 Feb 2001 12:09:49 -0800\n\n\n   ... please modify section 2.4 to read something like:\n\n   \"If the request-URL identifies a versionable resource, a new version\n   history resource MAY be created.\"\n\nI agree this needs to be clarified, but I prefer JimW's wording: \"In\ncore versioning, a version history resource is not assigned a URL, and\nhence is not visible in the http scheme URL space.\"\n\nThis keeps the versioning model more consistent, since logically\nthere always is a version history which consists of all the\nversions connected by predecessor relations.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6247894"}, {"subject": "Re: Patche", "content": "   From: Roy Seto <Roy.Seto@oracle.com>\n\n   An author uses what many existing versioning systems call a\n   subbranch to develop a logical change. Then that author\n   merges the subbranch into what many versioning systems would\n   call its parent branch (perhaps by using a workspace defined\n   in terms of the parent branch as the merge target). The\n   author would like to identify the versions on the parent\n   branch created by the merge process (marked as \"O\" in the\n   diagram below).\n\n----------------------O---- parent branch\n  \\                  /\n   \\                /\n    ---------------- subbranch\n\n       <--- ancestors   descendants ---> \n\nIn our system (which maintains both branches and change-sets),\nwe open up a new \"merge activity\" for the merge (which is a\nsub-activity of the branch activity), and then create all the\nnew versions on the parent branch in that \"merge\" activity.\nSo for us, the merge activity identifies those specific\nversions on the parent branch that are the result of the\nmerge.\n\nThe versioning protocol doesn't go into this level of detail\nof course, but that would be one way to do it.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6255883"}, {"subject": "Re: Labels and Statu", "content": "I agree with the points Lisa makes below, but I believe this\nkind of work should be done as a general WebDAV property\nmetadata effort (there are lots of interesting property\nmetadata information that you'd like to define and discover),\nand not something embedded in the versioning protocol\n(I'd say we've done more than our share by tackling the\n\"report\" problem :-).\n\nCheers,\nGeoff\n\n   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   I'd second what James says, only make it even more general.\n\n   Yes, many versioning systems have \"status\" properties on versions,\n   and the \"status\" property should be mutable, i.e. should be\n   writable = without creating a new version.  (Immutable properties\n   never change on old versions; changing an immutable property\n   creates a new version).\n\n   However, there are also publishing or workflow processes which require\n   their own mutable properties.  For example, \"publishing-status\" or\n   \"editing-status\" or \"approval-status\" or \"invoice-status\"...  We can't\n   be expected to predict all these, however it's a common need, and\n   defining only 'status' would not solve the general problem.\n\n   Thus, versioning needs a general way to allow creation of custom\n   properties which are mutable, AND custom properties which are =\n   immutable.  The server would of course reject requests for mutable\n   properties if it does not support mutability, but we need a\n   standard way for clients to ask for this.\n\n\n\n", "id": "lists-006-6263585"}, {"subject": "Re: From Juergen Reute", "content": "   From: Juergen Reuter <reuter@ira.uka.de>\n\n   In earlier versions of DeltaV, there was a computed property that listed\n   all checked-out working resources associated with a single versioned\n   resource.  In combination with the DAV:expand-property REPORT, you could\n   fetch properties of all working resources with a single request.\n   Similarly, you could (and still can) fetch properties of all version\n   resources using the DAV:version-set property in a single request.\n   So, with only two requests, I could fetch all properties that are needed\n   for displaying a revision graph that includes working resources and/or\n   checked out version-controlled resources.\n\n   For this purpose, I would have expected to see a DAV:checkout-set\n   (<!ELEMENT checkout-set (href*)>) property on version history resources\n   that identifies each checked-out resource whose DAV:checked-out property\n   identifies any version in the version history.  But I can not find such a\n   property.\n\n   Alternatively, I would be satisfied with some kind of DAV:version-tree\n   REPORT that applies on checked-out resources rather than versions, or a\n   DAV:version-tree REPORT that includes checked-out resources.\n\n   Is there some other way to retrieve properties from all working resources\n   associated with a versioned resource in a single request that I\n   overlooked?\n\nYes, just use the DAV:expand-property report, asking for the\nDAV:checkout-set of the DAV:revision-set of the version history\nresource.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6272329"}, {"subject": "Re: Labels and Statu", "content": "   From: \"James J. Hunt\" <jjh@ira.uka.de>\n\n      Introducing server-defined status properties is starting down\n      the slippery slope of document management. We intentionally kept\n      this out of Delta-V because it didn't seem essential for\n      versioning support, and would seriously delay its\n      introduction. I suggest we may want to start another working\n      group soon that address Delta-V extensions for interoperable\n      document management. I would be happy to be involved.\n\n   When that is the general consensus, than I would also like to be\n   involved, but than it real does need to happen soon.  I would still\n   change the example.\n\nI agree with Jim's points, and would want to define document\nmanagement properties as a follow-on effort.  I also think this\nshould be done in a new working group, since I think there is\na wider group of individuals that would be interested in\nparticipating in this design effort.\n\nAnd I am happy to change the example.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6280505"}, {"subject": "Re: Introductio", "content": "I agree with Tim that this is more appropriate for the scenarios\ndocument, and I strongly enourage James to sign on as a co-author\nof the scenarios document, and flesh out these scenarios in that\ndocument!\n\nCheers,\nGeoff\n\n\n   From: Tim_Ellison@uk.ibm.com\n\n   Hmm, this feels like you are leading the reader down a certain path -- I\n   suggest this is better covered in a scenarios doc.\n\n\n   \"James J. Hunt\" <jjh@allerton.de> on 2001-02-02 06:11:50 AM\n\n   The introduction is a bit short.  In particular, no mention is made\n   of the different operating modes that this protocol is designed to\n   support.  That makes it a bit difficult for someone who has not sat\n   in on several committee meetings to understand why the protocol is\n   \"so complicated\".  Can a new paragraph after the second paragraph\n   in the introduction as follows be added?\n\n   The extensions to WebDAV described here are designed to support\n   three different client/server interaction scenarios: versioning\n   unaware clients, server managed workspaces, and client managed\n   workspace.  In core versioning a compliant server provides a single\n   access point for each resource.  In essence, this is a default\n   server side workspace.  A server may allow versioning unaware\n   clients to modify resources in this workspace though normal WebDAV\n   requests.  This allows sequential modification of resources.  In\n   order to support parallel modification of resources, there needs to\n   be a method to create new workspaces.  To possibilities are\n   supported: server side workspaces via the workspace option and\n   client side workspace through the <client-workspace resource>\n   option.\n\n   Sincerely,\n   James J. Hunt\n   J=FCrgen Reuter\n\n\n\n", "id": "lists-006-6288421"}, {"subject": "properties of version histories (was: Re: Core versioning issues and nits", "content": "On Sun, Feb 04, 2001 at 07:52:39PM -0500, Geoffrey M. Clemm wrote:\n>    From: \"Lisa Dusseault\" <lisa@xythos.com>\n>...\n>    Please resolve this.  Placing custom properties on the VHR is\n>    unacceptable, because a VHR doesn't appear in regular collections the\n>    way a VCR does.  You would have to make one request to collection\n>    '/lisa/' to find all the VCRs and all the URLs to the VHRs, then make\n>    'n' requests to all the VHR URLs to find the values of the custom\n>    property.\n> \n> You can use the DAV:expand-property report if you want to obtain\n> all this information in one request.\n\nSpecifically, run the report using a Depth:1 on the VCR to grab the VHR URL\nand then the props of interest.\n\nN reports will be run and returned within the report body.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-6297060"}, {"subject": "OPTIONS and Depth (was: Re: Core versioning issues and nits", "content": "On Sun, Feb 04, 2001 at 08:05:06PM -0500, Geoffrey M. Clemm wrote:\n>...\n> Now this is a good argument for turning the DAV:supported-method-set\n> back into a property!  Which is what James Hunt has just asked us\n> to do.  I asked him \"why\".  I think this is a pretty good answer.\n> So I'd propose that we switch them back, based on this point that\n> Lisa has made.\n> \n> Any objections? (I assume that at least James will be in favor :-).\n> \n>    This is an order(N) operation, just to show a decent directory listing.\n>    Depth is not supported on OPTIONS requests, according to RFC2518: \"The\n>    Depth header is only supported if a method's definition explicitly\n>    provides for such support.\"\n> \n>    This is a serious client issue.  Please address...\n> \n> I assume turning the supported-xxx information back into a property\n> addresses this concern?\n\nThat doesn't make sense. You're always going to have a tension between\nOPTIONS for capability discovery and PROPFIND/Depth: for discovery over a\nset of resources. supported-xxx was moved to OPTIONS because that is where\ndiscovery normally occurs.\n\nBy your logic, we should move the DAV: header into properties.\n\nThe right answer is to modify OPTIONS to allow a Depth: header value.\n\nIf it comes back with a multistatus, then you know the server understood the\nDepth: header. If it didn't respond with a multi, then you probably don't\nhave a DeltaV server.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-6305784"}, {"subject": "Re: Labels and Statu", "content": "I think the point here is to have mutable properties (e.g. \"status\") on\nimmutable resources (e.g. version resources). That doesn't make sense to me\nat all.\n\nIMO, the mutable information is kept elsewhere and simply refers to the\nimmutable items.\n\nI'd agree with Geoff: let's limit the scope and complete the DeltaV spec.\n\nCheers,\n-g\n\nOn Sun, Feb 04, 2001 at 08:43:08PM -0500, Geoffrey M. Clemm wrote:\n> \n> I agree with the points Lisa makes below, but I believe this\n> kind of work should be done as a general WebDAV property\n> metadata effort (there are lots of interesting property\n> metadata information that you'd like to define and discover),\n> and not something embedded in the versioning protocol\n> (I'd say we've done more than our share by tackling the\n> \"report\" problem :-).\n> \n> Cheers,\n> Geoff\n> \n>    From: \"Lisa Dusseault\" <lisa@xythos.com>\n> \n>    I'd second what James says, only make it even more general.\n> \n>    Yes, many versioning systems have \"status\" properties on versions,\n>    and the \"status\" property should be mutable, i.e. should be\n>    writable = without creating a new version.  (Immutable properties\n>    never change on old versions; changing an immutable property\n>    creates a new version).\n> \n>    However, there are also publishing or workflow processes which require\n>    their own mutable properties.  For example, \"publishing-status\" or\n>    \"editing-status\" or \"approval-status\" or \"invoice-status\"...  We can't\n>    be expected to predict all these, however it's a common need, and\n>    defining only 'status' would not solve the general problem.\n> \n>    Thus, versioning needs a general way to allow creation of custom\n>    properties which are mutable, AND custom properties which are =\n>    immutable.  The server would of course reject requests for mutable\n>    properties if it does not support mutability, but we need a\n>    standard way for clients to ask for this.\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-6314779"}, {"subject": "Re: Term", "content": "   From: Tim_Ellison@uk.ibm.com\n\n   > 1.  Can section 1.4 Notational Convention be placed\n   > before Terms? This would eliminate some forward\n   > references, thus making the document easier to read.\n\n   Really, I don't recall any notational conventions used in terms (besides\n   the occasional MUST or MUST NOT<g>).\n\nWell, I don't really care one way or the other, and the MUST and the\nMUST NOT are in fact a forward reference (albeit fairly harmless ones\n:-), so I'd be happy to move the notational convention in front of the\nterminology section, as requested.  Does anyone object?\n\n   > Can the following sentence be added just after the first sentence\n   > in section 1.3?  \"Note that RFC 2518 uses terms from RFC 2068\n   > which is superseded by RFC 2616.\"  This would make it easier for\n   > someone who starts with this document (RFC 2518).  He or she\n   > would know immediately that RFC 2068 can be ignored.\n\n   I agree.\n\nWill do.\n\n   > 3. The difference between \"Version-Controlled Resource\"\n   > and \"Working Resource\" is not clear.\n   > In some sense, they are both working resources.\n   > The only difference is that \"Working Resources\" disappear\n   > after check-in and \"Version-Controlled Resources\" do not.\n\n   I'd say that was quite a significant difference.\n\nI agree, and also agree with all the following points\nmade by Tim (which I will omit).  I believe Tim makes\na compelling case for keeping the terminology as it is.\n\n   > The definitions of activity resource, variant resource, and\n   > variant-controlled resource are not clear.  I discussions with\n   > Geoff and Jim the line was that an activity represents both a\n   > branch and a change set.  That functionally they are the same.  A\n   > variant seems to also represent a branch, or at least the end of\n   > one.  Actually, it seem set of branches is a better description.\n   > The division does not seem very clear to us.  Can someone\n   > enlighten me?\n\n   Not sure how to enlighten you other than recommending a re-read of\n   RFC2616 variants which is what it took for me to 'get it'.  I'm\n   sure others can give more constructive suggestions.\n\nUnfortunately, that's the best suggestion I have as well.\nPerhaps you could explain what about RFC2616 variants don't\nmake sense to you, and what you need to author variants that\nis not provided by the variant option?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6323996"}, {"subject": "Re: Comments on -12: properties, REPORT, OPTION", "content": "   From: Tim_Ellison@uk.ibm.com\n\n   > ...  What I was driving at was, if the server\n   > signals that it does support the activity option, does that then\n   > mean the server MUST allow writing to DAV:current-activity-set via\n   > PROPPATCH?\n\n   I claim \"yes\" -- that's what supporting the activity option means (plus the\n   other stuff<g>).\n\nI agree (unless prevented by access control, locking, and other things\nthat might prevent you from writing to something that is writeable).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6333037"}, {"subject": "Re: Core versioning issues and nit", "content": "Tim covered most of the points very thoroughly ... I assume\nthat there have been followups to any of his responses that\npeople may have found unsatisfactory (there were several such\nfollowups :-).  So I just snipped out everything where all\nI had to say was \"I agree with what Tim says here\".\n\n   From: Tim_Ellison@uk.ibm.com\n\n   > 9) What is DAV:checkout-response\n   >\n   > The definition of the \"DAV:already-under-version-control\" status\n   > message (er, I mean 'postcondition') uses the\n   > \"DAV:checkout-response\" element.  That's not part of core.\n\n   Good catch, I suspect that is a typo. -- it should of course be\n   <DAV:version-control>.\n\nAnd based on other reviews, I'll just delete this part of the\npostcondition.\n\n   > 10) Interactions between LOCK and VERSION-CONTROL\n   >\n   > State whether a locked resource can be placed under\n   > version-control, and whether the lock-token must be supplied\n   > with the VERSION-CONTROL method.\n\n   Sounds reasonable.\n\nActually, the interaction between the versioning protocol and\nthe locking protocol is completely defined in 1.5.4, namely \nthat a property defined in the versioning protocol MUST NOT\nbe modified on a locked resource unless accompanied by a\nvalid lock token.  In particular, in this case, placing a\nresource under version control adds a DAV:checked-in property\non that resource, which requires a lock token if the resource\nis locked.\n\nThis might be worth adding to the FAQ, but I don't want to\nrepeat this on every method that updates a property (which\nmost of them do).\n\n   > 11) Interaction between existing headers and new methods\n   >\n   > What happens when Depth is applied to the VERSION-CONTROL\n   > method?  It seems that this is being addressed in a mail\n   > thread, but the specification must define the behaviour.\n   > What exactly happens if anything in the scope can't be\n   > turned into a VCR?\n\nDepth only applies to methods that explicitly state that they\nsupport the Depth header.  The VERSION-CONTROL method does not.\nWe don't disallow it though, to leave room for future extensions\nthat might find a use for the Depth header.\n\n   > 12) Version-tree report\n   >\n   > In 2.5, the version-tree report is required to be a\n   > \"DAV:multistatus\".  The response could for that could\n   > reasonably be 200 Success or 207 multistatus.  Your\n   > example shows 200.  Please state normatively, which\n   > response code is required.\n\n   Another good one, I think that should be 207 Multistatus.\n\nGreat catch!  Same problem with the \"locate-history\" report.\nI'll fix them both.\n\n   > 15) Version-history-is-tree\n   >\n   > \"(DAV:version-history-is-tree): If the request-URL\n   > identifies a version-controlled resource that was\n   > automatically checked out because DAV:auto-version was\n   > DAV:when-locked, then the versions identified by the\n   > DAV:predecessor-set of the checked-out resource MUST\n   > be descendants of the root version of the version\n   > history for the DAV:checked-out version.\"\n   >\n   > What does locking have to do with whether the versions\n   > must be descendants of the root version?  Wouldn't\n   > this also apply when doing autoversioning when unlocked?\n   > We don't really understand this paragraph.  Again, we\n   > wonder what this is doing in core.\n\n   I don't understand this either.  Given that the root version cannot be\n   deleted to maintain connectivity, surely all versions are descendants of\n   the root version.\n\nWhen a version-controlled resource is left checked-out (which in\ncore can only happen because DAV:auto-version was DAV:when-locked),\nthe DAV:predecessor-set can be updated by the client.  It could\nupdate the predecessor set to refer to some random resource that\nis not in the version history.  This postcondition prevents that.\n\n   > 17) OPTIONS supported-method-set\n   >\n   > Section 23.6:  this defines 'supported-method-set',\n   > but in fact there's already a header that expresses this.\n   > How are you dealing with that redundancy?\n\nNow that DAV:supported-method-set is back to being a property,\nit is no longer redundant.\n\n   Thanks for the comments, I hope my answers were not too flippant -- I'm\n   just in that kind of mood today.\n\nWhen dealing with an internet protocol, I believe the more\nflippancy the better !  (Not going to get a chuckle from\nthe protocol itself, that's for sure :-).\n\n   For those points where I was able to give a satisfactory answer I strongly\n   encourage you to add a Q&A to the Delta-V FAQ\n   (http://www.webdav.org/deltav/faq);\n\nI second that request!\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6340565"}, {"subject": "Re: Comments on VERSION-CONTRO", "content": "   From: Tim_Ellison@uk.ibm.com\n\n   > But then in the Postconditions section it states:\n   >\n   > > (DAV:already-under-version-control): If the request-URL identified\n   > > a resource already under version control at the time of the request,\n   > > the VERSION-CONTROL request MUST NOT change the state of that\n   > > version-controlled resource, and the DAV:checkout-response body MUST\n   > > contain a DAV:already-version-controlled element.\n   >\n   > Since it is my understanding that invoking VERSION-CONTROL\n   > on a resource with URL U has the effect of converting the\n   > resource at URL U into a version-controlled resource (as\n   > well as creating a new version resource, and a new version\n   > history resource), this appears to contradict the ignore rule\n   > given at the beginning of Section 2.4.  I can see flagging\n   > an error if VERSION-CONTROL is invokved on a version resource,\n   > or a version history resource, so perhaps that was the intent\n   > of this postcondition.\n\n   Good point, stating that the request is ignored but produces a prescribed\n   response seems counterintuative.\n\nYes, this was added when a reviewer asked for a response that would\ntell them whether or not the VERSION-CONTROL request was ignored\nbecause the resource was under version control already.  This is\nclearly confusing, so I agree with Tim's suggestion that we just drop\nthe requirement that the method return this information.  Anyone\nobject?\n\n   Secondly, I agree that there are a number of places where the\n   marshaling is underspecified with respect to (usually) error\n   conditions (though in this case it is a 200 OK response).  For\n   example, in REPORT \"the response body MUST contain the requested\n   report\" and \"The DAV:version-tree REPORT response body MUST be a\n   DAV:multistatus XML element.\"\n\nI didn't quite follow your point here Tim ... could you restate\nor clarify?\n\n   > *) This certainly raises the issue that, at present, the\n   > value of an empty DAV:auto-version property is not specified,\n   > and should be.\n\n   Agreed.  A quick check reveals that this is the only property value\n   declared as ANY.\n\nThe \"value\" of an empty DAV:auto-version property is well defined\n(it has none) ... do you mean \"the behavior of an empty DAV:auto-version\nproperty\"?  If the protocol doesn't specify it's behavior, then from\nan interoperable clients perspective, it has no behavior.  This\nis true for all aspects of the protocol.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6352782"}, {"subject": "Re: Comments on -12: properties, REPORT, OPTION", "content": "   From: \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n\n   > > 4) What are the semantics if there is an XML request body\n   > > for OPTIONS, and this request body does not include a\n   > > DAV:supported-method-set, DAV:supported-live-property-set,\n   > > or DAV:supported-report-set at all (i.e., what happens if\n   > > one or more are just plain omitted)?\n   >\n   > Then the corresponding response elements are 'just plain omitted'.\n\n   That makes sense, but it should be specified.  Another perfectly\n   reasonable response is to flag the input as a syntax error, since\n   it's missing an expected XML element, and this could cause\n   interoperability problems.\n\nNow that these are back to being properties, the question no longer\narises.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6362225"}, {"subject": "Re: Comments on -12: properties, REPORT, OPTION", "content": "   From: Tim_Ellison@uk.ibm.com\n\n   > Properties:\n   >\n   > In Section 1.5.2:\n   >\n   > 1) \"A protected property cannot be updated with a PROPPATCH\n   > request.\"\n   >\n   > This this is a requirement, I recommend changing the \"cannot\"\n   > to a \"MUST NOT\" since that is the intent of the text, and \"MUST\n   > NOT\" has a specific meaning according to RFC 2119.\n\n   I agree.\n\nThis is stated in section 2.9 (Additional PROPPATCH Semantics) so\nwould be redundant to state here as well.\n\n   > REPORT:\n   >\n   > REPORT doesn't fit in Section 23.  REPORT is a new, complex\n   > method that predominantly extends the capabilities of RFC 2518,\n   > rather than clarifying existing capabilities in 2518. So far,\n   > REPORT is only used in this draft, hence though it may have\n   > utility broader than just the DeltaV draft, so far there aren't\n   > any additional users.  It may make sense, at some point in the\n   > future, to include this in the Distributed Authoring specification.\n   > But for now, having it in a section titled \"Clarifications and\n   > Extensions to RFC 2518\" is a bit strange -- the *entire*\n   > specification could be labeled extensions to 2518.  Additionally,\n   > sometimes people view appendicies as being non-normative -- do\n   > you want to send the message that you can safely ignore\n   > implementing REPORT?  The definition of REPORT can be placed\n   > elsewhere in the specification, and just note that the authors\n   > recommend it be incorporated into a revision of RFC 2518, due\n   > to its potentially broad utility.\n\n   I agree with your observations for this editorial change that I'll leave up\n   to the authors to resolve.\n\nI agree as well.  I will make this change, unless anyone objects.  In\nparticular, I will add a \"report option\", and require that a core\nversioning server support the report option.\n\n   > OPTIONS:\n   >\n   > Section 23.6:\n   >\n   > 1) I think it makes sense to keep things open for additional\n   > OPTIONS extensions.  So, I would rephrase this as, if you\n   > include an XML request body with OPTIONS, here is what it means,\n   > and it must include the following XML element.  Right now\n   > you're cutting off all possible future extension to OPTIONS\n   > that doesn't use XML, and that is overcontraining.\n\n   Agreed.\n\nGood point.  I'll make this change.\n\n   > 2) I'm not sure why the \"supported-method-set\" capability\n   > is present, since it duplicates the existing functionality\n   > of OPTIONS, specifically the Allow header.  If the example\n   > in 23.6.1 were correct, it would highlight this.\n   >\n   > The correct *response* for the example in 23.6.1 is:\n\n   <<snip>>\n\n   > So, the same information is in the Allow header, and the\n   > supported-method element.  IMO, there is no clear advantage\n   > to duplicating this capability.\n\n   Agreed.\n\nNow that this is a property, there is value (i.e. you can\nuse Depth to get it for a whole collection in one request).\n\n   > 3) Within supported-live-property-set, and supported-report-set,\n   > why not marshall the live properties, and reports, as comma\n   > separated lists?  It has the dual advantage of being more compact,\n   > and easier to read. DeltaV clients must have the ability to\n   > parse comma separated lists, so it's not like this is a huge\n   > imposition.\n\n   The values used to be comma separated lists, and I don't remember why\n   somebody asked for the change.\n\nIn case you wanted to extend this information some day with metadata\nabout those properties (possible with XML, not with comma separated\nlists).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6370371"}, {"subject": "Re: Section 2.1.1 comment", "content": "All changes made as suggested.\n\nCheers,\nGeoff\n\n   From: \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n   Date: Wed, 31 Jan 2001 16:49:53 -0800\n\n   Section 2.1.1:\n\n   It took me a long time to figure out exactly what was being described here.\n   I think my confusion derived from not understanding that there were three\n   separate entities being discussed:\n\n   - version-controlled resource\n   - version resource\n   - version history\n\n   I think my confusion would be eased by changing the second, third, and\n   fourth sentences of the first paragraph of Section 2.1.1 to more clearly\n   identify the three resources, and the fact that the unversioned resource is\n   being converted into a new type of resource, the version-controlled\n   resource.\n\n   ----------\n\n   VERSION-CONTROL, when invoked on a resource with URL U, performs three\n   distinct operations:\n\n   1) It creates a new \"version resource\" whose body and dead properties are a\n   copy of the original, unversioned resource. The server assigns this resource\n   a new URL, VR, which is different from the original URL U.\n   2) It converts the unversioned resource into a \"version-controlled\n   resource\". The version-controlled resource keeps the original URL U. As part\n   of this conversion, it adds the DAV:checked-in property, whose value is the\n   URL of the version resource created in step #1.\n   3) It creates a new \"version history resource\" whose state initially just\n   contains URL VR, since that is, at present, the only version in the version\n   history.\n\n   Thus, whereas before VERSION-CONTROL, there was only one, unversioned\n   resource, after VERSION-CONTROL there are three separate, distinct\n   resources, each containing their own state and properties: the\n   version-controlled resource, the version resource, and the version history\n   resource. In core versioning, a version history resource is not assigned a\n   URL, and hence is not visible in the http scheme URL space. However, when\n   the version-history option (Section 5) is supported, this changes, and the\n   version history resource does have a URL.\n\n   ----------\n\n   With this change, the first sentence of the second paragraph is no longer\n   needed.\n\n   I recommend moving the third paragraph, and the figure following, to\n   immediately after the second paragraph. Plus, I recommend labeling all of\n   the boxes in the figure, as follows:\n\n\n     ===VERSION-CONTROL==>\n\n       |                       +----+\n       |                       |    | version history\n       |                       +----+\n       |                         |\n   /foo.html   |   /foo.html             |\n       |                         v\n    +----+     |     +----+ checked-in +----+\n    | S1 |     |     | S1 | ---------->| S1 | version resource\n    +----+     |     +----+            +----+ URL: /hist/73/v1\n unversioned   | version-controlled\n   resource    |     resource\n\n   Adding an arrowhead to the lines between the version-controlled resource and\n   the version resource, and the version history and the version resource,\n   would also be helpful, since this is fairly conventional for pointers.\n\n   In the third paragraph, the third sentence (\"The new version resource is\n   identified...\") should be changed to:\n\n   \"The original unversioned resource is converted into a version-controlled\n   resource, whose DAV:checked-in property identifies the version resource.\"\n\n   Using \"version-controlled resource\" is more clear than using the elliptical\n   \"resource that is now under version control.\" (The artist formerly known as\n   Prince... ;-)\n\n\n   In the second paragraph, I recommend changing the second sentence \"When a\n   method is applied...\" to:\n\n   Since the version-controlled resource and version resources are separate,\n   distinct resources, when a method is applied to the version-controlled\n   resource, it only applies to the version-controlled resource, and does not\n   apply to the version resource that is currently identified by the\n   DAV:checked-in property.\n\n   - Jim\n\n\n\n", "id": "lists-006-6381551"}, {"subject": "Re: CHECKIN and propertie", "content": "   From: \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n   Date: Wed, 31 Jan 2001 17:42:14 -0800\n\n   Section 2.2 and Section 2.3:\n\n   Is it a MUST level requirement that a core versioning server support all of\n   the properties in sections 2.2 and 2.3?  I.e., MUST a version-controlled\n   resource have all of the Section 2.2 properties defined upon it (well,\n   really, all that are appropriate for its checked out/checked in state), and\n   MUST a version resource have all of the Section 2.3 properties defined on\n   it?  If so, I couldn't find a place that explicitly states this.\n\nI'll add the statement that the properties defined by core or an option\nare REQUIRED for core or that option.\n\n   Section 2.2.3:\n\n   It seems like, most of the time, the server will be setting the value of\n   DAV:predecessor-set, and except for merges, or adding to the server-computed\n   value, the client shouldn't try to write to this property.  Is this correct?\n   If so, it would be nice to capture this in Section 2.2.3, so client writers\n   have a better expectation about how this property works.\n\nThere are common cases when branching is disallowed but multiple\ncheckouts are allowed where a client will be updating the predecessor\nset.  I believe this is better handled in the scenarios document or\nFAQ, and not in the protocol document itself.\n\n   Section 2.2.5:\n\n   This seems underspecified to me. There are really two parameters here,\n   resource is write-locked/unlocked, and autoversion status of when-unlocked,\n   and when-locked.  ...\n\nI'll fix this.\n\nIn particular, there are really only 3 interesting combinations:\n\nDAV:always-checkout-always-checkin\nDAV:always-checkout-when-unlocked-checkin\nDAV:when-locked-checkout\n\n   Also, what happens when the resource is write-locked, and the value of\n   DAV:auto-version is changed from when-locked to when-unlocked?  Is a version\n   automatically created upon successful completion of the PROPPATCH (because\n   there would already be an active CHECKOUT due to the lock, and the\n   when-locked condition)?\n\nYes, the postcondition of UNLOCK does not depend on the current state\nof the DAV:auto-version property.\n\n   Section 3.2:\n\n   CHECKIN takes a version-controlled resource, and turns it into a version\n   resource which is a copy of its body and dead properties.  Properties that\n   must exist on a checked-out version-controlled resource are:\n\n   DAV:checked-out\n   DAV:predecessor-set\n   DAV:precursor-set\n   DAV:auto-version\n\n   Which of these properties should be transferred over to the version resource\n   created by CHECKIN?  My guess is:\n\n   DAV:checked-out: no\nYes, properties that are not explicitly stated as being transferred are\nnot transferred.\n   DAV:predecessor-set: yes\n   DAV:precursor-set: yes\nOops!  Forgot this one ... will fix.\n   DAV:auto-version: no\n\n   At the very least, this issue is not currently addressed in the\n   specification (except for DAV:predecessor-set).  DAV:precursor-set behavior\n   is described implicitly (by the existence of the property on a version\n   resource) -- I think it should be made more explicit, in the description of\n   CHECKIN.\n\nIt is, in the DAV:initialize-version-content-and-properties postcondition.\n\n   The text describing the (DAV:checked-in) postcondition should explicitly\n   note that the properties being discussed are on the version-controlled\n   resource, and not the version resource.\n\nWill do.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6392438"}, {"subject": "what to implement? (was: Re: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm EST", "content": "Subversion will implement most of the options, too (although with some heavy\nrestrictions in the first release). We won't be doing Variants, Update. If\nwe ever do in-place checkout and workspaces, it will be a long ways off.\n\nAnd SVN is both a client and server :-)\n\nCheers,\n-g\n\nOn Fri, Feb 02, 2001 at 03:03:31PM -0800, Eric Sedlar wrote:\n> Oracle plans on implementing most of the DeltaV options,\n> with the notable exception of Variants.  \n> \n> In addition to end-user clients, we may also be using DeltaV\n> internally to communicate between middle tier and data servers.\n> \n> --Eric\n> \n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: Friday, February 02, 2001 11:50 AM\n> To: Jim Amsden; ietf-dav-versioning@w3.org\n> Subject: RE: Versioning TeleConf Agenda, 2/2/00 (Friday) 12-1pm EST\n> \n> \n> > We have struggled with how to handle core vs. advanced\n> > vs. options since the beginning of Delta-V. In fact,\n> > there is a recent thread on this subject that suggests\n> > splitting them into separate documents. The compromise\n> > we came up with was to have core contain the minimal,\n> > essential support for versioning semantics that we\n> > expected every server vendor would implement. That is,\n> > core represents the common functions provided by all\n> > versioning repository vendors while the extensions\n> > represent the variability. However, we don't expect any\n> > server to just implement core because by itself, core\n> > isn't that interesting. Even the document management\n> > vendors have expressed interest in a number of the\n> > extensions. We just couldn't get any agreement on common\n> > subsets. This has been the greatest source of\n> > controversy, not the semantics of the specific\n> > extensions themselves.\n> \n> Xythos is planning to implement core and only core, unless and until\n> some interoperable DAV clients also implement some of the more generally\n> useful extensions such as checkin/checkout, baselines, variants or\n> labels, or until a customer requires such options.\n> \n> \"Expressed interest\" is a vague statement, you could say that Xythos has\n> expressed interest in various extensions, however as I've stated we may\n> not implement any extensions anytime soon.\n> \n> Any other document management vendors care to discuss what options they\n> plan to implement?\n> \n> Lisa\n> \n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-6402683"}, {"subject": "LOCK and VERSION-CONTROL (was: Re: Core versioning issues and  nits", "content": "Geoff wrote:\n> Actually, the interaction between the versioning\n> protocol and the locking protocol is completely\n> defined in 1.5.4, namely that a property defined\n> in the versioning protocol MUST NOT be modified\n> on a locked resource unless accompanied by a\n> valid lock token.  In particular, in this case,\n> placing a resource under version control adds\n> a DAV:checked-in property on that resource,\n> which requires a lock token if the resource\n> is locked.\n\nNow I'd admit that some of the protocol has to be read very carefully to\nget the implications, but that one is WAY off the scale ;-)\n\nTim\n\n\n\n", "id": "lists-006-6413701"}, {"subject": "response body (was: Re: Comments on VERSION-CONTROL", "content": ">>   Secondly, I agree that there are a number of\n>>   places where the marshaling is underspecified\n>>   with respect to (usually) error conditions\n>>   (though in this case it is a 200 OK response).\n>>   For example, in REPORT \"the response body MUST\n>>   contain the requested report\" and \"The\n>>   DAV:version-tree REPORT response body MUST be\n>>   a DAV:multistatus XML element.\"\n>\n> I didn't quite follow your point here Tim ... could you restate\n> or clarify?\n\nSimply that when, say DAV:version-tree REPORT is in error, it returns an\nextended status element body (contrary to \"The DAV:version-tree REPORT\nresponse body MUST be a DAV:multistatus XML element.\")\n\nTim\n\n\n\n", "id": "lists-006-6421277"}, {"subject": "autoversion header (was: Re: DeltaV doesn't support a true client  workspace", "content": "From Geoff:\n> Everyone else: Do you think that the Autoversion\n> header for PUT is of sufficient value to be worth\n> putting into core?  It is a way for a versioning\n> client to interact with a server like Chuck's\n> without forcing his server to have every PUT to\n> a version-controlled resource result in a new\n> version.\n\nNo, please no more alternatives for, or combinations of, existing\nfunctionality.\n\nTim\n\n\n\n", "id": "lists-006-6429613"}, {"subject": "Re: Complexity and Core Consideration", "content": "> 1) Is the current form of the specification too complex?\n> Yes/No/Maybe. Why?\n\nI'm not sure on what scale to measure the complexity, but overall I would\nsay no -- it is a complex subject and the specification is short and\nprecise.\n\n\n> 2) Does there remain sufficient discussion going on surrounding\n> the OPTIONS that the draft should be split into two documents,\n> CORE and OPTIONS, so that we can move CORE forward?\n> Yes/No/Maybe.  Why?\n\n\"Does there remain sufficient discussion going on\"\nHmm, can decide if this means 'because there is so much discussion going\non' or 'because there is so little discussion going on' about optional\nversioning.\n\nThe only arguments for splitting the document are editorial (i.e.,\nreadbility) and process (i.e., submit separately).  Since the document has\nbeen restructured it is easy for a core developer to ignore the optional\nparts.  I just don't buy Jim W's comments about problems with having to\nskip forwards to read the Sections 15-22, greif, if a developer cannot sort\nthat out then I don't want to entrust my data to any server they are\nwriting!  I'd like to get the optional sections submitted so that people\nwho have declared their intent on this list can make things happen.\n\nSo, 'no', don't split the document.\n\nTim\n\n\n\n", "id": "lists-006-6437654"}, {"subject": "RE: LOCK and VERSION-CONTROL (was: Re: Core versioning issues and   nits", "content": "Good point.  I'll move this to its own section and expand.\nHow about the following:\n\n1.8Versioning Methods and Write Locks\nIf a write-locked resource has a non-computed property defined by this\ndocument, the property value MUST NOT be changed by a request unless the\nappropriate lock token is included in the request.  Since every method\nintroduced in this document other than REPORT modifies at least one property\ndefined by this document, every versioning method other than REPORT is\naffected by a write lock. In particular, the method MUST fail with a 423\n(Locked) status if the resource is write-locked and the appropriate token is\nnot specified in an If request header.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n\nGeoff wrote:\n> Actually, the interaction between the versioning\n> protocol and the locking protocol is completely\n> defined in 1.5.4, namely that a property defined\n> in the versioning protocol MUST NOT be modified\n> on a locked resource unless accompanied by a\n> valid lock token.  In particular, in this case,\n> placing a resource under version control adds\n> a DAV:checked-in property on that resource,\n> which requires a lock token if the resource\n> is locked.\n\nNow I'd admit that some of the protocol has to be read very carefully to\nget the implications, but that one is WAY off the scale ;-)\n\nTim\n\n\n\n", "id": "lists-006-6446611"}, {"subject": "Re: Complexity and Core Consideration", "content": "   From: Tim_Ellison@uk.ibm.com\n\n   The only arguments for splitting the document are editorial (i.e.,\n   readability) and process (i.e., submit separately).  Since the\n   document has been restructured it is easy for a core developer to\n   ignore the optional parts.  I just don't buy Jim W's comments about\n   problems with having to skip forwards to read the Sections 15-22,\n   grief, if a developer cannot sort that out then I don't want to\n   entrust my data to any server they are writing!  I'd like to get\n   the optional sections submitted so that people who have declared\n   their intent on this list can make things happen.\n\n   So, 'no', don't split the document.\n\nGood points.\n\nAnother reason to keep them together is that we have been so stringent\nin removing any \"forward references\" from the core section to any\noptional section (the only reference is to the \"version history\noption\").  If core and options are in one document, at least the table\nof contents provides a minimal roadmap for someone reading the core\nsection and confused about the absence of some key concept (such as\nlabels or an explicit CHECKOUT/CHECKIN method).\n\nWith this in mind, I go from being \"neutral\" to being strongly\nin favor of keeping the options with the core in one document.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6455507"}, {"subject": "Re: response body (was: Re: Comments on VERSION-CONTROL", "content": "   From: Tim_Ellison@uk.ibm.com\n   Date: Mon, 5 Feb 2001 11:33:04 +0000\n\n\n\n   >>   Secondly, I agree that there are a number of\n   >>   places where the marshaling is underspecified\n   >>   with respect to (usually) error conditions\n   >>   (though in this case it is a 200 OK response).\n   >>   For example, in REPORT \"the response body MUST\n   >>   contain the requested report\" and \"The\n   >>   DAV:version-tree REPORT response body MUST be\n   >>   a DAV:multistatus XML element.\"\n   >\n   > I didn't quite follow your point here Tim ... could you restate\n   > or clarify?\n\n   Simply that when, say DAV:version-tree REPORT is in error, it returns an\n   extended status element body (contrary to \"The DAV:version-tree REPORT\n   response body MUST be a DAV:multistatus XML element.\")\n\nOK, I think I get it.  These statements should be qualified by \"if the\nrequest succeeds\".  Will this address your concern?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6464141"}, {"subject": "Re: OPTIONS and Depth (was: Re: Core versioning issues and nits", "content": "   From: Greg Stein <gstein@lyra.org>\n\n   On Sun, Feb 04, 2001 at 08:05:06PM -0500, Geoffrey M. Clemm wrote:\n   >...\n   > Now this is a good argument for turning the DAV:supported-method-set\n   > back into a property!  Which is what James Hunt has just asked us\n   > to do.  I asked him \"why\".  I think this is a pretty good answer.\n   > So I'd propose that we switch them back, based on this point that\n   > Lisa has made.\n\n   That doesn't make sense. You're always going to have a tension between\n   OPTIONS for capability discovery and PROPFIND/Depth: for discovery over a\n   set of resources. supported-xxx was moved to OPTIONS because that is where\n   discovery normally occurs.\n\nYes, there always is such a tension, but I think it is reasonable to\nmake the cut at \"information about just that resource\" and \"information\nabout the server that implements that resource\".  With this criterion,\nit is reasonable to marshal \"supported-xxx\" (which is about the\nparticular resource) as a property, as opposed to the \"xxx-collection-set\"\ninformation (which is about the server), which should continue\nto be marshalled as an OPTIONS response.\n\n   By your logic, we should move the DAV: header into properties.\n\nNo, because that is about the server, not just about the particular\nresource.\n\n   The right answer is to modify OPTIONS to allow a Depth: header value.\n\nWe could do that, but then to make sure that your PROPFIND and OPTIONS\nrequests are not out of synch, you'd have to Depth lock the resource\ntree (and it would be nice to not have to Depth lock the tree just to\nquery information about it).  In addition, a Depth header on \"server\nbased information\" is almost always redundant, since most of the\nresources will return exactly the same value.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6472701"}, {"subject": "Re: response body (was: Re: Comments on VERSION-CONTROL", "content": ">    >>   Secondly, I agree that there are a number of\n>    >>   places where the marshaling is underspecified\n>    >>   with respect to (usually) error conditions\n>    >>   (though in this case it is a 200 OK response).\n>    >>   For example, in REPORT \"the response body MUST\n>    >>   contain the requested report\" and \"The\n>    >>   DAV:version-tree REPORT response body MUST be\n>    >>   a DAV:multistatus XML element.\"\n>    >\n>    > I didn't quite follow your point here Tim ... could\n>    > you restate or clarify?\n>\n>    Simply that when, say DAV:version-tree REPORT is in\n>    error, it returns an extended status element body\n>    (contrary to \"The DAV:version-tree REPORT response\n>    body MUST be a DAV:multistatus XML element.\")\n>\n> OK, I think I get it.  These statements should be qualified\n> by \"if the request succeeds\".  Will this address your concern?\n\nI really wasn't that concerned<g>, I was acknowledging Juergen/James'\ncomments -- but yes, that would fix it.\n\nTim\n\n\n\n", "id": "lists-006-6482130"}, {"subject": "resource type/state (was: Re: Core versioning issues and nits", "content": ">    From: \"Lisa Dusseault\" <lisa@xythos.com>\n>\n>    > > 7) How do you distinguish between:\n>    > >  - A versionable resource\n>    > >  - A non-versionable resource\n>    > >  - A version-controlled resource\n>\n>    > A versionable resource will answer with (at least) Allow:\n>    > VERSION-CONTROL to an OPTIONS request, a non-versionable resource\n>    > will not.  A version-controlled resource is the only resource\n>    > with a DAV:checked-in or DAV:checked-out property.\n>\n>    > There was some debate a while ago about making the resource types\n>    > explicit, with various methods sugested.  I have to say that\n>    > determining type by the presence or absence of properties is\n>    > sub-optimal since, among other things, it makes for careful\n>    > consideration when defining new resources with overlapping\n>    > property names.\n>\n> One person's \"resource type\" is another persons \"resource state\".\n> Is \"checked-out\" a resource type or a resource state?  Is \"locked\"\n> a resource type or a resource state.  Is \"under version control\"\n> a resource type or a resource state. ...\n\nI'm not getting drawn into that one<g>\n\n> So either you need to carefully consider your choice of property\n> names (which you should do anyway), or carefully consider your\n> choice of \"resource type names\".\n\nI think the issue comes down to using the presence or absence of a property\nto define a resource type (to use the document's terminology), rather than\nusing a property's value.  Practically, it means issuing a PROPFIND and\ndiscarding some of the response and/or looking for errors.  This feels like\na secondary effect from the definition of those properties (although\nclearly it is a primary effect given that clients typically need to know\nthe resource type).\n\nI say property names should be chosen carefully since extensions may not be\nable to use the property names DAV:checked-out and DAV:checked-in without\nother properties that distinguish the resource type.\n\n>    I agree that determining type by the absence of properties is\n>    sub-optimal; I'd say it's not very reliable.\n>\n> How is it any less reliable than looking for a particular value\n> in a \"resourcetype\" property?\n\nI agree that Lisa's use of the word \"unreliable\" is incorrect here, but I'd\nsay that looking for a property value is more direct and extensible.\n\nTim\n\n\n\n", "id": "lists-006-6491039"}, {"subject": "Re: Complexity and Core Consideration", "content": "   From: \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n\n   > The first question is just an editorial question.  I would prefer to\n   > keep the versioning protocol as one document -- after all, when the\n   > first paragraph of the introductions says:\n   >\n   >   \"An implementor that is only interested in core versioning should read\n   >    Section I (Introduction), Section II (Core Versioning), and Section\n   >    15 (Report Option).\"\n   >\n   > is a reader really all that likely to be confused?\n\n   Yes, because in order to implement core, you also need to read, understand,\n   and subset the information in the security considerations, i18n, IANA\n   considerations, references, as well as understand and implement the error\n   reporting extensions listed in the appendix, so you can properly report\n   errors from VERSION-CONTROL.  And these are just the ones I can list from\n   memory.\n\nFirst, I agree that the \"core implementor should read ...\" should be\nfixed to say \"core implementor should not read the optional sections\nnumbered 3-14\", since I agree that a core implementor should read the\nsecurity etc. sections.\n\nBut let's look at Jim's key argument that a core reader would have to\nsubset the information in these sections.  I just reread the security,\ni18n, IANA considerations, and references sections, and the only part\nthat does not apply to core versioning is one sentence in the i18n\nsection that refers to labels.  So this means that these sections\nwould have to be replicated in full in two documents (I don't think\nthe IESG would allow us ommitting these sections in either of the\ndocuments).\n\nThis means that a diligent reader of both documents (and the majority\nof respondents so far have indicated they will be doing at least one\noption) would have to read all these sections twice, only to discover\nthat there is only one additional sentence in one of those sections.\nWe could warn them by adding a prefix to each section saying\n\"note: this is a copy of the same section in the core versioning\ndocument\", but that is only slightly less unappealing.\n\n   Plus, a core-only document would have a shorter introduction, and a\n   shorter definitions section, making it ever so easier to\n   understand.  A core-only document would also appear much less\n   intimidating, since, if printed double-sided, you could make a\n   working paper airplane out the stack of papers. :-)\n\nOnly a paragraph or two could be ommitted from the introduction\n(the semantics of the options appear in the options sections, not\nin the introduction).  Also the optional definitions section is clearly\nmarked as such, and I believe serves as a vital point of reference\nfor the majority of the readers who will care about at least one\nof the options. \n\nAs for the paper-airplane argument, a 40 page double sided document\nwill probably be the smallest versioning-related document that a\nversioning implementor has ever enountered (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6500716"}, {"subject": "Re: autoversion header (was: Re: DeltaV doesn't support a true client   workspace", "content": "   From: Tim_Ellison@uk.ibm.com\n\n   From Geoff:\n   > Everyone else: Do you think that the Autoversion\n   > header for PUT is of sufficient value to be worth\n   > putting into core?  It is a way for a versioning\n   > client to interact with a server like Chuck's\n   > without forcing his server to have every PUT to\n   > a version-controlled resource result in a new\n   > version.\n\n   No, please no more alternatives for, or combinations of, existing\n   functionality.\n\nTim makes a good point.  Since folks are already concerned about\ncomplexity and the number of options, we need to be very stringent\nabout requiring a high level of demonstrated need and support for any\nnew option or additional variation in an existing option.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6511064"}, {"subject": "Re: response body (was: Re: Comments on VERSION-CONTROL", "content": "   From: Tim_Ellison@uk.ibm.com\n\n   >    >>   Secondly, I agree that there are a number of\n   >    >>   places where the marshaling is underspecified\n   >    >>   with respect to (usually) error conditions\n   >    >>   (though in this case it is a 200 OK response).\n   >    >>   For example, in REPORT \"the response body MUST\n   >    >>   contain the requested report\" and \"The\n   >    >>   DAV:version-tree REPORT response body MUST be\n   >    >>   a DAV:multistatus XML element.\"\n   >    >\n   >    Simply that when, say DAV:version-tree REPORT is in\n   >    error, it returns an extended status element body\n   >    (contrary to \"The DAV:version-tree REPORT response\n   >    body MUST be a DAV:multistatus XML element.\")\n   >\n   > OK, I think I get it.  These statements should be qualified\n   > by \"if the request succeeds\".  Will this address your concern?\n\n   I really wasn't that concerned<g>, I was acknowledging Juergen/James'\n   comments -- but yes, that would fix it.\n\nOk, I'll make that fix.  It's really bad to have false statements\nin the protocol, even if there is a reasonable interpretation\nvery confusing to another.  I'll make this change to every\nmarshalling section.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6519385"}, {"subject": "draft-ietf-deltav-versioning-12.2 is now availabl", "content": "<http://www.webdav.org/deltav/protocol/draft-ietf-deltav-versioning-12.2.htm>\n\nThis contains all accepted changes from the working group last\ncall period.  All changes are enumerated in the final section\nof the document, as well as who requested the change.\n\nIf a change that you have requested has been accepted, please review\nthat section of the protocol to confirm that your issue has been\nacceptably addressed.\n\nThankyou to all the reviewers!\n\nI will submit this as the -13 draft tomorrow.\n\nAs a heads up, this Friday we will be having a conference call,\nand the subject is whether the document is ready to send to the\nIESG for \"proposed standard\" status (there will be an IESG last\ncall period at that point).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6528012"}, {"subject": "Re: WebDAV/DeltaV Interoperability and XML Validatio", "content": "   From: \"James J. Hunt\" <jjh@allerton.de>\n\n   The reasons for the concern over tags that are used both as empty\n   tags and as tag pairs (with or without content) were problems with\n   a earlier version of an XML parser that had problems with combining\n   both form and the following quote from the XML specification.\n\nI couldn't find any following quote ... did I miss it?\n\n   For interoperability, the empty-element tag should be used, and\n   should only be used, for elements which are declared EMPTY.\n\nI don't remember seeing that in the XML spec.  Which section is\nthat from?\n\n   Additionally, using tags both requires the use of ANY for dead\n   properties.  The current XML parser from sun can handle them, so I\n   can live with them.\n\nDoes that mean that you are OK with a property element being\noptionally empty?\n\n   P.S. I have yet to find a good solution for the display of version\n   graphs.  I have a few ideas.  Could we telephone?\n\nThis week is pretty packed for me, so email would probably be\nbetter (too many meetings :-).  Hopefully things will ease\nup at some point, but it's hard to predict when.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6535354"}, {"subject": "Re: DAV Versioning DTD", "content": "James and Juergen:\n\nThanks for all your hard work in the DTD area!\nIt looks below like you have uncovered some problems or \nambiguities in the protocol.  Even if we do not end up\nusing validating DTD's as our syntactic definition\nmechanism, any technique that uncovers a problem is\nof great value.\n\n   From: \"James J. Hunt\" <jjh@allerton.de>\n\n   The current definition of how errors are returned in DAV versioning is\n   incompatible with WebDAV.  I have made a change that should be help\n   there.\n\nThis should be fixed.  Could you describe how error returns in DAV\nversioning is incompatible with WebDAV?\n\n   The \"at most one of .... in any order \"is defined with an\n   arbitrary order here.  I will fix that as well, though it will not\n   pretty be pretty.   Please let me know if I have forgotten anything.\n\nWell, that's one of the concerns with using DTD's.  If something that\ncan easily and clearly be expressed in English (i.e. \"at most one\nof ... in any order\") requires a complex DTD, then the constraint\nmight be better expressed in English.\n\n   The DTD and two examples, which validate against the DTD using Sun's\n   latest XML parser, are included.   Can you easily send me the all\n   examples from the current draft or at least the draft as text?\n\nAll I've currently got (i.e. the latest .doc version and a generated html\nversion) are now up on the web site).  Anything you can do to clean\nup the examples would be great!  I've read them so many times that\nmy eyes just blur over when I try to read them again (:-).\n\n   The tags add, set, and remove as used in labels, must be renamed\n   because set and remove are already defined differently for\n   propertyupdate.\n\nThis is a key question.  We currently are using XML in argument lists.\nRequiring that a given element type have exactly one global definition\nis like saying that each function must have formal parameter names\nthat are different from every other formal parameter name of any other\ndefined function.  This is clearly a major constraint, and disallowing\nboth PROPPATCH and LABEL to use DAV:set is a good example of this.\n\nNow we could change to saying that there is a generic DAV:arg\nelement type, and have an attribute say what kind of arg it is,\nbut that would be inconsistent with the conventions of 2518.\n\nSo unfortunately, I believe you are going to have to provide some\ncompelling arguments for why XML validation matters in a WebDAV\ncontext (other than making it easier to proof check some of the\nsurface syntax of the examples :-).  Minimally, you will probably need\nto rebut the argument in my preceding message that there is no\ncompelling argument for XML validation by a WebDAV message processor.\nAs a reminder, this argument says that \"if XML validation succeeds, it\nhas no effect on processing of a message, and if XML validation fails,\nbut the message can be understood by the message processor, a\nforgiving message processor will go ahead and process the message\nanyway.\"  So given the cost of passing a DTD along with a message, or\nthe cost to a server of accessing any remote DTD that it doesn't have\ncached locally, I see no evidence that many server writers will bother\nwith validation, or care about the results even if they did validate.\n\n   I still believe that a complete DTD is helpful for people who have not\n   had a chance to sit in on all the DAV versioning discussions.  I find\n   the document to be too dependent on examples.  A DTD that is consistent\n   with the examples would help.\n\nPerhaps if you indicated the places where the XML value syntax in the\nversioning protocol is ambiguous or unclear, we could then decide if a\nDTD is the appropriate mechanism to clear it up.\n\n   P.S. An example of  our new proposal for expand-property with properties\n   as tags instead of attributes will be as follows:\n\n   <?xml version=3D\"1.0\" encoding=3D\"utf-8\" ?>\n   <!DOCTYPE DAV:webdav-1.0 SYSTEM\n   \"http://www.webdav.org/dtd/deltav-0.12.1.1.dtd\" !>\n   <expand-property xmlns=3D\"DAV:\">\n     <prop-apply>\n       <version-history/>\n       <prop-apply>\n <version-set/>\n <prop>\n   <creator-displayname/>\n   <activity-set/>\n </prop>\n       </prop-apply>\n     </prop-apply>\n   </expand-property>\n\nThis is certainly simpler than the attribute form, but it\nis still more complicated than what we have now.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-6544417"}, {"subject": "RE: Core versioning issues and nit", "content": "> This has probably been covered in the previous message on \"pass\n> through\" behavior, but just to make sure, if by a \"property that can\n> be considered to apply to the document as a whole, including all its\n> versions\" you mean a property that \"passes through\" to all its\n> versions, then, no, the protocol provides no such capability, in order\n> to prevent the complexities that caused us to give up on a direct\n> reference resource.\n\nNo, that's not what I mean.  I don't mean at all that the property\npasses through to the versions.  I mean that it is a property that is\nnot semantically sensible if you look at it on an individual version.\nE.g. \"Editor-in-Chief\", is a property which is likely to mean \"The\nperson who is editor-in-chief of this entire document, including all its\npast versions\".  I've called this a \"global\" property in another email.\n\n> You can use the DAV:expand-property report if you want to obtain\n> all this information in one request.\n\nNo, that's impossible for clients that are not versioning-aware.\n\nlisa\n\n\n\n", "id": "lists-006-6556553"}, {"subject": "RE: FW: DeltaV Passthrough issue", "content": "> Note: Lisa asks a bunch of great questions here.  They are all\n> good candidates for FAQ entries.  For the moment, I'll just\n> do the easy thing and answer them in email.  I'll try to get\n> this info transcribed to the FAQ.  If anyone else has a chance\n> to enter this information in the FAQ, that would be greatly\n> appreciated!\n\nTwo of the questions I asked so far seemed to be answered with simple\nclarifications.  I've added those to the FAQ.\n\nMany of the questions are NOT suitable for being answered in the FAQ.\nThey clearly ask for normative declarations (rather than unstated\nassumptions), which belong in the spec, or rewording of text in the\nspec.\n\n> But there is no \"implicit\" pass through by a version-controlled\n> resource.  This is explicitly stated in section 2.1.\n>\n>    To recap:  When new kinds of resources that have targets,\n>    like \"Direct Reference Resources\" or \"Version controlled Resources\"\n>    (DRR/VCR), are exposed to clients that are not familiar\n> with the new\n>    kinds of resources, it's often beneficial to allow some of\n> the methods\n>    the client may send to \"pass through\" to the target of DRR/VCR.\n>\n> A version-controlled resource does not have a \"target\".  We\n> explicitly got rid of this term because it was misleading people\n> into thinking just what you describe above.  Pass through behavior\n> only occurs when explicitly requested by a header, or when\n> explicitly defined in the semantics of a new method.\n\nI'd like to believe you ;) but the draft states:\n\n\"A PUT or PROPPATCH to a version-controlled resource with the\nDAV:auto-version property set will automatically check out that resource\nprior to executing the PUT or PROPPATCH.  If that resource is\nwrite-locked, the resource remains checked-out until the resource is\nunlocked, at which time the resource is checked in and a new version is\ncreated in the version history of that resource.\"\n\nThat to me is \"passthrough\", even without the label target, because it\nbypasses the content or properties of the VCR in order to create a new\nversion.  How am I supposed to change the properties of the VCR itself?\nThe previous paragraph states:\n\n\"In order to use methods like PUT and PROPPATCH to directly modify the\ncontent or dead properties of a version-controlled resource, the\nversion-controlled resource must first be checked out.  When the\nchecked-out resource is checked in, a new version is created in the\nversion history of that version-controlled resource.  The version that\nwas checked out is remembered as the predecessor of the new version.\"\n\nThat is unacceptable.  It's completely unacceptable to create a new\nversion of a resource, just in order to be able to modify a property\nlike 'Last-published-version' on the VCR.  For the sake of conciseness,\nlet's call this a \"global\" property: it applies to all versions, and\ncan't have different values on different versions.\n\nIn order to modify a global property, does a new version have to be\ncreated? Even though nothing changed on the old version? (the only\nchange, conceptually, is a dead property on the VCR).  If I understand\nthe model correctly, that won't work because the properties of a\nchecked-in VCR are the same as the properties of the checked-in version.\nSo global properties can't be placed on VCRs at all.\n\nWhere do global properties go, then? You state that rather than put\nglobal properties on the VCR, the client ought to put them on the VH:\n\n> It sounds like you're talking about properties on the version history\n> resource.  Your server of course must then support the version history\n> option, but then you PROPPATCH the version history resource\n> just as you\n> would PROPPATCH any other resource.\n\nThat's unacceptable.  First, as you point out, the server must support\nan extra resource, the VHR.  Then, in order to present a directory\nlisting with the value of a global property like\n\"Last-published-version\" for each of n VCRs in a directory, the client\nwould have to issue a depth:1 PROPFIND request to find all the URLs to\nthe VHRs, then issue n PROPFIND requests, one to each VHR independently,\nto get the values of \"Last-published-version\".\n\nHowever, the real showstopper is the lack of resource transparency.\nGlobal properties, like \"author\" from Dublin Core, or \"Editor-in-Chief\",\nare hidden away in VHRs.  That means that versioning-unaware clients\ncannot interoperate with versioning clients on the same set of\ndocuments.  They can't even PROPFIND a set of VCRs to get properties\nwhich ought to exist.\n\nlisa\n\n\n\n", "id": "lists-006-6564957"}, {"subject": "Re: Option abus", "content": "\"Geoffrey M. Clemm\" wrote:\n\n>\n> It really doesn't matter whether we marshall this as an OPTIONS call\n> or as a PROPFIND for a property.  This used to be marshalled as a\n> property but a reviewer pointed out that this information seemed more\n> like an option than a property.\n>\n> Can you give some motivation for switching this back to being a property?\n>\n> Cheers,\n> Geoff\n\nDear Geoff,\n\nMy understanding of an option is \"does the server support x\".  Properties\nassociate values to keys for a given resource.  Let us take\nDAV:workspace-collection-set.  Especially when you say that the http namespace\ncan be spread over several servers, the question I ask with this tag is not do\nyou support workspaces, rather for a given versionable workspace, where can I\ncreate a workspace for it?  In other words, I am asking what is the workspace\narea associated with this resource.  That seems to me to be a property of that\nresource, because every resource could answer it differently.\n\nSincerely,\nJames\n\n\n\n", "id": "lists-006-6576915"}, {"subject": "RE: Core versioning issues and nit", "content": ">\n>    I agree that determining type by the absence of properties is\n>    sub-optimal; I'd say it's not very reliable.\n>\n> How is it any less reliable than looking for a particular value\n> in a \"resourcetype\" property?\n\nA particular value on a particular property can be preserved even when\nthe protocol changes (whether the protocol is changing as a result of\nsanctioned IETF activity or independent vendor activity).  Also, a\nparticular value on a particular property is less likely to appear \"by\naccident\".\n\nIn contrast, the absence of a property is less likely to be preserved\nwhen extending the protocol: somebody will come up with a new useful\nvalue for the property, and break clients that relied on that property\nbeing absent.  Or, on an non-versioning server like IIS 5.0 that\nsupports dead properties, somebody could set the \"DAV:checked-in\"\nproperty to ANY value, and no matter what value it's set to, it risks\nbreaking clients that look for that property.\n\nI'm not saying this is broke (particularly if the DAV:supported-methods\ncomes back as a property).  It's just not as reliable as I would prefer.\n\nLisa\n\n\n\n", "id": "lists-006-6584823"}, {"subject": "RE: Core versioning issues and nit", "content": "> -----Original Message-----\n> On Behalf Of Geoffrey M. Clemm\n>\n>    > 10) Interactions between LOCK and VERSION-CONTROL\n>    >\n>    > State whether a locked resource can be placed under\n>    > version-control, and whether the lock-token must be supplied\n>    > with the VERSION-CONTROL method.\n>\n>    Sounds reasonable.\n>\n> Actually, the interaction between the versioning protocol and\n> the locking protocol is completely defined in 1.5.4, namely\n> that a property defined in the versioning protocol MUST NOT\n> be modified on a locked resource unless accompanied by a\n> valid lock token.  In particular, in this case, placing a\n> resource under version control adds a DAV:checked-in property\n> on that resource, which requires a lock token if the resource\n> is locked.\n>\n> This might be worth adding to the FAQ, but I don't want to\n> repeat this on every method that updates a property (which\n> most of them do).\n\nPlease look again.  Section 1.5.4 states:\n\"If a write-locked resource has a non-computed property defined by this\ndocument, the property value MUST NOT be changed by a request unless the\nappropriate lock token is included in the request.\"\n\nHow does this _completely_ _define_ the locking and VERSION-CONTROL\ninteractions?  It contradicts your explanation, since the draft\nexplicitly says \"non-computed property\", and your explanation includes\ncomputed properties set as a by-product of versioning methods!\n\nMore seriously, I'm starting to get very disturbed by the response\n\"we'll clarify in the FAQ\".  Delta-V is an internet-draft defining a\nprotocol for the purposes of interoperability.  It should therefore\nprovide a complete description of the protocol.  Once the protocol is\npublished we'll no doubt find under-specified areas and may need to\ndocument these in a FAQ until we can correct them in the transition to\nDraft. However, it seems like very bad policy to publish a draft that we\nknow to be incomplete or confusing with the intention to clarify it in a\nnon-normative non-archival document.\n\nLisa\n\n\n\n", "id": "lists-006-6593254"}, {"subject": "RE: properties of version histories (was: Re: Core versioning issues and nits", "content": "> >    Please resolve this.  Placing custom properties on the VHR is\n> >    unacceptable, because a VHR doesn't appear in regular\n> collections the\n> >    way a VCR does.  You would have to make one request to collection\n> >    '/lisa/' to find all the VCRs and all the URLs to the\n> VHRs, then make\n> >    'n' requests to all the VHR URLs to find the values of the custom\n> >    property.\n> >\n> > You can use the DAV:expand-property report if you want to obtain\n> > all this information in one request.\n>\n> Specifically, run the report using a Depth:1 on the VCR to\n> grab the VHR URL\n> and then the props of interest.\n>\n> N reports will be run and returned within the report body.\n>\n\nThis, also, is not possible for versioning-unaware clients.\n\nlisa\n\n\n\n", "id": "lists-006-6602507"}, {"subject": "RE: Complexity and Core Consideration", "content": "> 1) Is the current form of the specification too complex?\n> Yes/No/Maybe. Why?\n>\n\nYes.  The definitions are complex.  The language used is frequently too\ncomplex.\n\n> 2) Does there remain sufficient discussion going on surrounding\n> the OPTIONS that the draft should be split into two documents,\n> CORE and OPTIONS, so that we can move CORE forward?\n> Yes/No/Maybe.  Why?\n\nYes, core should be split out.  This would force the definitions used by\n'core' to be self-consistent even without the advanced options being\npresent.  This will improve readability and expand the potential\nreadership of the document.\n\nTim said:\n\n> The only arguments for splitting the document are editorial (i.e.,\n> readbility) and process (i.e., submit separately).\n\nThat's a straw man.  Another argument to split out is consistency.\nWhile it is possible for core to be self-consistent while it is part of\na larger draft, it seems difficult.\n\nAnother argument, related to readability is exposure/reach.  I believe\ndeltaV-core will get more exposure and more readers, thus more\ncomments/suggestions, and perhaps even more implementations, if it is\nbroken out and clearly expressed.\n\nRight now, I'm afraid that despite the stated intent of the authors to\nmake DeltaV suitable for document publishing purposes, the inclusion of\nso many specialiazed features and definitions will scare away document\npublishing implementors.  They'll start reading the document, see \"Fork,\nMerge\" in section 1.3, \"Workspace Resource\", \"Version-controlled\ncollection resource\" , \"Collection version resource\", \"configuration\",\n\"baseline\", \"activity\" and \"Variant\" in section 1.3.1, and be put off by\nthe perceived complexity.  That would be a shame.\n\nMy experience backs this up:  we have customers, some doing client work,\nwho are interested in doing document management with versioning, and\nthey haven't reviewed DeltaV because the task is so daunting.\n\nLisa\n\n\n\n", "id": "lists-006-6611114"}, {"subject": "RE: Labels and Statu", "content": "> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Greg Stein\n>\n> I think the point here is to have mutable properties (e.g.\n> \"status\") on\n> immutable resources (e.g. version resources). That doesn't\n> make sense to me\n> at all.\n\nI hope to make it make sense, then.  I think many processes, both in the\nsource-control world (building, testing) and the document-publishing\nworld (reviewing, approving), require mutable properties on immutable\nresources.\n\nExample 1 -- build process\n\nThe build process involves a nightly build with a build ID.\nTesters/coders want to be able to look at a version of a file, and see\nif it ever was successfully part of a build.  You would want to define a\nproperty like \"successful-build-set\".  If a particular version of a\nparticular resource is successfully built into build 1527, you add that\nvalue to the \"successful-build-set\" property of that version.  The next\nnight, the version doesn't change, but the build number is 1528, so now\nthe \"successful-build-set\" property should have two build IDs in its\nvalue, without having the version itself ever change.  The third night,\ncode is changed in that file, so a new version is created.  It\nsuccessfully builds into build #1529, so now on the _new_ version, the\n\"successful-build-set\" property has the value \"1529\".  The _old_ version\nstill has a value of \"1527, 1528\", for the same property.\n\nExample 2 -- document publishing\n\nIn a document publishing house, you want to keep track of which versions\nhave been reviewed and approved for publishing.  (You can't use LABEL\nbecause more than one version of a document may have been reviewed, and\nmore than one version may have been approved, and LABEL doesn't allow\nthe same value on different versions).  So you want to define a set of\nproperties:  \"reviewed-by\", \"reviewed-date\", \"review-status\",\n\"approved-by\" and \"approved-date\".  Each of these properties needs to be\nchanged, without creating new versions.  For example, the publishing\npolicy might change, and the reviewer needs to go back to a version that\nhad previously been marked \"review-status\" = \"NOT_APPROVED\" and change\nthe value to \"APPROVED\".  Or in a completlely normal process, the\nreviewer might want to mark \"reviewed-by\" as \"Joe Blow\", and\n\"review-status\" as \"RECOMMEND_APPROVAL\".  Then Joe's manager can go in\nand change \"review-status\" to \"APPROVED\" and also set the \"approved-by\"\nand \"approved-date\" properties accordingly.  All of these properties\nrefer to a specific version of the document, not to the document as a\nwhole.  None of these properties should ever force a new version to be\ncreated.\n\nSo my question is, where else, besides the versions themselves, are you\ngoing to set these properties?  I believe it does make sense to have\nmutable properties on immutable resources.  It is a matter of\nadministrator policy, more often than a matter of implementor policy.\n\nI can certainly understand the existence of systems where the model and\nprocesses are defined so that mutable properties are forbidden.\nHowever, that is an implementor choice which restricts administrator\npolicy.  In my implementation, we do not wish to restrict administrator\npolicy in that way.\n\nLisa\n\n\n\n", "id": "lists-006-6620724"}, {"subject": "Autoversion confusio", "content": "I have a question about DAV:auto-version \"when-locked\" value.  In my\nmodel of the way things work:\n\nOn a non-versioning server with a non-versioning client:\n - client issues LOCK on A\n - Lock-owner client issues PUT to A, creating the content A' (A-prime)\n - Any client issues GET to A, retrieving the content A'\n\nOn a versioning server with a non-versioning client, where resource A is\na VCR, which has DAV:auto-version equals \"when-locked\".\n - client issues LOCK on A, creating a checked-out version\n - Lock-owner client issues PUT to A, modifying the checked-out version\nto have the content A'\n - Any client issues a GET to A, which retreives the body of the VCR,\nwhich is the same as the body of the last checked-in version, which is\nNOT the content A'.\n\nSo, on a versioning server with DAV:auto-version set to \"when-locked\",\nclients cannot GET the latest content PUT by the lock-owner (without\nspecifying the version URL), until UNLOCK occurs and the version is\nchecked in.  This is inconsistent with the way a non-versioning server\nbehaves.\n\nI like the functionality this feature is supposed to provide, but is\nthere a way of resolving this discrepancy?  The problem may lie in the\nfact that the VCR is defined to have the same body and contents of the\nlast checked-in version, rather than the currently checked-out version.\n\nLisa\n\n\n\n", "id": "lists-006-6631953"}, {"subject": "RE: Labels and Statu", "content": "> I agree with the points Lisa makes below, but I believe this\n> kind of work should be done as a general WebDAV property\n> metadata effort (there are lots of interesting property\n> metadata information that you'd like to define and discover),\n> and not something embedded in the versioning protocol\n> (I'd say we've done more than our share by tackling the\n> \"report\" problem :-).\n\nI understand your reluctance to take this on, but I don't think the\nversioning protocol satisfies document publishing needs without the\nability to create custom mutable properties.\n\nWhat we've got in the draft so far, is the set of mutable properties\nwhich are needed for source-control systems, like \"Label-name-set\" and\nperhaps \"DAV:workspace\", and they are supposedly \"Calculated\"\nproperties.  Document publishing needs aren't met by the label option,\nand there seems to be no way of adding new mutable properties short of\npublishing an internet-draft.\n\nlisa\n\n\n\n", "id": "lists-006-6641559"}, {"subject": "RE: Core versioning issues and nit", "content": "If a resource doesn't have a URL, and can't be queried or seen or used,\nis it a resource?  If a tree falls in the forest, and nobody is there to\nhear it, does it make a sound?\n\nExistential questions aside, the proposed wording would be acceptable,\nbut a little confusing.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Geoffrey M.\n> Clemm\n> Sent: Sunday, February 04, 2001 5:31 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: Core versioning issues and nits\n>\n>\n>\n>    From: \"Lisa Dusseault\" <lisa@xythos.com>\n>    Date: Fri, 2 Feb 2001 12:09:49 -0800\n>\n>\n>    ... please modify section 2.4 to read something like:\n>\n>    \"If the request-URL identifies a versionable resource, a\n> new version\n>    history resource MAY be created.\"\n>\n> I agree this needs to be clarified, but I prefer JimW's wording: \"In\n> core versioning, a version history resource is not assigned a URL, and\n> hence is not visible in the http scheme URL space.\"\n>\n> This keeps the versioning model more consistent, since logically\n> there always is a version history which consists of all the\n> versions connected by predecessor relations.\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-6649390"}, {"subject": "RE: Core versioning issues and nit", "content": ">\n>    From: \"Lisa Dusseault\" <lisa@xythos.com>\n>\n>    In fact, it's not so much that that URLs are scarce, but\n> that good user\n>    interfaces are difficult.  How do I explain what URL namespaces are\n>    reserved for special-purpose resources like VRs, VHRs, or\n> (to take an\n>    example from another realm) principals?  At least you\n> could give me a\n>    good error message to return when users try to create new\n> resources or\n>    collections in reserved namespaces!\n>\n> I think that a 405 status return, along with an Allow header\n> indicating\n> what MKxxx method would succeed in this space (if any) gives you\n> all the information you can really use.\n\nHow about \"DAV:reserved-namespace\" as a status message, with 405 as the\nresponse code?\n\nlisa\n\n\n\n", "id": "lists-006-6659023"}, {"subject": "Re: DTD Confusio", "content": "Dear Goeff,\n\n\n>\n>    The tendency of the\n>    authors of the DeltaV document to write ANY in every place that one\n>    would like to be able to the protocol is both unnecessary and unhelpful.\n>\n> The purpose of ANY in the protocol usually indicates that there is\n> no DTD construct that usefully describes the syntactic constraints\n> on what elements can appear, and therefore those constraints are\n> described in English text.\n\nANY is needed for the case when the possible responses are not known in\nadvance.  This is the case with the content of dead properties.\n\n>\n>    In particular, a DTD is similar to a BNF for a language: a parser need\n>    not use the BNF directly to parse the language, but It still gives\n>    implementers a way of precisely describing the language.\n>\n> DTD's provide a very limited vocabulary for describing the syntax.\n> In the case of the versioning protocol, we mostly need the ability\n> to say \"at most one of each of the following element types can\n> appear, in any order\".  Unfortunately, there is no DTD construct\n> to express this, so we use (very) simple English text to describe\n> this constraint.\n\nAs long as the number of such options are finite, they can be described in\nDTD.  One must list all possible combinations.  It may not be pretty, but it\ndoes work.  Of course, if you mix such options with elements that can appear\nwithout limit on their number, one can not express it precisely with a DTD,\nbut then it is not a context free grammar.  You can not expect any reasonable\ngrammar to describe such a mixture exactly.  The other reasonable alternative\nis to specify the grammar without limit on occurrence, then define the\nbehavior so that only the first (or last) will have effect.\n\nExample\n\n<!ELEMENT foo ((A | B | C | D)*)>\n\nWith the description:  only at most one occurrence of  each of B and D are\nused; subsequent occurrence are to be ignored.  This is still more useful than\n\n<!ELEMENT foo ANY>\n\nwhich tells me absolutely nothing about what foo may contain.\n\n>\n>    Of course, this\n>    would be contrary to the spirit of this protocol.  However, validation\n>    does not work this way.  If a client sends a message based on a new DTD,\n>    it causes no problem.  The client must send a copy or a reference of the\n>    new DTD with its message.  The server has two choices: it may fetch the\n>    new DTD and validate against that DTD, or the server may simply check\n>    for well-formedness. In both cases, the server need not and should not\n>    reject the request, so long as the request matches the given DTD.  If it\n>    does not match, however, something is in fact wrong with the request.=20\n>    Even in this case, the server is still permitted to recover from the\n>    error.  The same applies in reverse for responses from the client.\n>\n> Yes, and this illustrates the very limited value of including a DTD\n> (or a reference to a DTD) in a message.  If the message is valid (wrt\n> the DTD), the DTD has no effect on how the message is processed.  If\n> the message isn't something the receiver can process, it will be\n> rejected whether it is valid or not.  So the only case where a DTD\n> matters is where the client can process the message, but it doesn't\n> match the DTD that was sent.  As you state above, the recipient may\n> well want to process the message anyway in this case, and ignore the\n> fact that the message didn't match the DTD that it came with.\n>\n\nWhen a message fails, it is helpful for debugging to know whether a valid\nmessage failed because it was not understood, or if a tag was present that is\nproprietary.   This can help when tracing interoperability problems between a\nclient and server from different vendors.\n\n>\n> Because of this, our implementations will not send DTD's (or references\n> to DTD's) with our messages, nor will we process any DTD's (or references\n> to DTD's) that are included.  What matters to us is whether we can\n> process the message, not whether it matches some DTD.\n>\n\nThis does not speak well for interoperability.\n\n>\n>    We opine that a client or a server should be able to send messages that\n>    conform to the DTD that it uses.   This does not inhibit communication\n>    with peers that use another version of the protocol.\n>\n> I agree, as long as we do not require that a DTD (or a reference to a DTD)\n> be sent, and we do not require that a DTD (or a reference to a DTD) be\n> processed by the receiver of the message.\n>\n\nI opine that the DTD helps one reason about the protocol.  It collects\neverything in one place, and helps eliminate duplications (like using the tags\nadd and remove for labels, when they are already define differently for\npropertyupdate).  The larger the protocol become, the more important it is.\n\nYou obviously disagree, but I think a defined grammar also makes it easier to\ndebug interoperability problems.\n\n>\n>    Each new version\n>    must have its own DTD, but this should be a good basis for understanding\n>    what the protocol actually is in any given version and how it changes\n>    from one version to the next.  A well designed DTD should also help\n>    insure that new version are, in fact, upwardly compatible.\n>\n> The fact that new variants are syntactically compatible with old\n> variants is rather trivial to verify, with or without the use of\n> DTD's.  The hard part is making sure that the semantics is upwardly\n> compatible.  But in any case, DTD's do not help when they do not have\n> the capability of describing the syntactic constraints of a particular\n> type of message (as is the case for the versioning messages).\n\nThis is only true if you can determine if a (foreign) client or server\nactually implements some interface.\n\n>\n> Cheers,\n> Geoff\n\nA better description language than DTD is certainly desirable, but DTD is not\nso useless that it is not worth using.\n\nSincerely,\nJames\n\n\n\n", "id": "lists-006-6667411"}, {"subject": "Re: WebDAV/DeltaV Interoperability and XML Validatio", "content": "Dear Geoff,\n\n\"Geoffrey M. Clemm\" wrote:\n\n>    From: \"James J. Hunt\" <jjh@allerton.de>\n>\n>    The reasons for the concern over tags that are used both as empty\n>    tags and as tag pairs (with or without content) were problems with\n>    a earlier version of an XML parser that had problems with combining\n>    both form and the following quote from the XML specification.\n>\n> I couldn't find any following quote ... did I miss it?\n>\n>    For interoperability, the empty-element tag should be used, and\n>    should only be used, for elements which are declared EMPTY.\n>\n> I don't remember seeing that in the XML spec.  Which section is\n> that from?\n\nIt is in section \"3.1 Start-Tags, End-Tags, and Empty-Element Tags\" under\nthe header \"Tags for Empty Elements\".\n\n>\n>\n>    Additionally, using tags both requires the use of ANY for dead\n>    properties.  The current XML parser from sun can handle them, so I\n>    can live with them.\n>\n> Does that mean that you are OK with a property element being\n> optionally empty?\n>\n\nGiven the above quote, I am not particularly happy with it, but I can\nlive with it.  The main problem I have is that any application can define\na new tags for a dead property and use it in prop.  This means\nthat prop can only be defined as any.  If we had a dead property element,\nI would be happier:\n\n       <!ELEMENT dead-prop ANY>\n        <!ATTLIST dead-prop name CDATA #REQUIRED>\n\nThat way, I could say useful things about structuring property in DTDs.\n\nSincerely,\nJames\n\n\n\n", "id": "lists-006-6680413"}, {"subject": "Re: Labels and Statu", "content": "Lisa Dusseault wrote:\n\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Greg Stein\n> >\n> > I think the point here is to have mutable properties (e.g.\n> > \"status\") on\n> > immutable resources (e.g. version resources). That doesn't\n> > make sense to me\n> > at all.\n>\n> I hope to make it make sense, then.  I think many processes, both in the\n> source-control world (building, testing) and the document-publishing\n> world (reviewing, approving), require mutable properties on immutable\n> resources.\n>\n> Example 1 -- build process\n>\n> The build process involves a nightly build with a build ID.\n> Testers/coders want to be able to look at a version of a file, and see\n> if it ever was successfully part of a build.  You would want to define a\n> property like \"successful-build-set\".  If a particular version of a\n> particular resource is successfully built into build 1527, you add that\n> value to the \"successful-build-set\" property of that version.  The next\n> night, the version doesn't change, but the build number is 1528, so now\n> the \"successful-build-set\" property should have two build IDs in its\n> value, without having the version itself ever change.  The third night,\n> code is changed in that file, so a new version is created.  It\n> successfully builds into build #1529, so now on the _new_ version, the\n> \"successful-build-set\" property has the value \"1529\".  The _old_ version\n> still has a value of \"1527, 1528\", for the same property.\n>\n> Example 2 -- document publishing\n>\n> In a document publishing house, you want to keep track of which versions\n> have been reviewed and approved for publishing.  (You can't use LABEL\n> because more than one version of a document may have been reviewed, and\n> more than one version may have been approved, and LABEL doesn't allow\n> the same value on different versions).  So you want to define a set of\n> properties:  \"reviewed-by\", \"reviewed-date\", \"review-status\",\n> \"approved-by\" and \"approved-date\".  Each of these properties needs to be\n> changed, without creating new versions.  For example, the publishing\n> policy might change, and the reviewer needs to go back to a version that\n> had previously been marked \"review-status\" = \"NOT_APPROVED\" and change\n> the value to \"APPROVED\".  Or in a completlely normal process, the\n> reviewer might want to mark \"reviewed-by\" as \"Joe Blow\", and\n> \"review-status\" as \"RECOMMEND_APPROVAL\".  Then Joe's manager can go in\n> and change \"review-status\" to \"APPROVED\" and also set the \"approved-by\"\n> and \"approved-date\" properties accordingly.  All of these properties\n> refer to a specific version of the document, not to the document as a\n> whole.  None of these properties should ever force a new version to be\n> created.\n>\n> So my question is, where else, besides the versions themselves, are you\n> going to set these properties?  I believe it does make sense to have\n> mutable properties on immutable resources.  It is a matter of\n> administrator policy, more often than a matter of implementor policy.\n>\n> I can certainly understand the existence of systems where the model and\n> processes are defined so that mutable properties are forbidden.\n> However, that is an implementor choice which restricts administrator\n> policy.  In my implementation, we do not wish to restrict administrator\n> policy in that way.\n>\n> Lisa\n\nDear Lisa,\n\nWell written!  A first stab at a general mechanism might be a\nDAV:mutable-property tag.\n\n<!ELEMENT mutable-property ANY>\n<!ATTLIST mutable-property name CDATA #REQUIRED>\n\nMutable properties are application defined properties on a version resource\nor version controlled resource with the following characteristics:\n\n   1. they can be changes at any time by a WebDAV client; and\n\n   2. they are cleared on a target version resource when that resource is\nchecked out.\n\nThis is certainly better than nothing, but three problems remain:\n\n  1. how can one trace who changed this property last;\n\n  2. how can access to such a property be controlled; and\n\n  3. how can standard mutable properties be defined later?\n\nSincerely,\nJames\n\n\n\n", "id": "lists-006-6689508"}, {"subject": "Re: DAV Versioning DTD", "content": "On Mon, Feb 05, 2001 at 04:21:11PM -0500, Geoffrey M. Clemm wrote:\n>...\n> As a reminder, this argument says that \"if XML validation succeeds, it\n> has no effect on processing of a message, and if XML validation fails,\n> but the message can be understood by the message processor, a\n> forgiving message processor will go ahead and process the message\n> anyway.\"\n\nAgreed!\n\n> So given the cost of passing a DTD along with a message, or\n> the cost to a server of accessing any remote DTD that it doesn't have\n> cached locally, I see no evidence that many server writers will bother\n> with validation, or care about the results even if they did validate.\n\nmod_dav (and, therefore, Apache 2.0 and later) will never do DTD validation\non the incoming requests. The XML is parsed (and checked that it is\nwell-formed), but the code that tears up the elements is more than\nsufficient for detecting improper usage / violations of the expected element\nconstruction. An XML validator won't assist that in any way.\n\nI'm still going to write code like:\n\n    /* get the label string */\n    if ((child = dav_find_child(elem, \"label-name\")) == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,\n              \"The label command element does not contain \"\n                      \"a \\\"label-name\\\" element.\");\n       return HTTP_BAD_REQUEST;\n    }\n\nWhy use a validator when an \"if\" command during processing does the same\nthing, and can give me a very nice error message?\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-6701899"}, {"subject": "Re: DAV Versioning DTD", "content": "Dear Geoff,\n\n\"Geoffrey M. Clemm\" wrote:\n\n> James and Juergen:\n>\n> Thanks for all your hard work in the DTD area!\n> It looks below like you have uncovered some problems or\n> ambiguities in the protocol.  Even if we do not end up\n> using validating DTD's as our syntactic definition\n> mechanism, any technique that uncovers a problem is\n> of great value.\n>\n>    From: \"James J. Hunt\" <jjh@allerton.de>\n>\n>    The current definition of how errors are returned in DAV versioning is\n>    incompatible with WebDAV.  I have made a change that should be help\n>    there.\n>\n> This should be fixed.  Could you describe how error returns in DAV\n> versioning is incompatible with WebDAV?\n\nSection 1.6, \"Response Bodies for 403 and 409 Status Responses,\" states the\nfollowing:\n\n  \"In a 207 Multi-Status response, this element would appear in the\nappropriate\n    DAV:response-description element\"\n\nDAV:response-description is defined as\n\n<!ELEMENT responsedescription (#PCDATA)>\n\nwhich is not a tag.\n\nThe solution is replace all occurrences of responsedescription with\n\n(responsedescription | error)\n\nwhere error is defined as\n\n<!ELEMENT error (user-defined-error |\n  put-under-version-control-error |\n  already-under-version-control-error |\n  cannot-modify-version-controlled-content-error |\n  cannot-modify-version-error |\n  cannot-modify-version-controlled-property-error |\n  cannot-modify-protected-property-error |\n  cannot-modify-unsupported-property-error |\n  auto-version-when-unlocked-error |\n  cannot-delete-root-version-error |\n  cannot-delete-referenced-version-error |\n  no-version-delete-error |\n  update-predecessor-set-error |\n  initialize-precursor-error |\n  auto-checkout-when-locked-error |\n  cannot-rename-resource-error |\n  preserve-history-error |\n  must-be-checked-in-error |\n  is-checked-out-error |\n  initialize-predecessor-set-error |\n  must-be-checked-out-error |\n  version-history-is-tree-error |\n  create-version-error |\n  initialize-version-content-and-properties-error |\n  checked-in-error |\n  keep-checked-out-error |\n  must-be-checked-out-version-controlled-resource-error |\n  cancel-checked-out-error |\n  restore-content-and-dead-properties-error |\n  must-be-checked-in-version-controlled-resource-error |\n  must-select-version-in-same-history-error |\n  update-content-and-dead-properties-error |\n  update-checked-in-property-error |\n  must-be-version-history-error |\n  delete-version-set-error |\n  cannot-copy-history-error |\n  new-version-history-error |\n  add-to-history-error |\n  create-working-resource-error |\n  create-working-resource-from-checked-in-version-error |\n  delete-working-resource-error |\n  resource-must-be-null-error |\n  workspace-location-ok-error |\n  initialize-workspace-error |\n  delete-workspace-members-error |\n  workspace-member-moved-error |\n  workspace-moved-error |\n  cannot-add-to-existing-history-error |\n  must-be-version-error |\n  one-version-controlled-resource-per-history-per-workspace-error |\n  new-version-controlled-resource-error |\n  cannot-merge-checked-out-resource-error |\n  checkout-not-allowed-error |\n  ancestor-version-error |\n  descendant-version-error |\n  checked-out-for-merge-error |\n  update-merge-set-error |\n  report-ignored-set-error |\n  report-properties-error |\n  delete-version-reference-error |\n  merge-must-be-complete-error |\n  must-not-be-checked-out-error |\n  must-be-new-label-error |\n  label-must-exist-error |\n  add-label-error |\n  remove-label-error |\n  must-not-have-label-and-apply-to-version-error |\n  depth-update-error |\n  version-controlled-configuration-must-be-empty-error |\n  must-be-baseline-error |\n  must-have-no-version-controlled-members-error |\n  one-baseline-controlled-collection-per-history-per-workspace-error |\n  create-version-controlled-configuration-error |\n  reference-version-controlled-configuration-error |\n  select-existing-baseline-error |\n  create-empty-baseline-error |\n  baselines-from-same-history-error |\n  no-checked-out-baseline-controlled-collection-members-error |\n  create-baseline-collection-error |\n  auto-baseline-error |\n  baseline-controlled-members-must-be-checked-in-error |\n  set-baseline-controlled-collection-members-error |\n  merge-baseline-error |\n  activity-location-ok-error |\n  initialize-activity-error |\n  must-be-activity-error |\n  delete-activity-reference-error |\n  update-checked-out-reference-error |\n  update-activity-reference-error |\n  update-workspace-reference-error |\n  one-checkout-per-activity-per-history-error |\n  linear-activity-error |\n  initialize-activity-set-error |\n  initialize-unreserved-error |\n  atomic-activity-checkin-error |\n  checkin-activity-error |\n  cannot-modify-checked-in-parent-error |\n  cannot-modify-destination-checked-in-parent-error |\n  initialize-version-history-bindings-error |\n  initialize-version-controlled-bindings-error |\n  version-control-working-collection-members-error |\n  update-version-controlled-collection-members-error |\n  checkout-of-version-with-descendant-is-forbidden-error |\n  checkout-of-version-with-descendant-is-discouraged-error |\n  checkout-of-checked-out-version-is-forbidden-error |\n  checkout-of-checked-out-version-is-discouraged-error |\n  checkin-fork-forbidden-error |\n  checkin-fork-discouraged-error |\n  cannot-delete-default-variant-error |\n  delete-variant-reference-error |\n  cannot-rename-variant-error |\n  variant-control-error |\n  create-new-variant-error |\n  delete-variant-predecessor-error |\n  must-select-variant-error |\n  update-default-variant-error |\n  update-variant-controlled-resource-error)> <!-- May be extended here -->\n\n<!ELEMENT user-defined-error ANY>            <!--- new!! -->\n\n>\n>\n>    The \"at most one of .... in any order \"is defined with an\n>    arbitrary order here.  I will fix that as well, though it will not\n>    pretty be pretty.   Please let me know if I have forgotten anything.\n>\n> Well, that's one of the concerns with using DTD's.  If something that\n> can easily and clearly be expressed in English (i.e. \"at most one\n> of ... in any order\") requires a complex DTD, then the constraint\n> might be better expressed in English.\n>\n\nOne could do both!   One could also weaken the requirement so that it could be\nexpressed with * and write something like \"tag foo should occur at most once;\nadditional occurrences should be ignored.\"\nNote that with boolean tags, there is no difference between one occurrence and\nn occurrences: on is on.\n\n>\n>    The DTD and two examples, which validate against the DTD using Sun's\n>    latest XML parser, are included.   Can you easily send me the all\n>    examples from the current draft or at least the draft as text?\n>\n> All I've currently got (i.e. the latest .doc version and a generated html\n> version) are now up on the web site).  Anything you can do to clean\n> up the examples would be great!  I've read them so many times that\n> my eyes just blur over when I try to read them again (:-).\n\nA pure text version of the spec would help.  MS Word leaves too much junk in\nthe HTML.\n\nThis only makes sense if we can agree that a DTD for this protocol should be\nincluded in the document and the DTD is definitive (aside from the at most\nonce issue) .\n\n>\n>\n>    The tags add, set, and remove as used in labels, must be renamed\n>    because set and remove are already defined differently for\n>    propertyupdate.\n>\n> This is a key question.  We currently are using XML in argument lists.\n> Requiring that a given element type have exactly one global definition\n> is like saying that each function must have formal parameter names\n> that are different from every other formal parameter name of any other\n> defined function.  This is clearly a major constraint, and disallowing\n> both PROPPATCH and LABEL to use DAV:set is a good example of this.\n\nThis is an unfortunate, but not over burdening restriction.\n\n>\n>\n> Now we could change to saying that there is a generic DAV:arg\n> element type, and have an attribute say what kind of arg it is,\n> but that would be inconsistent with the conventions of 2518.\n>\n> So unfortunately, I believe you are going to have to provide some\n> compelling arguments for why XML validation matters in a WebDAV\n> context (other than making it easier to proof check some of the\n> surface syntax of the examples :-).  Minimally, you will probably need\n> to rebut the argument in my preceding message that there is no\n> compelling argument for XML validation by a WebDAV message processor.\n> As a reminder, this argument says that \"if XML validation succeeds, it\n> has no effect on processing of a message, and if XML validation fails,\n> but the message can be understood by the message processor, a\n> forgiving message processor will go ahead and process the message\n> anyway.\"  So given the cost of passing a DTD along with a message, or\n> the cost to a server of accessing any remote DTD that it doesn't have\n> cached locally, I see no evidence that many server writers will bother\n> with validation, or care about the results even if they did validate.\n\nSee previous message, but testing during implementation is another example of\nwhere a DTD can be useful.  There may be good reasons why one would not wish\nto do verification in a production system, but a DTD is a formal specification\nthat one can verify against.  It will not catch all errors, but it can catch\nmany stupid, annoying ones.\n\n>\n>\n>    I still believe that a complete DTD is helpful for people who have not\n>    had a chance to sit in on all the DAV versioning discussions.  I find\n>    the document to be too dependent on examples.  A DTD that is consistent\n>    with the examples would help.\n>\n> Perhaps if you indicated the places where the XML value syntax in the\n> versioning protocol is ambiguous or unclear, we could then decide if a\n> DTD is the appropriate mechanism to clear it up.\n\nEverywhere that ANY is used.  For instance, if I want to know what parameters\ncheckout can take, I have to examine the entire document.  A good DTD at the\nend would help a lot.\n\n>\n>\n>    P.S. An example of  our new proposal for expand-property with properties\n>    as tags instead of attributes will be as follows:\n>\n>    <?xml version=3D\"1.0\" encoding=3D\"utf-8\" ?>\n>    <!DOCTYPE DAV:webdav-1.0 SYSTEM\n>    \"http://www.webdav.org/dtd/deltav-0.12.1.1.dtd\" !>\n>    <expand-property xmlns=3D\"DAV:\">\n>      <prop-apply>\n>        <version-history/>\n>        <prop-apply>\n>          <version-set/>\n>          <prop>\n>            <creator-displayname/>\n>            <activity-set/>\n>          </prop>\n>        </prop-apply>\n>      </prop-apply>\n>    </expand-property>\n>\n> This is certainly simpler than the attribute form, but it\n> is still more complicated than what we have now.\n\nIt makes the structure obvious, instead of relying on the fact that prop is\ndefined as ANY.  I can make the structure clear with a relatively concise\nDTD.  I will send a new full example using tags for properties along with the\ncorresponding DTD.\n\n>\n> Cheers,\n> Geoff\n\nSincerely,\nJames\n\nP.S. I took the liberty of adding -error to the end of all error tags.  This\nhelps avoid tag conflicts and makes the tag more obviously an error message.\n\nP.P.S. As a boolean tag in checkout unreserved is okay, but as an attribute\nthat can be true or false, I find reserved to be a better name.  Reserved\n= true makes more immediate sense than unreserved = true.\n\nP.P.P.S.  It would be nice to have a boolean tag for this, instead of PCDATA.\nHow about\n\n<!ELEMENT boolean EMPTY>\n<!ATTLIST value (true | false) #REQUIRED>\n\n\n\n", "id": "lists-006-6710150"}, {"subject": "Re: Complexity and Core Consideration", "content": "Lisa Dusseault wrote:\n\n> > 1) Is the current form of the specification too complex?\n> > Yes/No/Maybe. Why?\n> >\n>\n> Yes.  The definitions are complex.  The language used is frequently too\n> complex.\n>\n> > 2) Does there remain sufficient discussion going on surrounding\n> > the OPTIONS that the draft should be split into two documents,\n> > CORE and OPTIONS, so that we can move CORE forward?\n> > Yes/No/Maybe.  Why?\n>\n> Yes, core should be split out.  This would force the definitions used by\n> 'core' to be self-consistent even without the advanced options being\n> present.  This will improve readability and expand the potential\n> readership of the document.\n>\n> Tim said:\n>\n> > The only arguments for splitting the document are editorial (i.e.,\n> > readbility) and process (i.e., submit separately).\n>\n> That's a straw man.  Another argument to split out is consistency.\n> While it is possible for core to be self-consistent while it is part of\n> a larger draft, it seems difficult.\n>\n> Another argument, related to readability is exposure/reach.  I believe\n> deltaV-core will get more exposure and more readers, thus more\n> comments/suggestions, and perhaps even more implementations, if it is\n> broken out and clearly expressed.\n>\n> Right now, I'm afraid that despite the stated intent of the authors to\n> make DeltaV suitable for document publishing purposes, the inclusion of\n> so many specialiazed features and definitions will scare away document\n> publishing implementors.  They'll start reading the document, see \"Fork,\n> Merge\" in section 1.3, \"Workspace Resource\", \"Version-controlled\n> collection resource\" , \"Collection version resource\", \"configuration\",\n> \"baseline\", \"activity\" and \"Variant\" in section 1.3.1, and be put off by\n> the perceived complexity.  That would be a shame.\n>\n> My experience backs this up:  we have customers, some doing client work,\n> who are interested in doing document management with versioning, and\n> they haven't reviewed DeltaV because the task is so daunting.\n>\n> Lisa\n\nDear Colleagues,\n\nLisa has a good point about the complexity being daunting, but I disagree\nwith the remedy.  This is a point were a good introduction could help.  I\ntried to take a stab at this but was shot down.  My intent was to give the\nreader a bit of motivation about the structure of the document.  The read\nshould be given some feeling up front, about what parts of the document\nneed to be studied to support document management, file based revision\ncontrol, and configuration management, as well as some indication as to the\nchoices about client vs server managed work areas.  Perhaps someone else\ncould take a shot at it.\n\nSincerely,\nJames\n\n\n\n", "id": "lists-006-6729380"}, {"subject": "New DAV Versioning DTD", "content": "Dear Geoff,\n\nHere is the rework of the DTD to use attributes.  It is now completely upward\ncompatible to WebDAV and fixes the error bug.  Four verified examples are\nincluded.\n\n\nSection 2.2.3 and 2.2.4: Changed supported-xxx back to be properties (James)\n\nThis is backwards from what I asked for xxx-collection-set should be changed\nto properties, not supported-xxxx.\n\nPlease take a close look at the options and options-response definition.\n\nSincerely,\nJames\n\n\n\n<!--============ Root Elements ==================\n                  propfind\n                  propertyupdate\n                  propertybehavior\n                  multistatus\n                  prop\n                  lockinfo\n                  version-tree\n                  expand-property\n                  options\n                  options-response\n                  options-value\n                  collection-set-value\n                  checkout\n                  checkin\n                  update\n                  locate-history\n                  version-control\n                  merge\n                  merge-preview\n                  label\n                  baseline-control\n                  baseline\n                  baseline-comparision\n                  latest-activity-version\n                  checkout-fork\n                  checkin-fork\n                  merge-response\n                  merge-preview-response\n                  baseline-comparision-report\n                  latest-activity-version-report\n                  error\n    ============ End Root Elements ==================-->\n\n<!--============ Top Level DAV Requests ==================-->\n<!ELEMENT propfind (allprop | propname | prop)>\n<!ATTLIST propfind xmlns CDATA #IMPLIED>\n\n<!ELEMENT allprop EMPTY>\n<!ATTLIST allprop xmlns CDATA #IMPLIED>\n<!ELEMENT propname EMPTY>\n<!ATTLIST propname xmlns CDATA #IMPLIED>\n\n<!ELEMENT propertyupdate (remove | set)+>\n<!ATTLIST propertyupdate xmlns CDATA #IMPLIED>\n<!ELEMENT remove (prop)>\n<!ELEMENT set (prop)>\n\n<!ELEMENT propertybehavior (omit | keepalive)>\n<!ATTLIST propertybehavior xmlns CDATA #IMPLIED>\n<!ELEMENT omit EMPTY>\n<!ELEMENT keepalive (#PCDATA | href)*>\n\n<!--============ Top Level DAV Responses ==================-->\n\n<!ELEMENT multistatus (response+, (responsedescription | error)?)>\n<!ATTLIST multistatus xmlns CDATA #IMPLIED>\n<!ELEMENT response (href, ((href*, status)|(propstat+)),\n                        (responsedescription |\n                         error)?)>                       <!-- added! -->\n<!ELEMENT propstat ((prop | multiprop), status,\n                    (responsedescription | error)?)> <!-- expanded -->\n<!ELEMENT status (#PCDATA)>\n<!ELEMENT responsedescription (#PCDATA)>\n\n<!ELEMENT prop ANY>         <!-- ANY == (\"property-tag\" | multiprop)* -->\n<!ATTLIST prop xmlns CDATA #IMPLIED>\n\n<!ELEMENT lockinfo (lockscope, locktype, owner?)>\n<!ATTLIST lockinfo xmlns CDATA #IMPLIED>\n<!ELEMENT locktype (write)>\n<!ELEMENT write EMPTY>\n\n<!--============ Additional XML Elements from Section 12 ==================-->\n\n<!ELEMENT lockscope (exclusive | shared)>\n<!ELEMENT exclusive EMPTY>\n<!ELEMENT shared EMPTY>\n\n<!ELEMENT owner ANY>\n\n<!ELEMENT href (#PCDATA)>\n\n<!--=========== Property Values ===============-->\n<!--=========== Value for DAV:resourcetype ===============-->\n<!ELEMENT collection EMPTY>\n\n<!--=========== Value for DAV:lockdiscovery ===============-->\n<!ELEMENT activelock (lockscope, locktype, depth,\n                          owner?, timeout?, locktoken?)>\n<!ELEMENT depth (#PCDATA)>\n<!ELEMENT timeout (#PCDATA)>\n<!ELEMENT locktoken (href+)>\n\n<!--=========== Value for DAV:source ===============-->\n<!ELEMENT link (src+, dst+)>\n<!ELEMENT dst (#PCDATA)>\n<!ELEMENT src (#PCDATA)>\n\n<!--=========== Value for DAV:supportedlocks ===============-->\n<!ELEMENT lockentry (lockscope, locktype)>\n\n<!--=========== WebDAV defined properties ===============\n<!ELEMENT creationdate       (#PCDATA)>\n<!ELEMENT displayname        (#PCDATA)>\n<!ELEMENT getcontentlanguage (#PCDATA)>\n<!ELEMENT getcontentlength   (#PCDATA)>\n<!ELEMENT getcontenttype     (#PCDATA)>\n<!ELEMENT getetag            (#PCDATA)>\n<!ELEMENT getlastmodified    (#PCDATA)>\n<!ELEMENT lockdiscovery      (activelock)*>\n<!ELEMENT resourcetype       ANY>\n<!ELEMENT source             (link)*>\n<!ELEMENT supportedlock      (lockentry)*>\n    ====================================================-->\n\n<!--=========== Top Level DeltaV core Requests ===============-->\n<!ELEMENT version-tree (prop?)>\n<!ATTLIST version-tree xmlns CDATA #IMPLIED>\n\n<!ELEMENT expand-property (prop-apply*)>\n<!ATTLIST expand-property xmlns CDATA #IMPLIED>\n<!ELEMENT prop-apply\n ((link | \n   checked-in |\n   checked-out |\n   predecessor-set |\n   precursor-set |\n   predecessor-set |\n   successor-set |\n   checkout-set |\n   precursor-set |\n   version-set |\n   root-version |\n   version-history |\n   workspace-checkout-set |\n   workspace |\n   merge-set |\n   auto-merge-set |\n   baseline-controlled-collection |\n   subbaseline-set |\n   baseline-collection |\n   baseline-selector |\n   baseline-controlled-collection-set |\n   activity-version-set |\n   activity-checkout-set |\n   subactivity-set |\n   current-workspace-set |\n   activity-set |\n   current-activity-set |\n   eclipse-set |\n   variant-set |\n   default-variant),\n  (prop | prop-apply)*)>\n\n<!ELEMENT options ((supported-method-set |\n                    supported-report-set |\n                    supported-live-property-set)*)> <!-- modified -->\n<!ATTLIST options xmlns CDATA #IMPLIED>\n<!ELEMENT supported-method-set (supported-method*)>\n<!ELEMENT supported-method EMPTY>\n<!ATTLIST supported-method\n name\n (propfind |\n  propertyupdate |\n  propertybehavior |\n  lockinfo |\n  expand-property |\n  options |\n  checkout |\n  checkin |\n  update |\n  locate-history |\n  version-control |\n  merge |\n  merge-preview |\n  label |\n  baseline-control |\n  baseline |\n  baseline-comparision |\n  latest-activity-version |\n  checkout-fork |\n  checkin-fork)\n #REQUIRED>\n\n<!ELEMENT supported-report-set (supported-report*)>\n<!ELEMENT supported-report EMPTY>\n<!ATTLIST supported-report name\n (version-tree | baseline-comparision-report | latest-activity-version-report)\n #REQUIRED>\n\n<!ELEMENT supported-live-property-set (supported-live-property*)>\n<!ELEMENT supported-live-property ANY>\n\n<!ELEMENT versionable-resource-collection-set (href*)>\n<!ELEMENT version-history-collection-set (href*)>\n<!ELEMENT workspace-collection-set (href*)>\n<!ELEMENT activity-collection-set (href*)>\n\n<!--=========== Top Level DeltaV core Responses ===============-->\n\n<!ELEMENT options-response ((supported-methods-set |\n                             supported-report-set |\n                             supported-live-property-set)*)> <!-- modified -->\n<!ATTLIST options-response xmlns CDATA #IMPLIED>\n\n<!--=========== WebDAV defined core properties ===============\n<!ELEMENT checked-in              (href?)>\n<!ELEMENT checked-out             (href?)>\n<!ELEMENT predecessor-set         (href*)>\n<!ELEMENT precursor-set           (href*)>\n<!ELEMENT auto-version            ((when-unlocked?, when-locked?) |\n                                   (when-locked?, when-unlocked?))>\n<!ELEMENT predecessor-set         (href*)>\n<!ELEMENT successor-set           (href*)>\n<!ELEMENT checkout-set            (href*)>\n<!ELEMENT version-name            (#PCDATA)>\n<!ELEMENT precursor-set           (href*)>\n<!ELEMENT version-control         (already-version-controlled?)>\n\n    ====================================================-->\n<!ELEMENT when-unlocked EMPTY>\n<!ELEMENT when-locked EMPTY>\n<!ELEMENT already-version-controlled EMPTY>\n\n<!--=========== Top Level DeltaV optional Requests ===============-->\n<!ELEMENT checkout\n (activity-set? | apply-to-version? |\n  unreserved? | fork-ok?)>           <!-- May be extended here -->\n<!ATTLIST checkout xmlns CDATA #IMPLIED>\n<!ELEMENT avtivity-set (href+ | new)>\n<!ELEMENT new EMPTY>\n<!ELEMENT unreserved EMPTY>\n\n<!ELEMENT checkin (keep-check-out?)> <!-- May be extended here -->\n<!ATTLIST checkin xmlns CDATA #IMPLIED>\n<!ELEMENT keep-checked-out EMPTY>\n\n<!ELEMENT update\n ((version? | label-name? | variant?),\n  fork-ok?)>                            <!-- May be extended here -->\n<!ATTLIST update xmlns CDATA #IMPLIED>\n<!ELEMENT variant (href)>\n\n<!ELEMENT locate-history (version-history-set, prop)>\n<!ATTLIST locate-history xmlns CDATA #IMPLIED>\n<!ELEMENT version-history-set (href+)>\n\n<!ELEMENT version-control\n (version?, variant-control?)>           <!-- May be extended here -->\n<!ATTLIST version-control xmlns CDATA #IMPLIED>\n<!ELEMENT variant-control EMPTY>\n\n<!ELEMENT merge (source, no-auto-merge?, no-checkout?,\n                     apply-to-version?, fork-ok?,\n                     prop?)>              <!-- May be extended here -->\n<!ATTLIST merge xmlns CDATA #IMPLIED>\n<!ELEMENT no-auto-merge EMPTY>\n<!ELEMENT no-checkout EMPTY>\n\n<!ELEMENT merge-preview (source)>\n<!ATTLIST merge-preview xmlns CDATA #IMPLIED>\n\n<!ELEMENT label (add-label | set-label | remove-label)>\n<!ATTLIST label xmlns CDATA #IMPLIED>\n<!ELEMENT add-label (label-name)>     <!-- Renamed from add -->\n<!ELEMENT set-label (label-name)>     <!-- Renamed from set -->\n<!ELEMENT remove-label (label-name)>  <!-- Renamed from remove -->\n\n<!ELEMENT baseline-control (baseline?)><!-- May be extended here -->\n<!ATTLIST baseline-control xmlns CDATA #IMPLIED>\n\n<!ELEMENT baseline (href)>\n<!ATTLIST baseline xmlns CDATA #IMPLIED>\n\n<!ELEMENT baseline-comparision (href)>\n<!ATTLIST baseline-comparision xmlns CDATA #IMPLIED>\n\n<!ELEMENT latest-activity-version (href)>\n<!ATTLIST latest-activity-version xmlns CDATA #IMPLIED>\n\n<!ELEMENT checkout-fork\n (ok | discouraged | forbidden)?> <!-- May be extended here -->\n<!ATTLIST checkout-fork xmlns CDATA #IMPLIED>\n\n<!ELEMENT checkin-fork\n (ok | discouraged | forbidden)?> <!-- May be extended here -->\n<!ATTLIST checkin-fork xmlns CDATA #IMPLIED>\n\n<!--=========== Top Level DeltaV optional Responses ===============-->\n<!ELEMENT merge-response\n (update-set?, merged-set?,\n  ignored-set)?>                          <!-- May be extended here -->\n<!ATTLIST merge-response xmlns CDATA #IMPLIED>\n<!ELEMENT updated-set (response+)>\n<!ELEMENT merged-set (response+)>\n<!ELEMENT ignored-set (href+)>\n\n<!ELEMENT merge-preview-response\n (update-preview | conflict |\n  ignored-preview)*>                      <!-- was ignore-preview -->\n<!ATTLIST merge-preview-response xmlns CDATA #IMPLIED>\n<!ELEMENT update-preview (target, version)>\n<!ELEMENT conflict (target, common-ancestor, version)>\n<!ELEMENT target (href)>\n<!ELEMENT common-ancestor (href)>\n<!ELEMENT ignored-preview (version)>  <!-- should be href -->\n\n<!ELEMENT baseline-comparision-report\n (added-version | deleted-version | changed-version)*>\n<!ATTLIST baseline-comparision-report xmlns CDATA #IMPLIED>\n<!ELEMENT added-version (href)>\n<!ELEMENT deleted-version (href)>\n<!ELEMENT changed-version (href, href)>\n\n<!ELEMENT latest-activity-version-report (href)>\n<!ATTLIST latest-activity-version-report xmlns CDATA #IMPLIED>\n\n<!--=========== DeltaV Optional Extensions ===============-->\n<!ELEMENT apply-to-version EMPTY>\n\n<!--=========== DeltaV Common Elements ===============-->\n<!ELEMENT version (href)>\n\n<!ELEMENT label-name (#PCDATA)>\n\n<!ELEMENT fork-ok EMPTY>\n\n<!ELEMENT source (href)>\n\n<!ELEMENT ok EMPTY>\n<!ELEMENT discouraged EMPTY>\n<!ELEMENT forbidden EMPTY>\n\n<!--=========== DeltaV Extensions to DAV:Prop ===============-->\n\n<!ELEMENT multiprop\n ((link | \n   checked-in |\n   checked-out |\n   predecessor-set |\n   precursor-set |\n   predecessor-set |\n   successor-set |\n   checkout-set |\n   precursor-set |\n   version-set |\n   root-version |\n   version-history |\n   workspace-checkout-set |\n   workspace |\n   merge-set |\n   auto-merge-set |\n   baseline-controlled-collection |\n   subbaseline-set |\n   baseline-collection |\n   baseline-selector |\n   baseline-controlled-collection-set |\n   activity-version-set |\n   activity-checkout-set |\n   subactivity-set |\n   current-workspace-set |\n   activity-set |\n   current-activity-set |\n   eclipse-set |\n   variant-set |\n   default-variant),\n   (response+))>                                         <!--- new!! -->\n\n<!--=========== Property Values ===============-->\n<!--=========== Value for DAV:resourcetype ===============-->\n<!ELEMENT history EMPTY>\n\n<!ELEMENT version-controlled-binding\n (binding-name, version-history)>\n<!ELEMENT binding-name (#PCDATA)>\n\n<!ELEMENT string (#PCDATA)>\n<!ELEMENT name (#PCDATA)>\n\n<!--=========== WebDAV defined optional properties ===============-->\n<!ELEMENT version-set                        (href*)>\n<!ELEMENT root-version                       (href?)>\n<!ELEMENT version-history                    (href?)>\n<!ELEMENT workspace-checkout-set             (href*)>\n<!ELEMENT workspace                          (href?)>\n<!ELEMENT merge-set                          (href*)>\n<!ELEMENT auto-merge-set                     (href*)>\n<!ELEMENT baseline-controlled-collection     (href)>\n<!ELEMENT subbaseline-set                    (href*)>\n<!ELEMENT baseline-collection                (href)>\n<!ELEMENT baseline-selector                  (href)>\n<!ELEMENT baseline-controlled-collection-set (href*)>\n<!ELEMENT activity-version-set               (href*)>\n<!ELEMENT activity-checkout-set              (href*)>\n<!ELEMENT subactivity-set                    (href*)>\n<!ELEMENT current-workspace-set              (href*)>\n<!ELEMENT activity-set                       (href*)>\n<!ELEMENT reserved                           (#PCDATA)> <!-- was unreserved -->\n<!ELEMENT current-activity-set               (href*)>\n<!ELEMENT version-controlled-binding-set     (version-controlled-binding*)>\n<!ELEMENT eclipse-set                        (href*)>\n<!ELEMENT variant-set                        (href*)>\n<!ELEMENT default-variant                    (href?)>\n<!ELEMENT comment                            (string*)>\n<!ELEMENT creator-displayname                (name*)>\n<!--====================================================-->\n<!--================ DeltaV errors =====================-->\n<!--- new!! -->\n<!ELEMENT error (user-defined-error |\n  put-under-version-control-error |\n  already-under-version-control-error |\n  cannot-modify-version-controlled-content-error |\n  cannot-modify-version-error |\n  cannot-modify-version-controlled-property-error |\n  cannot-modify-protected-property-error |\n  cannot-modify-unsupported-property-error |\n  auto-version-when-unlocked-error |\n  cannot-delete-root-version-error |\n  cannot-delete-referenced-version-error |\n  no-version-delete-error |\n  update-predecessor-set-error |\n  initialize-precursor-error |\n  auto-checkout-when-locked-error |\n  cannot-rename-resource-error |\n  preserve-history-error |\n  must-be-checked-in-error |\n  is-checked-out-error |\n  initialize-predecessor-set-error |\n  must-be-checked-out-error |\n  version-history-is-tree-error |\n  create-version-error |\n  initialize-version-content-and-properties-error |\n  checked-in-error |\n  keep-checked-out-error |\n  must-be-checked-out-version-controlled-resource-error |\n  cancel-checked-out-error |\n  restore-content-and-dead-properties-error |\n  must-be-checked-in-version-controlled-resource-error |\n  must-select-version-in-same-history-error |\n  update-content-and-dead-properties-error |\n  update-checked-in-property-error |\n  must-be-version-history-error |\n  delete-version-set-error |\n  cannot-copy-history-error |\n  new-version-history-error |\n  add-to-history-error |\n  create-working-resource-error |\n  create-working-resource-from-checked-in-version-error |\n  delete-working-resource-error |\n  resource-must-be-null-error |\n  workspace-location-ok-error |\n  initialize-workspace-error |\n  delete-workspace-members-error |\n  workspace-member-moved-error |\n  workspace-moved-error |\n  cannot-add-to-existing-history-error |\n  must-be-version-error |\n  one-version-controlled-resource-per-history-per-workspace-error |\n  new-version-controlled-resource-error |\n  cannot-merge-checked-out-resource-error |\n  checkout-not-allowed-error |\n  ancestor-version-error |\n  descendant-version-error |\n  checked-out-for-merge-error |\n  update-merge-set-error |\n  report-ignored-set-error |\n  report-properties-error |\n  delete-version-reference-error |\n  merge-must-be-complete-error |\n  must-not-be-checked-out-error |\n  must-be-new-label-error |\n  label-must-exist-error |\n  add-label-error |\n  remove-label-error |\n  must-not-have-label-and-apply-to-version-error |\n  depth-update-error |\n  version-controlled-configuration-must-be-empty-error |\n  must-be-baseline-error |\n  must-have-no-version-controlled-members-error |\n  one-baseline-controlled-collection-per-history-per-workspace-error |\n  create-version-controlled-configuration-error |\n  reference-version-controlled-configuration-error |\n  select-existing-baseline-error |\n  create-empty-baseline-error |\n  baselines-from-same-history-error |\n  no-checked-out-baseline-controlled-collection-members-error |\n  create-baseline-collection-error |\n  auto-baseline-error |\n  baseline-controlled-members-must-be-checked-in-error |\n  set-baseline-controlled-collection-members-error |\n  merge-baseline-error |\n  activity-location-ok-error |\n  initialize-activity-error |\n  must-be-activity-error |\n  delete-activity-reference-error |\n  update-checked-out-reference-error |\n  update-activity-reference-error |\n  update-workspace-reference-error |\n  one-checkout-per-activity-per-history-error |\n  linear-activity-error |\n  initialize-activity-set-error |\n  initialize-unreserved-error |\n  atomic-activity-checkin-error |\n  checkin-activity-error |\n  cannot-modify-checked-in-parent-error |\n  cannot-modify-destination-checked-in-parent-error |\n  initialize-version-history-bindings-error |\n  initialize-version-controlled-bindings-error |\n  version-control-working-collection-members-error |\n  update-version-controlled-collection-members-error |\n  checkout-of-version-with-descendant-is-forbidden-error |\n  checkout-of-version-with-descendant-is-discouraged-error |\n  checkout-of-checked-out-version-is-forbidden-error |\n  checkout-of-checked-out-version-is-discouraged-error |\n  checkin-fork-forbidden-error |\n  checkin-fork-discouraged-error |\n  cannot-delete-default-variant-error |\n  delete-variant-reference-error |\n  cannot-rename-variant-error |\n  variant-control-error |\n  create-new-variant-error |\n  delete-variant-predecessor-error |\n  must-select-variant-error |\n  update-default-variant-error |\n  update-variant-controlled-resource-error)> <!-- New! May be extended here -->\n\n<!ELEMENT user-defined-error ANY>            <!-- new!! -->\n\n<!ELEMENT put-under-version-control-error EMPTY>\n<!ELEMENT already-under-version-control-error EMPTY>\n<!ELEMENT cannot-modify-version-controlled-content-error EMPTY>\n<!ELEMENT auto-version-when-unlocked-error EMPTY>\n<!ELEMENT cannot-modify-version-controlled-property-error EMPTY>\n<!ELEMENT cannot-modify-version-error EMPTY>\n<!ELEMENT cannot-modify-protected-property-error EMPTY>\n<!ELEMENT cannot-modify-unsupported-property-error EMPTY>\n<!ELEMENT cannot-delete-root-version-error EMPTY>\n<!ELEMENT cannot-delete-referenced-version-error EMPTY>\n<!ELEMENT no-version-delete-error EMPTY>\n<!ELEMENT update-predecessor-set-error EMPTY>\n<!ELEMENT initialize-precursor-error EMPTY>\n<!ELEMENT auto-checkout-when-locked-error EMPTY>\n<!ELEMENT cannot-rename-resource-error EMPTY>\n<!ELEMENT preserve-history-error EMPTY>\n<!ELEMENT version-history-is-tree-error EMPTY>\n<!ELEMENT create-version-error EMPTY>\n<!ELEMENT must-be-checked-in-error EMPTY>\n<!ELEMENT is-checked-out-error EMPTY>\n<!ELEMENT initialize-predecessor-set-error EMPTY>\n<!ELEMENT must-be-checked-out-error EMPTY>\n<!ELEMENT initialize-version-content-and-properties-error EMPTY>\n<!ELEMENT checked-in-error EMPTY>\n<!ELEMENT keep-checked-out-error EMPTY>\n<!ELEMENT must-be-checked-out-version-controlled-resource-error EMPTY>\n<!ELEMENT cancel-checked-out-error EMPTY>\n<!ELEMENT restore-content-and-dead-properties-error EMPTY>\n<!ELEMENT must-be-checked-in-version-controlled-resource-error EMPTY>\n<!ELEMENT must-select-version-in-same-history-error EMPTY>\n<!ELEMENT update-content-and-dead-properties-error EMPTY>\n<!ELEMENT update-checked-in-property-error EMPTY>\n<!ELEMENT must-be-version-history-error EMPTY>\n<!ELEMENT delete-version-set-error EMPTY>\n<!ELEMENT cannot-copy-history-error EMPTY>\n<!ELEMENT new-version-history-error EMPTY>\n<!ELEMENT add-to-history-error EMPTY>\n<!ELEMENT create-working-resource-error EMPTY>\n<!ELEMENT create-working-resource-from-checked-in-version-error EMPTY>\n<!ELEMENT delete-working-resource-error EMPTY>\n<!ELEMENT resource-must-be-null-error EMPTY>\n<!ELEMENT workspace-location-ok-error EMPTY>\n<!ELEMENT initialize-workspace-error EMPTY>\n<!ELEMENT delete-workspace-members-error EMPTY>\n<!ELEMENT workspace-member-moved-error EMPTY>\n<!ELEMENT workspace-moved-error EMPTY>\n<!ELEMENT cannot-add-to-existing-history-error EMPTY>\n<!ELEMENT must-be-version-error EMPTY>\n<!ELEMENT\n one-version-controlled-resource-per-history-per-workspace-error EMPTY>\n<!ELEMENT new-version-controlled-resource-error EMPTY>\n<!ELEMENT cannot-merge-checked-out-resource-error EMPTY>\n<!ELEMENT checkout-not-allowed-error EMPTY>\n<!ELEMENT ancestor-version-error EMPTY>\n<!ELEMENT descendant-version-error EMPTY>\n<!ELEMENT checked-out-for-merge-error EMPTY>\n<!ELEMENT update-merge-set-error EMPTY>\n<!ELEMENT report-ignored-set-error EMPTY>\n<!ELEMENT report-properties-error EMPTY>\n<!ELEMENT delete-version-reference-error EMPTY>\n<!ELEMENT merge-must-be-complete-error EMPTY>\n<!ELEMENT must-not-be-checked-out-error EMPTY>\n<!ELEMENT must-be-new-label-error EMPTY>\n<!ELEMENT label-must-exist-error EMPTY>\n<!ELEMENT add-label-error EMPTY>\n<!ELEMENT remove-label-error EMPTY>\n<!ELEMENT must-not-have-label-and-apply-to-version-error EMPTY>\n<!ELEMENT depth-update-error EMPTY>\n<!ELEMENT version-controlled-configuration-must-be-empty-error EMPTY>\n<!ELEMENT must-be-baseline-error EMPTY>\n<!ELEMENT must-have-no-version-controlled-members-error EMPTY>\n<!ELEMENT one-baseline-controlled-collection-per-history-per-workspace-error\n EMPTY>\n<!ELEMENT create-version-controlled-configuration-error EMPTY>\n<!ELEMENT reference-version-controlled-configuration-error EMPTY>\n<!ELEMENT select-existing-baseline-error EMPTY>\n<!ELEMENT create-empty-baseline-error EMPTY>\n<!ELEMENT baselines-from-same-history-error EMPTY>\n<!ELEMENT no-checked-out-baseline-controlled-collection-members-error EMPTY>\n<!ELEMENT create-baseline-collection-error EMPTY>\n<!ELEMENT auto-baseline-error EMPTY>\n<!ELEMENT baseline-controlled-members-must-be-checked-in-error EMPTY>\n<!ELEMENT set-baseline-controlled-collection-members-error EMPTY>\n<!ELEMENT merge-baseline-error EMPTY>\n<!ELEMENT activity-location-ok-error EMPTY>\n<!ELEMENT initialize-activity-error EMPTY>\n<!ELEMENT must-be-activity-error EMPTY>\n<!ELEMENT delete-activity-reference-error EMPTY>\n<!ELEMENT update-checked-out-reference-error EMPTY>\n<!ELEMENT update-activity-reference-error EMPTY>\n<!ELEMENT update-workspace-reference-error EMPTY>\n<!ELEMENT one-checkout-per-activity-per-history-error EMPTY>\n<!ELEMENT linear-activity-error EMPTY>\n<!ELEMENT initialize-activity-set-error EMPTY>\n<!ELEMENT initialize-unreserved-error EMPTY>\n<!ELEMENT atomic-activity-checkin-error EMPTY>\n<!ELEMENT checkin-activity-error EMPTY>\n<!ELEMENT cannot-modify-checked-in-parent-error EMPTY>\n<!ELEMENT cannot-modify-destination-checked-in-parent-error EMPTY>\n<!ELEMENT initialize-version-history-bindings-error EMPTY>\n<!ELEMENT initialize-version-controlled-bindings-error EMPTY>\n<!ELEMENT version-control-working-collection-members-error EMPTY>\n<!ELEMENT update-version-controlled-collection-members-error EMPTY>\n<!ELEMENT checkout-of-version-with-descendant-is-forbidden-error EMPTY>\n<!ELEMENT checkout-of-version-with-descendant-is-discouraged-error EMPTY>\n<!ELEMENT checkout-of-checked-out-version-is-forbidden-error EMPTY>\n<!ELEMENT checkout-of-checked-out-version-is-discouraged-error EMPTY>\n<!ELEMENT checkin-fork-forbidden-error EMPTY>\n<!ELEMENT checkin-fork-discouraged-error EMPTY>\n<!ELEMENT cannot-delete-default-variant-error EMPTY>\n<!ELEMENT delete-variant-reference-error EMPTY>\n<!ELEMENT cannot-rename-variant-error EMPTY>\n<!ELEMENT variant-control-error EMPTY>\n<!ELEMENT create-new-variant-error EMPTY>\n<!ELEMENT delete-variant-predecessor-error EMPTY>\n<!ELEMENT must-select-variant-error EMPTY>\n<!ELEMENT update-default-variant-error EMPTY>\n<!ELEMENT update-variant-controlled-resource-error EMPTY>\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE multistatus\n  SYSTEM \"http://www.webdav.org/dtd/deltav-0.12.2.0.dtd\">\n<propfind xmlns=\"DAV:\">\n <prop>\n  <versionable-resource-collection-set/>\n  <version-history-collection-set/>\n </prop>\n</propfind>\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE multistatus\n  SYSTEM \"http://www.webdav.org/dtd/deltav-0.12.2.0.dtd\">\n<multistatus xmlns=\"DAV:\">\n <response>\n  <href>http://www.webdav.org</href>\n   <propstat>\n    <prop>\n     <versionable-resource-collection-set>\n      <href>http://www.webdav.org/public/projects</href>\n      <href>http://www.webdav.org/users/projects</href>\n     </versionable-resource-collection-set>\n     <version-history-collection-set>\n      <href>http://www.webdav.org/public/archive</href>\n      <href>http://www.webdav.org/users/archive</href>\n     </version-history-collection-set>\n    </prop>\n    <status>HTTP/1.1 200 OK</status>\n   </propstat>\n </response>\n</multistatus>\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE expand-property\n  SYSTEM \"http://www.webdav.org/dtd/deltav-0.12.2.0.dtd\">\n<expand-property xmlns=\"DAV:\">\n <prop-apply>\n  <version-history/>\n  <prop>\n   <version-set/>\n   <creator-displayname/>\n   <activity-set/>\n  </prop>\n </prop-apply>\n</expand-property>\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE multistatus\n  SYSTEM \"http://www.webdav.org/dtd/deltav-0.12.2.0.dtd\">\n<multistatus xmlns=\"DAV:\">\n <response>\n  <href>http://www.webdav.org/foo.html</href>\n  <propstat>\n   <multiprop>\n    <version-history/>\n    <response>\n     <href>http://repo.webdav.org/his/23</href>\n     <propstat>\n      <multiprop>\n       <version-set/>\n       <response>\n        <href>http://repo.webdav.org/his/23/ver/1</href>\n        <propstat>\n         <prop>\n          <creator-displayname><name>Fred</name></creator-displayname>\n          <activity-set>\n           <href>http://www.webdav.org/ws/dev/surely</href>\n           <href>http://www.webdav.org/ws/dev/jest</href>\n          </activity-set>\n         </prop>\n         <status>HTTP/1.1 200 OK</status>\n        </propstat>\n       </response>\n       <response>\n        <href>http://repo.webdav.org/his/23/ver/2</href>\n        <propstat>\n         <prop>\n          <creator-displayname><name>Sally</name></creator-displayname>\n          <activity-set>\n           <href>http://repo.webdav.org/act/add-refresh-cmd</href>\n          </activity-set>\n         </prop>\n         <status>HTTP/1.1 200 OK</status>\n        </propstat>\n       </response>\n      </multiprop>\n      <status>HTTP/1.1 200 OK</status>\n     </propstat>\n    </response>\n   </multiprop>\n   <status>HTTP/1.1 200 OK</status>\n  </propstat>\n </response>\n</multistatus>\n\n\n\n", "id": "lists-006-6739652"}, {"subject": "Re: DAV Versioning DTD", "content": "Dear Geoff,\n\nHere is the new proposal for expand-properties.  It has the advantage over the\ncurrent version of not overloading the prop semantics.  Structure information\nis conveyed via the prop-apply and multiprop tags in the request and response\nrespectively.  Note that they can only be used for properties that contain\nhrefs.  These examples verify against my latest DTD which I will send after\nthis.  Note also that the example in version 12 and 12.1 of the specification\nreturned erroneous values for creator-displayname.  That is fixed below.\n\nSincerely,\nJames\n\n\nDTD\n\n<!ELEMENT expand-property (prop-apply*)>\n<!ELEMENT DAV:prop-apply\n ((link |\n   checked-in |\n   checked-out |\n   predecessor-set |\n   precursor-set |\n   predecessor-set |\n   successor-set |\n   checkout-set |\n   precursor-set |\n   version-set |\n   root-version |\n   version-history |\n   workspace-checkout-set |\n   workspace |\n   merge-set |\n   auto-merge-set |\n   baseline-controlled-collection |\n   subbaseline-set |\n   baseline-collection |\n   baseline-selector |\n   baseline-controlled-collection-set |\n   activity-version-set |\n   activity-checkout-set |\n   subactivity-set |\n   current-workspace-set |\n   activity-set |\n   current-activity-set |\n   eclipse-set |\n   variant-set |\n   default-variant),\n  (prop | prop-apply)*)>\n\n<!ELEMENT propstat ((prop | multiprop), status,\n                    (responsedescription | error)?)>\n<!ELEMENT multiprop\n ((link |\n   checked-in |\n   checked-out |\n   predecessor-set |\n   precursor-set |\n   predecessor-set |\n   successor-set |\n   checkout-set |\n   precursor-set |\n   version-set |\n   root-version |\n   version-history |\n   workspace-checkout-set |\n   workspace |\n   merge-set |\n   auto-merge-set |\n   baseline-controlled-collection |\n   subbaseline-set |\n   baseline-collection |\n   baseline-selector |\n   baseline-controlled-collection-set |\n   activity-version-set |\n   activity-checkout-set |\n   subactivity-set |\n   current-workspace-set |\n   activity-set |\n   current-activity-set |\n   eclipse-set |\n   variant-set |\n   default-variant),\n   (response*))>\n\nREQUEST\n\nREPORT /foo.html HTTP/1.1\nHOST: www.webdav.org\nContent-Type: text/xml; charset=\"utf-8\"\nContent-Lenght: ????\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE expand-property\n  SYSTEM \"http://www.webdav.org/dtd/deltav-0.12.2.0.dtd\">\n<expand-property xmlns=\"DAV:\">\n <prop-apply>\n  <version-history/>\n  <prop>\n   <version-set/>\n   <creator-displayname/>\n   <activity-set/>\n  </prop>\n </prop-apply>\n</expand-property>\n\nRESPONSE\n\nHTTP/1.1 207 Mutli-Status\nContent-Type: text/xml; charset=\"utf-8\"\nContent-Lenght: ????\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE multistatus\n  SYSTEM \"http://www.webdav.org/dtd/deltav-0.12.2.0.dtd\">\n<multistatus xmlns=\"DAV:\">\n <response>\n  <href>http://www.webdav.org/foo.html</href>\n  <propstat>\n   <multiprop>\n    <version-history/>\n    <response>\n     <href>http://repo.webdav.org/his/23</href>\n     <propstat>\n      <multiprop>\n       <version-set/>\n       <response>\n        <href>http://repo.webdav.org/his/23/ver/1</href>\n        <propstat>\n         <prop>\n          <creator-displayname><name>Fred</name></creator-displayname>\n          <activity-set>\n           <href>http://www.webdav.org/ws/dev/surely</href>\n           <href>http://www.webdav.org/ws/dev/jest</href>\n          </activity-set>\n         </prop>\n         <status>HTTP/1.1 200 OK</status>\n        </propstat>\n       </response>\n       <response>\n        <href>http://repo.webdav.org/his/23/ver/2</href>\n        <propstat>\n         <prop>\n          <creator-displayname><name>Sally</name></creator-displayname>\n          <activity-set>\n           <href>http://repo.webdav.org/act/add-refresh-cmd</href>\n          </activity-set>\n         </prop>\n         <status>HTTP/1.1 200 OK</status>\n        </propstat>\n       </response>\n      </multiprop>\n      <status>HTTP/1.1 200 OK</status>\n     </propstat>\n    </response>\n   </multiprop>\n   <status>HTTP/1.1 200 OK</status>\n  </propstat>\n </response>\n</multistatus>\n\n\n\n", "id": "lists-006-6777580"}, {"subject": "Re: Autoversion confusio", "content": "> I have a question about DAV:auto-version \"when-locked\"\n> value.  In my model of the way things work:\n>\n> On a non-versioning server with a non-versioning client:\n>  - client issues LOCK on A\n>  - Lock-owner client issues PUT to A, creating the\n> content A' (A-prime)\n>  - Any client issues GET to A, retrieving the content A'\n\nAgreed.\n\n> On a versioning server with a non-versioning client,\n> where resource A is a VCR, which has DAV:auto-version\n> equals \"when-locked\".\n>  - client issues LOCK on A, creating a checked-out version\n\nThe check-out doesn't occur until a modification request (e.g.,\nPUT/PROPPATCH) is received.  So a LOCK immediately folowed by an UNLOCK\nwould not create a new version.\n\n>  - Lock-owner client issues PUT to A, modifying the\n> checked-out version to have the content A'\n\nWell, modifying the checked out *version-controlled resource* (not\n'version', a version does not have a DAV:auto-version property).\n\n>  - Any client issues a GET to A, which retreives the\n> body of the VCR, which is the same as the body of the\n> last checked-in version, which is NOT the content A'.\n\nNo, the body of the version-controlled resource will be the target of the\nGET, so it will be the value of A'.\n\n> So, on a versioning server with DAV:auto-version set\n> to \"when-locked\", clients cannot GET the latest content\n> PUT by the lock-owner (without specifying the version URL),\n> until UNLOCK occurs and the version is checked in.  This\n> is inconsistent with the way a non-versioning server\n> behaves.\n>\n> I like the functionality this feature is supposed to\n> provide, but is there a way of resolving this discrepancy?\n> The problem may lie in the fact that the VCR is defined\n> to have the same body and contents of the last checked-in\n> version, rather than the currently checked-out version.\n\nI believe there is no inconsistency.\nThere is a difference between a checked-out version-controlled resource and\na checked out version (which is called a working resource).\n\nTim\n\n\n\n", "id": "lists-006-6789393"}, {"subject": "resourcetype (was: RE: Core versioning issues and nits", "content": "I agree with Lisa.\n\n(other than the comment \"somebody could set the 'DAV:checked-in' property\nto ANY value\" because (1) just 'somebody' should not be using the DAV:\nnamespace, especially without consideration of the current specs., (2)\nservers should enforce (1), and (3) servers that did have an opionion about\nDAV:checked-in would definitely disallow setting any value, so clients\nwould fail very early.)\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK.\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n\"Lisa Dusseault\" <lisa@xythos.com> on 2001-02-05 10:58:35 PM\n\nPlease respond to lisa@xythos.com\n\nTo:   \"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com>,\n      ietf-dav-versioning@w3.org\ncc:\nSubject:  RE: Core versioning issues and nits\n\n\n\n\n>\n>    I agree that determining type by the absence of properties is\n>    sub-optimal; I'd say it's not very reliable.\n>\n> How is it any less reliable than looking for a particular value\n> in a \"resourcetype\" property?\n\nA particular value on a particular property can be preserved even when\nthe protocol changes (whether the protocol is changing as a result of\nsanctioned IETF activity or independent vendor activity).  Also, a\nparticular value on a particular property is less likely to appear \"by\naccident\".\n\nIn contrast, the absence of a property is less likely to be preserved\nwhen extending the protocol: somebody will come up with a new useful\nvalue for the property, and break clients that relied on that property\nbeing absent.  Or, on an non-versioning server like IIS 5.0 that\nsupports dead properties, somebody could set the \"DAV:checked-in\"\nproperty to ANY value, and no matter what value it's set to, it risks\nbreaking clients that look for that property.\n\nI'm not saying this is broke (particularly if the DAV:supported-methods\ncomes back as a property).  It's just not as reliable as I would prefer.\n\nLisa\n\n\n\n", "id": "lists-006-6798657"}, {"subject": "Re: resourcetype (was: RE: Core versioning issues and nits", "content": "Tim_Ellison@uk.ibm.com wrote:\n\n> I agree with Lisa.\n>\n> (other than the comment \"somebody could set the 'DAV:checked-in' property\n> to ANY value\" because (1) just 'somebody' should not be using the DAV:\n> namespace, especially without consideration of the current specs., (2)\n> servers should enforce (1), and (3) servers that did have an opionion about\n> DAV:checked-in would definitely disallow setting any value, so clients\n> would fail very early.)\n>\n> Regards,\n>\n> Tim Ellison\n> Java Technology Centre, MP146\n> IBM UK Laboratory, Hursley Park, Winchester, UK.\n> tel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n>\n> \"Lisa Dusseault\" <lisa@xythos.com> on 2001-02-05 10:58:35 PM\n>\n> Please respond to lisa@xythos.com\n>\n> To:   \"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com>,\n>       ietf-dav-versioning@w3.org\n> cc:\n> Subject:  RE: Core versioning issues and nits\n>\n> >\n> >    I agree that determining type by the absence of properties is\n> >    sub-optimal; I'd say it's not very reliable.\n> >\n> > How is it any less reliable than looking for a particular value\n> > in a \"resourcetype\" property?\n>\n> A particular value on a particular property can be preserved even when\n> the protocol changes (whether the protocol is changing as a result of\n> sanctioned IETF activity or independent vendor activity).  Also, a\n> particular value on a particular property is less likely to appear \"by\n> accident\".\n>\n> In contrast, the absence of a property is less likely to be preserved\n> when extending the protocol: somebody will come up with a new useful\n> value for the property, and break clients that relied on that property\n> being absent.  Or, on an non-versioning server like IIS 5.0 that\n> supports dead properties, somebody could set the \"DAV:checked-in\"\n> property to ANY value, and no matter what value it's set to, it risks\n> breaking clients that look for that property.\n>\n> I'm not saying this is broke (particularly if the DAV:supported-methods\n> comes back as a property).  It's just not as reliable as I would prefer.\n>\n> Lisa\n\nDear Colleagues,\n\nI think that the spec. should explicitly reserve all names in the DAV\nnamespace.  Application properties should be limited to other namespaces.\nThat would avoid this problem.\n\nSincerely,\nJames\n\n\n\n", "id": "lists-006-6809301"}, {"subject": "RE: FW: DeltaV Passthrough issue", "content": "> \"A PUT or PROPPATCH to a version-controlled\n> resource with the DAV:auto-version property set\n> will automatically check out that resource prior\n> to executing the PUT or PROPPATCH.  If that\n> resource is write-locked, the resource remains\n> checked-out until the resource is unlocked, at\n> which time the resource is checked in and a new\n> version is created in the version history of\n> that resource.\"\n>\n> That to me is \"passthrough\", even without the\n> label target, because it bypasses the content or\n> properties of the VCR in order to create a new\n> version.\n\nI just don't see how that can be interpreted as \"passthrough\".\n\nTo paraphrase, the steps are:\n\n1) start with a checked-in VCR whose contents and dead properties are the\nsame as (i.e., copies of) a version.  The version is identified by the\nDAV:checked-in property.\n\n2) check out the VCR.  This has no effect on the version referred to in (1)\nabove.  Now the VCR is a checked-out VCR whose content and properties can\nbe modified (independently of any version).  The version this checked-out\nVCR used to look like before it was modified is identified by the\nDAV:checked-out property (in fact it will be the same vallue as the\nDAV:checked-in used to have in step (1).\n\n3) After making the required modifications, check-in the VCR.  This has two\neffects, (a) the VCR cannot be further modified without checking it out\nagain, and (b) a copy of the now immutable VCR is placed in the version\nhistory as a new version (whose DAV:predecessor-set by default will\nidentify the version referred to in step (1).\n\nSo the VCR does not \"passthrough\" any methods to the version it was\noriginally based on, but check-in on a VCR does have a side-effect on the\nversion history.\n\n> How am I supposed to change the properties of the VCR itself?\n\nJust PROPPATCH the checked-out VCR.\n\nWhen checked in, the VCR's content, dead properties and live properties\nidentified in the DAV:initialize-version-content-and-properties\npostcondition of Section 3.2 CHECKIN will be made those of the new version.\n\n> The previous paragraph states:\n>\n> \"In order to use methods like PUT and PROPPATCH to\n> directly modify the content or dead properties of\n> a version-controlled resource, the version-controlled\n> resource must first be checked out.  When the checked-out\n> resource is checked in, a new version is created in the\n> version history of that version-controlled resource.\n> The version that was checked out is remembered as the\n> predecessor of the new version.\"\n\nYes, that say it much more eloquently.\n\n> That is unacceptable.  It's completely unacceptable to\n> create a new version of a resource, just in order to be\n> able to modify a property like 'Last-published-version'\n> on the VCR.  For the sake of conciseness, let's call\n> this a \"global\" property: it applies to all versions, and\n> can't have different values on different versions.\n\nYou say \"unacceptable\", but others say it is absolutely necessary that a\nchecked-in version-controlled resource has immutable properties and content\n(for caching, delta-ing, reproducability, etc.)\n\nAdding a \"global\" property to a particular resource and saying that it\napplies to a set of resources seems like a misnomer.   ...but running with\nyour term for now,\n\n> In order to modify a global property, does a new version\n> have to be created? Even though nothing changed on the\n> old version? (the only change, conceptually, is a dead\n> property on the VCR).  If I understand the model correctly,\n> that won't work because the properties of a checked-in\n> VCR are the same as the properties of the checked-in version.\n> So global properties can't be placed on VCRs at all.\n\nCorrect -- a VCR would be no place for such a global property.\n\n> Where do global properties go, then? You state that rather\n> than put global properties on the VCR, the client ought to\n> put them on the VH:\n>\n>> It sounds like you're talking about properties on the\n>> version history resource.  Your server of course must\n>> then support the version history option, but then you\n>> PROPPATCH the version history resource just as you\n>> would PROPPATCH any other resource.\n\nRight, since the history represents the entire set of versions, it seems\nthe appropriate place to put a property that refers to the entire set of\nversions, like 'Last-published-version'.\n\n> That's unacceptable.  First, as you point out, the server\n> must support an extra resource, the VHR.  Then, in order\n> to present a directory listing with the value of a global\n> property like \"Last-published-version\" for each of n VCRs\n> in a directory, the client would have to issue a depth:1\n> PROPFIND request to find all the URLs to the VHRs, then\n> issue n PROPFIND requests, one to each VHR independently,\n> to get the values of \"Last-published-version\".\n\nCorrect -- makes that property report seem well worth the money <g>.\n\n> However, the real showstopper is the lack of resource\n> transparency.  Global properties, like \"author\" from Dublin\n> Core, or \"Editor-in-Chief\", are hidden away in VHRs.  That\n> means that versioning-unaware clients cannot interoperate\n> with versioning clients on the same set of documents.  They\n> can't even PROPFIND a set of VCRs to get properties which\n> ought to exist.\n\nI don't have any suggestions for you here since there is no property that\nhas the characteristic of being defined on a set of resources in this way.\nall I can offer is that the version history resource has a URL that the\nversioning unaware client can use to PROPFIND/PROPPATCH dead properties --\nbut that would not be the same URL as any version-controlled resource\n(which is what I think you are asking for).\n\nTim\n\n\n\n", "id": "lists-006-6820570"}, {"subject": "Re: resourcetype (was: RE: Core versioning issues and nits", "content": "> I think that the spec. should explicitly reserve\n> all names in the DAV namespace.  Application properties\n> should be limited to other namespaces.\n> That would avoid this problem.\n\nAgreed, but there is already a notable client that does use this namespace.\n:-(\n\nTim\n\n\n\n", "id": "lists-006-6833918"}, {"subject": "Re: resourcetype (was: RE: Core versioning issues and nits", "content": "   > I think that the spec. should explicitly reserve\n   > all names in the DAV namespace.  Application properties\n   > should be limited to other namespaces.\n   > That would avoid this problem.\n\n   Agreed, but there is already a notable client that does use this namespace.\n   :-(\n\nDear Tim,\n\nI think we should do it anyway, with the note that the ones used by said\nclient(s) are grand-fathered.  Let the guilty list their sins (;-), by\nnaming what tags they already have in use.  Of course the list must be\nin the spec.  At least then, we can keep the problem from getting worse.\n\nSincerely,\nJames\n\n\n\n", "id": "lists-006-6841922"}, {"subject": "RE: Labels and Statu", "content": "> Mutable properties are application defined properties on a\n> version resource\n> or version controlled resource with the following characteristics:\n>\n>    1. they can be changes at any time by a WebDAV client; and\n>\n>    2. they are cleared on a target version resource when that\n> resource is checked out.\n\nCan you explain this?  By \"target version resource\", do you mean when a\nnew version is created with checkout, that mutable properties are\ncleared?  That does make sense.\n\n> This is certainly better than nothing, but three problems remain:\n>\n>   1. how can one trace who changed this property last;\nWe don't trace who makes changes to regular properties in WebDAV.  I\nwould call this out of scope.  A server can always do event logging\naccording to its own design, without interfering with WebDAV.\n\n>   2. how can access to such a property be controlled; and\nI can tell you, this group will definitely not address property access.\nThe ACL discussion may address property access control at some point.\n\n>   3. how can standard mutable properties be defined later?\nLots of ways...\n - PROPPATCH could be extended to have an extra XML element or attribute\nto declare a new property mutable (PROPFIND may be extended to have the\nsame)\n - A new method like CREATE-MUTABLE could create new mutable properties,\nwhich thereafter are set/read with PROPPATCH/PROPFIND.  In order to find\nout which properties are mutable, one could define a REPORT\n\"mutable-properties\".  This has the advantage of not requirng changes to\nPROPPATCH/PROPFIND.\n - Two new methods mirroring PROPPATCH/PROPFIND:  PATCH-MUTABLE and\nFIND-MUTABLE.  Presumably they'd duplicate the syntax, but only work\nwith mutable properties on versions.  (kind of icky, if you ask me, but\nit's an idea).\n\nlisa\n\n\n\n", "id": "lists-006-6850008"}, {"subject": "DeltaV Lack of global propertie", "content": "> > [Lisa]\n> > However, the real showstopper is the lack of resource\n> > transparency.  Global properties, like \"author\" from Dublin\n> > Core, or \"Editor-in-Chief\", are hidden away in VHRs.  That\n> > means that versioning-unaware clients cannot interoperate\n> > with versioning clients on the same set of documents.  They\n> > can't even PROPFIND a set of VCRs to get properties which\n> > ought to exist.\n>\n> [Tim]\n> I don't have any suggestions for you here since there is no\n> property that\n> has the characteristic of being defined on a set of resources\n> in this way.\n> all I can offer is that the version history resource has a\n> URL that the\n> versioning unaware client can use to PROPFIND/PROPPATCH dead\n> properties --\n> but that would not be the same URL as any version-controlled resource\n> (which is what I think you are asking for).\n>\n\nYes, that's what I'm asking for.  Although it's true that the VHR has a\nURL that a versioning-unaware client could hypothetically use, this is\nactually useless since a versioning-unaware client cannot get the URL of\nthe VHR; it doesn't even know it's supposed to look on VHRs for that\nproperty.\n\nThe functionality of having what I call \"global\" properties on VCRs is a\nrequirement for many document versioning scenarios.\n\nLisa\n\n\n\n", "id": "lists-006-6858969"}, {"subject": "RE: Autoversion confusio", "content": "Tim,\n\nI take your point about the checked-out version only being created when\nthe PUT is issued.  Still, some confusion remains.\n\nThe spec frequently makes statements like: \"The resource MUST have a\nDAV:checked-in property that identifies the new version.  The content,\ndead properties, and DAV:resourcetype of the new version MUST be the\nsame as those of the resource.  \"\nAlso: \"Although the content and dead properties of a checked-in\nversion-controlled resource are required to be the same as those of its\ncurrent DAV:checked-in version...\"\n\nOK, so based on my reading of this text and others, I assumed that the\nVCR ALWAYS had the body and the content of the last checked-in version,\nwhether or not the VCR was checked-out.  Nowhere does the draft state\notherwise, e.g. that a checked-out VCR has the body and properties of\nthe checked-out version.\n\nClearly, you and perhaps the other authors have a different mental model\nof the way this works, but nowhere in the draft is this stated.  I admit\nthat 2.1.2, on careful viewing, does imply that the checked-out VCR\nshows the body and properties of the latest version, but I want a\nnormative statement.\n\nLisa\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> Tim_Ellison@uk.ibm.com\n> Sent: Tuesday, February 06, 2001 3:22 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: Autoversion confusion\n>\n>\n>\n>\n> > I have a question about DAV:auto-version \"when-locked\"\n> > value.  In my model of the way things work:\n> >\n> > On a non-versioning server with a non-versioning client:\n> >  - client issues LOCK on A\n> >  - Lock-owner client issues PUT to A, creating the\n> > content A' (A-prime)\n> >  - Any client issues GET to A, retrieving the content A'\n>\n> Agreed.\n>\n> > On a versioning server with a non-versioning client,\n> > where resource A is a VCR, which has DAV:auto-version\n> > equals \"when-locked\".\n> >  - client issues LOCK on A, creating a checked-out version\n>\n> The check-out doesn't occur until a modification request (e.g.,\n> PUT/PROPPATCH) is received.  So a LOCK immediately folowed by\n> an UNLOCK\n> would not create a new version.\n>\n> >  - Lock-owner client issues PUT to A, modifying the\n> > checked-out version to have the content A'\n>\n> Well, modifying the checked out *version-controlled resource* (not\n> 'version', a version does not have a DAV:auto-version property).\n>\n> >  - Any client issues a GET to A, which retreives the\n> > body of the VCR, which is the same as the body of the\n> > last checked-in version, which is NOT the content A'.\n>\n> No, the body of the version-controlled resource will be the\n> target of the\n> GET, so it will be the value of A'.\n>\n> > So, on a versioning server with DAV:auto-version set\n> > to \"when-locked\", clients cannot GET the latest content\n> > PUT by the lock-owner (without specifying the version URL),\n> > until UNLOCK occurs and the version is checked in.  This\n> > is inconsistent with the way a non-versioning server\n> > behaves.\n> >\n> > I like the functionality this feature is supposed to\n> > provide, but is there a way of resolving this discrepancy?\n> > The problem may lie in the fact that the VCR is defined\n> > to have the same body and contents of the last checked-in\n> > version, rather than the currently checked-out version.\n>\n> I believe there is no inconsistency.\n> There is a difference between a checked-out\n> version-controlled resource and\n> a checked out version (which is called a working resource).\n>\n> Tim\n>\n\n\n\n", "id": "lists-006-6868168"}, {"subject": "Properties, ETags and version", "content": "I've never seen a clear resolution on whether property changes ought to\nresult in ETag changes or not, although it's been discussed in the past\non and off the main list.  This is really a core WebDAV issue, but I'm\ncc'ing the versioning list because the versioning model seems to suggest\na particular model.  First I'll tediously recap all the various\narguments I've heard/used so far... jump to the conclusions if you wish!\n\nArguments for changing ETag when properties change\n--------------------------------------------------\n\nIn versioning, when any of the regular dead properties of a resource\nchange, a new version is created.  Thus, a new version might have\nexactly the same body as the previous version, only one or more property\nvalue is changed.  This suggests that at least some properties are\nconsidered part of the resource itself.  More strongly, it pretty well\nforces the ETag to change, doesn't it?  Um, or does it?  What about the\nEtag on the VCR, anyway?\n\nThe implementation architecture argument: a server may store properties\ninside the file which also contains the resource body, and use\ninformation about this file (e.g. last-changed stamp) to create the\nETag.  This kind of architecture does not easily allow the ETag to\nremain the same when the properties change.\n\nThe sophisticated WebDAV client argument: for sophisticated WebDAV\nclients that do something like backup or replication, and care very much\nabout properties, there's currently no way to tell if the property set\nhas changed.  It would be desirable for this kind of client if some kind\nof indication changed, so that the client could tell when it's not\nnecessary to download properties at all (in most backup/replication\nscenarios, no changes at all is the common case, so it makes sense to\noptimise).\n\nArguments for keeping ETag same when properties change\n------------------------------------------------------\n\nFrequently-changing properties argument: It's pretty clear that one\ncould define resource properties which should NOT result in the ETag\nchanging.  E.g. a custom calculated property like \"last-accessed-date\"\nor \"last-accessed-by\" should not result in a change in the Etag every\ntime the resource is accessed.  So maybe it's easier not to change the\nETag for any property changes.\n\nThe principle of 'least surprise' and efficiency for existing HTTP\nclients:  Since many WebDAV resources seem to be widely accessed by HTTP\nclients, it would be a shame to force them to download a new body for a\nWebDAV resource if only the properties change.  The HTTP client expects\nthe body to change when the ETag changes, and performs unnecessary work\nif the ETag changes when the body does not.  This argument also holds\ntrue for the bulk of existing WebDAV clients which, as far as I can\ntell, do not store properties locally and thus are more efficient if the\nETag stays the same when properties change.  In other words, most\nexisting WebDAV clients don't care about knowing when properties change.\n\nThe precedent argument: Neither xythos nor mod_dav changes the etag when\nit gets a PROPPATCH.  I don't know about other servers.\n\nThe implementation architecture argument, from the opposite side:  a\nserver may store properties somewhere outside the file, and use the file\ninformation (e.g. last-changed stamp) to create the ETag.  This kind of\narchitecture does not easily allow the ETag to change when the\nproperties change.\n\nArguments for doing nothing\n---------------------------\n\nImplementations have already done one thing or the other. It's too late.\nThe most we could require of servers would be something like \"SHOULD\nNOT\" change the etag, or maybe even weaker.\n\nArguments for doing Something\n-----------------------------\n\nClients should at least be able to tell whether they can count on the\nETag changing when properties change.\n\nConclusions\n-----------\n\nMy suggestion is to add a _client_ requirement to the WebDAV proposed\nstandard when it gets updated.  E.g.  \"WebDAV clients MUST NOT rely on\nthe ETag changing in order to know when properties on the resource have\nchanged.\"\n\nThis is a pretty conservative suggestion, since it's pretty clear when\nlooking at existing WebDAV server implementations, that clients can't\nrely on the ETag changing when props change anyway.  Putting such a\nstatement in the spec just makes it clear, and avoids client developers\nhaving to test various servers to try to find out, or making poor\nassumptions.  Given this, I don't think it's necessary to make any\nrequirement on servers.  Servers are free to do whatever is most\nefficient or easiest, as long as the ETag changes in the way required by\nRFC2616.\n\nVersioning may want to address this issue separately.  Since changing\ndead properties creates a new version, I would assume the ETag would\nchange.  A regular HTTP client doing a GET on such a VCR would see a new\nETag even if the body has not changed.  However, my assumption may be\nwrong, thus, please clarify in DeltaV!\n\nIf clients need to know reliably when properties _do_ change (backup and\nreplication scenarios come to mind), we could get together and invent\nsome kind of ETag-analog for properties.  I'd be interested in this kind\nof feature, but I don't expect it's within the scope of any work\ncurrently being undertaken by the working groups.\n\nLisa Dusseault\n\n\n\n", "id": "lists-006-6880103"}, {"subject": "Re: DeltaV Lack of global propertie", "content": "> > > [Lisa]\n> > > However, the real showstopper is the lack of resource\n> > > transparency.  Global properties, like \"author\" from Dublin\n> > > Core, or \"Editor-in-Chief\", are hidden away in VHRs.  That\n> > > means that versioning-unaware clients cannot interoperate\n> > > with versioning clients on the same set of documents.  They\n> > > can't even PROPFIND a set of VCRs to get properties which\n> > > ought to exist.\n> >\n> > [Tim]\n> > I don't have any suggestions for you here since there is no\n> > property that\n> > has the characteristic of being defined on a set of resources\n> > in this way.\n> > all I can offer is that the version history resource has a\n> > URL that the\n> > versioning unaware client can use to PROPFIND/PROPPATCH dead\n> > properties --\n> > but that would not be the same URL as any version-controlled resource\n> > (which is what I think you are asking for).\n> >\n>\n> [Lisa]\n> Yes, that's what I'm asking for.  Although it's true that the\n> VHR has a URL that a versioning-unaware client could hypothetically\n> use, this is actually useless since a versioning-unaware client\n> cannot get the URL of the VHR; it doesn't even know it's supposed\n> to look on VHRs for that property.\n\nJust to be pedantic for a minute, if the client was totally versioning\nunaware then they would be unaware that versions of the resource exist, or\nthe need for \"global\" properties.  A versioning unaware client would set a\ndead property on an autoversioned version-controlled resource, and that\nwould be carried forward through subsequent versions of the resource.\n\nOk, so if a client was, say, versioning aware (i.e., knows versions exist)\nbut versioning challenged<g> (i.e., cannot make versioning calls) then they\ncould query the DAV:version-history property of the VCR (using PROPFIND) to\nget to the version history resource and set properties there (using\nPROPPATCH).  It would not require any versioning specific methods to\nimplement the \"global\" properties.\n\n> The functionality of having what I call \"global\" properties on VCRs\n> is a requirement for many document versioning scenarios.\n\nACK\n\nTim\n\n\n\n", "id": "lists-006-6892667"}, {"subject": "RE: Autoversion confusio", "content": "> I take your point about the checked-out version only\n> being created when the PUT is issued.  Still, some\n> confusion remains.\n\nOk, but we are converging!\n\n> The spec frequently makes statements like: \"The resource\n> MUST have a DAV:checked-in property that identifies the\n> new version.  The content, dead properties, and DAV:resourcetype\n> of the new version MUST be the same as those of the resource.  \"\n> Also: \"Although the content and dead properties of a checked-in\n> version-controlled resource are required to be the same as\n> those of its current DAV:checked-in version...\"\n\nThese statements are made in the context of a checked-in version-controlled\nresource.\n\n> OK, so based on my reading of this text and others, I assumed\n> that the VCR ALWAYS had the body and the content of the last\n> checked-in version, whether or not the VCR was checked-out.\n\nNo, when a version-controlled resource is checked in it has the same\ncontent and dead properties (C&DP) as the version identified in the\nDAV:checked-in property.  However, when a version-controlled resource is\nchecked-out, its C&DP are not necessarily the same as any version.\n\nThe moment it is checked out on the server, the VCR will have the same C&DP\nas the version identified by the DAV:checked-out property, but the nature\nof a checked-out VCR is that it can be modified, so subsequent PUTs etc.\nwill mean it is no longer the same as the DAV:checked-out version.\n\nTake another look at Section 2.1.2 Modifying a Version-Controlled Resource,\nin particular the diagram that shows the VCR moves to state S3 after the\nsuccessful PUT.  S3 is not captured as a version until the CHECKIN.  Of\ncourse, there could have been multiple PUTs and/or PROPPATCHes between the\nCHECKOUT and CHECKIN.\n\n> Nowhere does the draft state otherwise, e.g. that a checked-out\n> VCR has the body and properties of the checked-out version.\n\n...because that is untrue.  A VCR is a first-class resource, with content\nand properties.  When it is checked out it is \"open for change\".  There is\nno checked-out version associated with a checked-out VCR.\n\nThe only way to get a checked-out version is by sending CHECKOUT to the\nversion itself (i.e., using the version URL, or a Label: header). The\nchecked-out version is called a working resource (not a checekd-out VCR).\nCreating working resources is optional for the server (the\n\"working-resource\" option).\n\n> Clearly, you and perhaps the other authors have a different\n> mental model of the way this works, but nowhere in the draft\n> is this stated.  I admit that 2.1.2, on careful viewing, does\n> imply that the checked-out VCR shows the body and properties\n> of the latest version, but I want a normative statement.\n\nA checked-in VCR will always have the same C&DP as the DAV:checked-in\nversion.  Sending it CHECKOUT essentially flips a read-only bit to\nread/write (ok and jiggers the live properties a bit) and that's it!\nSimple eh?\n\nTim\n\n\n\n", "id": "lists-006-6902443"}, {"subject": "errors in 9.8 and 9.", "content": "The first precondition in 9.9 refers to DAV:apply-to-version. The UPDATE\nmethod can have a DAV:version element. DAV:apply-to-version is used in\nCHECKOUT. The name of the precondition would change, too.\n\nHowever, this precondition *does* apply to section 9.8 (CHECKOUT) (where it\nis missing). Basically, move the precondition in 9.9 up to 9.8, and then\nwrite a new one for 9.9.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-6912735"}, {"subject": "RE: errors in 9.8 and 9.", "content": "Thanks for finding that, Greg!  Yes, it was supposed to go in the\nCHECKOUT preconditions, not the UPDATE preconditions.\n\nWhat did you have in mind for a new precondition for 9.9 (UPDATE)?\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Greg Stein [mailto:gstein@lyra.org]\nSent: Wednesday, February 07, 2001 5:36 AM\nTo: ietf-dav-versioning@w3.org\nSubject: errors in 9.8 and 9.9\n\n\nThe first precondition in 9.9 refers to DAV:apply-to-version. The UPDATE\nmethod can have a DAV:version element. DAV:apply-to-version is used in\nCHECKOUT. The name of the precondition would change, too.\n\nHowever, this precondition *does* apply to section 9.8 (CHECKOUT) (where it\nis missing). Basically, move the precondition in 9.9 up to 9.8, and then\nwrite a new one for 9.9.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-6920032"}, {"subject": "Re: errors in 9.8 and 9.", "content": "Same text, but refer to the DAV:version element instead (within the text,\nand for the precondition name)\n\nCheers,\n-g\n\nOn Wed, Feb 07, 2001 at 07:31:45AM -0500, Clemm, Geoff wrote:\n> Thanks for finding that, Greg!  Yes, it was supposed to go in the\n> CHECKOUT preconditions, not the UPDATE preconditions.\n> \n> What did you have in mind for a new precondition for 9.9 (UPDATE)?\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: Greg Stein [mailto:gstein@lyra.org]\n> Sent: Wednesday, February 07, 2001 5:36 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: errors in 9.8 and 9.9\n> \n> \n> The first precondition in 9.9 refers to DAV:apply-to-version. The UPDATE\n> method can have a DAV:version element. DAV:apply-to-version is used in\n> CHECKOUT. The name of the precondition would change, too.\n> \n> However, this precondition *does* apply to section 9.8 (CHECKOUT) (where it\n> is missing). Basically, move the precondition in 9.9 up to 9.8, and then\n> write a new one for 9.9.\n> \n> Cheers,\n> -g\n> \n> -- \n> Greg Stein, http://www.lyra.org/\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-6928326"}, {"subject": "RE: errors in 9.8 and 9.", "content": "But a label header is not allowed with an UPDATE request\n(it wouldn't make sense, because an UPDATE request must \nbe applied to a version-controlled resource, and a Label\nheader applies a request to a version).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Greg Stein [mailto:gstein@lyra.org]\nSent: Wednesday, February 07, 2001 8:02 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: errors in 9.8 and 9.9\n\n\nSame text, but refer to the DAV:version element instead (within the text,\nand for the precondition name)\n\nCheers,\n-g\n\nOn Wed, Feb 07, 2001 at 07:31:45AM -0500, Clemm, Geoff wrote:\n> Thanks for finding that, Greg!  Yes, it was supposed to go in the\n> CHECKOUT preconditions, not the UPDATE preconditions.\n> \n> What did you have in mind for a new precondition for 9.9 (UPDATE)?\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: Greg Stein [mailto:gstein@lyra.org]\n> Sent: Wednesday, February 07, 2001 5:36 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: errors in 9.8 and 9.9\n> \n> \n> The first precondition in 9.9 refers to DAV:apply-to-version. The UPDATE\n> method can have a DAV:version element. DAV:apply-to-version is used in\n> CHECKOUT. The name of the precondition would change, too.\n> \n> However, this precondition *does* apply to section 9.8 (CHECKOUT) (where\nit\n> is missing). Basically, move the precondition in 9.9 up to 9.8, and then\n> write a new one for 9.9.\n> \n> Cheers,\n> -g\n> \n> -- \n> Greg Stein, http://www.lyra.org/\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-6936623"}, {"subject": "Re: errors in 9.8 and 9.", "content": "Not a Label header, but a DAV:label-name within the DAV:update element.\n(the actual XML constructs described in 9.9!)\n\nThe precondition is to prevent an UPDATE request with this body:\n\n  <D:update xmlns:D=\"DAV:\">\n    <D:label-name>whatever</D:label-name>\n    <D:version><D:href>http://some.thing/</D:href></D:version>\n  </D:update>\n\nThe UPDATE couldn't figure out which to use.\n\nOh. So I guess the text from 9.9 does simply move up to 9.8. Within section\n9.8, it must refer to the Label header, and the DAV:apply-to-version element.\n\nIn section 9.9, the precondition must refer to the DAV:label-name and\nDAV:version elements.\n\nCheers,\n-g\n\nOn Wed, Feb 07, 2001 at 08:15:27AM -0500, Clemm, Geoff wrote:\n> But a label header is not allowed with an UPDATE request\n> (it wouldn't make sense, because an UPDATE request must \n> be applied to a version-controlled resource, and a Label\n> header applies a request to a version).\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: Greg Stein [mailto:gstein@lyra.org]\n> Sent: Wednesday, February 07, 2001 8:02 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: errors in 9.8 and 9.9\n> \n> \n> Same text, but refer to the DAV:version element instead (within the text,\n> and for the precondition name)\n> \n> Cheers,\n> -g\n> \n> On Wed, Feb 07, 2001 at 07:31:45AM -0500, Clemm, Geoff wrote:\n> > Thanks for finding that, Greg!  Yes, it was supposed to go in the\n> > CHECKOUT preconditions, not the UPDATE preconditions.\n> > \n> > What did you have in mind for a new precondition for 9.9 (UPDATE)?\n> > \n> > Cheers,\n> > Geoff\n> > \n> > -----Original Message-----\n> > From: Greg Stein [mailto:gstein@lyra.org]\n> > Sent: Wednesday, February 07, 2001 5:36 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: errors in 9.8 and 9.9\n> > \n> > \n> > The first precondition in 9.9 refers to DAV:apply-to-version. The UPDATE\n> > method can have a DAV:version element. DAV:apply-to-version is used in\n> > CHECKOUT. The name of the precondition would change, too.\n> > \n> > However, this precondition *does* apply to section 9.8 (CHECKOUT) (where\n> it\n> > is missing). Basically, move the precondition in 9.9 up to 9.8, and then\n> > write a new one for 9.9.\n> > \n> > Cheers,\n> > -g\n> > \n> > -- \n> > Greg Stein, http://www.lyra.org/\n> \n> -- \n> Greg Stein, http://www.lyra.org/\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-6946227"}, {"subject": "RE: errors in 9.8 and 9.", "content": "Duh, of course.  I guess I should have gotten some sleep last night (:-).\nThanks for the patient explanation, Greg.  Will fix.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Greg Stein [mailto:gstein@lyra.org]\nSent: Wednesday, February 07, 2001 8:27 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: errors in 9.8 and 9.9\n\n\nNot a Label header, but a DAV:label-name within the DAV:update element.\n(the actual XML constructs described in 9.9!)\n\nThe precondition is to prevent an UPDATE request with this body:\n\n  <D:update xmlns:D=\"DAV:\">\n    <D:label-name>whatever</D:label-name>\n    <D:version><D:href>http://some.thing/</D:href></D:version>\n  </D:update>\n\nThe UPDATE couldn't figure out which to use.\n\nOh. So I guess the text from 9.9 does simply move up to 9.8. Within section\n9.8, it must refer to the Label header, and the DAV:apply-to-version\nelement.\n\nIn section 9.9, the precondition must refer to the DAV:label-name and\nDAV:version elements.\n\nCheers,\n-g\n\nOn Wed, Feb 07, 2001 at 08:15:27AM -0500, Clemm, Geoff wrote:\n> But a label header is not allowed with an UPDATE request\n> (it wouldn't make sense, because an UPDATE request must \n> be applied to a version-controlled resource, and a Label\n> header applies a request to a version).\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: Greg Stein [mailto:gstein@lyra.org]\n> Sent: Wednesday, February 07, 2001 8:02 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: errors in 9.8 and 9.9\n> \n> \n> Same text, but refer to the DAV:version element instead (within the text,\n> and for the precondition name)\n> \n> Cheers,\n> -g\n> \n> On Wed, Feb 07, 2001 at 07:31:45AM -0500, Clemm, Geoff wrote:\n> > Thanks for finding that, Greg!  Yes, it was supposed to go in the\n> > CHECKOUT preconditions, not the UPDATE preconditions.\n> > \n> > What did you have in mind for a new precondition for 9.9 (UPDATE)?\n> > \n> > Cheers,\n> > Geoff\n> > \n> > -----Original Message-----\n> > From: Greg Stein [mailto:gstein@lyra.org]\n> > Sent: Wednesday, February 07, 2001 5:36 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: errors in 9.8 and 9.9\n> > \n> > \n> > The first precondition in 9.9 refers to DAV:apply-to-version. The UPDATE\n> > method can have a DAV:version element. DAV:apply-to-version is used in\n> > CHECKOUT. The name of the precondition would change, too.\n> > \n> > However, this precondition *does* apply to section 9.8 (CHECKOUT) (where\n> it\n> > is missing). Basically, move the precondition in 9.9 up to 9.8, and then\n> > write a new one for 9.9.\n> > \n> > Cheers,\n> > -g\n> > \n> > -- \n> > Greg Stein, http://www.lyra.org/\n> \n> -- \n> Greg Stein, http://www.lyra.org/\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-6956493"}, {"subject": "Re: DeltaV Lack of global propertie", "content": "> Ok, so if a client was, say, versioning aware (i.e., knows versions exist)\n> but versioning challenged<g> (i.e., cannot make versioning calls) then they\n> could query the DAV:version-history property of the VCR (using PROPFIND) to\n> get to the version history resource and set properties there (using\n> PROPPATCH).  It would not require any versioning specific methods to\n> implement the \"global\" properties.\n\nInstead of calling the client versioning challenged, lets just say it is\nonly Core versioning aware.  As section 2.1.1 states, the version\nhistory resource is only exposed with the version history option.  But I\nwould expect/want \"global\" properties to be part of Core versioning and\nnot need to implement the version history option on the client and find\na server that has also implemented the version history option.\n\nthanks,\n--Barry\n\n\nTim_Ellison@uk.ibm.com wrote:\n> \n> > > > [Lisa]\n> > > > However, the real showstopper is the lack of resource\n> > > > transparency.  Global properties, like \"author\" from Dublin\n> > > > Core, or \"Editor-in-Chief\", are hidden away in VHRs.  That\n> > > > means that versioning-unaware clients cannot interoperate\n> > > > with versioning clients on the same set of documents.  They\n> > > > can't even PROPFIND a set of VCRs to get properties which\n> > > > ought to exist.\n> > >\n> > > [Tim]\n> > > I don't have any suggestions for you here since there is no\n> > > property that\n> > > has the characteristic of being defined on a set of resources\n> > > in this way.\n> > > all I can offer is that the version history resource has a\n> > > URL that the\n> > > versioning unaware client can use to PROPFIND/PROPPATCH dead\n> > > properties --\n> > > but that would not be the same URL as any version-controlled resource\n> > > (which is what I think you are asking for).\n> > >\n> >\n> > [Lisa]\n> > Yes, that's what I'm asking for.  Although it's true that the\n> > VHR has a URL that a versioning-unaware client could hypothetically\n> > use, this is actually useless since a versioning-unaware client\n> > cannot get the URL of the VHR; it doesn't even know it's supposed\n> > to look on VHRs for that property.\n> \n> Just to be pedantic for a minute, if the client was totally versioning\n> unaware then they would be unaware that versions of the resource exist, or\n> the need for \"global\" properties.  A versioning unaware client would set a\n> dead property on an autoversioned version-controlled resource, and that\n> would be carried forward through subsequent versions of the resource.\n> \n> Ok, so if a client was, say, versioning aware (i.e., knows versions exist)\n> but versioning challenged<g> (i.e., cannot make versioning calls) then they\n> could query the DAV:version-history property of the VCR (using PROPFIND) to\n> get to the version history resource and set properties there (using\n> PROPPATCH).  It would not require any versioning specific methods to\n> implement the \"global\" properties.\n> \n> > The functionality of having what I call \"global\" properties on VCRs\n> > is a requirement for many document versioning scenarios.\n> \n> ACK\n> \n> Tim\n\n\n\n", "id": "lists-006-6967636"}, {"subject": "RE: DeltaV Lack of global propertie", "content": "> Just to be pedantic for a minute, if the client was totally versioning\n> unaware then they would be unaware that versions of the\n> resource exist, or\n> the need for \"global\" properties.  A versioning unaware\n> client would set a\n> dead property on an autoversioned version-controlled\n> resource, and that\n> would be carried forward through subsequent versions of the resource.\n\nBut they would be aware of the need for a property like\n\"Editor-in-Chief\", they may need to get or set the value of this\nproperty.\n\n> Ok, so if a client was, say, versioning aware (i.e., knows\n> versions exist)\n> but versioning challenged<g> (i.e., cannot make versioning\n> calls) then they\n> could query the DAV:version-history property of the VCR\n> (using PROPFIND) to\n> get to the version history resource and set properties there (using\n> PROPPATCH).  It would not require any versioning specific methods to\n> implement the \"global\" properties.\n\nBut they would also potentially know about the property\n\"Editor-in-Chief\".  And the versioning-aware client can look at past\nversions, where the \"Editor-in-Chief\" property really should not have a\ndifferent value.\n\nSo how are the two clients supposed to use the same property\ninteroperably?\n\nLisa\n\n\n\n", "id": "lists-006-6978169"}, {"subject": "RE: Autoversion confusio", "content": "Tim, what you've described can make sense, but it leaves an unspecified\nhole in the middle.\n\nIf a client does a CHECKOUT then a PUT then a GET, what body do they\nsee?\n\nYou say \"when a version-controlled resource is checked-out, its C&DP are\nnot necessarily the same as any version.\"  That's not much of a\nrequirement!  It seems I could implement it such that when a client does\na CHECKOUT then a PUT then a GET, they see the body that existed on the\nVCR before the checkout.\n\nOn the other hand, you could implement it so that the same client does\nthe same CHECKOUT, PUT and GET, and they see the body that they PUT,\nwhich is NOT the body that existed on the VCR before the checkout.\n\nThe deltaV draft needs to pick one or another and make a clear\nrequirement.\n\nlisa\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> Tim_Ellison@uk.ibm.com\n> Sent: Wednesday, February 07, 2001 1:21 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Autoversion confusion\n>\n>\n>\n>\n> > I take your point about the checked-out version only\n> > being created when the PUT is issued.  Still, some\n> > confusion remains.\n>\n> Ok, but we are converging!\n>\n> > The spec frequently makes statements like: \"The resource\n> > MUST have a DAV:checked-in property that identifies the\n> > new version.  The content, dead properties, and DAV:resourcetype\n> > of the new version MUST be the same as those of the resource.  \"\n> > Also: \"Although the content and dead properties of a checked-in\n> > version-controlled resource are required to be the same as\n> > those of its current DAV:checked-in version...\"\n>\n> These statements are made in the context of a checked-in\n> version-controlled\n> resource.\n>\n> > OK, so based on my reading of this text and others, I assumed\n> > that the VCR ALWAYS had the body and the content of the last\n> > checked-in version, whether or not the VCR was checked-out.\n>\n> No, when a version-controlled resource is checked in it has the same\n> content and dead properties (C&DP) as the version identified in the\n> DAV:checked-in property.  However, when a version-controlled\n> resource is\n> checked-out, its C&DP are not necessarily the same as any version.\n>\n> The moment it is checked out on the server, the VCR will have\n> the same C&DP\n> as the version identified by the DAV:checked-out property,\n> but the nature\n> of a checked-out VCR is that it can be modified, so\n> subsequent PUTs etc.\n> will mean it is no longer the same as the DAV:checked-out version.\n>\n> Take another look at Section 2.1.2 Modifying a\n> Version-Controlled Resource,\n> in particular the diagram that shows the VCR moves to state\n> S3 after the\n> successful PUT.  S3 is not captured as a version until the\n> CHECKIN.  Of\n> course, there could have been multiple PUTs and/or\n> PROPPATCHes between the\n> CHECKOUT and CHECKIN.\n>\n> > Nowhere does the draft state otherwise, e.g. that a checked-out\n> > VCR has the body and properties of the checked-out version.\n>\n> ...because that is untrue.  A VCR is a first-class resource,\n> with content\n> and properties.  When it is checked out it is \"open for\n> change\".  There is\n> no checked-out version associated with a checked-out VCR.\n>\n> The only way to get a checked-out version is by sending\n> CHECKOUT to the\n> version itself (i.e., using the version URL, or a Label: header). The\n> checked-out version is called a working resource (not a\n> checekd-out VCR).\n> Creating working resources is optional for the server (the\n> \"working-resource\" option).\n>\n> > Clearly, you and perhaps the other authors have a different\n> > mental model of the way this works, but nowhere in the draft\n> > is this stated.  I admit that 2.1.2, on careful viewing, does\n> > imply that the checked-out VCR shows the body and properties\n> > of the latest version, but I want a normative statement.\n>\n> A checked-in VCR will always have the same C&DP as the DAV:checked-in\n> version.  Sending it CHECKOUT essentially flips a read-only bit to\n> read/write (ok and jiggers the live properties a bit) and that's it!\n> Simple eh?\n>\n> Tim\n>\n\n\n\n", "id": "lists-006-6987005"}, {"subject": "Re: Autoversion confusio", "content": "Given the explainations below, I am led to ask the following question:\n\nWhy does Core versioning support both DAV:when-locked and\nDAV:when-unlocked for the DAV:auto-version property?\n\nIn reading the Core spec (since I am only planning on implementing Core,\nI have followed the instruction in Section 1 to only read Sections 1, 2,\nand 23, in an effort to see if Core as defined is self contained and a\nreasonable set of functionality).  After reading the Core spec, I didn't\nunderstand why these two different types of autoversioning were being\nsupported (in general the Core spec lacks a lot in the area of\nexplaining things, many of these may be explained in more detail\nelsewhere in the spec, but within the core sections (1, 2, and 23) a lot\nof concepts are not explained clearly).  Then after seeing some of the\ndiscussion the last couple days on this list I thought I had it figured\nout:\n\nYou needed when-locked to provide the equivalent to a working resource\nin core.  So a client could make a series of changes that they\nconsidered an atomic unit of work (perhaps a put followed by a\nproppatch) and didn't want anyone else to see the changes mid way.  So\nthey could lock, put, proppatch, unlock and only when they unlocked\nwould the new version be created and only then would others see the\nchanges, until then all gets and propfinds would return the information\nfrom the latest checked in version.  But the client/person holding the\nlock would see changes to their virtual working resource.  I thought\nthat this was a great set of functionality for Core versioning.  \n\nBut now I see that this isn't the intention for the when-locked flag,\nand am left to wonder why it is really needed, or what it's intended\npurpose is.\n\nthanks,\n--Barry\n\n\nTim_Ellison@uk.ibm.com wrote:\n> \n> > I take your point about the checked-out version only\n> > being created when the PUT is issued.  Still, some\n> > confusion remains.\n> \n> Ok, but we are converging!\n> \n> > The spec frequently makes statements like: \"The resource\n> > MUST have a DAV:checked-in property that identifies the\n> > new version.  The content, dead properties, and DAV:resourcetype\n> > of the new version MUST be the same as those of the resource.  \"\n> > Also: \"Although the content and dead properties of a checked-in\n> > version-controlled resource are required to be the same as\n> > those of its current DAV:checked-in version...\"\n> \n> These statements are made in the context of a checked-in version-controlled\n> resource.\n> \n> > OK, so based on my reading of this text and others, I assumed\n> > that the VCR ALWAYS had the body and the content of the last\n> > checked-in version, whether or not the VCR was checked-out.\n> \n> No, when a version-controlled resource is checked in it has the same\n> content and dead properties (C&DP) as the version identified in the\n> DAV:checked-in property.  However, when a version-controlled resource is\n> checked-out, its C&DP are not necessarily the same as any version.\n> \n> The moment it is checked out on the server, the VCR will have the same C&DP\n> as the version identified by the DAV:checked-out property, but the nature\n> of a checked-out VCR is that it can be modified, so subsequent PUTs etc.\n> will mean it is no longer the same as the DAV:checked-out version.\n> \n> Take another look at Section 2.1.2 Modifying a Version-Controlled Resource,\n> in particular the diagram that shows the VCR moves to state S3 after the\n> successful PUT.  S3 is not captured as a version until the CHECKIN.  Of\n> course, there could have been multiple PUTs and/or PROPPATCHes between the\n> CHECKOUT and CHECKIN.\n> \n> > Nowhere does the draft state otherwise, e.g. that a checked-out\n> > VCR has the body and properties of the checked-out version.\n> \n> ...because that is untrue.  A VCR is a first-class resource, with content\n> and properties.  When it is checked out it is \"open for change\".  There is\n> no checked-out version associated with a checked-out VCR.\n> \n> The only way to get a checked-out version is by sending CHECKOUT to the\n> version itself (i.e., using the version URL, or a Label: header). The\n> checked-out version is called a working resource (not a checekd-out VCR).\n> Creating working resources is optional for the server (the\n> \"working-resource\" option).\n> \n> > Clearly, you and perhaps the other authors have a different\n> > mental model of the way this works, but nowhere in the draft\n> > is this stated.  I admit that 2.1.2, on careful viewing, does\n> > imply that the checked-out VCR shows the body and properties\n> > of the latest version, but I want a normative statement.\n> \n> A checked-in VCR will always have the same C&DP as the DAV:checked-in\n> version.  Sending it CHECKOUT essentially flips a read-only bit to\n> read/write (ok and jiggers the live properties a bit) and that's it!\n> Simple eh?\n> \n> Tim\n\n\n\n", "id": "lists-006-6999549"}, {"subject": "Splitting off core: where we stan", "content": "Back on December 1, 2000, I opined that splitting off core versioning from\nthe options seemed like a good idea, giving reasons both for and against the\nsplit [1].\n\nAt the time, Greg Stein [2] and Juergen Reuter both favored a split, though\nJuergen suggested that the split criteria should be to include all\nversioning features in one document, and configuration management features\nin another [3]. Geoff Clemm stated that he would be willing to make such a\nsplit, but indicated that he was concerned that this might delay core [4].\n\nOn February 2, 2001, the issue resurfaced, with Larry Masinter favoring\nsplitting off core, adding a new rationale [5]:\n\n   \"Everything outside of core versioning is much less\n   likely to progress along standards track at the same\n   rate as core versioning (more time to get independent\n   interoperable implementations of every feature); by\n   linking \"core versioning\" with \"non-core\" in the\n   initial spec, you're setting yourself up for having\n   to split the documents later. Much of non-core is\n   controversial.\"\n\nOn this same date, Mark Hale began a thread titled, \"Complexity and Core\nConsiderations\", where he polls working group members on whether they think\nthe specification should be split along core/non-core lines [6]. I replied,\nstating that I felt the specification should be split [7], to which Chris\nKaler [8] and Lisa Dusseault [9] agreed. Geoff Clemm [10], Tim Ellison\n[11],and James Hunt [12] all disagreed, and want the protocol specification\nunsplit.\n\nSo, at present we have six in favor of a split, three against. Not entirely\nrough consensus, but it certainly shows a leaning in one direction.\n\n- Jim\n\n[1]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0209.html\n[2]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0213.html\n[3]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0224.html\n[4]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0223.html\n[5]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0244.html\n[6]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0266.html\n[7]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0270.html\n[8]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0273.html\n[9]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0339.html\n[10]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0322.html\n[11]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0320.html\n[12]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0350.html\n\n\n\n", "id": "lists-006-7011548"}, {"subject": "RE: DTD Confusio", "content": "I also agree that DTDs can and should be avoided. Let's not forget that\nDTDs originated in an era when most SGML documents were created by\nhumans. WebDAV clients and servers do not need to deal with DTDs. Any\n\"invalid\" XML within requests or responses indicate (at best) a lack\nof conformance to specifications or (at worst) a bug or (unlikely) a\ntransmission failure.\n\nMy clients and servers do not generate internal or external DTDs and\nignore any received DTDs and are still (somehow :) able to discern XML\nthat is incorrect and then report the correct error codes.\n\nI would even consider removing all DTD-like information from the\ndraft or at least mark such as non-normative. After all, the lack of\nDTD expressiveness reduces their ability to define XML structures\neffectively. And removal (or replacement with BNF, XML-Schema, or\nequivalent) would (at least) lessen the need for purism arguments or\n(at best) reduce ambiguity.\n\nThanks, Ron\n\n-----Original Message-----\nFrom: Greg Stein [mailto:gstein@lyra.org]\nSent: Sunday, February 04, 2001 1:05 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: DTD Confusion\n\n\nOn Sun, Feb 04, 2001 at 02:17:39PM -0500, Geoffrey M. Clemm wrote:\n> \n>    There seem to be some confusion as to how DTD work.\n> \n> I don't think there is any confusion about how DTD's work,\n> but rather a disagreement about the value provided by a DTD.\n\nI \"vehemently agree\" with Geoff and the rest of his mail. Consider this a\nvote for avoiding the additional semantic complexity of bringing DTDs into\nthe protocol definition and processing.\n\n\n\n", "id": "lists-006-7023095"}, {"subject": "Straw poll: what options did you review", "content": "During the conference call this coming Friday, the top item for discussion\nwill be whether the document is currently in a sufficiently stable form that\nit should be sent along to the IESG for IETF-wide last call, and review by\nthe Application Area Director(s).\n\nOne of the most critical pieces of information I need to determine whether I\npersonally believe the draft should go forward is a good sense of how many\npeople have reviewed the *entire* specification, including all options.\nDuring the last call, I was only able to review the core capabilities, and\nsome of checkin/checkout, and this took me a day.\n\nSo, if you have reviewed the options part of the specification, please\nanswer the straw poll question below. Please indicate which options you have\nreviewed.  Geoff, I'll automatically assume you have reviewed the entire\ndocument :-) If I've cc'ed you on this email, that means you appear to have\ndone a thorough recent review, and are likely to have reviewed one or more\noptions. Hence, especially if I have cc'ed you, I would appreciate a straw\npoll response.  Poll responses to the list are preferred.\n\n1. Have you reviewed all options in the DeltaV protocol specification\n(Yes/No).\n\n2. If no, which options have you reviewed?\n\n3. If you have implementation experience for one or more options, and can\nshare this experience, which options have you implemented?\n\nPlease reply by Friday morning, 7AM, US Pacific time.\n\nThank you!\n\n- Jim\n\n\n\n", "id": "lists-006-7032338"}, {"subject": "RE: Splitting off core: where we stan", "content": "Jim,\n\n  I only voted against a split at the DeltaV breakout meeting in San Diego,\nbut I'll repeat it here to help your accounting.  A delay in the standards\nprocess for the workspace and baseline options, in particular, would\nprobably have an impact on the time until any Oracle DeltaV implementation\nwould be marketed.\n\n--Eric\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Whitehead\n> Sent: Wednesday, February 07, 2001 11:51 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Splitting off core: where we stand\n>\n>\n> Back on December 1, 2000, I opined that splitting off core versioning from\n> the options seemed like a good idea, giving reasons both for and\n> against the\n> split [1].\n>\n> At the time, Greg Stein [2] and Juergen Reuter both favored a\n> split, though\n> Juergen suggested that the split criteria should be to include all\n> versioning features in one document, and configuration management features\n> in another [3]. Geoff Clemm stated that he would be willing to make such a\n> split, but indicated that he was concerned that this might delay core [4].\n>\n> On February 2, 2001, the issue resurfaced, with Larry Masinter favoring\n> splitting off core, adding a new rationale [5]:\n>\n>    \"Everything outside of core versioning is much less\n>    likely to progress along standards track at the same\n>    rate as core versioning (more time to get independent\n>    interoperable implementations of every feature); by\n>    linking \"core versioning\" with \"non-core\" in the\n>    initial spec, you're setting yourself up for having\n>    to split the documents later. Much of non-core is\n>    controversial.\"\n>\n> On this same date, Mark Hale began a thread titled, \"Complexity and Core\n> Considerations\", where he polls working group members on whether\n> they think\n> the specification should be split along core/non-core lines [6].\n> I replied,\n> stating that I felt the specification should be split [7], to which Chris\n> Kaler [8] and Lisa Dusseault [9] agreed. Geoff Clemm [10], Tim Ellison\n> [11],and James Hunt [12] all disagreed, and want the protocol\n> specification\n> unsplit.\n>\n> So, at present we have six in favor of a split, three against.\n> Not entirely\n> rough consensus, but it certainly shows a leaning in one direction.\n>\n> - Jim\n>\n> [1]\n> http://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec\n/0209.html\n[2]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0213.html\n[3]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0224.html\n[4]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0223.html\n[5]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0244.html\n[6]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0266.html\n[7]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0270.html\n[8]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0273.html\n[9]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0339.html\n[10]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0322.html\n[11]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0320.html\n[12]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0350.html\n\n\n\n", "id": "lists-006-7043970"}, {"subject": "Re: Properties, ETags and version", "content": "Lisa Dusseault wrote:\n\n> Versioning may want to address this issue separately.  Since changing\n> dead properties creates a new version, I would assume the ETag would\n> change.  A regular HTTP client doing a GET on such a VCR would see a new\n> ETag even if the body has not changed.\n\n...which is probably a Bad Thing, since ETags are used for cache\nvalidation.  What's worse, a little extra complication for the people\nediting the site or a lot of extra load for the servers as people read the\nsite?\n\n--\n/==============================================================\\\n|John Stracke    | http://www.ecal.com |My opinions are my own.|\n|Chief Scientist |=============================================|\n|eCal Corp.      |You! Out of the gene pool!                   |\n|francis@ecal.com|                                             |\n\\==============================================================/\n\n\n\n", "id": "lists-006-7056807"}, {"subject": "RE: Splitting off core: where we stan", "content": "Jim,\n\nMy response echoes Eric's exactly. I'll weigh in on the \"against splitting\"\nside for all of the \"against\" reasons you've referenced.\n\nThanks, Ron\n\n-----Original Message-----\nFrom: Eric Sedlar [mailto:Eric.Sedlar@oracle.com]\nSent: Wednesday, February 07, 2001 12:20 PM\nTo: Jim Whitehead; ietf-dav-versioning@w3.org\nSubject: RE: Splitting off core: where we stand\n\n\nJim,\n\n  I only voted against a split at the DeltaV breakout meeting in San Diego,\nbut I'll repeat it here to help your accounting.  A delay in the standards\nprocess for the workspace and baseline options, in particular, would\nprobably have an impact on the time until any Oracle DeltaV implementation\nwould be marketed.\n\n--Eric\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Whitehead\n> Sent: Wednesday, February 07, 2001 11:51 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: Splitting off core: where we stand\n>\n>\n> Back on December 1, 2000, I opined that splitting off core versioning from\n> the options seemed like a good idea, giving reasons both for and\n> against the\n> split [1].\n>\n> At the time, Greg Stein [2] and Juergen Reuter both favored a\n> split, though\n> Juergen suggested that the split criteria should be to include all\n> versioning features in one document, and configuration management features\n> in another [3]. Geoff Clemm stated that he would be willing to make such a\n> split, but indicated that he was concerned that this might delay core [4].\n>\n> On February 2, 2001, the issue resurfaced, with Larry Masinter favoring\n> splitting off core, adding a new rationale [5]:\n>\n>    \"Everything outside of core versioning is much less\n>    likely to progress along standards track at the same\n>    rate as core versioning (more time to get independent\n>    interoperable implementations of every feature); by\n>    linking \"core versioning\" with \"non-core\" in the\n>    initial spec, you're setting yourself up for having\n>    to split the documents later. Much of non-core is\n>    controversial.\"\n>\n> On this same date, Mark Hale began a thread titled, \"Complexity and Core\n> Considerations\", where he polls working group members on whether\n> they think\n> the specification should be split along core/non-core lines [6].\n> I replied,\n> stating that I felt the specification should be split [7], to which Chris\n> Kaler [8] and Lisa Dusseault [9] agreed. Geoff Clemm [10], Tim Ellison\n> [11],and James Hunt [12] all disagreed, and want the protocol\n> specification\n> unsplit.\n>\n> So, at present we have six in favor of a split, three against.\n> Not entirely\n> rough consensus, but it certainly shows a leaning in one direction.\n>\n> - Jim\n>\n> [1]\n> http://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec\n/0209.html\n[2]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0213.html\n[3]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0224.html\n[4]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0223.html\n[5]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0244.html\n[6]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0266.html\n[7]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0270.html\n[8]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0273.html\n[9]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0339.html\n[10]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0322.html\n[11]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0320.html\n[12]\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0350.html\n\n\n\n", "id": "lists-006-7064793"}, {"subject": "Re: Straw poll: what options did you review", "content": "As a note on this straw poll, I think that the question of whether you\nhave reviewed all the options in the protocol is not very relevant.\nVirtually nobody has expressed an interest in implementing all the\noptions (at least, not in their first release).\n\nThe relevant number is whether a sufficient number of people have\nreviewed each option (which in fairness to Jim, was his question\nnumber two).  And since the options are cleanly segregated into\nseparate sections, I'd be happy to \"defer\" any option that does not\nhave sufficient review/support.  My criteria for sufficient support is\nthat there are two different implementors planning on using it.\n\nCheers,\nGeoff\n\n\n   From: \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n\n   During the conference call this coming Friday, the top item for discussion\n   will be whether the document is currently in a sufficiently stable form that\n   it should be sent along to the IESG for IETF-wide last call, and review by\n   the Application Area Director(s).\n\n   One of the most critical pieces of information I need to determine whether I\n   personally believe the draft should go forward is a good sense of how many\n   people have reviewed the *entire* specification, including all options.\n   During the last call, I was only able to review the core capabilities, and\n   some of checkin/checkout, and this took me a day.\n\n   So, if you have reviewed the options part of the specification, please\n   answer the straw poll question below. Please indicate which options you have\n   reviewed.  Geoff, I'll automatically assume you have reviewed the entire\n   document :-) If I've cc'ed you on this email, that means you appear to have\n   done a thorough recent review, and are likely to have reviewed one or more\n   options. Hence, especially if I have cc'ed you, I would appreciate a straw\n   poll response.  Poll responses to the list are preferred.\n\n   1. Have you reviewed all options in the DeltaV protocol specification\n   (Yes/No).\n\n   2. If no, which options have you reviewed?\n\n   3. If you have implementation experience for one or more options, and can\n   share this experience, which options have you implemented?\n\n   Please reply by Friday morning, 7AM, US Pacific time.\n\n   Thank you!\n\n   - Jim\n\n\n\n", "id": "lists-006-7079246"}, {"subject": "Re: Splitting off core: where we stan", "content": "Jim forgot Edgar Schwarz and Preston Bannister's messages (both dated\n2/3/2001), both of whom voted for submitting the combined document to\nthe IESG.  Also, Jim Amsden left me phone mail saying that he was in\nfavor of submitting a combined document to the IESG (JimA, please do\nsend email to the list, to make it official).\n\nGreg and Juergen expressed their desire to split the document before\nwe cleanly separated out the core and options sections.  So I'd\nbe interested in hearing whether they still believe it should be\nsplit, especially since one of the prime motivations for doing the\nsplit is to defer the submission of the options to the IESG.\n\nSo with the addition of JimA, Eric, and Ron, that makes it:\nJimW, Larry, Mark, Lisa, Chris in favor of splitting\nGreg, Juergen possibly in favor of splitting\nGeoff, Tim, James, Edgar, Preston, Eric, Ron, JimA in favor of keeping together\n\nSo that makes the straw poll:\n5 for splitting\n2 maybe for splitting\n8 for keeping together\n\nSo depending on how we count the \"maybe\"s, that would make it\neither 8-7 in favor of keeping together or 8-5 in favor of\nkeeping it together.\n\nSo as Jim said, \"Not entirely rough consensus, but it certainly\nshows a leaning in one direction.\"  (:-).\n\nCheers,\nGeoff\n\n   From: \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n   Date: Wed, 7 Feb 2001 11:50:35 -0800\n\n   Back on December 1, 2000, I opined that splitting off core versioning from\n   the options seemed like a good idea, giving reasons both for and against the\n   split [1].\n\n   At the time, Greg Stein [2] and Juergen Reuter both favored a split, though\n   Juergen suggested that the split criteria should be to include all\n   versioning features in one document, and configuration management features\n   in another [3]. Geoff Clemm stated that he would be willing to make such a\n   split, but indicated that he was concerned that this might delay core [4].\n\n   On February 2, 2001, the issue resurfaced, with Larry Masinter favoring\n   splitting off core, adding a new rationale [5]:\n\n      \"Everything outside of core versioning is much less\n      likely to progress along standards track at the same\n      rate as core versioning (more time to get independent\n      interoperable implementations of every feature); by\n      linking \"core versioning\" with \"non-core\" in the\n      initial spec, you're setting yourself up for having\n      to split the documents later. Much of non-core is\n      controversial.\"\n\n   On this same date, Mark Hale began a thread titled, \"Complexity and Core\n   Considerations\", where he polls working group members on whether they think\n   the specification should be split along core/non-core lines [6]. I replied,\n   stating that I felt the specification should be split [7], to which Chris\n   Kaler [8] and Lisa Dusseault [9] agreed. Geoff Clemm [10], Tim Ellison\n   [11],and James Hunt [12] all disagreed, and want the protocol specification\n   unsplit.\n\n   So, at present we have six in favor of a split, three against. Not entirely\n   rough consensus, but it certainly shows a leaning in one direction.\n\n   - Jim\n\n\n\n", "id": "lists-006-7089015"}, {"subject": "Re (2): Splitting off core: where we stan", "content": "\"Eric Sedlar\" <Eric.Sedlar@oracle.com> wrote:\n>   I only voted against a split at the DeltaV breakout meeting in San Diego,\n> but I'll repeat it here to help your accounting.  A delay in the standards\n> process for the workspace and baseline options, in particular, would\n> probably have an impact on the time until any Oracle DeltaV implementation\n> would be marketed.\nThis really would be a shame :-) BTW, I also argued for keeping the spec in one\nin a recent post.\nThis makes 6 to 6 (counting the votes I read).\n\nCheers, Edgar\n\nP.S. Straw poll response still to come.\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Native Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-7099931"}, {"subject": "RE: Straw poll: what options did you review", "content": "> 1. Have you reviewed all options in the DeltaV protocol specification\n> (Yes/No).\nUm, 'yes', but not very recently.  \n\n> 2. If no, which options have you reviewed?\nMostly core.\n \n> 3. If you have implementation experience for one or more \n> options, and can\n> share this experience, which options have you implemented?\n\nnone.\n\n\n\n", "id": "lists-006-7107625"}, {"subject": "RE: Straw poll: what options did you review", "content": "> As a note on this straw poll, I think that the question of whether you\n> have reviewed all the options in the protocol is not very relevant.\n> Virtually nobody has expressed an interest in implementing all the\n> options (at least, not in their first release).\n>\n> The relevant number is whether a sufficient number of people have\n> reviewed each option (which in fairness to Jim, was his question\n> number two).  And since the options are cleanly segregated into\n> separate sections, I'd be happy to \"defer\" any option that does not\n> have sufficient review/support.  My criteria for sufficient support is\n> that there are two different implementors planning on using it.\n\nWell, ideally there will have been a number of reviews of the entire\ndocument, but a high average number of reviews/option is also a good sign.\n\nI'm not interested in defering options that haven't been sufficiently\nreviewed, I just want to make sure they have been thoroughly reviewed. If\nlack of reviews of one or more options is the critical path, I suspect these\nsections will get reviewed quickly.\n\nI really want to see this document progress as quickly as possible, but I\nalso need to know that it has been reviewed by a couple different pairs of\neyes.  It's much cheaper to fix errors now, by several orders of magnitude,\nthan after the spec. has been implemented N times.\n\n- Jim\n\n\n\n", "id": "lists-006-7115479"}, {"subject": "RE: Splitting off core: where we stan", "content": "> Jim forgot Edgar Schwarz and Preston Bannister's messages (both dated\n> 2/3/2001), both of whom voted for submitting the combined document to\n> the IESG.\n\nSorry about that -- I tried to be as thorough as possible.\n\nSome quick points:\n\n(a) I think the results of the straw poll concerning review coverage will\nlet us know whether, at minimum, further review work needs to take place on\nthe options.  If it turns out that they have seen sufficient review, then\nI'm OK with sending the core and options off at the same time, independent\nof how they are packaged.\n\n(b) One of the more compelling arguments for splitting core from non-core is\nthat a smaller, core specification is likely to progress to RFC faster than\none large document.  The next step beyond this is for the protocol to go\nthrough review by the Application Area Director(s), and, being human beings,\nthey will review a small document faster than a large one. RFC 2518 took 8\nmonths to be reviewed, and IPP took a full year.  When do you want your RFC\nnumber?\n\n(c) Another argument is the core parts will likely progress to Draft\nstandard status faster than the options will, since there will be more\ninteroperable implementations.  In this argument, what happens now is not\nnearly as important as a year from now, when it's time to revise for going\nfrom Proposed to Draft.\n\nOh, and on the phone a month ago, Yaron expressed a desire for core to be\nsplit off, and I suspect the intent of Mark Hale's email starting his ballot\nwas a desire to split off core.  So add 1 split, and 1 more maybe to the\n\"split\" column ;-)  Seriously, the only clear indication from this is the WG\nis pretty evenly divided (I won't use the word \"split\") on this issue.\n\n- Jim\n\nPS - I still think the paper plane argument has some merit... ;-)\n\n\n\n", "id": "lists-006-7124027"}, {"subject": "RE: Splitting off core: where we stan", "content": "> (b) One of the more compelling arguments for splitting core\n> from non-core is\n> that a smaller, core specification is likely to progress to\n> RFC faster than\n>\n> (c) Another argument is the core parts will likely progress to Draft\n> standard status faster than the options will, since there will be more\n> interoperable implementations.  In this argument, what\n> happens now is not\n> nearly as important as a year from now, when it's time to\n> revise for going\n> from Proposed to Draft.\n\nMy two reasons, which I tried to express but seems to have been\nforgotten :)  are not related to speed of progression to RFC or Draft\nStandard.  They are:\n\n1) The core versioning specification will be much clearer if it is split\nout.  The definitions required by core will be much shorter and simpler.\nForward references will _have_ to be removed.  Core will more likely be\nsuccesful stand-alone this way.\n\n2) More people will read and review the specification if it is (a) short\nand (b) relevant.  Right now, people may be unable or unwilling to\nreview the draft, both because it is long, and because it has sections\nand terminology which will seem irrelevant and off-putting to people\ninterested in a simple versioning model.  The first sentence in the\nrationale is:\n\n\"Versioning, parallel development, and configuration management are\nimportant features for remote authoring of Web content.\".\n\nOuch!  Right off, some people are going to be turned off by \"parallel\ndevelopment\" and \"configuration management\" and think \"I guess this\nisn't what I wanted after all, that's too bad.\"\n\nThen the \"terms\" section is full of terms which are unneeded by somebody\ndoing core; even in the supposed core section of terms there is \"fork,\nmerge\".\n\nAlthough adoption of DeltaV by implementors of document versioning (and\nother simple versioning systems) doesn't rely on the draft being split\nin two, I am sure that a large spec of daunting complexity is not a\nhelp.  In other words, splitting core out will encourage and speed\nreview and adoption of DeltaV \"core\" by a wider range of implementors\nand vendors.\n\nThis last point, to me, is the real key and the most important reason to\nsplit the documents.\n\nLisa\n\n\n\n", "id": "lists-006-7133132"}, {"subject": "RE: Splitting off core: where we stan", "content": "I wanted to state that I concur with what Lisa has said.  Well stated.\n\nMark\n\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: Wednesday, February 07, 2001 6:12 PM\n> To: Jim Whitehead; ietf-dav-versioning@w3.org\n> Subject: RE: Splitting off core: where we stand\n> \n> \n> > (b) One of the more compelling arguments for splitting core\n> > from non-core is\n> > that a smaller, core specification is likely to progress to\n> > RFC faster than\n> >\n> > (c) Another argument is the core parts will likely progress to Draft\n> > standard status faster than the options will, since there will be more\n> > interoperable implementations.  In this argument, what\n> > happens now is not\n> > nearly as important as a year from now, when it's time to\n> > revise for going\n> > from Proposed to Draft.\n> \n> My two reasons, which I tried to express but seems to have been\n> forgotten:)  are not related to speed of progression to RFC or Draft\n> Standard.  They are:\n> \n> 1) The core versioning specification will be much clearer if it is split\n> out.  The definitions required by core will be much shorter and simpler.\n> Forward references will _have_ to be removed.  Core will more likely be\n> succesful stand-alone this way.\n> \n> 2) More people will read and review the specification if it is (a) short\n> and (b) relevant.  Right now, people may be unable or unwilling to\n> review the draft, both because it is long, and because it has sections\n> and terminology which will seem irrelevant and off-putting to people\n> interested in a simple versioning model.  The first sentence in the\n> rationale is:\n> \n> \"Versioning, parallel development, and configuration management are\n> important features for remote authoring of Web content.\".\n> \n> Ouch!  Right off, some people are going to be turned off by \"parallel\n> development\" and \"configuration management\" and think \"I guess this\n> isn't what I wanted after all, that's too bad.\"\n> \n> Then the \"terms\" section is full of terms which are unneeded by somebody\n> doing core; even in the supposed core section of terms there is \"fork,\n> merge\".\n> \n> Although adoption of DeltaV by implementors of document versioning (and\n> other simple versioning systems) doesn't rely on the draft being split\n> in two, I am sure that a large spec of daunting complexity is not a\n> help.  In other words, splitting core out will encourage and speed\n> review and adoption of DeltaV \"core\" by a wider range of implementors\n> and vendors.\n> \n> This last point, to me, is the real key and the most important reason to\n> split the documents.\n> \n> Lisa\n\n\n\n", "id": "lists-006-7143288"}, {"subject": "[Moderator Action] RE: Straw poll: what options did you review", "content": "[freed from spam trap -rrs]\n\nDate: Wed, 7 Feb 2001 21:05:58 -0500 (EST)\nFrom: \"Larry Masinter\" <LMM@acm.org>\nTo: \"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com>,\n        <ietf-dav-versioning@w3.org>\nMessage-ID: <NDBBKEBDLFENBJCGFOIJEEBAEGAA.LMM@acm.org>\nSubject: RE: Straw poll: what options did you review?\n\nThe criteria for \"Proposed Standard\" in IETF is described in RFC 2026:\n\n  A Proposed Standard specification is generally stable, has resolved\n   known design choices, is believed to be well-understood, has received\n   significant community review, and appears to enjoy enough community\n   interest to be considered valuable.\n\nI think \"significant community review\" means \"a large number of working group\nparticipants have reviewed the whole document\". I think \"well-understood\"\nmeans \"most working group members could explain what it does\" and\n\"enough community interest to be considered valuable\" means \"there\nare lots of people who plan to implement this\".\n\nI think it's a fairly creative interpretation to translate \"significant\ncommunity review\" into \"at least two people have read each section\",\nand not really consistant with my experience of how the IETF works.\n\nIf you split the document into \"core\" and \"non-core\", it's pretty clear\nthat the \"core\" document has been more widely reviewed than \"non-core\";\nit might be able to make progress as a Proposed Standard because it's\naimed at a narrower community.\n\nI'll also point out that it seems that progress through area directors,\nIESG review and the RFC editor seem to be proportional to the square\nof the length of the document rather than linear; shorter documents\nget on the queue more quickly because (just as seems to have happened\nwith working group participants) reviewers have to find a block of time\nwhere they can sit down and review the whole thing.\n\nChunking improves throughput. Use it.\n\nLarry\n-- \nhttp://larry.masinter.net\n\n\n\n", "id": "lists-006-7154280"}, {"subject": "Re: Splitting off core: where we stan", "content": "On Wed, Feb 07, 2001 at 06:26:41PM -0500, Geoffrey M. Clemm wrote:\n>...\n> Greg and Juergen expressed their desire to split the document before\n> we cleanly separated out the core and options sections.\n\nRight. With the current document organization, I'm ambivalent. It is quite\nfine, and I can easily build an implementation with it in hand. The speed of\nprogression through the IETF has some merit in terms of how to treat the\ndocument, but I also find it rather disturbing that a standard has to be a\nslave to the IETF process.\n\nPersonally, I'll code against the draft as it is submitted to the IETF,\nwhether as a single or two-part draft. It doesn't matter to me, and it\ndoesn't matter how fast it progresses to Draft Standard. One of the luxuries\nof Open Source coding, is that I can build something without a marketing\ndepartment forcing interoperability or forwards/backwards compatibility. If\nthe spec changes later, then I can change the code at will. (of course, I do\nfeel some weight from mod_dav users and it being used in some cases as a\nreference point; but forward development is much easier on me; changes can\nbe fixed)\n\nAh well. Point is: the speed of progression thru the IETF doesn't bother me.\nAnd the unified document is somewhat more appealing and may encourage people\nto look at what their other options are when they investigate the core\nversioning.\n\nIn Apache terms, I'd say that I'm \"-0\" on splitting it... meaning that I'm\nnot for it, but wouldn't complain if it was split.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-7164582"}, {"subject": "RE: Splitting off core: where we stan", "content": "I think the reason that the working group is so divided on this is\nthat we all have our own reasons for supporting DeltaV.  Frankly,\nthe fact that we have a standard document in the first place is\ncompletely amazing, given the major differences in versioning models\nin use right now.  The way the spec deals with change set vs. branching,\nclient vs. server workspaces, document management and source code\nconfiguration management issues, and resolves the tradeoffs, is a\nmajor accomplishment.\n\nTo me, splitting the document upsets the delicate balance that has\nbeen developed by Geoff Clemm & Jim Amsden over the past few years,\nand the reason for the proposed split is procedural, not technical.\n\nSplitting the document would require enough rework to probably delay\nsubmission by a month, as we remove all of the forward references from\nCore into the option stuff, and then go through a round of nitpicking\non errors in that process.\n\nWhile it is clear that Larry & others are right, that Core would go\nthrough the standards process faster alone, it is also clear that\nthe options would go through much slower.  So, the time benefit of\nsplitting depends on the relative value assigned to the MOST important\noption for each implementor, vs. the value assigned to Core.  Naturally\nthe people who only plan to implement Core are in favor of splitting,\nsince they assign a very small (if not zero) value to the options.\nPlus, the cost of splitting the document must be added to the time\ncost/benefit of the split standard.\n\nSuccessful standards are all about the implementations (and how\ninteroperable they are), not the IESG.  If we have a bunch of people\nout there doing implementations, with a spec that is stable, that\nachieve interoperability, that is the important part.  If the content\nof the spec is basically done, isn't it better to have the people on\nthis working group focusing more on implementation of the spec than\non rehashing its format for another month?  \n\nFinally, to Lisa's point, I don't see how splitting\nthe document helps people who just want to implement Core.  I actually\nthink it hurts them, because they will want to interoperate with\npeople implementing many of the options, and if they have no clue as\nto where those folks are coming from, they will have a harder time\ndebugging interoperability problems.  It's like trying to implement\na mail server and only understanding RFC822, without having any clue\nas to what MIME is.  Yeah you can do it, but you aren't going to get\nmuch interoperability.\n\n\n\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\nSent: Wednesday, February 07, 2001 6:12 PM\nTo: Jim Whitehead; ietf-dav-versioning@w3.org\nSubject: RE: Splitting off core: where we stand\n\n\n> (b) One of the more compelling arguments for splitting core\n> from non-core is\n> that a smaller, core specification is likely to progress to\n> RFC faster than\n>\n> (c) Another argument is the core parts will likely progress to Draft\n> standard status faster than the options will, since there will be more\n> interoperable implementations.  In this argument, what\n> happens now is not\n> nearly as important as a year from now, when it's time to\n> revise for going\n> from Proposed to Draft.\n\nMy two reasons, which I tried to express but seems to have been\nforgotten :)  are not related to speed of progression to RFC or Draft\nStandard.  They are:\n\n1) The core versioning specification will be much clearer if it is split\nout.  The definitions required by core will be much shorter and simpler.\nForward references will _have_ to be removed.  Core will more likely be\nsuccesful stand-alone this way.\n\n2) More people will read and review the specification if it is (a) short\nand (b) relevant.  Right now, people may be unable or unwilling to\nreview the draft, both because it is long, and because it has sections\nand terminology which will seem irrelevant and off-putting to people\ninterested in a simple versioning model.  The first sentence in the\nrationale is:\n\n\"Versioning, parallel development, and configuration management are\nimportant features for remote authoring of Web content.\".\n\nOuch!  Right off, some people are going to be turned off by \"parallel\ndevelopment\" and \"configuration management\" and think \"I guess this\nisn't what I wanted after all, that's too bad.\"\n\nThen the \"terms\" section is full of terms which are unneeded by somebody\ndoing core; even in the supposed core section of terms there is \"fork,\nmerge\".\n\nAlthough adoption of DeltaV by implementors of document versioning (and\nother simple versioning systems) doesn't rely on the draft being split\nin two, I am sure that a large spec of daunting complexity is not a\nhelp.  In other words, splitting core out will encourage and speed\nreview and adoption of DeltaV \"core\" by a wider range of implementors\nand vendors.\n\nThis last point, to me, is the real key and the most important reason to\nsplit the documents.\n\nLisa\n\n\n\n", "id": "lists-006-7173103"}, {"subject": "Re: [Moderator Action] RE: Straw poll: what options did you review", "content": "As a preface, I really appreciate Larry taking the time to suggest\nways to speed up the protocol review process.  But (I'm sure you\nknew there was a \"but\" coming up soon :-), we need to make sure\nthat the proverbial baby doesn't get flung out with the proverbial\nbath water (:-).  \n\n   From: \"Larry Masinter\" <LMM@acm.org>\n\n   The criteria for \"Proposed Standard\" in IETF is described in RFC 2026:\n\n      A Proposed Standard specification is generally stable, has\n      resolved known design choices, is believed to be\n      well-understood, has received significant community review, and\n      appears to enjoy enough community interest to be considered\n      valuable.\n\n   I think \"significant community review\" means \"a large number of\n   working group participants have reviewed the whole document\". I\n   think \"well-understood\" means \"most working group members could\n   explain what it does\" and \"enough community interest to be\n   considered valuable\" means \"there are lots of people who plan to\n   implement this\".\n\nI think that the criteria are quite clear as stated in RF 2026, and\nthat your interpretation significantly raises the bar beyond what is\nstated there.\n\n   I think it's a fairly creative interpretation to translate \"significant\n   community review\" into \"at least two people have read each section\",\n   and not really consistant with my experience of how the IETF works.\n\nI agree that would be a creative interpretation, so I'm sure glad it's\nnothing that I ever said (:-).  What I did say was:\n\n\"My criteria for sufficient support is that there are two different\nimplementors planning on using it.\"\n\nIn particular, I was talking about \"support\" for the current\nprotocol by the working group, not the level of community review,\nand I was talking about plans to use it for an implementation,\nnot just having read it.\n\nThis criteria is derived from the IETF definition of what is required\nto transition from proposed standard to draft standard:\n\n \"Draft Standard\n A specification from which at least two independent and interoperable\n implementations from different code bases have been developed, and\n for which sufficient successful operational experience has been\n obtained, may be elevated to the \"Draft Standard\" level. \"\n\n   If you split the document into \"core\" and \"non-core\", it's pretty clear\n   that the \"core\" document has been more widely reviewed than \"non-core\";\n   it might be able to make progress as a Proposed Standard because it's\n   aimed at a narrower community.\n\nYes, but the majority of the implementors are planning on implementing\nmore than core, and therefore we will not have a basis for\ninteroperation until we have stable Proposed Standard against which we\ncan code.\n\n   I'll also point out that it seems that progress through area directors,\n   IESG review and the RFC editor seem to be proportional to the square\n   of the length of the document rather than linear; shorter documents\n   get on the queue more quickly because (just as seems to have happened\n   with working group participants) reviewers have to find a block of time\n   where they can sit down and review the whole thing.\n\nI share your desire to maximize the speed of the review process, but\nit doesn't help us to get something quickly through the review process\nif it is not something that provides us with the basis for\ninteroperable implementations.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-7186826"}, {"subject": "Re: Splitting off core: where we stan", "content": "   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   ...\n\n   Although adoption of DeltaV by implementors of document versioning (and\n   other simple versioning systems) doesn't rely on the draft being split\n   in two, I am sure that a large spec of daunting complexity is not a\n   help.  In other words, splitting core out will encourage and speed\n   review and adoption of DeltaV \"core\" by a wider range of implementors\n   and vendors.\n\n   This last point, to me, is the real key and the most important reason to\n   split the documents.\n\nSince we have reorganized the document, I have seen no\nevidence of any reader being confused about what sections\nthey could skip, so a core implementor appears not to be\nfaced with daunting complexity any longer.\n\nI believe the complexity metric that matters is: how understandable\nis an option for the implementors that plan on implementing that\noption?  By that criterion, the options appear to be *simpler*\nthan the core (so maybe we should standardize on the options,\nand defer the core until later :-).\n\nAs you have stated above, adoption of DeltaV by implementors\nof simple versioning systems doesn't rely on the draft being\nsplit in two.  But if splitting the document results\nin deferring or delaying the standardization of the versioning\noptions (as others have advocated),  the delay resulting\nfrom the splitting does prevent adoption of DeltaV\nby versioning systems that *require* some of those options\nfor interoperation, and it appears that the majority of\nworking group members that are planning on implementing\nDeltaV do require at least one of the options.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-7197659"}, {"subject": "Re: Splitting off core: where we stan", "content": "On Thu, Feb 08, 2001 at 02:12:49AM -0500, Geoffrey M. Clemm wrote:\n>...\n> split in two.  But if splitting the document results\n> in deferring or delaying the standardization of the versioning\n> options (as others have advocated),  the delay resulting\n> from the splitting does prevent adoption of DeltaV\n> by versioning systems that *require* some of those options\n> for interoperation, and it appears that the majority of\n> working group members that are planning on implementing\n> DeltaV do require at least one of the options.\n\nRight.\n\n[ as I've said, I don't \"require\" anything, but am probably the wacko case ]\n\nBut let's look at some of the stated/implied/inferred implementations:\n\nSubversion: bunch o' options\nOracle: requires workspaces and baselines\nRational: nothing stated publicly :-), but they're doing a bunch of options\nXythos: core\n\nI'm seeing a tendency towards \"as much as possible\" rather than not. Xythos\nis the odd man out, but that is based on pragmatism (chicken and egg: wait\nfor clients before building up the server). The rest have time and\ninclination to build the bundle without (necessarily) waiting for the\nclients to catch up (or they are building clients, too (such as SVN)).\n\nSo... there is certainly support for saying that core by itself is pretty\nuseless and not the focus of most implementors. And if that is the case,\nthen why bother to break it out (with the hope that it gets standardized\nsooner rather than later).\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-7206774"}, {"subject": "section 11.", "content": "Section 11.3 applies to checked out resources, whether they are checked out\nVCRs or working resources. The heading and the text of 11.3.1 needs to be\nupdated to reflect both types of checkouts.\n\nI'm presuming that the term \"checked-out resource\" applies to both types.\nIf so, then that term ought to be used.\n\n[ maybe this limitation to one type occurs elsewhere in the spec? haven't\n  looked yet ]\n\nAh: there is a similar reference in the second paragraph of Section 11\n(intro). Third sentence. And the third paragraph.\n[ not exhaustive; just found this one while doing some reading ]\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-7215586"}, {"subject": "RE: Splitting off core: where we stan", "content": "# Stand up and applaud vigourously #\n\nI agree with everything that Eric has written below.  He expressed it very\neloquently.\n\nThe goal is not to get through the IESG process and get an RFC number as\nquickly as possible, rather it is to get a stable basis for interoperable\nimplementations.  The Proposed Standard track is the psychological\nmilestone for authors, reviewers, and implementers to raise the maturity\nlevel of the spec.  I believe that we meet the criteria for doing so.\n\nAs I've said before, I believe that the document is well presented, and\nthat developers capable of implementing to it will not be confused by which\nsections they must understand to implement the functionality they require.\n\nTim\n\n-----------------------------------\nEric wrote:\n\nI think the reason that the working group is so divided on this is\nthat we all have our own reasons for supporting DeltaV.  Frankly,\nthe fact that we have a standard document in the first place is\ncompletely amazing, given the major differences in versioning models\nin use right now.  The way the spec deals with change set vs. branching,\nclient vs. server workspaces, document management and source code\nconfiguration management issues, and resolves the tradeoffs, is a\nmajor accomplishment.\n\nTo me, splitting the document upsets the delicate balance that has\nbeen developed by Geoff Clemm & Jim Amsden over the past few years,\nand the reason for the proposed split is procedural, not technical.\n\nSplitting the document would require enough rework to probably delay\nsubmission by a month, as we remove all of the forward references from\nCore into the option stuff, and then go through a round of nitpicking\non errors in that process.\n\nWhile it is clear that Larry & others are right, that Core would go\nthrough the standards process faster alone, it is also clear that\nthe options would go through much slower.  So, the time benefit of\nsplitting depends on the relative value assigned to the MOST important\noption for each implementor, vs. the value assigned to Core.  Naturally\nthe people who only plan to implement Core are in favor of splitting,\nsince they assign a very small (if not zero) value to the options.\nPlus, the cost of splitting the document must be added to the time\ncost/benefit of the split standard.\n\nSuccessful standards are all about the implementations (and how\ninteroperable they are), not the IESG.  If we have a bunch of people\nout there doing implementations, with a spec that is stable, that\nachieve interoperability, that is the important part.  If the content\nof the spec is basically done, isn't it better to have the people on\nthis working group focusing more on implementation of the spec than\non rehashing its format for another month?\n\nFinally, to Lisa's point, I don't see how splitting\nthe document helps people who just want to implement Core.  I actually\nthink it hurts them, because they will want to interoperate with\npeople implementing many of the options, and if they have no clue as\nto where those folks are coming from, they will have a harder time\ndebugging interoperability problems.  It's like trying to implement\na mail server and only understanding RFC822, without having any clue\nas to what MIME is.  Yeah you can do it, but you aren't going to get\nmuch interoperability.\n\n\n\n", "id": "lists-006-7222736"}, {"subject": "Re: Straw poll: what options did you review", "content": "1. Have you reviewed all options in the DeltaV protocol specification\n(Yes/No).\n\n     Yes.\n\n\n2. If no, which options have you reviewed?\n\n\n\n3. If you have implementation experience for one or more options, and can\nshare this experience, which options have you implemented?\n\n     No comment :-(\n\n\nTim\n\n\n\n", "id": "lists-006-7233119"}, {"subject": "RE: Autoversion confusio", "content": "> Tim, what you've described can make sense, but it leaves\n> an unspecified hole in the middle.\n>\n> If a client does a CHECKOUT then a PUT then a GET, what body\n> do they see?\n\nIf we are talking about a checked-in version-controlled resource, say\n/foo.html, then\n\nCHECKOUT /foo --> makes /foo.html a checked-out version-controlled\nresource,\nPUT /foo --> updates the content of the checked-out VCR,\nGET /foo --> gets the content of the checked-out VCR (i.e., whatever you\njust PUT).\n\nIf we are talking about a version, say /his/12/ver/3 (and the server\nsupports working resources):\n\nCHECKOUT /his/12/ver/3 --> creates a working resource whose URL is returned\nin the Location: header (say, /wr/45) and leaves the version unchanged,\nPUT /wr/45 --> updates the content of the working resource,\nGET /wr/45 --> gets the content of the working resource (i.e., whatever you\njust PUT),\nGET /his/12/ver/3 --> gets the content of the version (it will be unchanged\nby any of this).\n\n[Obviously I've left of the http://hostname... from the URLs]\n\n> You say \"when a version-controlled resource is checked-out, its\n> C&DP are not necessarily the same as any version.\"  That's not\n> much of a requirement!\n\nWell once the VCR is checked-out it is mutable, so subsequent PUTs and\nPROPPATCHes will be altering its state.  That state is not captured as a\nversion (i.e., in version history) until the VCR is checked in.\n\n> It seems I could implement it such that when a client does\n> a CHECKOUT then a PUT then a GET, they see the body that\n> existed on the VCR before the checkout.\n\nThat would contradict the 'you now GET what you just PUT' expectation\n(requirement?) for a content-bearing resource.\n\n> On the other hand, you could implement it so that the same\n> client does the same CHECKOUT, PUT and GET, and they see\n> the body that they PUT, which is NOT the body that existed\n> on the VCR before the checkout.\n\nYep.  In fact it need not be the same client.  In the example above, other\nclients GETting /foo can see all the state transitions of the VCR.\n\nIf you, as a client, want to hide these intermediate states for /foo, then\nusing a working resource would be preferrable.\n\nCHECKOUT the version to create a working resource.\nPUT/PROPPATCH etc the working resource.\nCHECKIN the working resource to create a new version.\nUPDATE /foo to the new version.  This will result in the VCR at /foo having\nthe same content and dead properties as the new version.\n\n> The deltaV draft needs to pick one or another and make a clear\n> requirement.\n\n\nTim\n\n\n\n", "id": "lists-006-7240638"}, {"subject": "Re: Autoversion confusio", "content": "Barry wrote:\n> Given the explainations below, I am led to ask the\n> following question:\n>\n> Why does Core versioning support both DAV:when-locked and\n> DAV:when-unlocked for the DAV:auto-version property?\n\nIt's worse than that<g>, since\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0315.html\n\nthe options are now:\n     DAV:always-checkout-always-checkin\n     DAV:always-checkout-when-unlocked-checkin\n     DAV:when-locked-checkout\n     DAV:never\n\nThe names are a description in themselves!  But if you want more read the\nupdated Section 2.3.5.\n\n> In reading the Core spec (since I am only planning on\n> implementing Core, I have followed the instruction in\n> Section 1 to only read Sections 1, 2, and 23, in an effort\n> to see if Core as defined is self contained and a reasonable\n> set of functionality).  After reading the Core spec, I didn't\n> understand why these two different types of autoversioning\n> were being supported (in general the Core spec lacks a lot\n> in the area of explaining things, many of these may be\n> explained in more detail elsewhere in the spec, but within\n> the core sections (1, 2, and 23) a lot of concepts are not\n> explained clearly).  Then after seeing some of the discussion\n> the last couple days on this list I thought I had it figured\n> out:\n\nThe autoversion functionality is not explained elsewhere in the spec., so\nif it doesn't make sense from what you read then that needs to be fixed.\n\n> You needed when-locked to provide the equivalent to a\n> working resource in core.  So a client could make a series\n> of changes that they considered an atomic unit of work\n> (perhaps a put followed by a proppatch) and didn't want\n> anyone else to see the changes mid way.  So they could lock,\n> put, proppatch, unlock and only when they unlocked would\n> the new version be created and only then would others see\n> the changes, until then all gets and propfinds would return\n> the information from the latest checked in version.  But\n> the client/person holding the lock would see changes to\n> their virtual working resource.  I thought that this was\n> a great set of functionality for Core versioning.\n\nNo, LOCK never has had the semantics of hiding updates until the UNLOCK,\nand it would be wrong to change its semantics between RFC2518 and DeltaV.\n\n> But now I see that this isn't the intention for the when-locked\n> flag, and am left to wonder why it is really needed, or what\n> it's intended purpose is.\n\nThe interaction between locking and versioning here is simply to avoid\ncreating numerous versions of the intermediate states on the basis that\nthese intermediate states are not 'worthy' of being retained as versions,\nbut the versioning unaware client has no way of indicating this.  The\nDAV:auto-version property states a policy in this respect.\n\n\nTim\n\n\n\n", "id": "lists-006-7250442"}, {"subject": "RE: DeltaV Lack of global propertie", "content": "> > Just to be pedantic for a minute, if the client\n> > was totally versioning unaware then they would be\n> > unaware that versions of the resource exist, or\n> > the need for \"global\" properties.  A versioning\n> > unaware client would set a dead property on an\n> > autoversioned version-controlled resource, and\n> > that would be carried forward through subsequent\n> > versions of the resource.\n>\n> But they would be aware of the need for a property\n> like \"Editor-in-Chief\", they may need to get or set\n> the value of this property.\n\nI don't understand your point.  Assuming a versioning unaware client, what\ncharacteristics of the property could they expect that are not provided for\nby RFC2518?\n\n> > Ok, so if a client was, say, versioning aware (i.e.,\n> > knows versions exist) but versioning challenged<g>\n> > (i.e., cannot make versioning calls) then they\n> > could query the DAV:version-history property of\n> > the VCR (using PROPFIND) to get to the version\n> > history resource and set properties there (using\n> > PROPPATCH).  It would not require any versioning\n> > specific methods to implement the \"global\" properties.\n>\n> But they would also potentially know about the property\n> \"Editor-in-Chief\".  And the versioning-aware client\n> can look at past versions, where the \"Editor-in-Chief\"\n> property really should not have a different value.\n\nYou missed my point, the property would be on the version history resource,\nbut does not require any versioning specific methods to get or set.\n\n> So how are the two clients supposed to use the same\n> property interoperably?\n\nA versioning unaware client would have no such expectations for a property\nlike this.  Please explain further, I feel I'm missing it.\n\n\nTim\n\n\n\n", "id": "lists-006-7260377"}, {"subject": "Re: DeltaV Lack of global propertie", "content": "> > Ok, so if a client was, say, versioning aware (i.e.,\n> > knows versions exist) but versioning challenged<g>\n> > (i.e., cannot make versioning calls) then they could\n> > query the DAV:version-history property of the VCR\n> > (using PROPFIND) to get to the version history resource\n> > and set properties there (using PROPPATCH).  It would\n> > not require any versioning specific methods to implement\n> > the \"global\" properties.\n>\n> Instead of calling the client versioning challenged, lets\n> just say it is only Core versioning aware.  As section\n> 2.1.1 states, the version history resource is only exposed\n> with the version history option.  But I would expect/want\n> \"global\" properties to be part of Core versioning and\n> not need to implement the version history option on the\n> client and find a server that has also implemented the\n> version history option.\n\nVersion history has been in and out of core a few times!  The version\nhistory resource is the rightful place for information about *all* the\nversions, if a property that has this characteristic is important to you\nthen core+version history makes sense.  The resource property model of\nRFC2518 has not been tampered with.\n\nTim\n\n\n\n", "id": "lists-006-7269397"}, {"subject": "Re: Splitting off core: where we stan", "content": "On the straw poll,\n\nas some one who has been involved in the activity from the beginning and as\nsome one who has been reading the specification through its iterations, I\nwould vote to keep the specification together.\n\nSankar\n\n\n\n", "id": "lists-006-7277538"}, {"subject": "Re: DTD Confusio", "content": "> I also agree that DTDs can and should be avoided. Let's not forget that\n> DTDs originated in an era when most SGML documents were created by\n> humans. WebDAV clients and servers do not need to deal with DTDs.\n\nWebDAV/DeltaV clients and servers are also created by humans.  And the\nWebDAV and DeltaV protocol are created by humans.  I already found a\ncouple of bugs in the WebDAV protocol specification just by trying to\nvalidate the examples that are given in the protocol (just have a look at\nthe open issues list for WebDAV!).  And there are frequent messages on\n(at least) the WebDAV versioning list about strange message content\nproduced by various servers and clients.  I am pretty sure that, if we\nwere using valid XML, we would have much less trouble.\n\nPlease note that (as far as I know) no one is trying to force\nimplementers to validate WebDAV/DeltaV XML content.  What is requested\nhere, is to give implementers the possibility to validate the content in\na way that conforms with the XML specification, if they choose to do some\nvalidation.\n\n> Any \"invalid\" XML within requests or responses indicate (at best) a\n> lack of conformance to specifications or (at worst) a bug\n\nA bug in the specification itself is even worse, since it may lead to\ndifferent opinions about which behaviour is conformant.  And, recognizing\nall those messages about problems with WebDAV clients and servers, bugs\nin WebDAV client/server applications seem to be anything but seldom; so\nit is very likely that you really want some kind of validation.\n\nGreetings,\n           Juergen\n\n\n\n", "id": "lists-006-7284773"}, {"subject": "Re: DTD Confusio", "content": "To put it in short words: I totally agree with Juergen!!!\n\nWe had a lot of trouble during implementing our WebDAV client which were\ncaused by the fact that client and server implementers had different\nunderstandings of the protocol. The majority of that trouble could have been\navoided with a crystal clear DTD (e. g. without or at least with a reduced\nnumbers of ANYs) because the likelihood of misunderstandings of the protocol\ncan be tremendously reduced if such a DTD exists.\n\nBest, Hartmut\n\nJuergen Reuter wrote:\n\n> > I also agree that DTDs can and should be avoided. Let's not forget that\n> > DTDs originated in an era when most SGML documents were created by\n> > humans. WebDAV clients and servers do not need to deal with DTDs.\n>\n> WebDAV/DeltaV clients and servers are also created by humans.  And the\n> WebDAV and DeltaV protocol are created by humans.  I already found a\n> couple of bugs in the WebDAV protocol specification just by trying to\n> validate the examples that are given in the protocol (just have a look at\n> the open issues list for WebDAV!).  And there are frequent messages on\n> (at least) the WebDAV versioning list about strange message content\n> produced by various servers and clients.  I am pretty sure that, if we\n> were using valid XML, we would have much less trouble.\n>\n> Please note that (as far as I know) no one is trying to force\n> implementers to validate WebDAV/DeltaV XML content.  What is requested\n> here, is to give implementers the possibility to validate the content in\n> a way that conforms with the XML specification, if they choose to do some\n> validation.\n>\n> > Any \"invalid\" XML within requests or responses indicate (at best) a\n> > lack of conformance to specifications or (at worst) a bug\n>\n> A bug in the specification itself is even worse, since it may lead to\n> different opinions about which behaviour is conformant.  And, recognizing\n> all those messages about problems with WebDAV clients and servers, bugs\n> in WebDAV client/server applications seem to be anything but seldom; so\n> it is very likely that you really want some kind of validation.\n>\n> Greetings,\n>            Juergen\n\n\n\n", "id": "lists-006-7293899"}, {"subject": "Splitting the documen", "content": "It is extremely important that we define the versioning protocol in such a \nway that interoperability is achieved between many client applications, \nand many repository implementations. This is what defines the WebDAV value \nproposition. Accomplishing this requires compromise between the needs of \nmany different existing and emerging client and repository \nimplementations. The Delta-V design team(s) and working group have spent \nmany long hours wrestling with this issue that resulted in many different \nproposals and permutations of levels, core, extensions, etc. It was very \nclear early on in our design sessions that starting out defining these \ndifferent levels and/or options was getting us nowhere. So our overall \ndesign strategy was to iterate between defining a consistent set of \nsemantics that provided the functionality we all through would be useful \nin a distributed authoring and versioning environment and logical subsets \nthat met existing needs. Hopefully the result would be subsets consistent \nwith the versioning semantics as a whole. This would limit the possibility \nof having different ways to do the same thing in different levels, and \nwould ensure servers with more options would be compatible with clients \nexpecting less options. However, coming up with the levels, even after \nhaving a pretty good idea of the complete semantics, also proved extremely \ndifficult. It seemed to that whenever something got included, someone else \nwould want it excluded and include something else. We just couldn't \ndecide.\n\nThe lesson to be learned from this is that there is no one answer that is \ngoing to meet everyone's needs. To me this is the key reason for keeping \nversioning in one document. It allows server implementers to make their \nimplementation choices based on the options the want to support. Core \nversioning represents the absolute minimum subset of the versioning \nsemantics that any client should expect from any versioning server. It \nrepresents the subset of the versioning semantics that was common across \nmost of the repositories represented by the working group members. But \ncommonality does not imply semantic completeness, it just defines what's \ncommon. Some WebDAV servers will certainly implement just core versioning, \nand these will be useful. However, there are many server implementations \nthat either are, or will implement many of the options. \n\nI think we've already had our opportunity to \"split the document\" when the \n\"V\" was removed from RFC2518. To support the server implementations that \nare already underway, we need to move both core and the extensions through \nthe standards process. Otherwise interoperability will certainly suffer as \nthe needs of these sever implementations are not met by core. I realize \nthis will result in some challenges, but I think we need to face these \nchallenges with solutions rather than deferring them again. I also think \nGeoff has done an exceptional job addressing the concerns of the working \ngroup by clearly separating core versioning from each of the options, as \nwell as making each option as independent from all others as possible. The \nresult still isn't ideal in that there are a lot of options which will \ncertainly introduce complexity, especially for client writers. But it \nseems like an effective compromise that we should take forward and let the \nprocess take its course. Core versioning in a separate document would \nprobably proceed through the standards process faster and result in less \ncontroversy. It might also result in more interoperable core-only server \nimplementations. But it wouldn't meet the needs of a number of WebDAV \nservers that are already under development. Also, the time required to get \nan RFC number will not necessarily inhibit development of interoperable \nservers. Many of us were more than willing to implement WebDAV servers \nlong before RFC2518 was accepted. Participation in the working groups and \nunderstanding the stability of the specification semantics are what's \nreally important.\n\nSo I think we should use the IETF process to help us uncover and address \ncontroversial options. We should present the complete versioning semantics \nin a single document so that 1) we ensure the semantics as a whole get \nreviewed and issues are resolved, and 2) server implementers have the \nspecifications for the options they need to implement now, not at some \nlater date. Splitting the document up and allowing them to progress on \nseparate tracks will not meet the server implementers' needs, and as a \nconsequence, may result in less interoperable versioning server \nimplementations.\n\n\n\n", "id": "lists-006-7303148"}, {"subject": "Re: Splitting off core: where we stan", "content": "> Greg and Juergen expressed their desire to split the document before\n> we cleanly separated out the core and options sections.  So I'd\n> be interested in hearing whether they still believe it should be\n> split, especially since one of the prime motivations for doing the\n> split is to defer the submission of the options to the IESG.\n\nAs I already stated on Dec 4th, my point was not to split the document,\nbut to refine the structure of the whole document.  The orthogonality of\noptions, as claimed in the introduction, makes the protocol much more\nunderstandable, provided that the claim really holds true.\n\nBut 7.4 says:\n\n  If a server supports the workspace option, it MUST also support the\n  checkout option and the version-history option.\n\nSo, options are not completely orthogonal.  I think there was at least\none other such constraint somewhere in the protocol, if I remember right.\nHence it might be worth to present these dependencies at some central\nplace, possibly as a figure, so that the structure really gets clear.\n\nGreetings,\n            Juergen\n\n\n\n", "id": "lists-006-7314624"}, {"subject": "Re: Straw poll: what options did you review", "content": "1. Have you reviewed all options in the DeltaV protocol specification\n(Yes/No).\n\nYes (12.1), but I was concentrating on syntax issues and neglecting\nsemantic details.\n\n2. If no, which options have you reviewed?\n\n3. If you have implementation experience for one or more options, and can\nshare this experience, which options have you implemented?\n\nLast year, I implemented the core part (server and client) as of draft\n04.5, which includes checkout, update (as of 04.5, select-target),\nversion-history (as of 04.5, implicit on VCRs), working resources,\nlabels, reports (including DAV:expand-property REPORT).\n\nGreetings,\n            Juergen\n\n\n\n", "id": "lists-006-7323626"}, {"subject": "Re: Splitting off core: where we stan", "content": "   From: Juergen Reuter <reuter@ira.uka.de>\n\n   > Greg and Juergen expressed their desire to split the document before\n   > we cleanly separated out the core and options sections.  So I'd\n   > be interested in hearing whether they still believe it should be\n   > split, especially since one of the prime motivations for doing the\n   > split is to defer the submission of the options to the IESG.\n\n   As I already stated on Dec 4th, my point was not to split the document,\n   but to refine the structure of the whole document.  The orthogonality of\n   options, as claimed in the introduction, makes the protocol much more\n   understandable, provided that the claim really holds true.\n\n   But 7.4 says:\n\n     If a server supports the workspace option, it MUST also support the\n     checkout option and the version-history option.\n\n   So, options are not completely orthogonal.  I think there was at least\n   one other such constraint somewhere in the protocol, if I remember right.\n   Hence it might be worth to present these dependencies at some central\n   place, possibly as a figure, so that the structure really gets clear.\n\nGood point.  I will add this as text to the introductory paragraph\nthat discusses the orthogonality of the options, and will try some\nASCII art as well.  As Juergen says, this would provide a very nice\nroadmap to the document, emphasizing what is core and what\ndependencies there are (the other dependency is that \"versioning\"\ndepends on \"report\").\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-7332048"}, {"subject": "Straw poll results so fa", "content": "So far I've received the following straw poll results:\n\nJim Amsden: all\nTim Ellison: all\nMark Hale: all\nJuergen Reuter: all\nEric Sedlar: all, but not at sufficient detail to do implementation work\nLisa Dusseault: yes, but not recently\n\nI think we can safely assume Geoff Clemm has read the entire draft, and Greg\nStein has also presumably reviewed and/or implemented a fair portion of the\noptions as well.\n\nBottom line, there appear to be 5 people who have reviewed all options, and\nthree who have reviewed a subset.  Any others out there?\n\n- Jim\n\n\n\n", "id": "lists-006-7340791"}, {"subject": "RE: Splitting off core: where we stan", "content": "On Thursday, February 08, 2001 3:59 AM, Greg Stein wrote:\n> But let's look at some of the stated/implied/inferred implementations:\n> \n> Rational: nothing stated publicly :-), but they're doing a \n> bunch of options\n\nActually, a recent message from Geoff stated that we're implementing all but\nWorking Resources and Variants, and Fork-Control will probably miss the cut\nfor an initial implementation. (We can add Working Resources and Variants\nsome day, if there ends up being demand for those options from clients.)\n\nI would like to add my vote for keeping the document as is (not splitting\nit). It is very important to have a stable specification for these options\nas soon as possible. My sense from the traffic on this list is that the vast\nmajority of server implementors are planning on implementing at least some\nof the options. Letting the status of the options specifications lag behind\nthe core specification will impede the availability and interoperability of\na number of implementations.\n\nJohn\n\n\n\n", "id": "lists-006-7348430"}, {"subject": "RE: Straw poll results so fa", "content": "> Bottom line, there appear to be 5 people who have reviewed \n> all options, and three who have reviewed a subset.  Any others out there?\n\nYes, I've reviewed the entire document. I would say that I have\nimplementation experience with most of the options, but in \"prototype\" form\n(waiting for the spec to settle down before committing serious effort).\n\nJohn\n\n\n\n", "id": "lists-006-7356499"}, {"subject": "RE: Splitting the documen", "content": "Right.  If actual implementations are going to use the \"options\" outside the\n\"core\" then splitting the document seems of little benefit.  Perhaps the\ncombined document will take longer to be processed, but will it take longer\nthan a core document followed by an options documents?   The time might not\nbe very different.\n\n... given also that splitting the document will take yet another round of\ndiscussion ...\n\nEnough chatter.  Time to cut to the chase scene :).\n\n  -----Original Message-----\n  From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n  Sent: Thursday, February 08, 2001 8:08 AM\n  To: ietf-dav-versioning@w3.org\n  Subject: Splitting the document\n\n\n\n  It is extremely important that we define the versioning protocol in such a\nway that interoperability is achieved between many client applications, and\nmany repository implementations. This is what defines the WebDAV value\nproposition. Accomplishing this requires compromise between the needs of\nmany different existing and emerging client and repository implementations.\nThe Delta-V design team(s) and working group have spent many long hours\nwrestling with this issue that resulted in many different proposals and\npermutations of levels, core, extensions, etc. It was very clear early on in\nour design sessions that starting out defining these different levels and/or\noptions was getting us nowhere. So our overall design strategy was to\niterate between defining a consistent set of semantics that provided the\nfunctionality we all through would be useful in a distributed authoring and\nversioning environment and logical subsets that met existing needs. ! ! !\nHopefully the result would be subsets consistent with the versioning\nsemantics as a whole. This would limit the possibility of having different\nways to do the same thing in different levels, and would ensure servers with\nmore options would be compatible with clients expecting less options.\nHowever, coming up with the levels, even after having a pretty good idea of\nthe complete semantics, also proved extremely difficult. It seemed to that\nwhenever something got included, someone else would want it excluded and\ninclude something else. We just couldn't decide.\n\n  The lesson to be learned from this is that there is no one answer that is\ngoing to meet everyone's needs. To me this is the key reason for keeping\nversioning in one document. It allows server implementers to make their\nimplementation choices based on the options the want to support. Core\nversioning represents the absolute minimum subset of the versioning\nsemantics that any client should expect from any versioning server. It\nrepresents the subset of the versioning semantics that was common across\nmost of the repositories represented by the working group members. But\ncommonality does not imply semantic completeness, it just defines what's\ncommon. Some WebDAV servers will certainly implement just core versioning,\nand these will be useful. However, there are many server implementations\nthat either are, or will implement many of the options.\n\n  I think we've already had our opportunity to \"split the document\" when the\n\"V\" was removed from RFC2518. To support the server implementations that are\nalready underway, we need to move both core and the extensions through the\nstandards process. Otherwise interoperability will certainly suffer as the\nneeds of these sever implementations are not met by core. I realize this\nwill result in some challenges, but I think we need to face these challenges\nwith solutions rather than deferring them again. I also think Geoff has done\nan exceptional job addressing the concerns of the working group by clearly\nseparating core versioning from each of the options, as well as making each\noption as independent from all others as possible. The result still isn't\nideal in that there are a lot of options which will certainly introduce\ncomplexity, especially for client writers. But it seems like an effective\ncompromise that we should take forwa! ! ! rd and let the process take its\ncourse. Core versioning in a separate document would probably proceed\nthrough the standards process faster and result in less controversy. It\nmight also result in more interoperable core-only server implementations.\nBut it wouldn't meet the needs of a number of WebDAV servers that are\nalready under development. Also, the time required to get an RFC number will\nnot necessarily inhibit development of interoperable servers. Many of us\nwere more than willing to implement WebDAV servers long before RFC2518 was\naccepted. Participation in the working groups and understanding the\nstability of the specification semantics are what's really important.\n\n  So I think we should use the IETF process to help us uncover and address\ncontroversial options. We should present the complete versioning semantics\nin a single document so that 1) we ensure the semantics as a whole get\nreviewed and issues are resolved, and 2) server implementers have the\nspecifications for the options they need to implement now, not at some later\ndate. Splitting the document up and allowing them to progress on separate\ntracks will not meet the server implementers' needs, and as a consequence,\nmay result in less interoperable versioning server implementations.\n\n\n\n", "id": "lists-006-7364272"}, {"subject": "Re: Straw poll results so fa", "content": "> So far I've received the following straw poll results:\n> ...\n> Juergen Reuter: all\n\nNo, that is not exactly what I intended to state (you silently dropped\nthe clause starting with \"but\"...).  I am also fine with: \"yes, but not\nat sufficient detail to do implementation work\".\n\nGreetings,\n            Juergen\n\n\n\n", "id": "lists-006-7376958"}, {"subject": "RE: Autoversion confusio", "content": "Tim, you've explained this in email before.  I'm not disagreeing with\nyour interpretation but the point is that standards need to be\nself-contained so that implementors don't need to go read the mailing\nlist archives to achieve interoperability.  Currently, this behavior is\nunderspecified.\n\nHere's a proposed addition to section XXX that clarifies how the DeltaV\nrequires implementations to behave:\n\n\"In core versioning, while a VCR is checked out it may be the target of\nmultiple write operations.  During this period, other clients MUST still\nbe able to perform read operations on the VCR's URL, and the results\nMUST show the results of all the write operations that have been\nperformed thus far.  (Note: if a scenario requires hiding a\nwork-in-progress from other clients, the \"working resource\" option can\nbe used.)\"\n\nDoes this accurately reflect your understanding of how things ought to\nwork? I'm not particularly committed to this language or indeed to this\ninterpretation but the document must pick one and state it explicitly.\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> Tim_Ellison@uk.ibm.com\n> Sent: Thursday, February 08, 2001 2:29 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Autoversion confusion\n>\n>\n>\n>\n> > Tim, what you've described can make sense, but it leaves\n> > an unspecified hole in the middle.\n> >\n> > If a client does a CHECKOUT then a PUT then a GET, what body\n> > do they see?\n>\n> If we are talking about a checked-in version-controlled resource, say\n> /foo.html, then\n>\n> CHECKOUT /foo --> makes /foo.html a checked-out version-controlled\n> resource,\n> PUT /foo --> updates the content of the checked-out VCR,\n> GET /foo --> gets the content of the checked-out VCR (i.e.,\n> whatever you\n> just PUT).\n>\n> If we are talking about a version, say /his/12/ver/3 (and the server\n> supports working resources):\n>\n> CHECKOUT /his/12/ver/3 --> creates a working resource whose\n> URL is returned\n> in the Location: header (say, /wr/45) and leaves the version\n> unchanged,\n> PUT /wr/45 --> updates the content of the working resource,\n> GET /wr/45 --> gets the content of the working resource\n> (i.e., whatever you just PUT),\n> GET /his/12/ver/3 --> gets the content of the version (it\n> will be unchanged\n> by any of this).\n>\n> [Obviously I've left of the http://hostname... from the URLs]\n>\n> > You say \"when a version-controlled resource is checked-out, its\n> > C&DP are not necessarily the same as any version.\"  That's not\n> > much of a requirement!\n>\n> Well once the VCR is checked-out it is mutable, so subsequent PUTs and\n> PROPPATCHes will be altering its state.  That state is not\n> captured as a\n> version (i.e., in version history) until the VCR is checked in.\n>\n> > It seems I could implement it such that when a client does\n> > a CHECKOUT then a PUT then a GET, they see the body that\n> > existed on the VCR before the checkout.\n>\n> That would contradict the 'you now GET what you just PUT' expectation\n> (requirement?) for a content-bearing resource.\n>\n> > On the other hand, you could implement it so that the same\n> > client does the same CHECKOUT, PUT and GET, and they see\n> > the body that they PUT, which is NOT the body that existed\n> > on the VCR before the checkout.\n>\n> Yep.  In fact it need not be the same client.  In the example\n> above, other\n> clients GETting /foo can see all the state transitions of the VCR.\n>\n> If you, as a client, want to hide these intermediate states\n> for /foo, then\n> using a working resource would be preferrable.\n>\n> CHECKOUT the version to create a working resource.\n> PUT/PROPPATCH etc the working resource.\n> CHECKIN the working resource to create a new version.\n> UPDATE /foo to the new version.  This will result in the VCR\n> at /foo having\n> the same content and dead properties as the new version.\n>\n> > The deltaV draft needs to pick one or another and make a clear\n> > requirement.\n>\n>\n> Tim\n>\n\n\n\n", "id": "lists-006-7385028"}, {"subject": "RE: Splitting off core: where we stan", "content": "> Subversion: bunch o' options\n> Oracle: requires workspaces and baselines\n> Rational: nothing stated publicly :-), but they're doing a\n> bunch of options\n> Xythos: core\n>\n> So... there is certainly support for saying that core by\n> itself is pretty useless and not the focus of most\n> implementors. And if that is the case, then why bother to\n> break it out (with the hope that it gets standardized\n> sooner rather than later).\n\nGreg, I think your data supports my point.  Xythos is the only WebDAV\nserver that is not doing source code control, that is planning to\nimplement any part of DeltaV.  I think I'm the only person designing a\nversioning server that isn't for source control, that has bothered to\nread the entire spec, but then I'm used to daunting technical documents.\n\nLet's take a step back. Originally we had a single document without any\ndistinction between core and options. In response to complaints that it\nwas too complicated, and massive overkill for simple scenarios, we\nlabelled some of the material core and the rest options. Now, there are\nessentially four situations:\n\n(1) Core useful, options useless.\n(2) Core useful alone, options useful.\n(3) Core useless, core + options useful.\n(4) All of DeltaV useless.\n\nIn case (1) our best move is to simply throw away the options and\npublish core.\nIn case (2) we should be able to publish core but since there's\nsignificant demand for the options they ought to be standardized\nrelatively quickly.\nIn case (3) we should throw away the distinction between core and\noptions and publish one monolithic document.\nIn case (4) we should all go home.\n\nKeeping core separate but in the same document is a half-measure that in\nmy view serves no real purpose. I'm particularly unimpressed by the\nargument that standardizing core alone will hold up standardization of\nthe options. If the options aren't interesting enough to stand on their\nown then we should throw them away, not glue them to core so that the\nIESG has to take all-or-nothing. We're trying to design a broadly\nimplementable technical standard, not pork-barrelling in Congress.\n\nLisa\n\n\n\n", "id": "lists-006-7397484"}, {"subject": "Re: Straw poll results so fa", "content": "I have also read the specification, but not at a sufficient level to start\nimplementing.\n\nHowever, I have been tracking the discussion w.r.to the semantic consistency\nissue that Tim so eloquently expressed. That was important for me. The\nsystem that we implemnted (not using Delta-V) did implement several of the\noptions with a simple \"consistency\" model. Hence I wanted to make sure that\nwe would not be forced to reinvent the wheel and worse yet lose the\nsimplicity of our core model.\n\n\n\n", "id": "lists-006-7407440"}, {"subject": "RE: Splitting off core: where we stan", "content": "Lisa,\n\n  I don't know what makes you think we're doing source code control.\nWe're focusing on web content management.  I think source code control\nis already done pretty well by other vendors.\n\n  I also don't see how the categorization is that helpful.  First of\nall, it is clear from the mailing list that the correct category is #2\n(core & options both useful).  Some people just want to implement Core.\nHowever, a large group of people (probably somewhat more than half),\nwill implement at least one option.  I also don't see how the conclusion\nfor your category #2, \"we should be able to publish core but since there's\nsignificant demand for the options they ought to be standardized\nrelatively quickly\" follows.  You are just asserting that if \ncore & options are both useful, they should be split, without stating\na reason for this conclusion.\n\n  There are many valid reasons that a separate DeltaV options standard\nwould proceed more slowly down the standards track other than lack of\ninterest.  First of all, now there will be a second spec for options\nreviewers to examine, which will replicate much of the same introductory\ninformationin the options spec.  Second, there will be a loss of context\ncaused by removing forward references from Core to the options.  Two-way\nlinks are generally more useful than one-way links.  Third, there is the\ncost that both of the split documents would pay while we are waiting for\nthe splitting.  I could go on...\n\n  As far as the politics of this goes, the issue is not \"pork-barreling\"\nthe IESG, but in fracturing the consensus of the working group.  If you\npeel off the support of those folks interested only in Core from the\noptions stuff, and make the folks who think that Core is useless by itself\nunhappy because the stuff that they care about got throw out of the \"fast\ntrack\" spec, I think everyone interested in DeltaV will lose.\n\n--Eric\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault\n> Sent: Thursday, February 08, 2001 10:11 AM\n> To: Greg Stein; ietf-dav-versioning@w3.org\n> Subject: RE: Splitting off core: where we stand\n> \n> \n> > Subversion: bunch o' options\n> > Oracle: requires workspaces and baselines\n> > Rational: nothing stated publicly :-), but they're doing a\n> > bunch of options\n> > Xythos: core\n> >\n> > So... there is certainly support for saying that core by\n> > itself is pretty useless and not the focus of most\n> > implementors. And if that is the case, then why bother to\n> > break it out (with the hope that it gets standardized\n> > sooner rather than later).\n> \n> Greg, I think your data supports my point.  Xythos is the only WebDAV\n> server that is not doing source code control, that is planning to\n> implement any part of DeltaV.  I think I'm the only person designing a\n> versioning server that isn't for source control, that has bothered to\n> read the entire spec, but then I'm used to daunting technical documents.\n> \n> Let's take a step back. Originally we had a single document without any\n> distinction between core and options. In response to complaints that it\n> was too complicated, and massive overkill for simple scenarios, we\n> labelled some of the material core and the rest options. Now, there are\n> essentially four situations:\n> \n> (1) Core useful, options useless.\n> (2) Core useful alone, options useful.\n> (3) Core useless, core + options useful.\n> (4) All of DeltaV useless.\n> \n> In case (1) our best move is to simply throw away the options and\n> publish core.\n> In case (2) we should be able to publish core but since there's\n> significant demand for the options they ought to be standardized\n> relatively quickly.\n> In case (3) we should throw away the distinction between core and\n> options and publish one monolithic document.\n> In case (4) we should all go home.\n> \n> Keeping core separate but in the same document is a half-measure that in\n> my view serves no real purpose. I'm particularly unimpressed by the\n> argument that standardizing core alone will hold up standardization of\n> the options. If the options aren't interesting enough to stand on their\n> own then we should throw them away, not glue them to core so that the\n> IESG has to take all-or-nothing. We're trying to design a broadly\n> implementable technical standard, not pork-barrelling in Congress.\n> \n> Lisa\n> \n> \n\n\n\n", "id": "lists-006-7414931"}, {"subject": "RE: Splitting off core: where we stan", "content": "Working group memebers:\n\nFirst I would like to thank everyone for their interest and hard work. \nThanks to you, we are really making progress on a very hard problem. I am \nparticularly pleased with the mailing list participation (even though its \ngetting hard to keep up). Delta-V is truly a healthy working group. \nHowever, as chair, I am sometimes obligated to arbitrate situations where \nthere is no clear working group consensus, or when conflicting goals make \nit impossible to choose between otherwise valid options. It isn't a \nquestion of who's right or wrong, everyone is right but for different \nreasons. Splitting the document is clearly one of these cases. So I am \nchoosing to submit Delta-V to the IETF as a single document. If this \nproves to be the wrong choice, we can consider other options when the need \narises. So let's put this one behind us and spend some of this valuable \nenergy reviewing those pesky options! Again, thanks to everyone for their \nthoughtful input. With your continued effort, we'll all come out winners.\n\n\n\n", "id": "lists-006-7427806"}, {"subject": "RE: Splitting off core: where we stan", "content": "Lisa,\n\nJust for the record: Our WebDAV/DeltaV server is also \"not doing\nsource code control\" and I have read the entire document (several\ntimes :)\n\nBTW, there's another (more famous) WebDAV server that isn't about\nsource control: Microsoft Exchange 2000 :)\n\nThanks, Ron\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Thursday, February 08, 2001 10:11 AM\nTo: Greg Stein; ietf-dav-versioning@w3.org\nSubject: RE: Splitting off core: where we stand\n\n...  Xythos is the only WebDAV\nserver that is not doing source code control, that is planning to\nimplement any part of DeltaV.  I think I'm the only person designing a\nversioning server that isn't for source control, that has bothered to\nread the entire spec ...\n\n\n\n", "id": "lists-006-7436182"}, {"subject": "RE: Autoversion confusio", "content": "This shouldn't be necessary, since the HTTP spec defines the behavior of GET\nand PUT. Specifically, it says that PUT to a particular resource defines the\nresponse for any following GET on that same resource (I'm paraphrasing from\nmemory). There can't be any other possible interpretation (that doesn't\nbreak HTTP semantics).\n\nJohn\n\n> -----Original Message-----\n> From: Lisa Dusseault [mailto:lisa@xythos.com]\n> Sent: Thursday, February 08, 2001 1:00 PM\n> To: Tim_Ellison@uk.ibm.com; ietf-dav-versioning@w3.org\n> Subject: RE: Autoversion confusion\n> \n> \n> Tim, you've explained this in email before.  I'm not disagreeing with\n> your interpretation but the point is that standards need to be\n> self-contained so that implementors don't need to go read the mailing\n> list archives to achieve interoperability.  Currently, this \n> behavior is\n> underspecified.\n> \n> Here's a proposed addition to section XXX that clarifies how \n> the DeltaV\n> requires implementations to behave:\n> \n> \"In core versioning, while a VCR is checked out it may be the \n> target of\n> multiple write operations.  During this period, other clients \n> MUST still\n> be able to perform read operations on the VCR's URL, and the results\n> MUST show the results of all the write operations that have been\n> performed thus far.  (Note: if a scenario requires hiding a\n> work-in-progress from other clients, the \"working resource\" option can\n> be used.)\"\n> \n> Does this accurately reflect your understanding of how things ought to\n> work? I'm not particularly committed to this language or \n> indeed to this\n> interpretation but the document must pick one and state it explicitly.\n> \n> lisa\n> \n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> > Tim_Ellison@uk.ibm.com\n> > Sent: Thursday, February 08, 2001 2:29 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: RE: Autoversion confusion\n> >\n> >\n> >\n> >\n> > > Tim, what you've described can make sense, but it leaves\n> > > an unspecified hole in the middle.\n> > >\n> > > If a client does a CHECKOUT then a PUT then a GET, what body\n> > > do they see?\n> >\n> > If we are talking about a checked-in version-controlled \n> resource, say\n> > /foo.html, then\n> >\n> > CHECKOUT /foo --> makes /foo.html a checked-out version-controlled\n> > resource,\n> > PUT /foo --> updates the content of the checked-out VCR,\n> > GET /foo --> gets the content of the checked-out VCR (i.e.,\n> > whatever you\n> > just PUT).\n> >\n> > If we are talking about a version, say /his/12/ver/3 (and the server\n> > supports working resources):\n> >\n> > CHECKOUT /his/12/ver/3 --> creates a working resource whose\n> > URL is returned\n> > in the Location: header (say, /wr/45) and leaves the version\n> > unchanged,\n> > PUT /wr/45 --> updates the content of the working resource,\n> > GET /wr/45 --> gets the content of the working resource\n> > (i.e., whatever you just PUT),\n> > GET /his/12/ver/3 --> gets the content of the version (it\n> > will be unchanged\n> > by any of this).\n> >\n> > [Obviously I've left of the http://hostname... from the URLs]\n> >\n> > > You say \"when a version-controlled resource is checked-out, its\n> > > C&DP are not necessarily the same as any version.\"  That's not\n> > > much of a requirement!\n> >\n> > Well once the VCR is checked-out it is mutable, so \n> subsequent PUTs and\n> > PROPPATCHes will be altering its state.  That state is not\n> > captured as a\n> > version (i.e., in version history) until the VCR is checked in.\n> >\n> > > It seems I could implement it such that when a client does\n> > > a CHECKOUT then a PUT then a GET, they see the body that\n> > > existed on the VCR before the checkout.\n> >\n> > That would contradict the 'you now GET what you just PUT' \n> expectation\n> > (requirement?) for a content-bearing resource.\n> >\n> > > On the other hand, you could implement it so that the same\n> > > client does the same CHECKOUT, PUT and GET, and they see\n> > > the body that they PUT, which is NOT the body that existed\n> > > on the VCR before the checkout.\n> >\n> > Yep.  In fact it need not be the same client.  In the example\n> > above, other\n> > clients GETting /foo can see all the state transitions of the VCR.\n> >\n> > If you, as a client, want to hide these intermediate states\n> > for /foo, then\n> > using a working resource would be preferrable.\n> >\n> > CHECKOUT the version to create a working resource.\n> > PUT/PROPPATCH etc the working resource.\n> > CHECKIN the working resource to create a new version.\n> > UPDATE /foo to the new version.  This will result in the VCR\n> > at /foo having\n> > the same content and dead properties as the new version.\n> >\n> > > The deltaV draft needs to pick one or another and make a clear\n> > > requirement.\n> >\n> >\n> > Tim\n> >\n> \n\n\n\n", "id": "lists-006-7445915"}, {"subject": "Re: Splitting off core: where we stan", "content": "Lisa,\n\n> implement any part of DeltaV.  I think I'm the only person designing a\n> versioning server that isn't for source control, that has bothered to\n> read the entire spec, but then I'm used to daunting technical documents.\n>\n\nI don't think this is entirely correct even though it does not take away\nfrom your main point. At different points in time folks from FileNet and\nInterwoven have participated in the review and I would think that they would\nconsider what they do as *not source control*.\n\nCloser to home, we have developed a system that is primarily used for\n'document/content management' and we are hoping to move that on to using\nDELTA-V instead of RMI it currently uses once DELTA-V settles down.\n\nI will post my opinion about your main point in a different email.\n\nSankar\n\n\n\n", "id": "lists-006-7460880"}, {"subject": "Re: Straw poll results so fa", "content": "On Thu, Feb 08, 2001 at 09:25:12AM -0800, Jim Whitehead wrote:\n>...\n> I think we can safely assume Geoff Clemm has read the entire draft, and Greg\n> Stein has also presumably reviewed and/or implemented a fair portion of the\n> options as well.\n\nI seem to recall my last *serious* review, with the intent of finding errors\nand providing feedback, was in July. Since then, I've been reading various\nsections at different times, on and off.\n\nI've pretty much read (several times, in varying detail) through all but the\nworkspace option. I should probably do a hard-core read, though. My\nimplementation has been pretty light, in kind of a breadth-first approach.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-7468730"}, {"subject": "Re: Splitting off core: where we stan", "content": "Lisa,\n\n> (1) Core useful, options useless.\n> (2) Core useful alone, options useful.\n> (3) Core useless, core + options useful.\n> (4) All of DeltaV useless.\n>\n\nThis is one way to phrase the argument. Your argument discretizes the\nchoices where there is a continuum. Therefore, I would like to interject a\ndifferent conceptual view point. As I understand things, the spec. goes from\nserial joint authoring support to more and more parallel joint authoring to\nmerge support. For those interested in supporting features that involve\nparallel joint authoring, semantic consistency of the specification as it\nmoves from serial authoring to parallel authoring is important so that\nwhatever marketing decides, the engineers can digest one model of\nconsistency management and implement features as time permits. The most\nrecent note from John Vasta on this thread sort of points this out. For that\ncrowd (I am one of them), the fact that the specification is the way it is\nhelps us identify and deal with semantic consistency issues particularly\nwhen it comes to implementation. Wading through 4 different documents is not\nfun. For some one like you who has been involved in the discussions\nintimately, parceling the pieces does not raise an issue due to familiarity\nwith the issues and how they were resolved. For some one like me who is not\ntracking all the issues, who is hoping to read the spec. in detail once it\nis done, I don't have any context.\n\nIn my mind, the tradeoff is between losing context and therefore\nconsistency/ease of implementation vs.the one-large-document digesting\nissue.\n\nSince I will be spending more time in implementation than in reading and\ndigesting a spec. document, I vote for optimizing the larger value.\n\nSankar\n\n\n\n", "id": "lists-006-7476000"}, {"subject": "Re: Splitting off core: where we stan", "content": "I believe Lisa was referring to DeltaV servers. Exchange isn't. If we go on\nthat line, mod_dav isn't about source control either.\n\n[ mod_dav as part of Apache 2.0, when the Subversion backend is plugged\n  in... now *that* is very much intended for source control. (but it can do\n  any kind of document, of course) ]\n\nHowever, I think Lisa is being incorrect here. We know Oracle is doing\nDeltaV work. If I were to hazard a guess, I'd say it is for content\nmanagement rather than source control. Oracle's value proposition is a lot\nhigher for large content management problems, compared to applying Oracle to\na source control situation :-)\n\n[ you'll never catch me installing Oracle so that I can manage a few dozen\n  .c files! :-) ]\n\nCheers,\n-g\n\nOn Thu, Feb 08, 2001 at 11:26:18AM -0800, Ron Jacobs wrote:\n> Lisa,\n> \n> Just for the record: Our WebDAV/DeltaV server is also \"not doing\n> source code control\" and I have read the entire document (several\n> times :)\n> \n> BTW, there's another (more famous) WebDAV server that isn't about\n> source control: Microsoft Exchange 2000 :)\n> \n> Thanks, Ron\n> \n> -----Original Message-----\n> From: Lisa Dusseault [mailto:lisa@xythos.com]\n> Sent: Thursday, February 08, 2001 10:11 AM\n> To: Greg Stein; ietf-dav-versioning@w3.org\n> Subject: RE: Splitting off core: where we stand\n> \n> ...  Xythos is the only WebDAV\n> server that is not doing source code control, that is planning to\n> implement any part of DeltaV.  I think I'm the only person designing a\n> versioning server that isn't for source control, that has bothered to\n> read the entire spec ...\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-7484824"}, {"subject": "RE: Splitting off core: where we stan", "content": "> [ you'll never catch me installing Oracle so that I can manage a few dozen\n>   .c files! :-) ]\n> \n> Cheers,\n> -g\n> \n\nGreg--\n\n  I don't know what you're talking about.  The Oracle Installer is\nso easy to use a child could install Oracle.  I use Oracle at home to\nkeep track of all of my recipes ;-)  We're going to be rolling out\nOracle iRecipe with DeltaV support as our first project.\n\n  --Eric\n\n\n\n", "id": "lists-006-7494274"}, {"subject": "Re: Straw poll: what options did you review", "content": "> 1. Have you reviewed all options in the DeltaV protocol specification\nNo, even if I think I read every option at least once :-)\n\n> 2. If no, which options have you reviewed?\nI had a closer look at CHECKOUT, UPDATE, VERSION-HISTORY, WORKSPACE, LABEL\nand BASELINE. Which doesn't mean to say that all other options aren't important.\nThe question is how much time you have.\n\n> 3. If you have implementation experience for one or more options, and can\n> share this experience, which options have you implemented?\nI implemented sort of workspaces and baselines based on RCS some years ago.\nSo I was confined to local scope and would like to see these features also\nbeing available on the Web.\n\nCheers, Edgar\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Native Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-7502162"}, {"subject": "Versioning TeleConf Agenda, 2/9/00 (Friday) 12-1pm ES", "content": "phone: 888 819 8909  pass-code#97985\n\nAgenda:\n\nIs the 12.2 version of the draft ready for submission to the IESG?\n\n(Note: I have two pending changes, namely Juergen's option dependency\ndiagram, and Greg's word change for section 11.3).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-7510357"}, {"subject": "RE: Splitting off core: where we stan", "content": "thanks, greg, that's exactly right.\n\nI'll admit I also classed \"web-site source control management\" along\nwith traditional C/C++/java/whatever source code control, which is what\nmight have confused some people about how I was classifying different\nimplementors.  Web sites with source code under versioning control may\nwell have needs for branching, baselines, I don't know what else.  You\nneed to worry about files being included in other files, using the\ncorrect stylesheet, and so on.  One might reasonably use several of the\nadvanced versioning scenarios to do serious web-site management.\n\nIMHO, doing \"simple document versioning\", the server never needs to\nworry about how one document relates to another.  Each document is\nstand-alone.  No need for baselines, activities, workspaces, or labels.\n\nOf course there's grey area, because many web pages are authored under\nexactly the same conditions as \"simple document versioning\".  And there\nare also large, complex content management problems, like authoring\ntechnical manuals, where separate resources *do* interact.  I'l have to\ncome up with a better term for what I mean.  Maybe:\n \"Versioning system for stand-alone resources\"\n\nWould my statement be true if I said I was the only person designing a\n\"versioning system for stand-alone resources\"?\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Greg Stein\n> Sent: Thursday, February 08, 2001 12:22 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: Splitting off core: where we stand\n>\n>\n> I believe Lisa was referring to DeltaV servers. Exchange\n> isn't. If we go on\n> that line, mod_dav isn't about source control either.\n>\n> [ mod_dav as part of Apache 2.0, when the Subversion backend\n> is plugged\n>   in... now *that* is very much intended for source control.\n> (but it can do\n>   any kind of document, of course) ]\n>\n> However, I think Lisa is being incorrect here. We know Oracle is doing\n> DeltaV work. If I were to hazard a guess, I'd say it is for content\n> management rather than source control. Oracle's value\n> proposition is a lot\n> higher for large content management problems, compared to\n> applying Oracle to\n> a source control situation :-)\n>\n> [ you'll never catch me installing Oracle so that I can\n> manage a few dozen\n>   .c files! :-) ]\n>\n> Cheers,\n> -g\n>\n> On Thu, Feb 08, 2001 at 11:26:18AM -0800, Ron Jacobs wrote:\n> > Lisa,\n> >\n> > Just for the record: Our WebDAV/DeltaV server is also \"not doing\n> > source code control\" and I have read the entire document (several\n> > times :)\n> >\n> > BTW, there's another (more famous) WebDAV server that isn't about\n> > source control: Microsoft Exchange 2000 :)\n> >\n> > Thanks, Ron\n> >\n> > -----Original Message-----\n> > From: Lisa Dusseault [mailto:lisa@xythos.com]\n> > Sent: Thursday, February 08, 2001 10:11 AM\n> > To: Greg Stein; ietf-dav-versioning@w3.org\n> > Subject: RE: Splitting off core: where we stand\n> >\n> > ...  Xythos is the only WebDAV\n> > server that is not doing source code control, that is planning to\n> > implement any part of DeltaV.  I think I'm the only person\n> designing a\n> > versioning server that isn't for source control, that has\n> bothered to\n> > read the entire spec ...\n>\n> --\n> Greg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-7518082"}, {"subject": "RE: Versioning TeleConf Agenda, 2/9/00 (Friday) 12-1pm ES", "content": "Geoff,\n\nCould you please post a schedule for how the document will be handled from\nhere if it is approved to be sent to IESG (dates and document stages, how\npublic voting is handled, etc.)?\n\nThanks,\n\nMark\n\n\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Thursday, February 08, 2001 4:04 PM\n> To: 'ietf-dav-versioning@w3.org'\n> Subject: Versioning TeleConf Agenda, 2/9/00 (Friday) 12-1pm EST\n>\n>\n> phone: 888 819 8909  pass-code#97985\n>\n> Agenda:\n>\n> Is the 12.2 version of the draft ready for submission to the IESG?\n>\n> (Note: I have two pending changes, namely Juergen's option dependency\n> diagram, and Greg's word change for section 11.3).\n>\n> Cheers,\n> Geoff\n\n\n\n", "id": "lists-006-7530108"}, {"subject": "RE: Straw poll: what options did you review", "content": "> 1. Have you reviewed all options in the DeltaV protocol specification\n> (Yes/No).\n\nYes, but in many cases my review was last fall, so I can't claim to be up to\ndate.\n\n> 2. If no, which options have you reviewed?\n>\n> 3. If you have implementation experience for one or more \n> options, and can share this experience, which options have\n> you implemented?\n\nNone.\n\n--Chuck Fay \nFileNET Corporation, 3565 Harbor Blvd., Costa Mesa, CA 92626 \nphone:  (714) 327-3513, fax:  (714) 327-5076, email:  cfay@filenet.com\n\n\n\n", "id": "lists-006-7539502"}, {"subject": "Re: Versioning TeleConf Agenda, 2/9/00 (Friday) 12-1pm ES", "content": "   From: \"Mark A. Hale\" <mark.hale@interwoven.com>\n\n   Could you please post a schedule for how the document will be handled from\n   here if it is approved to be sent to IESG (dates and document stages, how\n   public voting is handled, etc.)?\n\nThe description of IETF standardization process is defined in\nan internet standard (of course :-), namely RFC 2026, with a\npointer on the www.ietf.org home page.\n\nIn particular, at this stage, a standards action is submitted\nby the IETF Working Group Chair (Jim Amsden for DeltaV) to its\narea director, copied to the IETF Secretariat.\n\nThe IESG initiates an IESG last call period (of no less than\ntwo weeks).  Then the IESG will make a final determination\n\"in a timely fashion\" after the last call period expires,\nwhether or not to approve the standards action, and will\nnotify the IETF via the mailing list of its decision.\n\n(No public voting ... it is the IESG that decides, but they\ncan ask for outside reviewers if they decide that is appropriate).\n\nThere are then additional procedures for advancing on the\nstandards track (e.g. from proposed standard to draft standard).\nIn particular, draft standard status requires operational experience\nwith the effective interoperability of two implementations with\ndistinct code bases.\n\nThere are a lot more details in RFC 2026.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-7547562"}, {"subject": "Re: DTD Confusio", "content": "A compromise suggestion for those interested in DTD's:\n\nEach of the WebDAV messages are a separate XML document.\nIf you design a separate DTD for each WebDAV message type\n(i.e. one for a PROPFIND request, one for a PROPFIND response,\none for a CHECKIN request, etc.), I believe you will find\nthat all the anomalies disappear.  In addition,\nI believe this will produce a set of much more manageable,\nextensible DTD's than would be provided by trying to\namass all WebDAV DTD information into one massive DTD.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-7556613"}, {"subject": "Re: DeltaV Lack of global propertie", "content": "Just for interests sake, what would be the locking behavior of these\n\"shared\" (a term I'd slightly prefer over \"global\" or \"mutable\")\nproperties?  If you lock a version, does that prevent change to that\nproperty on all versions?  Are shared properties unaffected by write\nlocks?\n\nNote that although I'm always interested in exploring worthwhile\nextensions to the WebDAV protocol, I'll point out that the versioning\nprotocol has received some criticism for being too complex because of\ntoo many options, so I'm very reluctant to add even more options\nbefore the IESG has a chance to review the ones that have already been\ndesigned and reviewed.\n\nCheers,\nGeoff\n\n   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   > Mutable properties are application defined properties on a\n   > version resource\n   > or version controlled resource with the following characteristics:\n   >\n   >    1. they can be changes at any time by a WebDAV client; and\n   >\n   >    2. they are cleared on a target version resource when that\n   > resource is checked out.\n\n   Can you explain this?  By \"target version resource\", do you mean when a\n   new version is created with checkout, that mutable properties are\n   cleared?  That does make sense.\n\n   > This is certainly better than nothing, but three problems remain:\n   >\n   >   1. how can one trace who changed this property last;\n\n   We don't trace who makes changes to regular properties in WebDAV.  I\n   would call this out of scope.  A server can always do event logging\n   according to its own design, without interfering with WebDAV.\n\n   >   2. how can access to such a property be controlled; and\n\n   I can tell you, this group will definitely not address property access.\n   The ACL discussion may address property access control at some point.\n\n   >   3. how can standard mutable properties be defined later?\n\n   Lots of ways...\n    - PROPPATCH could be extended to have an extra XML element or attribute\n   to declare a new property mutable (PROPFIND may be extended to have the\n   same)\n    - A new method like CREATE-MUTABLE could create new mutable properties,\n   which thereafter are set/read with PROPPATCH/PROPFIND.  In order to find\n   out which properties are mutable, one could define a REPORT\n   \"mutable-properties\".  This has the advantage of not requirng changes to\n   PROPPATCH/PROPFIND.\n    - Two new methods mirroring PROPPATCH/PROPFIND:  PATCH-MUTABLE and\n   FIND-MUTABLE.  Presumably they'd duplicate the syntax, but only work\n   with mutable properties on versions.  (kind of icky, if you ask me, but\n   it's an idea).\n\n   lisa\n\n   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   > Just to be pedantic for a minute, if the client was totally\n   > versioning unaware then they would be unaware that versions of\n   > the resource exist, or the need for \"global\" properties.  A\n   > versioning unaware client would set a dead property on an\n   > autoversioned version-controlled resource, and that would be\n   > carried forward through subsequent versions of the resource.\n\n   But they would be aware of the need for a property like\n   \"Editor-in-Chief\", they may need to get or set the value of this\n   property.\n\n   > Ok, so if a client was, say, versioning aware (i.e., knows\n   > versions exist) but versioning challenged<g> (i.e., cannot make\n   > versioning calls) then they could query the DAV:version-history\n   > property of the VCR (using PROPFIND) to get to the version\n   > history resource and set properties there (using PROPPATCH).  It\n   > would not require any versioning specific methods to implement\n   > the \"global\" properties.\n\n   But they would also potentially know about the property\n   \"Editor-in-Chief\".  And the versioning-aware client can look at\n   past versions, where the \"Editor-in-Chief\" property really should\n   not have a different value.\n\n   So how are the two clients supposed to use the same property\n   interoperably?\n\n\n\n", "id": "lists-006-7563835"}, {"subject": "Re: DTD Confusio", "content": "Excellent suggestion Geoff! I couldn't agree more. However, this is really \na WebDAV issue too, so the WebDAV working group should get involved. If \nthey aren't interested in providing DTDs, then there probably isn't much \npoint in Delta-V doing providing a partial set. Also note that having the \nDTDs should never require clients or servers to use them. They won't help \nformalize the extensions either. Personally I'm more interested in getting \nthe semantics understood and formalized. DTDs can't do this, they only do \nstructure. A good, complete object model, including behavior, state \nmodels, and/or interaction diatrams (or collaboration graphs depending on \nyour preference) would be much more useful.\n\n\n\n\n\n\n\"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com>\nSent by: ietf-dav-versioning-request@w3.org\n02/08/2001 10:03 PM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        Re: DTD Confusion\n\n \n\n\nA compromise suggestion for those interested in DTD's:\n\nEach of the WebDAV messages are a separate XML document.\nIf you design a separate DTD for each WebDAV message type\n(i.e. one for a PROPFIND request, one for a PROPFIND response,\none for a CHECKIN request, etc.), I believe you will find\nthat all the anomalies disappear.  In addition,\nI believe this will produce a set of much more manageable,\nextensible DTD's than would be provided by trying to\namass all WebDAV DTD information into one massive DTD.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-7575489"}, {"subject": "RE: Versioning TeleConf Agenda, 2/9/00 (Friday) 12-1pm ES", "content": "> Then the IESG will make a final determination\n> \"in a timely fashion\" after the last call period expires,\n> whether or not to approve the standards action, and will\n> notify the IETF via the mailing list of its decision.\n>\n> (No public voting ... it is the IESG that decides, but they\n> can ask for outside reviewers if they decide that is appropriate).\n\nIn particular, it is my understanding that voting in the IESG is such that\nIESG members who have not reviewed the specification generally abstain.\nHowever, it only takes one yes vote, from an IESG member who has reviewed\nthe specification, to allow the specification to move forward.  Thus, once\nthe specification finishes IESG last call, the critical path then becomes\nthe review by at least one of the IESG members. Typically, the IESG member\nwho reviews a specification is the working group's area director. In theory\nthe review can go quickly, but in practice this tends to take several months\n(this is what Larry Masinter is referring to with his \"square of the length\nof the spec.\" rule of thumb).\n\nOnce the AD review is complete, there are generally a small number of issues\nthat must be addressed by the working group before the AD will give it a yes\nvote in an IESG meeting.  Feedback from the AD does not typically affect the\ncore data model or abstractions provided by the protocol, but this is, in\ntheory, possible.  After the working group addresses these comments from the\nAD (and incorporates any other changes that have accumulated during the\nwait), and submits a new I-D, the IESG then reviews the document.\n\n- Jim\n\n\n\n", "id": "lists-006-7584778"}, {"subject": "RE: Splitting off core: where we stan", "content": "Based on the opinions expressed by working group members (which tend to\nfavor keeping the document together more than splitting it apart), I agree\nwith the Chair's decision, and will abide by it. I agree that we should\nfocus our energy on reviewing options.\n\n- Jim\n  -----Original Message-----\n  From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n  Sent: Thursday, February 08, 2001 11:20 AM\n  To: ietf-dav-versioning@w3.org\n  Subject: RE: Splitting off core: where we stand\n\n\n\n  Working group memebers:\n\n  First I would like to thank everyone for their interest and hard work.\nThanks to you, we are really making progress on a very hard problem. I am\nparticularly pleased with the mailing list participation (even though its\ngetting hard to keep up). Delta-V is truly a healthy working group. However,\nas chair, I am sometimes obligated to arbitrate situations where there is no\nclear working group consensus, or when conflicting goals make it impossible\nto choose between otherwise valid options. It isn't a question of who's\nright or wrong, everyone is right but for different reasons. Splitting the\ndocument is clearly one of these cases. So I am choosing to submit Delta-V\nto the IETF as a single document. If this proves to be the wrong choice, we\ncan consider other options when the need arises. So let's put this one\nbehind us and spend some of this valuable energy reviewing those pesky\noptions! Again, thanks to everyone for their thoughtful input. With! ! !\nyour continued effort, we'll all come out winners.\n\n\n\n", "id": "lists-006-7593334"}, {"subject": "RE: DTD Confusio", "content": "Well, I personally have had mixed emotions concerning the value of DTDs in\nthe protocol specification.  When DTDs come up, half of the time I curse\nYaron for pushing DAV into using XML in the first place.  But, then there\nare times, such as when editing the ACL specification recently, where the\nact of creating the DTD uncovered several errors in the XML aspects of the\nspecification, and DTDs seem like a good thing.\n\nIf someone with deep implementation experience like Hartmut Warncke feels\nthat appropriate use of DTDs would have saved some interoperability\nproblems, then it seems like the 3-5 hours to produce these DTDs would be\nworthwhile (it didn't take that long to produce the ACL spec. one, even with\nfixing the errors I found).\n\nAs for the per-method DTD, this seems like a good idea, one worth exploring\nin the revision of RFC 2518.\n\nOf course, this is all subject to the caveat that the WebDAV XML rules not\nbe interfered with (i.e., sibling ordering is not guaranteed, the XML\nnamespace append rules, and the unknown element ignore rule).  I'm also not\nin favor of sending the URL of the DTD in every message -- what a waste of\nbandwidth, since clients and servers won't be doing dynamic validation.\n\n- Jim\n\n  Excellent suggestion Geoff! I couldn't agree more. However, this is really\na WebDAV issue too, so the WebDAV working group should get involved. If they\naren't interested in providing DTDs, then there probably isn't much point in\nDelta-V doing providing a partial set. Also note that having the DTDs should\nnever require clients or servers to use them. They won't help formalize the\nextensions either. Personally I'm more interested in getting the semantics\nunderstood and formalized. DTDs can't do this, they only do structure. A\ngood, complete object model, including behavior, state models, and/or\ninteraction diatrams (or collaboration graphs depending on your preference)\nwould be much more useful.\n\n\n\n", "id": "lists-006-7602732"}, {"subject": "VERSION-CONTROL status reportin", "content": "In the 12.2 draft, Section 2.5 states:\n\n> If the request-URL identifies a version-controlled resource,\n> the resource just remains under version-control.  This allows\n> a client to be unaware of whether or not a server automatically\n> puts a resource under version control when it is created.\n\nAnd then lists as a Postcondition:\n\n> (DAV:already-under-version-control): If the request-URL identified\n> a resource already under version control at the time of the request,\n> the VERSION-CONTROL request MUST NOT change the DAV:checked-in or\n> DAV:checked-out property of that version-controlled resource.\n\nSection 1.6 then leads one to believe that this condition would result in a\n403 or a 409 status response, even though this appears to be normal\noperation, and hence would warrant a 200 OK response.\n\nGeoff Clemm's message of February 4, 2001\n(http://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0311.htm\nl) makes it sound like this Postcondition would be dropped.  Is it\nintentionally still in the draft?\n\n- Jim\n\n\n\n", "id": "lists-006-7611403"}, {"subject": "Status reporting comment", "content": "At present, the DeltaV specification leaves it up to implementors to\ndetermine whether to return a 403 or a 409 for precondition and\npostcondition errors.  Since the specification doesn't provide explicit\nguidance on this topic, it seems likely that this will lead to different\nimplementations making different decisions.  Since these status codes do\nhave slightly different semantics (one the client might want to resubmit\n(409), the other the client should not resubmit(403)), this is unfortunate,\nsince it will lead clients to lump 403 and 409 together, presumably never\nattempting to resubmit since the resubmit semantics of 403/409 cannot be\ndepended upon.\n\nOne way to rectify this is to explicitly note which of the status codes\nshould be returned next to the precondition/postcondition XML element name,\nwhen it is possible to determine that only one status code will ever apply.\nIn cases where it could depend, both 403/409 could be indicated.\n\nAlso, I think the specification should explicitly note that the IETF\ncontrols the namespace of error XML elements, and that implementations are\nNOT free to create these XML elements willy-nilly if they encounter error\nconditions not forseen by the specification.\n\n- Jim\n\n\n\n", "id": "lists-006-7619650"}, {"subject": "RE: VERSION-CONTROL status reportin", "content": "> And then lists as a Postcondition:\n>\n> > (DAV:already-under-version-control): If the request-URL identified\n> > a resource already under version control at the time of the request,\n> > the VERSION-CONTROL request MUST NOT change the DAV:checked-in or\n> > DAV:checked-out property of that version-controlled resource.\n>\n\nHmm, I think I was thrown off by the title of this precondition.  It seems\nthat the purpose of the postcondition is to flag when the property invariant\n(DAV:checked-in' == DAV:checked-in) ^ (DAV:checked-out' == DAV:checked-out)\ncannot be maintained, and so the name of the postcondition really should be\nsomething like \"DAV:property-invariant-violated\".\n\n- Jim\n\n\n\n", "id": "lists-006-7627972"}, {"subject": "Workspace option comment", "content": "1) Ambiguity of the term \"resource\".\n\nSection 7.1.1, DAV:workspace-checkout-set property:\n\n> This property identifies each checked-out resource whose\n> DAV:workspace property identifies this workspace.\n\nDoes this property identify a \"version controlled resource\", or\na \"version resource\" (or both)? (Or \"version history resource?\") Just\nsaying \"resource\" is ambiguous.\n\nThe same problem affects Section 7.2.1 (DAV:Workspace). If a\nserver OPTIONally supports this property, which types of\nresources should have this property defined on it?  Is this\ndefined on \"version controlled resources\" or \"version\nresources\" (or both)?  Also, it sounds like non-version-controlled\nresources should also support this property.  Should\n\"version history resources\" support this property -- I can't\nsee much need for that, but maybe there is a use case.\n\n2) Section 7.7\n\nThis section is being defined as a delta to the definition of\nVERSION-CONTROL given in Section 2.5, which states:\n\n> (DAV:put-under-version-control): If the request-URL identified\n> a versionable resource at the time of the request, a new version\n> history is created and a new version resource is created in the\n> new version history.\n\nSince this isn't the intent in 7.7, there needs to be explicit\nlanguage stating that, when a version resource is specified in the\nrequest body, a new version history resource is NOT created. A new\ndefinition of the (DAV:put-under-version-control) postcondition is\nalso needed in this case.\n\n3) Child workspaces of workspaces?\n\nIs it possible for a workspace to be contained by another workspace?\nThe specification is silent on this issue, though the definition\nof workspaces as collections suggests that yes, a workspace can\ncontain a child workspace.\n\n4) Are workspaces versionable?\n\nIs it possible to place a workspace under version control using the\nVERSION-CONTROL method?  The specification is silent on this topic.\n\nMinor nits:\n\nSection 7.1:\n\n> The workspace option introduces the following REQUIRED\n> properties for a workspace.\n\nBut there is only one property (singular) introduced.\n\nThe same comment applies to Section 7.2\n\nSection 7.2.1:\n\n> If the resource is associated with a workspace, this\n> property MUST identifies this workspace.\n\nidentifies --> identify\n\nHmm, it stretches credulity that 7+ people could have carefully reviewed\nthis option and not caught at least these nits, if not the other issues.\n\n- Jim\n\n\n\n", "id": "lists-006-7635631"}, {"subject": "Antwort: Versioning TeleConf Agenda, 2/9/00 (Friday) 12-1pm ES", "content": "Hello,\n\nI won't teleconference but nevertheless I think the options dependency diagram\nis a good idea because in practice options aren't independant.\nProbably it's just not possible to define all options orthogonal.\n\nMit freundlichen Gr??en / Best regards\n\nEdgar Schwarz\n\n--\nEdgar.Schwarz@marconi.com, Postf. 1920, D-71509 Backnang,+49 7191 13 3382,\nMarconi Communications, Access Division, Quality and Process Improvement\nPrivat kann jeder soviel C programmieren oder Videos ansehen wie er mag\n(Niklaus Wirth). Make it as simple as possible, but not simpler (A.Einstein)\n\n\n|--------+----------------------->\n|        |          \"Clemm,      |\n|        |          Geoff\"       |\n|        |          <gclemm@ratio|\n|        |          nal.com>     |\n|        |                       |\n|        |          09.02.2001   |\n|        |          01:04        |\n|        |                       |\n|--------+----------------------->\n  >----------------------------------------------------------------------------|\n  |                                                                            |\n  |       An:     \"'ietf-dav-versioning@w3.org'\" <ietf-dav-versioning@w3.org>  |\n  |       Kopie:  (Blindkopie: Edgar Schwarz/MAIN/MC1)                         |\n  |       Thema:  Versioning TeleConf Agenda, 2/9/00 (Friday) 12-1pm EST       |\n  >----------------------------------------------------------------------------|\n\n\n\n\n\n\nphone: 888 819 8909  pass-code#97985\n\nAgenda:\n\nIs the 12.2 version of the draft ready for submission to the IESG?\n\n(Note: I have two pending changes, namely Juergen's option dependency\ndiagram, and Greg's word change for section 11.3).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-7645289"}, {"subject": "RE: Autoversion confusio", "content": "John wrote:\n> This shouldn't be necessary, since the HTTP spec\n> defines the behavior of GET and PUT. Specifically,\n> it says that PUT to a particular resource defines\n> the response for any following GET on that same\n> resource (I'm paraphrasing from memory). There\n> can't be any other possible interpretation (that\n> doesn't break HTTP semantics).\n\nI agree with John.\n\nAt the risk of nagging<g>, a version-controlled resource is an honest to\ngoodness WebDAV resource, with content and properties (version-controlled\ncollections have members and properties).  Intuatively, if a PUT to the\nresource succeeds (200 OK) then a client is entitled to believe they will\nGET the same entity back.\n\np.s.\nI had a quick look through the HTTP/1.1 spec, and didn't see anything that\nstates this categorically.  In fact, Section 9.6 (PUT) states:\n \"HTTP/1.1 does not define how a PUT method affects the state of an origin\nserver.\"\nNow, how many clients do a GET just to check what they actually will\nretrieve after a successful PUT!\n\nTim\n\n\n\n", "id": "lists-006-7654386"}, {"subject": "Re: Status reporting comment", "content": "Jim wrote:\n> At present, the DeltaV specification leaves it up\n> to implementors to determine whether to return a\n> 403 or a 409 for precondition and postcondition\n> errors.  Since the specification doesn't provide\n> explicit guidance on this topic, it seems likely\n> that this will lead to different implementations\n> making different decisions.  Since these status\n> codes do have slightly different semantics (one\n> the client might want to resubmit (409), the\n> other the client should not resubmit(403)), this\n> is unfortunate, since it will lead clients to\n> lump 403 and 409 together, presumably never\n> attempting to resubmit since the resubmit\n> semantics of 403/409 cannot be depended upon.\n\nI tried this for an earlier revision of the spec., but didn't get any\nsupport for it.\n(\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0142.html)\n\n\n> One way to rectify this is to explicitly note which\n> of the status codes should be returned next to the\n> precondition/postcondition XML element name, when\n> it is possible to determine that only one status\n> code will ever apply.  In cases where it could\n> depend, both 403/409 could be indicated.\n\nWe can give it a shot and I'm happy to provide my updated list, but I'm\nreluctant to getting into a big discussion about whether/why a particular\ncondition is a 403 or 409 or either.\n\n> Also, I think the specification should explicitly\n> note that the IETF controls the namespace of error\n> XML elements, and that implementations are NOT free\n> to create these XML elements willy-nilly if they\n> encounter error conditions not forseen by the specification.\n\nI disagree.  I think it is sufficient to reserve the DAV: namespace, and if\nI choose to return\n     <IBM:bad-hair-day/>\nas a reason for not doing something, then I don't see that it will be\ndetrimental to other clients.\n\nTim\n\n\n\n", "id": "lists-006-7662763"}, {"subject": "Submitting DeltaV as Informational RFC?           (was: Splitting off core: where we stand", "content": "Following the recent discussion about the maturity of DeltaV, I wonder if\nit might be an option to submit DeltaV as an informational RFC.  On the\none hand, this might satisfy people that want to see some 'official' RFC\nbefore starting to work on software.  On the other hand, an informational\nRFC is probably much easier to change than a proposed standard RFC, which\nis a standard tracks document.\n\nJust have a look at the HTTP protocol:  As of May 1996, HTTP was still\nissued as informational RFC (RFC 1945), although there had been HTTP\nserver implementations running since 1990, i.e. for about 6 years.  HTTP\nswitched to a proposed standard not earlier than in January 1997 (RFC\n2068).  The bottom line here is, that HTTP became a proposed standard not\nbefore there were many implementations available revealing all the\nbugs and weaknesses of earlier HTTP protocol versions.  In my opinion,\nWebDAV suffers from this experience; and DeltaV should do it better than\nWebDAV!\n\nGreetings,\n            Juergen\n\n\n\n", "id": "lists-006-7671867"}, {"subject": "Re: Workspace option comment", "content": "On Fri, Feb 09, 2001 at 12:03:09AM -0800, Jim Whitehead wrote:\n> 1) Ambiguity of the term \"resource\".\n> \n> Section 7.1.1, DAV:workspace-checkout-set property:\n> \n> > This property identifies each checked-out resource whose\n> > DAV:workspace property identifies this workspace.\n> \n> Does this property identify a \"version controlled resource\", or\n> a \"version resource\" (or both)? (Or \"version history resource?\") Just\n> saying \"resource\" is ambiguous.\n\n\"checked-out resource\" refers to a VCR that has been checked out, or to a\nworking resource (which is, by definition, checked out from a version\nresource).\n\nSo \"resource\" doesn't exist in that phrase, just \"checkedout resource\" :-)\n\n>...\n> Hmm, it stretches credulity that 7+ people could have carefully reviewed\n> this option and not caught at least these nits, if not the other issues.\n\nWho said how careful they were? I'm sure everybody has applied a different\nlevel. Whether \"credulity\" is an issue or not, the underlying question is\nwhether additional review is need before submitting last call.\n\nAre those nits enough to prevent last call? Hardly.\n\nThe other four issues? Possibly.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-7680909"}, {"subject": "Re: Workspace option comment", "content": "> 1) Ambiguity of the term \"resource\".\n>\n> Section 7.1.1, DAV:workspace-checkout-set property:\n>\n> > This property identifies each checked-out resource\n> > whose DAV:workspace property identifies this workspace.\n>\n> Does this property identify a \"version controlled\n> resource\", or a \"version resource\" (or both)? (Or\n> \"version history resource?\") Just saying \"resource\"\n> is ambiguous.\n\nThe term \"checked-out resource\" is used consistently through the document.\nIt refers to a checked-out version-controlled resource, and, if the\nworking-resource OPTION is supported) a working resource.\n\nNote that a \"version resource\" is by definition a checked-in resource.\nA version history resource is not a versionable resource (and therefore\ncannot be checked in/out).\n\nMaybe the term \"checked-out resource\" should be added to Section 1.4 Terms?\n\n> The same problem affects Section 7.2.1 (DAV:Workspace).\n> If a server OPTIONally supports this property, which\n> types of resources should have this property defined\n> on it?  Is this defined on \"version controlled\n> resources\" or \"version resources\" (or both)?  Also,\n> it sounds like non-version-controlled resources should\n> also support this property.  Should \"version history\n> resources\" support this property -- I can't see much\n> need for that, but maybe there is a use case.\n\nAny resource that is a member of the workspace will have this property, so\n\"yes\" for version-controlled resources and unversioned resources etc., that\nare associated with the workspace, and \"no\" for version resources and\nversion history resources since they are created by the server in\n'server-generated URL' namespace which typically would not be in a\nworkspace.\n\n> 2) Section 7.7\n>\n> This section is being defined as a delta to the definition\n> of VERSION-CONTROL given in Section 2.5, which states:\n>\n> > (DAV:put-under-version-control): If the request-URL identified\n> > a versionable resource at the time of the request, a new version\n> > history is created and a new version resource is created in the\n> > new version history.\n>\n> Since this isn't the intent in 7.7, there needs to be\n> explicit language stating that, when a version resource\n> is specified in the request body, a new version history\n> resource is NOT created. A new definition of the\n> (DAV:put-under-version-control) postcondition is also\n> needed in this case.\n\nSection 2.5 is describing the case when there is no <DAV:version> body\nspecified, and that holds equally true in Section 7.7.\n\nThe Section 7.7 precondition (DAV:cannot-add-to-existing-history) handles\nthe case of trying to bring another versionable resource under version\ncontrol with a <DAV:version> body.  I think that the 7.7 preamble\n\"...create a new version-controlled resource for an existing version\nhistory.\" and this precondition are sufficient.  Am I missing something?\n\n> 3) Child workspaces of workspaces?\n>\n> Is it possible for a workspace to be contained by another\n> workspace?  The specification is silent on this issue,\n> though the definition of workspaces as collections suggests\n> that yes, a workspace can contain a child workspace.\n\nSince it is not explicitly disallowed, then yes you can.\n\nYou'll see in Section '7.2.1 DAV:workspace' that the DAV:workspace of a\nworkspace MUST identify itself, and all other resources MUST have the same\nDAV:workspace value as their parent collection.  This means that the\nworkspace containment is constrained to follow the collection containment\n(otherwise things get really freaky).\n\n> 4) Are workspaces versionable?\n>\n> Is it possible to place a workspace under version control\n> using the VERSION-CONTROL method?  The specification is\n> silent on this topic.\n\nA workspace is a collection, so if the server supports versioned\ncollections, then yes, a workspace can be versioned.\n\n> Minor nits:\n>\n> Section 7.1:\n>\n> > The workspace option introduces the following REQUIRED\n> > properties for a workspace.\n>\n> But there is only one property (singular) introduced.\n>\n> The same comment applies to Section 7.2\n\nI went back to my marked-up copy of the spec., and yes, I did miss it :-(\n\n> Section 7.2.1:\n>\n> > If the resource is associated with a workspace, this\n> > property MUST identifies this workspace.\n>\n> identifies --> identify\n\nThis was introduced since I last read that section.  Geez you'd think he\ncould type properly<g>\n\n> Hmm, it stretches credulity that 7+ people could have\n> carefully reviewed this option and not caught at least\n> these nits, if not the other issues.\n\nI'm only owning up to the plural/singual nits, the other stuff passes\nmuster with me.\n\n...but there have been a few revisions since my last detailed read through\nfront-to-back, maybe it's time to do it again.\n\nTim\n\n\n\n", "id": "lists-006-7689117"}, {"subject": "Security through Obscurit", "content": "This is Section 18.3 (in -12.2) ... I read the text and it makes sense, but\nnot under this heading?\n\nTim\n\n\n\n", "id": "lists-006-7701182"}, {"subject": "RE: DTD Confusio", "content": "I agree with all of Jim's points below.\n\nMy only thought was that if the DTD advocates were comfortable with\nthis statement, that I could add a statement in the notation\nconvention section that the document specifies the DTD for each type of\nmessage, and that the definition of an element in the DTD of one\ntype of message can in general differ from the DTD for that element in\nanother\ntype of message.  For example, the DAV:set element in PROPFIND and the\nLABEL method.\n\nCheers,\nGeoff \n\n-----Original Message-----\nFrom: Jim Amsden [mailto:jamsden@us.ibm.com]\n\n... this is really a WebDAV issue too, so the WebDAV working group should\nget involved. If they aren't interested in providing DTDs, then there\nprobably isn't much point in Delta-V doing providing a partial set. Also\nnote that having the DTDs should never require clients or servers to use\nthem. They won't help formalize the extensions either. Personally I'm more\ninterested in getting the semantics understood and formalized. DTDs can't do\nthis, they only do structure. A good, complete object model, including\nbehavior, state models, and/or interaction diatrams (or collaboration graphs\ndepending on your preference) would be much more useful. \n\n\n\n\n\"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com> \n\nA compromise suggestion for those interested in DTD's:\n\nEach of the WebDAV messages are a separate XML document.\nIf you design a separate DTD for each WebDAV message type\n(i.e. one for a PROPFIND request, one for a PROPFIND response,\none for a CHECKIN request, etc.), I believe you will find\nthat all the anomalies disappear.  In addition,\nI believe this will produce a set of much more manageable,\nextensible DTD's than would be provided by trying to\namass all WebDAV DTD information into one massive DTD.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-7708129"}, {"subject": "RE: Status reporting comment", "content": "The choice of whether to return a 403 or a 409 was deliberately\nleft up to the server.  This will commonly depend on what options\nare supported by the server.  Even if the protocol today makes\nit likely that only one of these status codes is returned by a\nserver, I would not want to state this in the protocol, to leave\nroom for servers that end up being more constrained or less constrained\nby future extensions to the protocol.  Is this OK with you Jim?\n\nI completely agree with Jim's point about IETF controlling the error\nnamespace, and will make this addition to the protocol unless\nthere are any objections.\n\nCheers,\nGeoff \n\n-----Original Message-----\nFrom: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\nSent: Friday, February 09, 2001 1:51 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Status reporting comments\n\n\nAt present, the DeltaV specification leaves it up to implementors to\ndetermine whether to return a 403 or a 409 for precondition and\npostcondition errors.  Since the specification doesn't provide explicit\nguidance on this topic, it seems likely that this will lead to different\nimplementations making different decisions.  Since these status codes do\nhave slightly different semantics (one the client might want to resubmit\n(409), the other the client should not resubmit(403)), this is unfortunate,\nsince it will lead clients to lump 403 and 409 together, presumably never\nattempting to resubmit since the resubmit semantics of 403/409 cannot be\ndepended upon.\n\nOne way to rectify this is to explicitly note which of the status codes\nshould be returned next to the precondition/postcondition XML element name,\nwhen it is possible to determine that only one status code will ever apply.\nIn cases where it could depend, both 403/409 could be indicated.\n\nAlso, I think the specification should explicitly note that the IETF\ncontrols the namespace of error XML elements, and that implementations are\nNOT free to create these XML elements willy-nilly if they encounter error\nconditions not forseen by the specification.\n\n- Jim\n\n\n\n", "id": "lists-006-7717281"}, {"subject": "RE: DTD Confusio", "content": "I agree with all of Jim's points below, and just to make sure that\nthere is no misunderstanding of my position, I would\nvigorously object to any requirement of any kind wrt the presence\nof DTD in WebDAV messages (other than the requirement that they\nbe optional :-).\n\nMy suggestion was just intended as a way to allow the DTD folks to \nget what they need, while clarifying that the protocol will only\nbe concerned with intra-message, not inter-message DTD consistency.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\nSent: Friday, February 09, 2001 1:05 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: DTD Confusion\n\n\nWell, I personally have had mixed emotions concerning the value of DTDs in\nthe protocol specification.  When DTDs come up, half of the time I curse\nYaron for pushing DAV into using XML in the first place.  But, then there\nare times, such as when editing the ACL specification recently, where the\nact of creating the DTD uncovered several errors in the XML aspects of the\nspecification, and DTDs seem like a good thing.\n \nIf someone with deep implementation experience like Hartmut Warncke feels\nthat appropriate use of DTDs would have saved some interoperability\nproblems, then it seems like the 3-5 hours to produce these DTDs would be\nworthwhile (it didn't take that long to produce the ACL spec. one, even with\nfixing the errors I found).\n \nAs for the per-method DTD, this seems like a good idea, one worth exploring\nin the revision of RFC 2518.\n \nOf course, this is all subject to the caveat that the WebDAV XML rules not\nbe interfered with (i.e., sibling ordering is not guaranteed, the XML\nnamespace append rules, and the unknown element ignore rule).  I'm also not\nin favor of sending the URL of the DTD in every message -- what a waste of\nbandwidth, since clients and servers won't be doing dynamic validation.\n\n- Jim\n\n\n\n", "id": "lists-006-7726693"}, {"subject": "RE: VERSION-CONTROL status reportin", "content": "The name of this postcondition probably should be changed to\nsomething like \"DAV:must-not-change-existing-checked-in-out\".\nIt just says that a server must return a 403/409 if it cannot\nsatisfy this condition.  It's hard to imagine how a server could\nfail to satisfy the postcondition that tells it to leave something\nalone, but I gave it a name since all the other postconditions have names.\n\nThe \"return this on success\" semantics has been removed, as stated\nin the message you quoted.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\nSent: Friday, February 09, 2001 1:17 AM\nTo: ietf-dav-versioning@w3.org\nSubject: VERSION-CONTROL status reporting\n\n\nIn the 12.2 draft, Section 2.5 states:\n\n> If the request-URL identifies a version-controlled resource,\n> the resource just remains under version-control.  This allows\n> a client to be unaware of whether or not a server automatically\n> puts a resource under version control when it is created.\n\nAnd then lists as a Postcondition:\n\n> (DAV:already-under-version-control): If the request-URL identified\n> a resource already under version control at the time of the request,\n> the VERSION-CONTROL request MUST NOT change the DAV:checked-in or\n> DAV:checked-out property of that version-controlled resource.\n\nSection 1.6 then leads one to believe that this condition would result in a\n403 or a 409 status response, even though this appears to be normal\noperation, and hence would warrant a 200 OK response.\n\nGeoff Clemm's message of February 4, 2001\n(http://lists.w3.org/Archives/Public/ietf-dav-versioning/2001JanMar/0311.htm\nl) makes it sound like this Postcondition would be dropped.  Is it\nintentionally still in the draft?\n\n- Jim\n\n\n\n", "id": "lists-006-7735914"}, {"subject": "RE: VERSION-CONTROL status reportin", "content": "Yes, I've gone and fixed that title.\n\nNote though that the title is always of the form \"must do or not do X\",\ni.e. what the postcondition gets you, and not \"what went wrong\".\n(Sort of a glass half full vs. half empty issue :-).  So a standard\nerror message would be \"Could not ensure xxx\".  And\n\"Could not ensure property-invariant-violated\" probably isn't\nwhat we want (:-).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\nSent: Friday, February 09, 2001 2:05 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: VERSION-CONTROL status reporting\n\n\n\n> And then lists as a Postcondition:\n>\n> > (DAV:already-under-version-control): If the request-URL identified\n> > a resource already under version control at the time of the request,\n> > the VERSION-CONTROL request MUST NOT change the DAV:checked-in or\n> > DAV:checked-out property of that version-controlled resource.\n>\n\nHmm, I think I was thrown off by the title of this precondition.  It seems\nthat the purpose of the postcondition is to flag when the property invariant\n(DAV:checked-in' == DAV:checked-in) ^ (DAV:checked-out' == DAV:checked-out)\ncannot be maintained, and so the name of the postcondition really should be\nsomething like \"DAV:property-invariant-violated\".\n\n- Jim\n\n\n\n", "id": "lists-006-7745286"}, {"subject": "RE: Autoversion confusio", "content": "I agree with Tim and John.  Although the HTTP/1.1 spec \ndoesn't make GET/PUT behavior as explicit as we might want,\nI don't believe there is any confusion in the community\nas to the behavior of GET/PUT on an ordinary resource.\nI believe any attempt by us to define the core semantics\nof GET/PUT would lead folks to believe we are trying to\n*change* the definition of GET/PUT, which is very much not\nwhat we want to do. \n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Friday, February 09, 2001 4:58 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Autoversion confusion\n\n\n\n\nJohn wrote:\n> This shouldn't be necessary, since the HTTP spec\n> defines the behavior of GET and PUT. Specifically,\n> it says that PUT to a particular resource defines\n> the response for any following GET on that same\n> resource (I'm paraphrasing from memory). There\n> can't be any other possible interpretation (that\n> doesn't break HTTP semantics).\n\nI agree with John.\n\nAt the risk of nagging<g>, a version-controlled resource is an honest to\ngoodness WebDAV resource, with content and properties (version-controlled\ncollections have members and properties).  Intuatively, if a PUT to the\nresource succeeds (200 OK) then a client is entitled to believe they will\nGET the same entity back.\n\np.s.\nI had a quick look through the HTTP/1.1 spec, and didn't see anything that\nstates this categorically.  In fact, Section 9.6 (PUT) states:\n \"HTTP/1.1 does not define how a PUT method affects the state of an origin\nserver.\"\nNow, how many clients do a GET just to check what they actually will\nretrieve after a successful PUT!\n\nTim\n\n\n\n", "id": "lists-006-7753898"}, {"subject": "RE: Status reporting comment", "content": "OK, looks like my \"if there are no objections\"\nprecondition just got violated (:-).\n\nDoes anyone have a rebuttal to Tim's response?\n(I can't think of one :-).\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Friday, February 09, 2001 5:09 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: Status reporting comments\n\n\n\n\nJim wrote:\n> At present, the DeltaV specification leaves it up\n> to implementors to determine whether to return a\n> 403 or a 409 for precondition and postcondition\n> errors.  Since the specification doesn't provide\n> explicit guidance on this topic, it seems likely\n> that this will lead to different implementations\n> making different decisions.  Since these status\n> codes do have slightly different semantics (one\n> the client might want to resubmit (409), the\n> other the client should not resubmit(403)), this\n> is unfortunate, since it will lead clients to\n> lump 403 and 409 together, presumably never\n> attempting to resubmit since the resubmit\n> semantics of 403/409 cannot be depended upon.\n\nI tried this for an earlier revision of the spec., but didn't get any\nsupport for it.\n(\nhttp://lists.w3.org/Archives/Public/ietf-dav-versioning/2000OctDec/0142.html\n)\n\n\n> One way to rectify this is to explicitly note which\n> of the status codes should be returned next to the\n> precondition/postcondition XML element name, when\n> it is possible to determine that only one status\n> code will ever apply.  In cases where it could\n> depend, both 403/409 could be indicated.\n\nWe can give it a shot and I'm happy to provide my updated list, but I'm\nreluctant to getting into a big discussion about whether/why a particular\ncondition is a 403 or 409 or either.\n\n> Also, I think the specification should explicitly\n> note that the IETF controls the namespace of error\n> XML elements, and that implementations are NOT free\n> to create these XML elements willy-nilly if they\n> encounter error conditions not forseen by the specification.\n\nI disagree.  I think it is sufficient to reserve the DAV: namespace, and if\nI choose to return\n     <IBM:bad-hair-day/>\nas a reason for not doing something, then I don't see that it will be\ndetrimental to other clients.\n\nTim\n\n\n\n", "id": "lists-006-7763130"}, {"subject": "RE: Submitting DeltaV as Informational RFC?           (was: Split ting off core: where we stand", "content": "The fact that an informational RFC is easier to change is exactly why\n\"proposed standard\" is vital for progress with the Versioning Protocol.\nThe additional stability implied by \"proposed standard\" is essential\nfor an organization like mine and Eric's to commit the resources to an\nimplementation.\n\nIt is important to point out here that most of the recent discussions\nwere about changing the format of the document (e.g. splitting into\ntwo) or about adding new options (e.g. \"mutable properties\" and\n\"New-Version\" header for PUT), and not about changing the existing\nsemantics or marshalling.  The main exception is the DTD discussion,\nwhich I hope is resolved via the \"per message type\" approach, and\nwhich did not receive consensus support as meriting a change to\nthe protocol.\n\nSo I believe that the stability required by \"proposed standard\" status\nhas been achieved by the current protocol document.  It is expected\nthat there will be changes from \"proposed standard\" to \"draft standard\",\nbut these should be the result of real implementation experience\nwhich I believe we will only get if we stabilize at \"proposed standard\"\nstatus. \n\nCheers,\nGeoff   \n\n-----Original Message-----\nFrom: Juergen Reuter [mailto:reuter@ira.uka.de]\nSent: Friday, February 09, 2001 5:30 AM\nTo: ietf-dav-versioning@w3.org\nCc: reuter@ira.uka.de\nSubject: Submitting DeltaV as Informational RFC? (was: Splitting off\ncore: where we stand)\n\n\nFollowing the recent discussion about the maturity of DeltaV, I wonder if\nit might be an option to submit DeltaV as an informational RFC.  On the\none hand, this might satisfy people that want to see some 'official' RFC\nbefore starting to work on software.  On the other hand, an informational\nRFC is probably much easier to change than a proposed standard RFC, which\nis a standard tracks document.\n\nJust have a look at the HTTP protocol:  As of May 1996, HTTP was still\nissued as informational RFC (RFC 1945), although there had been HTTP\nserver implementations running since 1990, i.e. for about 6 years.  HTTP\nswitched to a proposed standard not earlier than in January 1997 (RFC\n2068).  The bottom line here is, that HTTP became a proposed standard not\nbefore there were many implementations available revealing all the\nbugs and weaknesses of earlier HTTP protocol versions.  In my opinion,\nWebDAV suffers from this experience; and DeltaV should do it better than\nWebDAV!\n\nGreetings,\n            Juergen\n\n\n\n", "id": "lists-006-7772993"}, {"subject": "RE: Security through Obscurit", "content": "The intent of this paragraph was to identify a way in which\nDeltaV has an impact on \"Security Through Obscurity\" (i.e. the\nadditional links decreases the obscurity).  Is there a better\ntitle for this section?\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Friday, February 09, 2001 5:49 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Security through Obscurity\n\n\n\n\nThis is Section 18.3 (in -12.2) ... I read the text and it makes sense, but\nnot under this heading?\n\nTim\n\n\n\n", "id": "lists-006-7784342"}, {"subject": "Re: Submitting DeltaV as Informational RFC?           (was: Splitting off core: where we stand", "content": "Agh... no way. This *is* a standards track document. Nothing less.\n\nOn Fri, Feb 09, 2001 at 11:30:18AM +0100, Juergen Reuter wrote:\n> Following the recent discussion about the maturity of DeltaV, I wonder if\n> it might be an option to submit DeltaV as an informational RFC.  On the\n> one hand, this might satisfy people that want to see some 'official' RFC\n> before starting to work on software.  On the other hand, an informational\n> RFC is probably much easier to change than a proposed standard RFC, which\n> is a standard tracks document.\n> \n> Just have a look at the HTTP protocol:  As of May 1996, HTTP was still\n> issued as informational RFC (RFC 1945), although there had been HTTP\n> server implementations running since 1990, i.e. for about 6 years.  HTTP\n> switched to a proposed standard not earlier than in January 1997 (RFC\n> 2068).  The bottom line here is, that HTTP became a proposed standard not\n> before there were many implementations available revealing all the\n> bugs and weaknesses of earlier HTTP protocol versions.  In my opinion,\n> WebDAV suffers from this experience; and DeltaV should do it better than\n> WebDAV!\n> \n> Greetings,\n>             Juergen\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-7792494"}, {"subject": "Re: DTD Confusio", "content": "I'll go you one better. Not only would I vigorously object, I simply won't\nadd a requirement for them to the code I write :-)\n\nDTDs are nice from a descriptive standpoint, but they can't do anything\nabout the semantics. And since you're processing for semantics, the rules\nemboded in a DTD just naturally come along for the ride. There is little\nincremental benefit in this scenario.\n\nCheers,\n-g\n\nOn Fri, Feb 09, 2001 at 06:57:15AM -0500, Clemm, Geoff wrote:\n> I agree with all of Jim's points below, and just to make sure that\n> there is no misunderstanding of my position, I would\n> vigorously object to any requirement of any kind wrt the presence\n> of DTD in WebDAV messages (other than the requirement that they\n> be optional :-).\n> \n> My suggestion was just intended as a way to allow the DTD folks to \n> get what they need, while clarifying that the protocol will only\n> be concerned with intra-message, not inter-message DTD consistency.\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\n> Sent: Friday, February 09, 2001 1:05 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: DTD Confusion\n> \n> \n> Well, I personally have had mixed emotions concerning the value of DTDs in\n> the protocol specification.  When DTDs come up, half of the time I curse\n> Yaron for pushing DAV into using XML in the first place.  But, then there\n> are times, such as when editing the ACL specification recently, where the\n> act of creating the DTD uncovered several errors in the XML aspects of the\n> specification, and DTDs seem like a good thing.\n>  \n> If someone with deep implementation experience like Hartmut Warncke feels\n> that appropriate use of DTDs would have saved some interoperability\n> problems, then it seems like the 3-5 hours to produce these DTDs would be\n> worthwhile (it didn't take that long to produce the ACL spec. one, even with\n> fixing the errors I found).\n>  \n> As for the per-method DTD, this seems like a good idea, one worth exploring\n> in the revision of RFC 2518.\n>  \n> Of course, this is all subject to the caveat that the WebDAV XML rules not\n> be interfered with (i.e., sibling ordering is not guaranteed, the XML\n> namespace append rules, and the unknown element ignore rule).  I'm also not\n> in favor of sending the URL of the DTD in every message -- what a waste of\n> bandwidth, since clients and servers won't be doing dynamic validation.\n> \n> - Jim\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-7801696"}, {"subject": "Re: Autoversion confusio", "content": "On Fri, Feb 09, 2001 at 09:58:29AM +0000, Tim_Ellison@uk.ibm.com wrote:\n> John wrote:\n> > This shouldn't be necessary, since the HTTP spec\n> > defines the behavior of GET and PUT. Specifically,\n> > it says that PUT to a particular resource defines\n> > the response for any following GET on that same\n> > resource (I'm paraphrasing from memory). There\n> > can't be any other possible interpretation (that\n> > doesn't break HTTP semantics).\n> \n> I agree with John.\n> \n> At the risk of nagging<g>, a version-controlled resource is an honest to\n> goodness WebDAV resource, with content and properties (version-controlled\n> collections have members and properties).  Intuatively, if a PUT to the\n> resource succeeds (200 OK) then a client is entitled to believe they will\n> GET the same entity back.\n> \n> p.s.\n> I had a quick look through the HTTP/1.1 spec, and didn't see anything that\n> states this categorically.  In fact, Section 9.6 (PUT) states:\n>  \"HTTP/1.1 does not define how a PUT method affects the state of an origin\n> server.\"\n> Now, how many clients do a GET just to check what they actually will\n> retrieve after a successful PUT!\n\nSection 8.7.1 of RFC 2518 has what you're looking for :-)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-7811135"}, {"subject": "Re: Submitting DeltaV as Informational RFC?           (was: Splitting off core: where we stand", "content": "> Agh... no way. This *is* a standards track document. Nothing less.\n\nAccording to RFC 2026, section 4.2, an Informational RFC is *not* on\nthe standards track.\n\nGreetings,\n             Juergen\n\n\n\n", "id": "lists-006-7819500"}, {"subject": "RE: section 11.", "content": "Good point.  I will define \"checked-out resource\" in the terminology\nsection, and will check all occurrences of \"checked-out \nversion-controlled resource\" to see if they should say \"checked-out\nresource\" instead.\n\nCheers,\nGeoff \n\n-----Original Message-----\nFrom: Greg Stein [mailto:gstein@lyra.org]\nSent: Thursday, February 08, 2001 5:05 AM\nTo: ietf-dav-versioning@w3.org\nSubject: section 11.3\n\n\nSection 11.3 applies to checked out resources, whether they are checked out\nVCRs or working resources. The heading and the text of 11.3.1 needs to be\nupdated to reflect both types of checkouts.\n\nI'm presuming that the term \"checked-out resource\" applies to both types.\nIf so, then that term ought to be used.\n\n[ maybe this limitation to one type occurs elsewhere in the spec? haven't\n  looked yet ]\n\nAh: there is a similar reference in the second paragraph of Section 11\n(intro). Third sentence. And the third paragraph.\n[ not exhaustive; just found this one while doing some reading ]\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-7827854"}, {"subject": "Re: Autoversion confusio", "content": "Greg wrote:\n> > I had a quick look through the HTTP/1.1 spec, and\n> > didn't see anything that states this categorically.\n> > In fact, Section 9.6 (PUT) states:\n> >  \"HTTP/1.1 does not define how a PUT method affects\n> > the state of an origin server.\"\n> > Now, how many clients do a GET just to check what\n> > they actually will retrieve after a successful PUT!\n>\n> Section 8.7.1 of RFC 2518 has what you're looking for :-)\n\nRight, ...and HTTP/1.1 clients will be making this assumption too even if\nit is not written in the spec.; there's no room for negotiation here.\n\nTim\n\n\n\n", "id": "lists-006-7835979"}, {"subject": "RE: Submitting DeltaV as Informational RFC?           (was: Split ting off core: where we stand", "content": "That is exactly the point that Greg and I were trying to make.\nMany of us *require* a standards track document in order to make the\ninvestment necessary to develop an interoperable implementation.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Juergen Reuter [mailto:reuter@ira.uka.de]\nSent: Friday, February 09, 2001 8:43 AM\nTo: Greg Stein\nCc: reuter@ira.uka.de; ietf-dav-versioning@w3.org\nSubject: Re: Submitting DeltaV as Informational RFC? (was: Splitting off\ncore: where we stand)\n\n\n> Agh... no way. This *is* a standards track document. Nothing less.\n\nAccording to RFC 2026, section 4.2, an Informational RFC is *not* on\nthe standards track.\n\nGreetings,\n             Juergen\n\n\n\n", "id": "lists-006-7843597"}, {"subject": "Re: DTD Confusio", "content": "Dear Geoff and Jim,\n\nThe last DTD that I posted is in fact one DTD for each message packed\ntogether in one file.  There is a lot of common code in it.  I could\nmodify it to have one common section that is included by a short message\nbased DTD header for each message where it is necessary.  The only place\nwhere that is actually needed is if one would like to reuse set and\nfriends in LABEL.  I could live with that.\n\nThere are two places in the protocol where I would like to clean up a\nbit and it is not just a DTD issue.  One is that handling of error\nreturn information.  I would like a top level error element as given at\nthe end of my DTD proposal.  The second is the way the expand-property\nreport sends information.  I do not want to nest prop elements in prop\nelements.  I is just not very clean.  I made a suggestion to this effect,\nbut there was almost not comment on it.\n\nThe DTD information given in the WebDAV spec is much better than what is\ngiven in the DeltaV spec.  There are some problems with the way it is\nwritten, but nothing that prevented me from using it as a basis for a\nfully compatible DeltaV spec.\n\nJim. You have stated before that a complete object model is more\nimportant.  A DTD describes what can be sent.  It is true that it is not\nsufficient, but it certainly does not hurt.  I can only say, I have\nprovided a possible DTD and am willing to finish the job to answer all\nconcerns.  I would be a tremendous contribution if you would provide the\nsemantic model to complement it.\n\nSincerely,\nJames\n\n   I agree with all of Jim's points below.\n\n   My only thought was that if the DTD advocates were comfortable with\n   this statement, that I could add a statement in the notation\n   convention section that the document specifies the DTD for each type of\n   message, and that the definition of an element in the DTD of one\n   type of message can in general differ from the DTD for that element in\n   another\n   type of message.  For example, the DAV:set element in PROPFIND and the\n   LABEL method.\n\n   Cheers,\n   Geoff \n\n   -----Original Message-----\n   From: Jim Amsden [mailto:jamsden@us.ibm.com]\n\n   ... this is really a WebDAV issue too, so the WebDAV working group should\n   get involved. If they aren't interested in providing DTDs, then there\n   probably isn't much point in Delta-V doing providing a partial set. Also\n   note that having the DTDs should never require clients or servers to use\n   them. They won't help formalize the extensions either. Personally I'm more\n   interested in getting the semantics understood and formalized. DTDs can't do\n   this, they only do structure. A good, complete object model, including\n   behavior, state models, and/or interaction diatrams (or collaboration graphs\n   depending on your preference) would be much more useful. \n\n\n\n\n   \"Geoffrey M. Clemm\" <geoffrey.clemm@rational.com> \n\n   A compromise suggestion for those interested in DTD's:\n\n   Each of the WebDAV messages are a separate XML document.\n   If you design a separate DTD for each WebDAV message type\n   (i.e. one for a PROPFIND request, one for a PROPFIND response,\n   one for a CHECKIN request, etc.), I believe you will find\n   that all the anomalies disappear.  In addition,\n   I believe this will produce a set of much more manageable,\n   extensible DTD's than would be provided by trying to\n   amass all WebDAV DTD information into one massive DTD.\n\n   Cheers,\n   Geoff\n\n\n\n", "id": "lists-006-7852818"}, {"subject": "Re: Straw poll: what options did you review", "content": "Dear Jim,\n\nHere are my answers to the straw poll.\n\n   1. Have you reviewed all options in the DeltaV protocol specification\n   (Yes/No).\n\nYes, but I have not had sufficiently reviewed the implications of the\nVariant option.\n\n   2. If no, which options have you reviewed?\n\n\n   3. If you have implementation experience for one or more options, and can\n   share this experience, which options have you implemented?\n\nWe (J?rgen Reuter and I) have a prototype for the previous core version\nwith check-in check-out included.\n\nSincerely,\nJames J. Hunt\n\n\n\n", "id": "lists-006-7864226"}, {"subject": "Re: Straw poll: what options did you review", "content": "I'm answering for myself and a colleague:\n\n1. Have you reviewed all options in the DeltaV protocol specification\n\nBoris: No (Note: last time I read the spec in full its version number was \nin the 10s, but I tracked the changes as discussed on the list)\nColleague: No (But read 12.2)\n\n2. If no, which options have you reviewed?\n\nBoris: Everything except VARIANT and FORK-CONTROL\nColleague: CHECKOUT, UPDATE, VERSION-HISTORY, WORKING-RESOURCE, WORKSPACE, \nMERGE, LABEL, BASELINE\n\n3. If you have implementation experience for one or more options, and can\nshare this experience, which options have you implemented?\n\nsorry, no comment\n\n\n\n", "id": "lists-006-7872301"}, {"subject": "typos in version tree report exampl", "content": "Two typos in the version tree report example Section 2.6.1:\n\n>>RESPONSE\n     HTTP/1.1 207 OK  ** Should be Multi-Status **\n     Content-Type: ...\n     Content-Length: ...\n\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n     <D:multistatus xmlns:D=\"DAV:\"/>  ** This element is closed too early,\nas in /> **\n         <D:response>\n             <D:href>http://repo.webdav.org/his/23/ver/V1</D:href>\n             <D:propstat>\n                 <D:prop/>\n                     ... etc\n\n\n[JimW: I thought you'd reviewed core carefully <G>]\n\nTim\n\n\n\n", "id": "lists-006-7880250"}, {"subject": "Re: Workspace option comment", "content": "   From: \"Jim Whitehead\" <ejw@cse.ucsc.edu>\n\n   1) Ambiguity of the term \"resource\".\n\n   Section 7.1.1, DAV:workspace-checkout-set property:\n\n   > This property identifies each checked-out resource whose\n   > DAV:workspace property identifies this workspace.\n\n   Does this property identify a \"version controlled resource\", or\n   a \"version resource\" (or both)? (Or \"version history resource?\") Just\n   saying \"resource\" is ambiguous.\n\nAs Greg and Tim point out, the term is \"checked-out resource\",\nnot \"resource\".  I will follow Tim's suggestion and add the\nterm \"checked-out resource\" to the terminology section.  Saying\nthat a checked-out resource is the result of checking out\na resource sounds a bit like a statement issued by the\nDepartment of Redundancy Department, but given the thread\non \"does a PUT do a PUT\", I suppose we'd better put it in there (:-).\n\n   The same problem affects Section 7.2.1 (DAV:Workspace). If a\n   server OPTIONally supports this property, which types of\n   resources should have this property defined on it?\n\nThat's up to the implementation.  There is a requirement on\nall version-controlled resources in a given workspace\n(i.e. just one per version history), but the only effect\nof having another kind of resource in a workspace is that\nthe workspace is deleted if the workspace is deleted.\n\n   Is this\n   defined on \"version controlled resources\" or \"version\n   resources\" (or both)?\n\nAgain, up to the implementation.\n\n   Also, it sounds like non-version-controlled\n   resources should also support this property.\n\nThat's why we say it's a property on any WebDAV resource,\njust like the DAV:comment and DAV:author-displayname\nproperties.\n\n   Should\n   \"version history resources\" support this property -- I can't\n   see much need for that, but maybe there is a use case.\n\nUp to the implementation.\n\n   2) Section 7.7\n\n   This section is being defined as a delta to the definition of\n   VERSION-CONTROL given in Section 2.5, which states:\n\n   > (DAV:put-under-version-control): If the request-URL identified\n   > a versionable resource at the time of the request, a new version\n   > history is created and a new version resource is created in the\n   > new version history.\n\n   Since this isn't the intent in 7.7, there needs to be explicit\n   language stating that, when a version resource is specified in the\n   request body, a new version history resource is NOT created. A new\n   definition of the (DAV:put-under-version-control) postcondition is\n   also needed in this case.\n\nThe DAV:put-under-version-control applies only when\nwhen the request-URL identifies an existing resource.\nI'll add \"non-null versionable resource\" to ensure there\nis no confusion here.\n\n   3) Child workspaces of workspaces?\n\n   Is it possible for a workspace to be contained by another workspace?\n   The specification is silent on this issue, though the definition\n   of workspaces as collections suggests that yes, a workspace can\n   contain a child workspace.\n\nA workspace can appear in the URL space under another workspace\n(anything not forbidden is allowed).  But a resource can only\nidentify a single workspace in its DAV:workspace property, so\nthe answer depends on what you mean by \"contain\".  If you mean,\n\"appears under in the URL namespace\", yes.  If you mean \"has\nmultiple DAV:workspace values\", then no.\n\n   4) Are workspaces versionable?\n\n   Is it possible to place a workspace under version control using the\n   VERSION-CONTROL method?  The specification is silent on this topic.\n\nAnything that is not forbidden is allowed.  In particular, an\nimplementation can allow both the VERSION-CONTROL method and\nthe BASELINE-CONTROL method to be applied to a workspace\n(but it is not required to do so).  Our implementation will\nin fact not allow you to apply VERSION-CONTROL or BASELINE-CONTROL\nto the workspace, but I know of others that will.\n\n   Minor nits:\n\n   Section 7.1:\n\n   > The workspace option introduces the following REQUIRED\n   > properties for a workspace.\n\n   But there is only one property (singular) introduced.\n\nAfter a while, I got tired of changing back and forth between\n\"y\" and \"ies\", every time the number of properties changed between\none and many.  Please remember that I have prepared somewhere\nbetween 50 and 100 working drafts.  I was planning on cleaning this up in\nthe final draft before submission to the IESG, but I appreciate you\nraising the issue, because I may otherwise have forgotten to do\nso.\n\n   The same comment applies to Section 7.2\n\nSee above.\n\n   Section 7.2.1:\n\n   > If the resource is associated with a workspace, this\n   > property MUST identifies this workspace.\n\n   identifies --> identify\n\nThanks for catching that.  I recently did a pass through the document adding\nMUST in a few places where I thought it was appropriate, and in\nthis case neglected to modify \"identify\" to \"identifies\".\n\n   Hmm, it stretches credulity that 7+ people could have carefully reviewed\n   this option and not caught at least these nits, if not the other issues.\n\nPlease allow me to be a bit testy here.\n\nAlso please bear in mind that JimW is a good friend of\nmine, that I respect and admire his impressive contributions\nto WebDAV, and that if anyone has the right to criticize,\nit would be Jim, and that Jim has taken far more abuse as\nco-author of 2518 than I ever have (or hope to :-), and\nthat he has a really cute new baby that I hope to visit\nsomeday soon.\n\nSo with all that in mind:\n\n(flame-on :-)\n\nYou appear to be implying that those who have stated that they have\nreviewed this option are either lying or incompetent.  The reviewers\nhave been *incredibly* diligent and thorough, down to the point of\nidentifying places where there were only one space following a period,\nrather than two, and where there was a leading space in the beginning\nof a new section.  This indicates to me a level of effort far beyond\nthat required to ensure an interoperable and understandable document,\nand speaks loudly to both the interest and quality of the reviews.\n\nIt stretches my credulity to believe that your credulity was stretched\nby the fact that the reviewers understood a simplifying editorial\npolicy I have had since the very beginning, the fact that they\nmissed a typo that I introduced in a non-substantive change to the\ndocument, and the fact that you felt there were parts of the protocol\nthat deserved some clarification, but which previous reviewers felt\nwere clear in their current form.\n\n(flame off ... I'm sure I'll regret this, but really, didn't\nJim deserve it? :-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-7887974"}, {"subject": "RE: Autoversion confusio", "content": "<tim>I had a quick look through the HTTP/1.1 spec, and didn't see anything \nthat\nstates this categorically.  In fact, Section 9.6 (PUT) states:\n \"HTTP/1.1 does not define how a PUT method affects the state of an origin\nserver.\"\nNow, how many clients do a GET just to check what they actually will\nretrieve after a successful PUT!</tim>\n\nThe reason HTTP/1.1 says this is that the GET and PUT could be to a \ndynamic resource or database query. It is up to the semantics of the \nresource type (MIME type) to determine the meaning of GET and PUT. HTTP \nonly says what's on the wire.\n\n\n\n", "id": "lists-006-7901528"}, {"subject": "Re: DTD Confusion (i.e., opportunity", "content": "I think having the DTDs is great (XML Schema even better), and they should \nbe included in the document along with the notes that Jim W made about \nWebDAV conventions. I used the WebDAV DTDs a lot when developing DAV4J to \ndefine the objects being passed between the client and server. However, I \nstill don't think they should be in any way required by the protocol for \nsending or receiving requests. So I encourage anyone interested to \ncontribute to this valuable effort, and would be happy to consider \nincluding DTDs in the DeltaV spec as long as 1) they don't introduce \nunnecessary issues, and 2) we don't hold up the spec for the details. This \nis probably a refinement that can be applied after proposed draft.\n\n\n\n", "id": "lists-006-7909043"}, {"subject": "RE: Autoversion confusio", "content": "I wasn't talking only about the client that did the put.  The DeltaV\nspec ought to state normatively what OTHER clients experience.  I'll\nrepeat from my earlier mail, my suggested language:\n\n\"In core versioning, while a VCR is checked out it may be the target of\nmultiple write operations.  During this period, other clients MUST still\nbe able to perform read operations on the VCR's URL, and the results\nMUST show the results of all the write operations that have been\nperformed thus far.  (Note: if a scenario requires hiding a\nwork-in-progress from other clients, the \"working resource\" option can\nbe used.)\"\n\nlisa\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> Tim_Ellison@uk.ibm.com\n> Sent: Friday, February 09, 2001 1:58 AM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Autoversion confusion\n>\n>\n>\n>\n> John wrote:\n> > This shouldn't be necessary, since the HTTP spec\n> > defines the behavior of GET and PUT. Specifically,\n> > it says that PUT to a particular resource defines\n> > the response for any following GET on that same\n> > resource (I'm paraphrasing from memory). There\n> > can't be any other possible interpretation (that\n> > doesn't break HTTP semantics).\n>\n> I agree with John.\n>\n> At the risk of nagging<g>, a version-controlled resource is\n> an honest to\n> goodness WebDAV resource, with content and properties\n> (version-controlled\n> collections have members and properties).  Intuatively, if a\n> PUT to the\n> resource succeeds (200 OK) then a client is entitled to\n> believe they will\n> GET the same entity back.\n>\n> p.s.\n> I had a quick look through the HTTP/1.1 spec, and didn't see\n> anything that\n> states this categorically.  In fact, Section 9.6 (PUT) states:\n>  \"HTTP/1.1 does not define how a PUT method affects the state\n> of an origin\n> server.\"\n> Now, how many clients do a GET just to check what they actually will\n> retrieve after a successful PUT!\n>\n> Tim\n>\n\n\n\n", "id": "lists-006-7916773"}, {"subject": "PUT != PUT? (was: RE: Autoversion confusion", "content": "<tim>I had a quick look through the HTTP/1.1 spec, and\n     didn't see anything that states this categorically.\n     In fact, Section 9.6 (PUT) states:\n      \"HTTP/1.1 does not define how a PUT method affects\n      the state of an origin server.\"\n     Now, how many clients do a GET just to check what\n     they actually will retrieve after a successful PUT!\n</tim>\n\n<jim>\nThe reason HTTP/1.1 says this is that the GET and PUT\ncould be to a dynamic resource or database query. It\nis up to the semantics of the resource type (MIME type)\nto determine the meaning of GET and PUT. HTTP only says\nwhat's on the wire.\n</jim>\n\n<tim_2>\nOh Jim, no... from RFC2616,\n\n\"9.6 PUT\nThe PUT method requests that the enclosed entity be stored under the\nsupplied Request-URI. If the Request-URI refers to an already existing\nresource, the enclosed entity SHOULD be considered as a modified version of\nthe one residing on the origin server. \"\n\nwhereas\n\n\"9.5 POST\nThe POST method is used to request that the origin server accept the entity\nenclosed in the request as a new subordinate of the resource identified by\nthe Request-URI in the Request-Line. POST is designed to allow a uniform\nmethod to cover the following functions:\n     - Annotation of existing resources;\n      - Posting a message to a bulletin board, newsgroup, mailing list, or\nsimilar group of articles;\n      - Providing a block of data, such as the result of submitting a form,\nto a data-handling process;\n      - Extending a database through an append operation.\"\n\nHTTP/1.1 certainly contains some semantics and not just 'what is on the\nwire'.\n\n[I'm only continuing this thread because it is so funny!  How about we keep\nthis one for discussion at the bar?]\n\nTim\n\n\n\n", "id": "lists-006-7927040"}, {"subject": "Re: DTD Confusion (i.e., opportunity", "content": "I agree, it makes an excellent candidate for another appendix.\n\nTim\n\n\n\"Jim Amsden\" <jamsden@us.ibm.com> on 2001-02-09 04:07:52 PM\n\nPlease respond to \"Jim Amsden\" <jamsden@us.ibm.com>\n\nTo:   ietf-dav-versioning@w3.org\ncc:\nSubject:  Re: DTD Confusion (i.e., opportunity)\n\n\n\n\nI think having the DTDs is great (XML Schema even better), and they should\nbe included in the document along with the notes that Jim W made about\nWebDAV conventions. I used the WebDAV DTDs a lot when developing DAV4J to\ndefine the objects being passed between the client and server. However, I\nstill don't think they should be in any way required by the protocol for\nsending or receiving requests. So I encourage anyone interested to\ncontribute to this valuable effort, and would be happy to consider\nincluding DTDs in the DeltaV spec as long as 1) they don't introduce\nunnecessary issues, and 2) we don't hold up the spec for the details. This\nis probably a refinement that can be applied after proposed draft.\n\n\n\n", "id": "lists-006-7935384"}, {"subject": "RE: Autoversion confusio", "content": "Lisa wrote:\n> I wasn't talking only about the client that did\n> the put.\n\nNeither was I.  In general the HTTP sever has no way of knowing which\nclient is sending a PUT/GET request.\n\n> The DeltaV spec ought to state normatively what\n> OTHER clients experience.\n\nThankfully the spec doesn't get into sessions or whatever for identifying\nclients.  It's unnecessary.\n\n> I'll repeat from my earlier mail, my suggested language:\n>\n> \"In core versioning, while a VCR is checked out it\n> may be the target of multiple write operations.  During\n> this period, other clients MUST still be able to perform\n> read operations on the VCR's URL, and the results MUST\n> show the results of all the write operations that have\n> been performed thus far.  (Note: if a scenario requires\n> hiding a work-in-progress from other clients, the \"working\n> resource\" option can be used.)\"\n\nI'd be interested to hear if others think that we need to state this.\n\n\nTim\n\n------------------------\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> > Tim_Ellison@uk.ibm.com\n> > Sent: Friday, February 09, 2001 1:58 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: RE: Autoversion confusion\n> >\n> >\n> >\n> >\n> > John wrote:\n> > > This shouldn't be necessary, since the HTTP spec\n> > > defines the behavior of GET and PUT. Specifically,\n> > > it says that PUT to a particular resource defines\n> > > the response for any following GET on that same\n> > > resource (I'm paraphrasing from memory). There\n> > > can't be any other possible interpretation (that\n> > > doesn't break HTTP semantics).\n> >\n> > I agree with John.\n> >\n> > At the risk of nagging<g>, a version-controlled resource is\n> > an honest to\n> > goodness WebDAV resource, with content and properties\n> > (version-controlled\n> > collections have members and properties).  Intuatively, if a\n> > PUT to the\n> > resource succeeds (200 OK) then a client is entitled to\n> > believe they will\n> > GET the same entity back.\n> >\n> > p.s.\n> > I had a quick look through the HTTP/1.1 spec, and didn't see\n> > anything that\n> > states this categorically.  In fact, Section 9.6 (PUT) states:\n> >  \"HTTP/1.1 does not define how a PUT method affects the state\n> > of an origin\n> > server.\"\n> > Now, how many clients do a GET just to check what they actually will\n> > retrieve after a successful PUT!\n> >\n> > Tim\n> >\n\n\n\n", "id": "lists-006-7944017"}, {"subject": "RE: DeltaV doesn't support a true client workspac", "content": "From: Geoffrey M. Clemm [mailto:geoffrey.clemm@rational.com]\n>    From: \"Fay, Chuck\" <CFay@filenet.com>\n>    >    A third alternative would be to add a flavor of \n>    >    CHECKOUT-CHECKIN to core versioning in DeltaV\n>    >    that allows all changes to accompany the CHECKIN\n>    >    method.  This is the model used by the existing\n>    >    systems I mentioned.\n> \n>    Let's say that we shifted the keep-checked-out option from the\n>    CHECKIN request body to a header, and instead allowed an optional\n>    CHECKIN request body containing new contents for the resource.\n>    That is, the optional request body would be the same as a PUT\n>    request body.  That allows a client that is storing all\n>    intermediate state locally to do a single checkin with the new\n>    content bundled with the CHECKIN request.  This would not force all\n>    clients to do so, however.\n> \n> Currently, the protocol already provides an interoperable way of\n> achieving this result with the PUT method applied to a\n> version-controlled resource with DAV:auto-version set to\n> DAV:when-unlocked.  \n> \n> Perhaps your intent here is to provide a way for a client to get\n> auto-version behavior from PUT only when it explicitly asks for it?\n> I.e. you only want clients to create new versions if they know\n> that they are doing so?  If so, I believe a simpler way to\n> achieve your goal would be to add an Autoversion header to PUT.\n> This would tell PUT to have autoversioning behavior for just\n> that request.\n\nI see no value in an Autoversion header on PUT.  Clients that are not\nauto-versioning-aware would not use such a header by definition.  If a\nclient is auto-versioning-aware, it doesn't need a special header on PUT to\nget auto-version behavior only when it explicitly asks for it.  It would\nsimply choose to do a single PUT with all its changes, rather than multiple\nPUTS along the way.\n\n> This not only is far more consistent with the current pre-conditions\n> of CHECKIN (i.e. that it is only applied to a checked-out resource),\n\nI don't follow you here.  My proposal is to move the CHECKOUT option back\ninto core versioning, so both CHECKOUT and CHECKIN would be in core\nversioning.  The pre-condition on CHECKIN would still be enforced.  That is,\nCHECKIN would only be allowed on a checked-out resource that was checked out\nwith ... you guessed it ... CHECKOUT.  So I don't see the inconsistency you\nsuggest.\n\n> but also allows you to have just one new header, instead of requiring\n> a new header for every parameter to CHECKIN.\n> \n> So I have two questions:\n> \n> Chuck: Does the Autoversion header for PUT get you what you need?\n\nNo (see above).  To reiterate briefly, I'm trying to avoid a proliferation\nof versions created by auto-versioning.  My server would auto-version only\nfor versioning-unaware clients.  Versioning-aware clients would CHECKOUT,\nGET, do all modifications locally on the client, then CHECKIN with the new\ncontent as the CHECKIN request body.  What could be simpler?  I strongly\nurge that this model of use be supported by DeltaV.  Note that my server\nwould reject any PUTS on a checked-out VCR, because it would not implement\nmy proposed mutable VCR option.\n\n> Note that to be interoperable with versioning unaware clients,\n> you'll have to set DAV:auto-version anyway, so are you sure \n> that existing DAV:auto-version and PUT behavior isn't sufficient?\n\nYes, because of the problem of proliferating versions.\n\n--Chuck Fay \nFileNET Corporation, 3565 Harbor Blvd., Costa Mesa, CA 92626 \nphone:  (714) 327-3513, fax:  (714) 327-5076, email:  cfay@filenet.com\n\n\n\n", "id": "lists-006-7954757"}, {"subject": "minor comments regarding 12.", "content": "I'm passing on minor comments regarding 12.2 from a colleague. Sorry for \nbeing so late!\n\nBoris.\n\n\nsection 1.2:\nWord problem: error - reference source not found\n\nsection 2.1, third paragraph:\nmention that the new version resource is a root version resource.\n\nsection 2.2.3, 2.2.4:\nDAV:supported-method-set and DAV:supported-live-property-set should be \nprotected properties.\n\nsection 2.3.2:\nadd: \"This property is removed when the resource is checked in, and then \nadded back (potentially identifying a different version) when the resource \nis checked out again.\"\n\nsection 2.5, postconditions:\nchange \"a new version history is created and a new version resource is \ncreated\" to \"a new version history is created and a new root version \nresource is created\" (add \"root\")\n\nsection 7.2.1:\n\"If the resource is associated with a workspace\": when is a resource \nassociated with a workspace? If one of its parents is a workspace?\n\nsection 7.7:\nmissing precondition: parent of null resource MUST exist (or is this \ncovered elsewhere?)\npostcondition: add \"and whose workspace property identifies the containing \nworkspace\"\n\nsection 8.3.1, last sentence:\nchange \"was\" to \"were to be\"\n\nsection 9.2, Preconditions:\nDAV:must-select-version-in-same-history is misleading; you cannot select a \nversion from another history, but you could select no version if the label \nwas not found. The precondition should be \nDAV:must-select-version-in-history. (This applies to other sections \nlisting the same precondition name, e.g. 9.6)\n\nsection 9.8:\nThis section only applies when the server supports the WORKING-RESOURCE \noption\n\nsection 9.9,Preconditions:\nDAV:apply-to-version: where is this defined?\nDAV:label: should this be DAV:label-name ?\n\nsection 10.2.2\nURLs\n\nsection 10.4.1\nshould read: \"This property identifies the members of the workspace \ncollection that are collections under baseline control.\"\nalso: Can't the workspace itself show up in this list too?\n\nsection 10.5, third paragraph:\nchange \"members\" to \"member\"\n\nsection 10.5, Postcondition DAV:select-existing-baseline:\nHow does this deal with pre-existing non version-controlled resources in \nhte collection with the same relative name? The preconditions only \ndisallow pre-existing version-controlled resources.\n\nsection 10.10, Postconditions:\nbaseline-controlled-collection -> DAV:baseline-controlled-collection-set\n\n\n\n", "id": "lists-006-7967204"}, {"subject": "DAV:compare-baseline REPOR", "content": "This is a change request - I hope it's not too late:\n\nA compare-baseline REPORT only contains version URLs. This makes it very \npainful to find out what the changes are in terms of the VCRs that are \nexposed by the DAV:baseline-collection. I would like to see, instead of \nversion URLs being reported by the DAV:compare-baseline, the VCR URLs from \nthe corresponding DAV:baseline-collection(s).\n\nI would propose the following (just for the added-version case, \ndeleted-version and changed-version would be similar):\n\nA DAV:added-version element identifies a member of the \nDAV:baseline-collection of the compare baseline version whose \nDAV:checked-in version belongs to a version history from which no version \nis the DAV:checked-in version of a member of the DAV:baseline-collection \nof the request baseline.\n<!ELEMENT added-version (href)>\nAs an alternative, both URLs could be reported (VCR and version URLs).\n\nBoris.\n\n\n\n", "id": "lists-006-7977469"}, {"subject": "FW: DeltaV doesn't support a true client workspac", "content": "[Reformatted the first part of the message below for readability.  I hope\nthis one makes it through the mail servers in better shape.  --Chuck]\n\n-----Original Message-----\nFrom: Fay, Chuck [mailto:CFay@filenet.com]\nSent: Friday, February 09, 2001 9:10 AM\nTo: Geoffrey M. Clemm; ietf-dav-versioning@w3.org\nSubject: RE: DeltaV doesn't support a true client workspace\n\n\nFrom: Geoffrey M. Clemm [mailto:geoffrey.clemm@rational.com]\n> From: \"Fay, Chuck\" <CFay@filenet.com>\n>    > A third alternative would be to add a flavor of\n>    > CHECKOUT-CHECKIN to core versioning in DeltaV\n>    > that allows all changes to accompany the CHECKIN\n>    > method.  This is the model used by the existing\n>    > systems I mentioned.\n>\n>    Let's say that we shifted the keep-checked-out\n>    option from the CHECKIN request body to a header,\n>    and instead allowed an optional CHECKIN request\n>    body containing new contents for the resource.\n>    That is, the optional request body would be the\n>    same as a PUT request body.  That allows a client\n>    that is storing all intermediate state locally to\n>    do a single checkin with the new content bundled\n>    with the CHECKIN request.  This would not force all\n>    clients to do so, however.\n> \n> Currently, the protocol already provides an\n> interoperable way of achieving this result with the\n> PUT method applied to a version-controlled resource\n> with DAV:auto-version set to DAV:when-unlocked.\n>\n> Perhaps your intent here is to provide a way for a\n> client to get auto-version behavior from PUT only when\n> it explicitly asks for it?  I.e. you only want clients\n> to create new versions if they know that they are doing\n> so?  If so, I believe a simpler way to achieve your\n> goal would be to add an Autoversion header to PUT.\n> This would tell PUT to have autoversioning behavior for\n> just that request.\n\nI see no value in an Autoversion header on PUT.  Clients that are not\nauto-versioning-aware would not use such a header by definition.  If a\nclient is auto-versioning-aware, it doesn't need a special header on PUT to\nget auto-version behavior only when it explicitly asks for it.  It would\nsimply choose to do a single PUT with all its changes, rather than multiple\nPUTS along the way.\n\n> This not only is far more consistent with the current pre-conditions\n> of CHECKIN (i.e. that it is only applied to a checked-out resource),\n\nI don't follow you here.  My proposal is to move the CHECKOUT option back\ninto core versioning, so both CHECKOUT and CHECKIN would be in core\nversioning.  The pre-condition on CHECKIN would still be enforced.  That is,\nCHECKIN would only be allowed on a checked-out resource that was checked out\nwith ... you guessed it ... CHECKOUT.  So I don't see the inconsistency you\nsuggest.\n\n> but also allows you to have just one new header, instead of requiring\n> a new header for every parameter to CHECKIN.\n> \n> So I have two questions:\n> \n> Chuck: Does the Autoversion header for PUT get you what you need?\n\nNo (see above).  To reiterate briefly, I'm trying to avoid a proliferation\nof versions created by auto-versioning.  My server would auto-version only\nfor versioning-unaware clients.  Versioning-aware clients would CHECKOUT,\nGET, do all modifications locally on the client, then CHECKIN with the new\ncontent as the CHECKIN request body.  What could be simpler?  I strongly\nurge that this model of use be supported by DeltaV.  Note that my server\nwould reject any PUTS on a checked-out VCR, because it would not implement\nmy proposed mutable VCR option.\n\n> Note that to be interoperable with versioning unaware clients,\n> you'll have to set DAV:auto-version anyway, so are you sure \n> that existing DAV:auto-version and PUT behavior isn't sufficient?\n\nYes, because of the problem of proliferating versions.\n\n--Chuck Fay \nFileNET Corporation, 3565 Harbor Blvd., Costa Mesa, CA 92626 \nphone:  (714) 327-3513, fax:  (714) 327-5076, email:  cfay@filenet.com\n\n\n\n", "id": "lists-006-7986319"}, {"subject": "RE: Autoversion confusio", "content": "I'd be happy to see this language in the FAQ\n(and strongly encourage Lisa to add it there),\nbut I think it would be confusing to put something\nin the protocol that in effect says \"for this resource,\nGET and PUT will continue to work as defined in HTTP\",\nsince a natural conclusion would be that we are *not*\nguaranteeing that they will do so in other cases.\nAnd we definitely don't want people to reach that\n(incorrect) conclusion.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Friday, February 09, 2001 11:47 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Autoversion confusion\n\n\n\n\nLisa wrote:\n> I wasn't talking only about the client that did\n> the put.\n\nNeither was I.  In general the HTTP sever has no way of knowing which\nclient is sending a PUT/GET request.\n\n> The DeltaV spec ought to state normatively what\n> OTHER clients experience.\n\nThankfully the spec doesn't get into sessions or whatever for identifying\nclients.  It's unnecessary.\n\n> I'll repeat from my earlier mail, my suggested language:\n>\n> \"In core versioning, while a VCR is checked out it\n> may be the target of multiple write operations.  During\n> this period, other clients MUST still be able to perform\n> read operations on the VCR's URL, and the results MUST\n> show the results of all the write operations that have\n> been performed thus far.  (Note: if a scenario requires\n> hiding a work-in-progress from other clients, the \"working\n> resource\" option can be used.)\"\n\nI'd be interested to hear if others think that we need to state this.\n\n\nTim\n\n------------------------\n> > -----Original Message-----\n> > From: ietf-dav-versioning-request@w3.org\n> > [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of\n> > Tim_Ellison@uk.ibm.com\n> > Sent: Friday, February 09, 2001 1:58 AM\n> > To: ietf-dav-versioning@w3.org\n> > Subject: RE: Autoversion confusion\n> >\n> >\n> >\n> >\n> > John wrote:\n> > > This shouldn't be necessary, since the HTTP spec\n> > > defines the behavior of GET and PUT. Specifically,\n> > > it says that PUT to a particular resource defines\n> > > the response for any following GET on that same\n> > > resource (I'm paraphrasing from memory). There\n> > > can't be any other possible interpretation (that\n> > > doesn't break HTTP semantics).\n> >\n> > I agree with John.\n> >\n> > At the risk of nagging<g>, a version-controlled resource is\n> > an honest to\n> > goodness WebDAV resource, with content and properties\n> > (version-controlled\n> > collections have members and properties).  Intuatively, if a\n> > PUT to the\n> > resource succeeds (200 OK) then a client is entitled to\n> > believe they will\n> > GET the same entity back.\n> >\n> > p.s.\n> > I had a quick look through the HTTP/1.1 spec, and didn't see\n> > anything that\n> > states this categorically.  In fact, Section 9.6 (PUT) states:\n> >  \"HTTP/1.1 does not define how a PUT method affects the state\n> > of an origin\n> > server.\"\n> > Now, how many clients do a GET just to check what they actually will\n> > retrieve after a successful PUT!\n> >\n> > Tim\n> >\n\n\n\n", "id": "lists-006-7999468"}, {"subject": "RE: DeltaV doesn't support a true client workspac", "content": "The way we handle the version proliferation problem is to keep a maximum\nnumber of the number of autoversioned versions to keep around.  In a\nprevious product, we had a limit on the number of \"unreleased\" (in DeltaV\nterms, unlabeled and unbaselined) versions to keep around.\n\nWhen either count is reached, we start deleting old versions automatically.\n\n--Eric\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Fay, Chuck\nSent: Friday, February 09, 2001 9:10 AM\nTo: Geoffrey M. Clemm; ietf-dav-versioning@w3.org\nSubject: RE: DeltaV doesn't support a true client workspace\n\n\n\n> but also allows you to have just one new header, instead of requiring\n> a new header for every parameter to CHECKIN.\n> \n> So I have two questions:\n> \n> Chuck: Does the Autoversion header for PUT get you what you need?\n\nNo (see above).  To reiterate briefly, I'm trying to avoid a proliferation\nof versions created by auto-versioning.  My server would auto-version only\nfor versioning-unaware clients.  Versioning-aware clients would CHECKOUT,\nGET, do all modifications locally on the client, then CHECKIN with the new\ncontent as the CHECKIN request body.  What could be simpler?  I strongly\nurge that this model of use be supported by DeltaV.  Note that my server\nwould reject any PUTS on a checked-out VCR, because it would not implement\nmy proposed mutable VCR option.\n\n> Note that to be interoperable with versioning unaware clients,\n> you'll have to set DAV:auto-version anyway, so are you sure \n> that existing DAV:auto-version and PUT behavior isn't sufficient?\n\nYes, because of the problem of proliferating versions.\n\n--Chuck Fay \nFileNET Corporation, 3565 Harbor Blvd., Costa Mesa, CA 92626 \nphone:  (714) 327-3513, fax:  (714) 327-5076, email:  cfay@filenet.com\n\n\n\n", "id": "lists-006-8011249"}, {"subject": "Auto-version correction", "content": "Suggested corrections to the spec related to auto-versioning:\n\nSeveral sections still talk in terms of the auto-version property being\n\"set\" and describing behavior in that case, without specifying any\nparticular setting of auto-version.  This worked when it only had true and\nfalse values, since \"set\" implied the true value.  Now that it has four\ndifferent possible values, the use of the verb \"set\" alone is ambiguous.\n\nFor instance, section 2.1.2 overstates the case when it says \"A PUT or\nPROPPATCH to a version-controlled resource with the DAV:auto-version\nproperty set will automatically check out that resource prior to executing\nthe PUT or PROPPATCH.\"  Of the four different possible values for\nauto-version, some do not have the prescribed behavior (i.e., never, and\nwhen-locked-checkout if the VCR is unlocked).  So this needs to be reworded\nin order to avoid oversimplifying and misleading the reader.  For instance,\nparagraphs 2 and 3 of 2.1.2 could be replaced by the following paragraph:\n\n\"For clients that are unaware of versioning semantics, the DAV:auto-version\nproperty provides for automatic versioning on PUT and PROPPATCH methods.\nCertain settings of the auto-version property on a checked-in\nversion-controlled resource will cause that resource to be checked out\nautomatically, prior to executing the PUT or PROPPATCH.  With one setting of\nauto-version, the resource is checked back in immediately afterwards, again\nautomatically.  This results in a new version immediately after each\nsuccessful PUT or PROPPATCH.  With other settings of auto-version, if the\nresource is write-locked at the time of the PUT or PROPPATCH, it will remain\nchecked out for the duration of the lock, so that the automatic checkin is\ndelayed until the resource is unlocked.  Auto-versioning can also be turned\noff completely.  (See the sections on DAV:auto-version, PUT, PROPPATCH,\nCOPY, and UNLOCK for the details on auto-version settings.)\"\n\nThe above paragraph omits the note that \"unlock\" includes any way that a\nlock is removed, including lock timeout.  My thinking is that that sort of\ndetail should be covered in the section on DAV:auto-version, if necessary.\n\nAlso, sections 2.8 and 2.9 have preconditions based on auto-version being\n\"set\".  They too need to be updated to address specific settings of\nauto-version.  This would clarify one remaining case that is not specified:\nPUT on a checked-in, non-write-locked VCR with auto-version =\nwhen-locked-checkout.  My understanding from earlier mail is that the PUT\n(or PROPPATCH of a dead property) should fail in this case, but that is not\nclear from the preconditions.\n\n--Chuck Fay \nFileNET Corporation, 3565 Harbor Blvd., Costa Mesa, CA 92626 \nphone:  (714) 327-3513, fax:  (714) 327-5076, email:  cfay@filenet.com\n\n\n\n", "id": "lists-006-8021462"}, {"subject": "FW: DeltaV doesn't support a true client workspac", "content": "Reformatted one last time -- if this doesn't get through cleanly, you'll\nhave to parse it on your own (:-).  Sorry for the noise...  To make it\nworthwhile, I've included more on the proposal in this copy:\n\nI noticed that I didn't reiterate all the key points in my message below, so\nlet me elaborate here.  Assume that my versioning server does not allow\nmutable non-collection resources of any kind -- every PUT MUST create a new\nversion.  So it offers no storage of intermediate resource state between a\ncheckout and checkin.\n\nI'm proposing that the ability to do PUTs to a checked-out VCR remain an\noption.  That capability is currently embedded in the CHECKOUT option.  I\nwant to separate that capability out and keep it optional.  I want to return\nthe CHECKOUT, CHECKIN, and UNCHECKOUT methods to core versioning, but\nwithout the mutable checked-out VCR capability.  Thus a core versioning\nclient could do the following (assume all non-collection versionable\nresources are version-controlled):\n\nCHECKOUT /foo.html\nGET /foo.html\n  Modify content locally, saving intermediate\n  state locally or on a file server, but not\n  by doing a PUT to /foo.html, which is not\n  allowed in my proposal.  PUTs would not be\n  allowed on checked-out VCRs in core\n  versioning.  (Note that PUTs would always be\n  allowed on checked-in VCRs with auto-version\n  set to either always-checkout-* value.)\n  Finally I'm happy with my local copy and want\n  to create a new version on the server with\n  my local content.\nCHECKIN /foo.html (with new content in the request body)\n\nI don't see why there should any big objection to this proposal, except on\nreligious grounds that any real versioning server *must* provide\nintermediate storage of working versions.  Clients that can't live without\nintermediate storage on their versioning server can still take advantage of\nservers offering that option and don't have to include a request body with\nthe CHECKIN.  They just won't work with my server and I can accept that.  If\nall clients end up requiring that, I'll end up changing my server.  But it\nworks fine for many customers today without that capability.\n\nThis allows CHECKOUT/CHECKIN methods in core versioning, which seems\nintuitively necessary.  What kind of versioning server doesn't have the\nnotion of CHECKOUT and CHECKIN?  It seems unimaginable that core versioning\ncould be defined without including these methods.\n\n--Chuck\n\n-----Original Message-----\nFrom: Fay, Chuck \nSent: Friday, February 09, 2001 11:09 AM\nTo: Geoffrey M. Clemm; ietf-dav-versioning@w3.org\nSubject: FW: DeltaV doesn't support a true client workspace\n\n\n[Reformatted the first part of the message below for readability.  I hope\nthis one makes it through the mail servers in better shape.  --Chuck]\n\n-----Original Message-----\nFrom: Fay, Chuck [mailto:CFay@filenet.com]\nSent: Friday, February 09, 2001 9:10 AM\nTo: Geoffrey M. Clemm; ietf-dav-versioning@w3.org\nSubject: RE: DeltaV doesn't support a true client workspace\n\n\n       <cfay>\n       A third alternative would be to add a flavor of\n       CHECKOUT-CHECKIN to core versioning in DeltaV\n       that allows all changes to accompany the CHECKIN\n       method.  This is the model used by the existing\n       systems I mentioned.\n       </cfay>\n\n     <cfay>\n     ... Let's say that we shifted the keep-checked-out\n     option from the CHECKIN request body to a header,\n     and instead allowed an optional CHECKIN request\n     body containing new contents for the resource.\n     That is, the optional request body would be the\n     same as a PUT request body.  That allows a client\n     that is storing all intermediate state locally to\n     do a single checkin with the new content bundled\n     with the CHECKIN request.  This would not force all\n     clients to do so, however.\n     </cfay>\n\n  <gclemm>\n  Currently, the protocol already provides an\n  interoperable way of achieving this result with the\n  PUT method applied to a version-controlled resource\n  with DAV:auto-version set to DAV:when-unlocked.\n\n  Perhaps your intent here is to provide a way for a\n  client to get auto-version behavior from PUT only when\n  it explicitly asks for it?  I.e. you only want clients\n  to create new versions if they know that they are doing\n  so?  If so, I believe a simpler way to achieve your\n  goal would be to add an Autoversion header to PUT.\n  This would tell PUT to have autoversioning behavior for\n  just that request.\n  </gclemm>\n\nI see no value in an Autoversion header on PUT.  Clients that are not\nauto-versioning-aware would not use such a header by definition.  If a\nclient is auto-versioning-aware, it doesn't need a special header on PUT to\nget auto-version behavior only when it explicitly asks for it.  It would\nsimply choose to do a single PUT with all its changes, rather than multiple\nPUTS along the way.\n\n  <gclemm>\n  This not only is far more consistent with the current pre-conditions\n  of CHECKIN (i.e. that it is only applied to a checked-out resource),\n  </gclemm>\n\nI don't follow you here.  My proposal is to move the CHECKOUT option back\ninto core versioning, so both CHECKOUT and CHECKIN would be in core\nversioning.  The pre-condition on CHECKIN would still be enforced.  That is,\nCHECKIN would only be allowed on a checked-out resource that was checked out\nwith ... you guessed it ... CHECKOUT.  So I don't see the inconsistency you\nsuggest.\n\n  <gclemm>\n  but also allows you to have just one new header, instead of requiring\n  a new header for every parameter to CHECKIN.\n\n  So I have two questions:\n\n  Chuck: Does the Autoversion header for PUT get you what you need?\n  </gclemm>\n\nNo (see above).  To reiterate briefly, I'm trying to avoid a proliferation\nof versions created by auto-versioning.  My server would auto-version only\nfor versioning-unaware clients.  Versioning-aware clients would CHECKOUT,\nGET, do all modifications locally on the client, then CHECKIN with the new\ncontent as the CHECKIN request body.  What could be simpler?  I strongly\nurge that this model of use be supported by DeltaV.  Note that my server\nwould reject any PUTS on a checked-out VCR, because it would not implement\nmy proposed mutable VCR option.\n\n  <gclemm>\n  Note that to be interoperable with versioning unaware clients,\n  you'll have to set DAV:auto-version anyway, so are you sure \n  that existing DAV:auto-version and PUT behavior isn't sufficient?\n  </gclemm>\n\nYes, because of the problem of proliferating versions.\n\n--Chuck Fay \nFileNET Corporation, 3565 Harbor Blvd., Costa Mesa, CA 92626 \nphone:  (714) 327-3513, fax:  (714) 327-5076, email:  cfay@filenet.com\n\n\n\n", "id": "lists-006-8031861"}, {"subject": "Interoperability and client support of option", "content": "I have a bunch of questions about various options, and what is likely to\nbe used and what is going to cause interoperability problems.  My 'core'\nworry (pun intended) is that if I implement a server that supports only\ncore, it will not interoperate with any clients!  E.g. I found out from\nGreg that the Subversion client will not operate against a core-only\nserver.  So, herewith, the questions.  Please answer them if you're\ndoing any client work, whether the answer is yes or no.\n\n1) Is anybody planning to implement a client that will interoperate\nagainst a CORE server, not requiring any advanced options to be there at\nall?\n\n2) A slightly different variation: Is anybody planning to implement a\nclient that only does core, or will all versioning-aware clients support\nCHECKOUT/CHECKIN as well?  Will all versioning-aware clients support\nversion-history?\n\n3) Is anybody planning to use NONE OF these options:\n - working resource option\n - client workspace option\n - Workspace option\nIn other words, is anybody planning to expose the results of\nwork-in-progress, on the VCR, to all clients doing read operations?\n\n4) Can a client that does the checkout option but not the \"working\nresource\" option operate against servers with the \"Working Resource\"\noption?\n\n5) Can a client that doesn't know about the UPDATE option interoperate\nwith VCRs that have had UPDATE applied to them?\n\nRather than make an exhaustive list of these kinds of questions, I'll\njust note that I could raise similar issues for just about every option\nin the draft.  So here's how to head off that flood of questions!  For\nevery option, please add a little \"interoperability\" section, explaining\n - what happens if the client does not support this option but the\nserver does,\n - what happens if the client supports this option but the server does\nnot,\n - whether clients that do not support this option can interact with\nclients that do support this option (I mean, whether both kinds of\nclients can do operations freely on the same set of resources, on a\nserver that does support the option).\n\nEg one might state:\n - If a server implements this option at all, the client must ALSO\nimplement this option in order to interoperate.\nOr:\n - This option is only used when the client requests it.  The server\nthat implements this option MUST also support the case where the client\ndoes NOT request this option, in order to interoperate with clients that\ndo not support this option.\nOr:\n - A VCR on which this option has been used (e.g. UPDATE) MUST\ninteroperate with clients that are unaware of the option.\nOr:\n - If any clients on a system use this option (e.g. Merge), whether\nclients that do not understand the option (e.g. Merge) will be able to\nuse the resources on the system.\n\nThanks,\nLisa\n\n\n\n", "id": "lists-006-8048068"}, {"subject": "RE: DeltaV doesn't support a true client workspac", "content": "From Eric Sedlar:\n> The way we handle the version proliferation\n> problem is to keep a maximum number of the\n> number of autoversioned versions to keep\n> around.\n\nWe thought of this, but discarded it because there is no guarantee that the\nright set of versions would be retained.  You could end up with N trivially\ndifferent versions, especially due to the proliferation that autosave might\ncause, for instance, and lose the versions with significant deltas that\nshould have been retained.\n\n> In a previous product, we had a limit on\n> the number of \"unreleased\" (in DeltaV\n> terms, unlabeled and unbaselined) versions\n> to keep around.\n\nThat's a great idea if your server supports the label or baseline option.\nBut it doesn't help servers that don't.  :-(\n\n> When either count is reached, we start\n> deleting old versions automatically.\n\nI view retention policy as a workaround or band-aid to the real problem,\nwhich is not giving core versioning clients an obvious, clean, safe way to\ncheck in a new version explicitly.  Auto-versioning is great for backward\ncompatibility, but it's not real versioning in the classical sense of\ncheckout, change, checkin.  LOCK, PUT, UNLOCK is error-prone, in that\nclients will have to know not to do more than one PUT (for servers that\ndon't support storage of intermediate state), to avoid the proliferating\nversions trap.  With the alternative, i.e., CHECKOUT/CHECKIN methods, it's\nobvious to the developer that you only get to do one CHECKIN call per\nCHECKOUT.  The client just has to check to see if the mutable VCR option is\nsupported.  If so, it can do intermediate PUTS; if not, it saves all changes\nfor the CHECKIN method.  How can we deny the core versioning client access\nto CHECKOUT/CHECKIN methods?\n\n--Chuck Fay \nFileNET Corporation, 3565 Harbor Blvd., Costa Mesa, CA 92626 \nphone:  (714) 327-3513, fax:  (714) 327-5076, email:  cfay@filenet.com\n\n\n\n", "id": "lists-006-8058132"}, {"subject": "Re: Interoperability and client support of option", "content": "> 1) Is anybody planning to implement a client that will interoperate\n> against a CORE server, not requiring any advanced options to be there at\n> all?\n\nOne of the intentions of the protocol is that versioning-unware clients\nwill interoperate against any DeltaV server, including a core server\nwithout any advanced options at all.\n\nOf course, if you want to write a server that is intended to support a\nserious number of different clients, then you probably will have to\nimplement some of the options.\n\n> 3) Is anybody planning to use NONE OF these options:\n>  - working resource option\n>  - client workspace option\n>  - Workspace option\n\nAs for clients, same answer as for 1), i.e. (at least) any\nversioning-unware client.\n\n> In other words, is anybody planning to expose the results of\n> work-in-progress, on the VCR, to all clients doing read operations?\n\nIf I understand you correctly, this is a different question, because even\nfully-fledged clients may (e.g. by the user's choice) decide not to use\nany of the above options.  So, actually, the answer must always be yes\nfor any combination of a server and client.\n\n> 4) Can a client that does the checkout option but not the \"working\n> resource\" option operate against servers with the \"Working Resource\"\n> option?\n\nYes, but it can only work on the resource that is checked out under the\nURL of the VCR, since it does not know the URLs of the working resources.\n\n> 5) Can a client that doesn't know about the UPDATE option interoperate\n> with VCRs that have had UPDATE applied to them?\n\nYes, but if the server does not allow forking at the selected version,\nthe client can not create a new version until another proper update is\nissued.\n\n>  - what happens if the client does not support this option but the\n> server does,\n\nThe client then simply does not use the option.  But it may possibly not\nbe able to handle resources that have been created/modified by different\nclients that use that option (such as accessing working resources or\ncreating a new version on an updated VCR where forking is not allowed).\n\n>  - what happens if the client supports this option but the server does\n> not,\n\nThe server must reject the according request.  The client should explore\nthe server's capabilities via the OPTIONS method before requesting any\noptional behaviour.\n\n>  - whether clients that do not support this option can interact with\n> clients that do support this option (I mean, whether both kinds of\n> clients can do operations freely on the same set of resources, on a\n> server that does support the option).\n\nIn general, no (cp. again 4) and 5)).\n\n>  - If a server implements this option at all, the client must ALSO\n> implement this option in order to interoperate.\n\nI would regard such a constraint as a bug in the protocol, since a\nserver option never might enforce the client to implement anything.\n\n>  - This option is only used when the client requests it.  The server\n> that implements this option MUST also support the case where the client\n> does NOT request this option, in order to interoperate with clients that\n> do not support this option.\n\nI think this just describes some general requirements of a\n'server option'; it should always be that way.\n\n>  - A VCR on which this option has been used (e.g. UPDATE) MUST\n> interoperate with clients that are unaware of the option.\n\nThat is something that you almost never can achieve in general; see for\nexample the above answers on 4) and 5).  The problem here is, that you\nimplicitly want to have interoperability between different clients that\nuse different options.  This is only possible if you can map complex\noptions on simpler requirements.  For example, HTTP defines an optional\nheader that allows to GET only a range of bytes from a document.  This\ncan be mimicked by the more simple required GET without this header by\ngetting the whole document and throwing away all the data that is not\nneeded.\n\n>  - If any clients on a system use this option (e.g. Merge), whether\n> clients that do not understand the option (e.g. Merge) will be able to\n> use the resources on the system.\n\nIn the case of Merge, yes; in general (e.g. working resources, update) no.\n\nGreetings,\n            Juergen\n\n\n\n", "id": "lists-006-8068203"}, {"subject": "RE: DeltaV Lack of global propertie", "content": "> Just for interests sake, what would be the locking behavior of these\n> \"shared\" (a term I'd slightly prefer over \"global\" or \"mutable\")\n> properties?  If you lock a version, does that prevent change to that\n> property on all versions?  Are shared properties unaffected by write\n> locks?\n\nIt depends how it's defined.  I'd prefer for a \"shared\"/\"global\"\nproperty to exist on the VCR only, not on any of the versions.  That's\nthe easiest way for it to stay in synch across all versions.  Then,\nclearly, a LOCK on the VCR would affect the property as well.  A LOCK on\na version would not.\n\n(What is the meaning of a LOCK on a version, anyway?  If versions aren't\nmutable???)\n\nImportant note:  a \"global\" property is NOT the same as a \"mutable\"\nproperty.  A mutable property may exist on versions, may have different\nvalues on different versions, and most importantly, may be changed on a\nversion without causing a new version to be created.\n\n> Note that although I'm always interested in exploring worthwhile\n> extensions to the WebDAV protocol, I'll point out that the versioning\n> protocol has received some criticism for being too complex because of\n> too many options, so I'm very reluctant to add even more options\n> before the IESG has a chance to review the ones that have already been\n> designed and reviewed.\n\nI strongly feel that BOTH mutable and global properties are required\nfunctionality for many source code and document versioning scenarios.\n\nLisa\n\n\n\n", "id": "lists-006-8080354"}, {"subject": "Re: Interoperability and client support of option", "content": "On Fri, Feb 09, 2001 at 04:55:17PM -0800, Lisa Dusseault wrote:\n>...\n> 1) Is anybody planning to implement a client that will interoperate\n> against a CORE server, not requiring any advanced options to be there at\n> all?\n\nNope. First release will, in fact, only operate against Subversion servers\ndue to the use of a custom report. (that's the biggest; I'm not sure if\nthere are other, tweaky things; in the future, we'll do a fallback if the\nserver doesn't support the report)\n\n> 2) A slightly different variation: Is anybody planning to implement a\n> client that only does core, or will all versioning-aware clients support\n> CHECKOUT/CHECKIN as well?\n\nNo. CHECKOUT of version resources only (i.e. working resource option)\n\n> Will all versioning-aware clients support\n> version-history?\n\nWhat does \"support\" mean. The server manages these guys. What would the\nclient do with them?\n\n> 3) Is anybody planning to use NONE OF these options:\n>  - working resource option\n>  - client workspace option\n\nThe above two are the same.\n\n>  - Workspace option\n> In other words, is anybody planning to expose the results of\n> work-in-progress, on the VCR, to all clients doing read operations?\n\nThe SVN server only supports working resources.\n[ and only working resources that are checked out directly into an existing\n  activity ]\n\n> 4) Can a client that does the checkout option but not the \"working\n> resource\" option operate against servers with the \"Working Resource\"\n> option?\n\nIf they observe the Location: header returned from the CHECKOUT, they can\nprobably interoperate properly.\n\nNote that it is a misstatement to say the client does / does not do the\n\"working resource\" option. Servers do that. If you mean to say, \"if a client\nchecks out a version resource, then what happens on a server that doesn't\nsupport working resources?\" The answer is: failure.\n\n> 5) Can a client that doesn't know about the UPDATE option interoperate\n> with VCRs that have had UPDATE applied to them?\n\nYou started with a query about what people are planning to do. By this\nquestion, you've totally moved into questions about DeltaV itself.\n\nA client should be able to use resources that have UPDATE applied to them.\nBut you're going to have to narrow the question: what types of operations\nare you thinking of? You can't expect us to iterate over every single thing\nand tell you what will happen.\n\n> Rather than make an exhaustive list of these kinds of questions, I'll\n> just note that I could raise similar issues for just about every option\n> in the draft.  So here's how to head off that flood of questions!  For\n> every option, please add a little \"interoperability\" section, explaining\n\n*WHO* are you expecting to do this? Why don't you start us off with some\ntext for one or more sections.\n\nIt isn't nice to impose work on people without providing some of your own\nassistance.\n\nAnd this is *way* off the subject of what kinds of clients people will be\nwriting, and what they expect of the servers they talk to.\n\n\nThe SVN client expects (ie. fails if these are not present):\n\n*) activities\n*) baselines\n*) MERGE\n*) working resources\n*) REPORT\n*) version-controlled collections\n\nAnd a smattering of other bits (e.g. some of fork-control: two people\ncan/should be able to check out the same resource at the same time; only one\ncan check it back in, though)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8089522"}, {"subject": "Re: DeltaV doesn't support a true client workspac", "content": "On Fri, Feb 09, 2001 at 05:58:54PM -0800, Fay, Chuck wrote:\n>...\n> I view retention policy as a workaround or band-aid to the real problem,\n> which is not giving core versioning clients an obvious, clean, safe way to\n> check in a new version explicitly.  Auto-versioning is great for backward\n> compatibility, but it's not real versioning in the classical sense of\n> checkout, change, checkin.  LOCK, PUT, UNLOCK is error-prone, in that\n> clients will have to know not to do more than one PUT (for servers that\n> don't support storage of intermediate state), to avoid the proliferating\n> versions trap. With the alternative, i.e., CHECKOUT/CHECKIN methods, it's\n> obvious to the developer that you only get to do one CHECKIN call per\n> CHECKOUT.  The client just has to check to see if the mutable VCR option is\n> supported.  If so, it can do intermediate PUTS; if not, it saves all changes\n> for the CHECKIN method.  How can we deny the core versioning client access\n> to CHECKOUT/CHECKIN methods?\n\nYou are not suggesting anything new. If the client can avoid intermediate\nPUTs, with the intent of sending it during the CHECKIN, then the client\ncan/should just use a single PUT (with or without locking or checkin/out).\n\nThere is no reason to add complexity to the core protocol to support a\ntrivial (the name of the method that delivers the content) change in the\nclient.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8099835"}, {"subject": "Re: minor comments regarding 12.", "content": "   From: \"Boris Bokowski/OTT/OTI\" <Boris_Bokowski@oti.com>\n\n   section 1.2:\n   Word problem: error - reference source not found\n\nWill fix (so Word guru's: any way to ask Word whether there are\nany bad references?).\n\n   section 2.1, third paragraph:\n   mention that the new version resource is a root version resource.\n\nSome versioning systems allocate a dummy (null) root version,\nin which case the new version would be a descendant of that\nnull root version.\n\n   section 2.2.3, 2.2.4:\n   DAV:supported-method-set and DAV:supported-live-property-set should be \n   protected properties.\n\nYup!  Will fix.  (Will also fix DAV:supported-property-set).\n\n   section 2.3.2:\n   add: \"This property is removed when the resource is checked in, and then \n   added back (potentially identifying a different version) when the resource \n   is checked out again.\"\n\nGood suggestion.  Will do.\n\n   section 2.5, postconditions:\n   change \"a new version history is created and a new version resource is \n   created\" to \"a new version history is created and a new root version \n   resource is created\" (add \"root\")\n\nSee comment on 2.1.  It might not be the root version.\n\n   section 7.2.1:\n   \"If the resource is associated with a workspace\": when is a resource \n   associated with a workspace? If one of its parents is a workspace?\n\nWhen the parent has a DAV:workspace property, then the resource must\nhave one as well, but a server may decide to associate other resources\nwith the workspace (this was added for Mark, who wanted to be able to\nhave his server associate working resources with a workspace).\n\n   section 7.7:\n   missing precondition: parent of null resource MUST exist (or is this \n   covered elsewhere?)\n\nYes, that is required by RFC 2518.\n\n   postcondition: add \"and whose workspace property identifies the containing \n   workspace\"\n\nWe could add this postcondition to every method that creates a resource,\nbut I'd prefer to just state it as an axiom in the DAV:workspace\nproperty definition.  This keeps the requirement localized to the\nworkspace option.\n\n   section 8.3.1, last sentence:\n   change \"was\" to \"were to be\"\n\nWill do.\n\n   section 9.2, Preconditions:\n   DAV:must-select-version-in-same-history is misleading; you cannot select a \n   version from another history, but you could select no version if the label \n   was not found. The precondition should be \n   DAV:must-select-version-in-history. (This applies to other sections \n   listing the same precondition name, e.g. 9.6)\n\nGood point.  Will do.\n\n   section 9.8:\n   This section only applies when the server supports the WORKING-RESOURCE \n   option\n\nWell, I'd say that the section applies always, but the postcondition\ncannot be satisfied unless the server supports the working-resource\noption.\n\n   section 9.9,Preconditions:\n   DAV:apply-to-version: where is this defined?\n\nYes, Greg noticed this too ... this precondition has been fixed and\nmoved to CHECKOUT.\n\n   DAV:label: should this be DAV:label-name ?\n\nGood catch!\n\n   section 10.2.2\n   URLs\n\nThat's always a hard call.  I have consistently used \"URL's\" instead\nof \"URLs\" in the document, since URLs can sometimes be confused as\na four letter acronym.  I could change this if anyone cares enough\nto support this change request (otherwise it's just 1-1, and the author\nwins all tied trivial formatting issues :-).\n\n   section 10.4.1\n   should read: \"This property identifies the members of the workspace \n   collection that are collections under baseline control.\"\n   also: Can't the workspace itself show up in this list too?\n\nYup.  Will fix.\n\n   section 10.5, third paragraph:\n   change \"members\" to \"member\"\n\nI'll rewrite this paragraph ... the postconditions say that the new\nbaseline is empty, and that's what this paragraph should say as well. \n\n   section 10.5, Postcondition DAV:select-existing-baseline:\n   How does this deal with pre-existing non version-controlled resources in \n   the collection with the same relative name? The preconditions only \n   disallow pre-existing version-controlled resources.\n\nGood point.  I'll change that to \"must have no members\".\n\n   section 10.10, Postconditions:\n   baseline-controlled-collection -> DAV:baseline-controlled-collection-set\n\nActually, baseline-controlled-collection is right.  A version-controlled\nconfiguration has a DAV:baseline-controlled-collection, not a \nbaseline-controlled-collection-set (only workspaces have the\nlatter).\n\nBoris: Please thank your colleague for this excellent review!\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-8108369"}, {"subject": "Re: FW: DeltaV doesn't support a true client workspac", "content": "On Fri, Feb 09, 2001 at 04:26:32PM -0800, Fay, Chuck wrote:\n>...\n> I noticed that I didn't reiterate all the key points in my message below, so\n> let me elaborate here.  Assume that my versioning server does not allow\n> mutable non-collection resources of any kind -- every PUT MUST create a new\n> version.  So it offers no storage of intermediate resource state between a\n> checkout and checkin.\n\nFine. DeltaV can accomodate that without change.\n\n> I'm proposing that the ability to do PUTs to a checked-out VCR remain an\n> option.  That capability is currently embedded in the CHECKOUT option.  I\n> want to separate that capability out and keep it optional.  I want to return\n> the CHECKOUT, CHECKIN, and UNCHECKOUT methods to core versioning, but\n> without the mutable checked-out VCR capability.  Thus a core versioning\n> client could do the following (assume all non-collection versionable\n> resources are version-controlled):\n> \n> CHECKOUT /foo.html\n> GET /foo.html\n>   Modify content locally, saving intermediate\n>   state locally or on a file server, but not\n>   by doing a PUT to /foo.html, which is not\n>   allowed in my proposal.  PUTs would not be\n>   allowed on checked-out VCRs in core\n>   versioning.  (Note that PUTs would always be\n>   allowed on checked-in VCRs with auto-version\n>   set to either always-checkout-* value.)\n>   Finally I'm happy with my local copy and want\n>   to create a new version on the server with\n>   my local content.\n> CHECKIN /foo.html (with new content in the request body)\n\nHow about:\n\nGET /foo.html\n  Modify content locally, saving intermediate state locally or on a file\n  server.\nPUT /foo.html\n\nThat accomplishes exactly the same task as you requested. Why do we need to\nchange the current spec?\n\nIf your versioning-aware client (a given since you mentioned CHECKIN) can\nstash content locally, then it can hold all changes until a single PUT\noccurs.\n\nFurther, you can have your server set DAV:auto-version to be\nDAV:always-checkout-always-checkin and not allow clients to change in. That\nwill explicitly tell clients that any change will create a new version.\n\nThus, you can offer a Core server to do exactly what you are requesting. No\nneed for the \"CHECKOUT OPTION\" or for any change in the Core.\n\n> I don't see why there should any big objection to this proposal, except on\n> religious grounds that any real versioning server *must* provide\n> intermediate storage of working versions.\n\nI don't believe anybody has asserted that. If they have, then they're wrong\n:-) I believe my counter-example above shows that a server can effect this\nmodel with the current definition of Core.\n\n> Clients that can't live without\n> intermediate storage on their versioning server can still take advantage of\n> servers offering that option and don't have to include a request body with\n> the CHECKIN.  They just won't work with my server and I can accept that.  If\n> all clients end up requiring that, I'll end up changing my server.  But it\n> works fine for many customers today without that capability.\n\nAnd in the current model, if a client cannot buffer changes locally, they\nthey'll do a number of PUTs, which create a number of versions. Your\nproposed model doesn't change that resulting behavior.\n\n> This allows CHECKOUT/CHECKIN methods in core versioning, which seems\n> intuitively necessary.  What kind of versioning server doesn't have the\n> notion of CHECKOUT and CHECKIN?  It seems unimaginable that core versioning\n> could be defined without including these methods.\n\nI can easily imagine it, and I hope that I've easily explained it :-)\n\nTo me, a Core server is defined to do auto-versioning for versioning-unaware\nclients. For clients that have a bit of versioning awareness, they can do a\nfew nifty things, but the mechanisms for *creating versions* are very\nlimited. Much of the query / discovery facilities are present, however.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8120399"}, {"subject": "Re: DAV:compare-baseline REPOR", "content": "Now that we have the DAV:baseline-collection for a baseline,\nI agree that this is a much more appropriate value for the\nresults of this report.  In particular, I'd just return the\nVCR URL from the DAV:baseline-collection (you could get the\nversion URL from the DAV:checked-in property, if you cared).\n\nDoes anyone object?\n\nCheers,\nGeoff\n\n\n\n   From: \"Boris Bokowski/OTT/OTI\" <Boris_Bokowski@oti.com>\n   Date: Fri, 9 Feb 2001 13:56:39 -0500\n\n   This is a change request - I hope it's not too late:\n\n   A compare-baseline REPORT only contains version URLs. This makes it very \n   painful to find out what the changes are in terms of the VCRs that are \n   exposed by the DAV:baseline-collection. I would like to see, instead of \n   version URLs being reported by the DAV:compare-baseline, the VCR URLs from \n   the corresponding DAV:baseline-collection(s).\n\n   I would propose the following (just for the added-version case, \n   deleted-version and changed-version would be similar):\n\n   A DAV:added-version element identifies a member of the \n   DAV:baseline-collection of the compare baseline version whose \n   DAV:checked-in version belongs to a version history from which no version \n   is the DAV:checked-in version of a member of the DAV:baseline-collection \n   of the request baseline.\n   <!ELEMENT added-version (href)>\n   As an alternative, both URLs could be reported (VCR and version URLs).\n\n   Boris.\n\n\n\n", "id": "lists-006-8131573"}, {"subject": "Re: minor comments regarding 12.", "content": "On Fri, Feb 09, 2001 at 09:22:44PM -0500, Geoffrey M. Clemm wrote:\n>...\n>    section 10.2.2\n>    URLs\n> \n> That's always a hard call.  I have consistently used \"URL's\" instead\n> of \"URLs\" in the document, since URLs can sometimes be confused as\n> a four letter acronym.  I could change this if anyone cares enough\n> to support this change request (otherwise it's just 1-1, and the author\n> wins all tied trivial formatting issues :-).\n\nI tend to use URLs. The 's form always means \"possessive\" to me, rather than\n\"plural\".\n\nIn this context, I doubt that URLs will be ambiguous with some four letter\nacronum.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8140303"}, {"subject": "Re: minor comments regarding 12.", "content": "Thanks Geoff! \n\n>    section 9.8:\n>    This section only applies when the server supports the \nWORKING-RESOURCE \n>    option\n> \n> Well, I'd say that the section applies always, but the postcondition\n> cannot be satisfied unless the server supports the working-resource\n> option.\n\nThis might be understood as \"If you support LABEL, you must support \nWORKING-RESOURCE as well.\" I think the section should be hedged by \"If the \nserver supports the WORKING-RESOURCE option...\" so that this \ninterpretation is no longer possible.\n\n>    Word problem: error - reference source not found\n> \n> Will fix (so Word guru's: any way to ask Word whether there are\n> any bad references?).\n\nIn Word 2000, you can select all (CTRL-A) and recalculate (F9). After \nthis, the status line tells you about bad references. I don't know how to \nfind them once you know they are there, though. \n\nBoris.\n\n\n\n", "id": "lists-006-8147871"}, {"subject": "Re: DAV:compare-baseline REPOR", "content": "> Now that we have the DAV:baseline-collection for a baseline,\n> I agree that this is a much more appropriate value for the\n> results of this report.  In particular, I'd just return the\n> VCR URL from the DAV:baseline-collection (you could get the\n> version URL from the DAV:checked-in property, if you cared).\n> \n> Does anyone object?\n\nOf course not :-)\n\nHowever, now that I have a supporter I can at least try to be a bit more \ngreedy ;-)\n\nFor my anticipated use of this report, getting the version URLs as well \nwould be a substantial gain over having to query the DAV:checked-in \nproperty for each change.\n\nBoris.\n\n\n\n", "id": "lists-006-8156094"}, {"subject": "Re: minor comments regarding 12.", "content": "> > That's always a hard call.  I have consistently used \"URL's\" instead\n> > of \"URLs\" in the document, since URLs can sometimes be confused as\n> > a four letter acronym.  I could change this if anyone cares enough\n> > to support this change request (otherwise it's just 1-1, and the \nauthor\n> > wins all tied trivial formatting issues :-).\n> \n> I tend to use URLs. The 's form always means \"possessive\" to me, rather \nthan\n> \"plural\".\n\nI second that.\n\nSeems like 2-1 to me , at least so far :-)\n\nBoris.\n\n\n\n", "id": "lists-006-8163990"}, {"subject": "Re: DAV:compare-baseline REPOR", "content": "As a potential implementor of this report... no issues.\n\nPersonally, I'd also like to see move/copy reflected in the comparison\nreport. If a client is fetching the report to detect a difference, it would\nbe nice to see \"ah. that was copied from over <there>\". I don't have\nanything solid syntax to suggest here, though. I'll write something up if\npeople think it would be beneficial? (and with the understanding that a\nserver is not required to record copies/moves in the report, but could use\nadd/delete).\n\nCheers,\n-g\n\nOn Fri, Feb 09, 2001 at 09:28:56PM -0500, Geoffrey M. Clemm wrote:\n> \n> Now that we have the DAV:baseline-collection for a baseline,\n> I agree that this is a much more appropriate value for the\n> results of this report.  In particular, I'd just return the\n> VCR URL from the DAV:baseline-collection (you could get the\n> version URL from the DAV:checked-in property, if you cared).\n> \n> Does anyone object?\n> \n> Cheers,\n> Geoff\n> \n> \n> \n>    From: \"Boris Bokowski/OTT/OTI\" <Boris_Bokowski@oti.com>\n>    Date: Fri, 9 Feb 2001 13:56:39 -0500\n> \n>    This is a change request - I hope it's not too late:\n> \n>    A compare-baseline REPORT only contains version URLs. This makes it very \n>    painful to find out what the changes are in terms of the VCRs that are \n>    exposed by the DAV:baseline-collection. I would like to see, instead of \n>    version URLs being reported by the DAV:compare-baseline, the VCR URLs from \n>    the corresponding DAV:baseline-collection(s).\n> \n>    I would propose the following (just for the added-version case, \n>    deleted-version and changed-version would be similar):\n> \n>    A DAV:added-version element identifies a member of the \n>    DAV:baseline-collection of the compare baseline version whose \n>    DAV:checked-in version belongs to a version history from which no version \n>    is the DAV:checked-in version of a member of the DAV:baseline-collection \n>    of the request baseline.\n>    <!ELEMENT added-version (href)>\n>    As an alternative, both URLs could be reported (VCR and version URLs).\n> \n>    Boris.\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8171883"}, {"subject": "RE: typos in version tree report exampl", "content": "Will fix.  Thanks, Tim!\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Friday, February 09, 2001 10:05 AM\nTo: ietf-dav-versioning@w3.org\nSubject: typos in version tree report example\n\n\n\n\nTwo typos in the version tree report example Section 2.6.1:\n\n>>RESPONSE\n     HTTP/1.1 207 OK  ** Should be Multi-Status **\n     Content-Type: ...\n     Content-Length: ...\n\n     <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n     <D:multistatus xmlns:D=\"DAV:\"/>  ** This element is closed too early,\nas in /> **\n         <D:response>\n             <D:href>http://repo.webdav.org/his/23/ver/V1</D:href>\n             <D:propstat>\n                 <D:prop/>\n                     ... etc\n\n\n[JimW: I thought you'd reviewed core carefully <G>]\n\nTim\n\n\n\n", "id": "lists-006-8181162"}, {"subject": "RE: DAV:compare-baseline REPOR", "content": "OK, let's get a bit more disciplined here (:-).\nDoes anyone else want this change to be made?\nBy default, it stays the way it is (i.e. version URLs)\nunless the working group expresses a clear preference\nfor making the change.\n\nNote that one could compute the VCR's from the\nversion URLs by just doing\na Depth PROPFIND for the DAV:checked-in property on\nthe baseline-collection, and then match up the\nversion URLs with the\nversions from the Depth PROPFIND.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Geoffrey M. Clemm [mailto:geoffrey.clemm@rational.com]\nSent: Friday, February 09, 2001 9:29 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: DAV:compare-baseline REPORT\n\n\n\nNow that we have the DAV:baseline-collection for a baseline,\nI agree that this is a much more appropriate value for the\nresults of this report.  In particular, I'd just return the\nVCR URL from the DAV:baseline-collection (you could get the\nversion URL from the DAV:checked-in property, if you cared).\n\nDoes anyone object?\n\nCheers,\nGeoff\n\n\n\n   From: \"Boris Bokowski/OTT/OTI\" <Boris_Bokowski@oti.com>\n   Date: Fri, 9 Feb 2001 13:56:39 -0500\n\n   This is a change request - I hope it's not too late:\n\n   A compare-baseline REPORT only contains version URLs. This makes it very \n   painful to find out what the changes are in terms of the VCRs that are \n   exposed by the DAV:baseline-collection. I would like to see, instead of \n   version URLs being reported by the DAV:compare-baseline, the VCR URLs\nfrom \n   the corresponding DAV:baseline-collection(s).\n\n   I would propose the following (just for the added-version case, \n   deleted-version and changed-version would be similar):\n\n   A DAV:added-version element identifies a member of the \n   DAV:baseline-collection of the compare baseline version whose \n   DAV:checked-in version belongs to a version history from which no version\n\n   is the DAV:checked-in version of a member of the DAV:baseline-collection \n   of the request baseline.\n   <!ELEMENT added-version (href)>\n   As an alternative, both URLs could be reported (VCR and version URLs).\n\n   Boris.\n\n\n\n", "id": "lists-006-8189632"}, {"subject": "RE: minor comments regarding 12.", "content": "OK, that's 2-1, so URLs it is (:-).\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Greg Stein [mailto:gstein@lyra.org]\nSent: Friday, February 09, 2001 9:36 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: minor comments regarding 12.2\n\n\nOn Fri, Feb 09, 2001 at 09:22:44PM -0500, Geoffrey M. Clemm wrote:\n>...\n>    section 10.2.2\n>    URLs\n> \n> That's always a hard call.  I have consistently used \"URL's\" instead\n> of \"URLs\" in the document, since URLs can sometimes be confused as\n> a four letter acronym.  I could change this if anyone cares enough\n> to support this change request (otherwise it's just 1-1, and the author\n> wins all tied trivial formatting issues :-).\n\nI tend to use URLs. The 's form always means \"possessive\" to me, rather than\n\"plural\".\n\nIn this context, I doubt that URLs will be ambiguous with some four letter\nacronum.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8199597"}, {"subject": "Re: DAV:compare-baseline REPOR", "content": "On Fri, Feb 09, 2001 at 09:50:40PM -0500, Boris Bokowski/OTT/OTI wrote:\n> > Now that we have the DAV:baseline-collection for a baseline,\n> > I agree that this is a much more appropriate value for the\n> > results of this report.  In particular, I'd just return the\n> > VCR URL from the DAV:baseline-collection (you could get the\n> > version URL from the DAV:checked-in property, if you cared).\n> > \n> > Does anyone object?\n> \n> Of course not :-)\n> \n> However, now that I have a supporter I can at least try to be a bit more \n> greedy ;-)\n> \n> For my anticipated use of this report, getting the version URLs as well \n> would be a substantial gain over having to query the DAV:checked-in \n> property for each change.\n\nAgreed.\n\nAnother alternative to making the DAV:checked-in special (or saying that the\nversion resource URL is explicitly returned), is to simply allow a DAV:prop\nelement to exist in the report request, and each set of properties will be\nreturned for each [VCR] href mentioned in the report.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8207738"}, {"subject": "Re: DAV:compare-baseline REPOR", "content": "On Fri, Feb 09, 2001 at 10:36:15PM -0500, Clemm, Geoff wrote:\n> OK, let's get a bit more disciplined here (:-).\n> Does anyone else want this change to be made?\n> By default, it stays the way it is (i.e. version URLs)\n> unless the working group expresses a clear preference\n> for making the change.\n> \n> Note that one could compute the VCR's from the\n> version URLs by just doing\n> a Depth PROPFIND for the DAV:checked-in property on\n> the baseline-collection, and then match up the\n> version URLs with the\n> versions from the Depth PROPFIND.\n\nAssuming that Depth:infinity is not available (a good presumption, given the\nuse of baselines in the first place as a way to avoid overload), then your\nPROPFINDs will take log(N) requests before you find the VCR that corresponds\nto version in question.\n\nHowever, if you return VCR URLs, you can get the VR URL in a single\nPROPFIND.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8215634"}, {"subject": "Re: minor comments regarding 12.", "content": "   From: \"Boris Bokowski/OTT/OTI\" <Boris_Bokowski@oti.com>\n   Date: Fri, 9 Feb 2001 21:44:21 -0500\n\n   Thanks Geoff! \n\n   >    section 9.8:\n   >    This section only applies when the server supports the \n   WORKING-RESOURCE \n   >    option\n   > \n   > Well, I'd say that the section applies always, but the postcondition\n   > cannot be satisfied unless the server supports the working-resource\n   > option.\n\n   This might be understood as \"If you support LABEL, you must support \n   WORKING-RESOURCE as well.\" I think the section should be hedged by \"If the \n   server supports the WORKING-RESOURCE option...\" so that this \n   interpretation is no longer possible.\n\nGood point.  I will add that hedge to this section.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-8223376"}, {"subject": "Re: DeltaV Lack of global propertie", "content": "   From: \"Lisa Dusseault\" <lisa@xythos.com>\n\n   > Just for interests sake, what would be the locking behavior of these\n   > \"shared\" (a term I'd slightly prefer over \"global\" or \"mutable\")\n   > properties?  If you lock a version, does that prevent change to that\n   > property on all versions?  Are shared properties unaffected by write\n   > locks?\n\n   It depends how it's defined.  I'd prefer for a \"shared\"/\"global\"\n   property to exist on the VCR only, not on any of the versions.  That's\n   the easiest way for it to stay in synch across all versions.  Then,\n   clearly, a LOCK on the VCR would affect the property as well.  A LOCK on\n   a version would not.\n\nSorry, my typo.  I meant \"If you lock a version-controlled resource,\ndoes that prevent change to that property on all other version-controlled\nresources for that same version history (you have stated that you\nwant the property to appear on all version-controlled resources\nfor that version history).\n\nIs the property on the version history itself?  If not, does it\ndisappear if you delete the last version-controlled resource\nfor that version history (i.e. it's not there if you create\na new version-controlled resource for that version history)?\n\n   (What is the meaning of a LOCK on a version, anyway?  If versions aren't\n   mutable???)\n\nVersions have live properties which can be changed, and if the\nproperty is defined as being affected by a lock, a lock on\nthat version would prevent changes to that live property.\nBut as you say above, we should be talking about version-controlled\nresources, not versions.\n\n   Important note:  a \"global\" property is NOT the same as a \"mutable\"\n   property.  A mutable property may exist on versions, may have different\n   values on different versions, and most importantly, may be changed on a\n   version without causing a new version to be created.\n\nFair enough.  I shouldn't have confused the two.  Note that the\nprotocol allows the server to have both global/shared and mutable properties\nby just making them be live properties.  But I agree that there\nis currently no interoperable way for a client to define that\nthey want a property to be live, and no way to define the\nsemantics of their live properties (e.g. affected by a lock,\nmutable, shared/global, etc.).  But I believe that protocol for\nthis should be done in a general WebDAV forum, since defining\ncharacteristics of live properties (kept on copy, single valued,\nwhatever) is a general WebDAV issue, not a versioning-specific\nissue.\n\n   > Note that although I'm always interested in exploring worthwhile\n   > extensions to the WebDAV protocol, I'll point out that the versioning\n   > protocol has received some criticism for being too complex because of\n   > too many options, so I'm very reluctant to add even more options\n   > before the IESG has a chance to review the ones that have already been\n   > designed and reviewed.\n\n   I strongly feel that BOTH mutable and global properties are required\n   functionality for many source code and document versioning scenarios.\n\nSo are ACL's and Searching, but that's happening in a general WebDAV context,\nbecause it involves general functionality that shouldn't be\ntailored just to versioning needs.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-8231301"}, {"subject": "Re: FW: DeltaV doesn't support a true client workspac", "content": "   From: \"Fay, Chuck\" <CFay@filenet.com>\n\n   ...\n\n   CHECKIN /foo.html (with new content in the request body)\n\n   I don't see why there should any big objection to this proposal, except on\n   religious grounds that any real versioning server *must* provide\n   intermediate storage of working versions.\n\nI raised the (non-religious :-) objection in my previous response that\nthis requires that every argument for the CHECKIN request be a new\nheader.  I consider this completely unacceptable, since unlike XML\nelements, headers are in a single global namespace so it would be\ninfeasible for a server to safely extend the CHECKIN request.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-8241869"}, {"subject": "Re: Auto-version correction", "content": "   From: \"Fay, Chuck\" <CFay@filenet.com>\n\n   Suggested corrections to the spec related to auto-versioning:\n\n   Several sections still talk in terms of the auto-version property\n   being \"set\" and describing behavior in that case, without\n   specifying any particular setting of auto-version.  This worked\n   when it only had true and false values, since \"set\" implied the\n   true value.  Now that it has four different possible values, the\n   use of the verb \"set\" alone is ambiguous.\n\nGood point.\n\n   For instance, section 2.1.2 overstates the case when it says \"A PUT\n   or PROPPATCH to a version-controlled resource with the\n   DAV:auto-version property set will automatically check out that\n   resource prior to executing the PUT or PROPPATCH.\"  Of the four\n   different possible values for auto-version, some do not have the\n   prescribed behavior (i.e., never, and when-locked-checkout if the\n   VCR is unlocked).  So this needs to be reworded in order to avoid\n   oversimplifying and misleading the reader.\n\nI agree.\n\n   For instance, paragraphs 2 and 3 of 2.1.2 could be replaced by the\n   following paragraph:\n\n   \"For clients that are unaware of versioning semantics, the\n   DAV:auto-version property provides for automatic versioning on PUT\n   and PROPPATCH methods.  Certain settings of the auto-version\n   property on a checked-in version-controlled resource will cause\n   that resource to be checked out automatically, prior to executing\n   the PUT or PROPPATCH.  With one setting of auto-version, the\n   resource is checked back in immediately afterwards, again\n   automatically.  This results in a new version immediately after\n   each successful PUT or PROPPATCH.  With other settings of\n   auto-version, if the resource is write-locked at the time of the\n   PUT or PROPPATCH, it will remain checked out for the duration of\n   the lock, so that the automatic checkin is delayed until the\n   resource is unlocked.  Auto-versioning can also be turned off\n   completely.  (See the sections on DAV:auto-version, PUT, PROPPATCH,\n   COPY, and UNLOCK for the details on auto-version settings.)\"\n\nThanks for the suggested rewording, Chuck!  It always makes my\nlife easier to see exactly what you have in mind.\n\n   The above paragraph omits the note that \"unlock\" includes any way that a\n   lock is removed, including lock timeout.  My thinking is that that sort of\n   detail should be covered in the section on DAV:auto-version, if necessary.\n\nI agree.\n\n   Also, sections 2.8 and 2.9 have preconditions based on auto-version being\n   \"set\".  They too need to be updated to address specific settings of\n   auto-version.  This would clarify one remaining case that is not specified:\n   PUT on a checked-in, non-write-locked VCR with auto-version =\n   when-locked-checkout.  My understanding from earlier mail is that the PUT\n   (or PROPPATCH of a dead property) should fail in this case, but that is not\n   clear from the preconditions.\n\nWill fix.\n\nThanks for catching that ambiguity!\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-8250188"}, {"subject": "RE: Option abus", "content": "The DAV:workspace-collection set is usually the same for a\nwhole server, so just like the DAV header, there is no need\nto query it for more than one resource on a given server.\n\nIn contrast, the supported methods and live properties vary\nfrom resource to resource, and therefore are more appropriately\nmarshalled as a property so that it can easily be retrieved\nin a depth fashion with the other information about that resource.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: James J. Hunt [mailto:jjh@allerton.de]\nSent: Monday, February 05, 2001 1:15 PM\nTo: Geoffrey M. Clemm\nCc: ietf-dav-versioning@w3.org\nSubject: Re: Option abuse\n\n\n\"Geoffrey M. Clemm\" wrote:\n\n>\n> It really doesn't matter whether we marshall this as an OPTIONS call\n> or as a PROPFIND for a property.  This used to be marshalled as a\n> property but a reviewer pointed out that this information seemed more\n> like an option than a property.\n>\n> Can you give some motivation for switching this back to being a property?\n>\n> Cheers,\n> Geoff\n\nDear Geoff,\n\nMy understanding of an option is \"does the server support x\".  Properties\nassociate values to keys for a given resource.  Let us take\nDAV:workspace-collection-set.  Especially when you say that the http\nnamespace\ncan be spread over several servers, the question I ask with this tag is not\ndo\nyou support workspaces, rather for a given versionable workspace, where can\nI\ncreate a workspace for it?  In other words, I am asking what is the\nworkspace\narea associated with this resource.  That seems to me to be a property of\nthat\nresource, because every resource could answer it differently.\n\nSincerely,\nJames\n\n\n\n", "id": "lists-006-8260295"}, {"subject": "RE: FW: DeltaV doesn't support a true client workspac", "content": "I agree with Greg's response below.\n\nAlso, if you want to make sure that only a versioning-aware\nclient creates new versions (e.g. to make sure that a\nauto-saving versioning unaware client doesn't create a\nflood of versions), make your DAV:auto-version property\nmodifiable by your client (only allowing the value to be\nempty or DAV:always-checkout-always-checkin), and then initialize\nDAV:auto-version to be empty.  An attempt by a versioning\nunaware client to update the resource will fail, but a\nversioning-aware client can LOCK the resource, set the\nDAV:auto-version property to be DAV:always-checkout-always-checkin,\ndo the PUT, set the DAV:auto-version property back to empty,\nand then UNLOCK the resource.\n\nSo like Greg, I don't see that the protocol needs to be\nextended for you to do what you want.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Greg Stein [mailto:gstein@lyra.org]\nSent: Friday, February 09, 2001 9:31 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: FW: DeltaV doesn't support a true client workspace\n\n\nOn Fri, Feb 09, 2001 at 04:26:32PM -0800, Fay, Chuck wrote:\n>...\n> I noticed that I didn't reiterate all the key points in my message below,\nso\n> let me elaborate here.  Assume that my versioning server does not allow\n> mutable non-collection resources of any kind -- every PUT MUST create a\nnew\n> version.  So it offers no storage of intermediate resource state between a\n> checkout and checkin.\n\nFine. DeltaV can accomodate that without change.\n\n> I'm proposing that the ability to do PUTs to a checked-out VCR remain an\n> option.  That capability is currently embedded in the CHECKOUT option.  I\n> want to separate that capability out and keep it optional.  I want to\nreturn\n> the CHECKOUT, CHECKIN, and UNCHECKOUT methods to core versioning, but\n> without the mutable checked-out VCR capability.  Thus a core versioning\n> client could do the following (assume all non-collection versionable\n> resources are version-controlled):\n> \n> CHECKOUT /foo.html\n> GET /foo.html\n>   Modify content locally, saving intermediate\n>   state locally or on a file server, but not\n>   by doing a PUT to /foo.html, which is not\n>   allowed in my proposal.  PUTs would not be\n>   allowed on checked-out VCRs in core\n>   versioning.  (Note that PUTs would always be\n>   allowed on checked-in VCRs with auto-version\n>   set to either always-checkout-* value.)\n>   Finally I'm happy with my local copy and want\n>   to create a new version on the server with\n>   my local content.\n> CHECKIN /foo.html (with new content in the request body)\n\nHow about:\n\nGET /foo.html\n  Modify content locally, saving intermediate state locally or on a file\n  server.\nPUT /foo.html\n\nThat accomplishes exactly the same task as you requested. Why do we need to\nchange the current spec?\n\nIf your versioning-aware client (a given since you mentioned CHECKIN) can\nstash content locally, then it can hold all changes until a single PUT\noccurs.\n\nFurther, you can have your server set DAV:auto-version to be\nDAV:always-checkout-always-checkin and not allow clients to change in. That\nwill explicitly tell clients that any change will create a new version.\n\nThus, you can offer a Core server to do exactly what you are requesting. No\nneed for the \"CHECKOUT OPTION\" or for any change in the Core.\n\n> I don't see why there should any big objection to this proposal, except on\n> religious grounds that any real versioning server *must* provide\n> intermediate storage of working versions.\n\nI don't believe anybody has asserted that. If they have, then they're wrong\n:-) I believe my counter-example above shows that a server can effect this\nmodel with the current definition of Core.\n\n> Clients that can't live without\n> intermediate storage on their versioning server can still take advantage\nof\n> servers offering that option and don't have to include a request body with\n> the CHECKIN.  They just won't work with my server and I can accept that.\nIf\n> all clients end up requiring that, I'll end up changing my server.  But it\n> works fine for many customers today without that capability.\n\nAnd in the current model, if a client cannot buffer changes locally, they\nthey'll do a number of PUTs, which create a number of versions. Your\nproposed model doesn't change that resulting behavior.\n\n> This allows CHECKOUT/CHECKIN methods in core versioning, which seems\n> intuitively necessary.  What kind of versioning server doesn't have the\n> notion of CHECKOUT and CHECKIN?  It seems unimaginable that core\nversioning\n> could be defined without including these methods.\n\nI can easily imagine it, and I hope that I've easily explained it :-)\n\nTo me, a Core server is defined to do auto-versioning for versioning-unaware\nclients. For clients that have a bit of versioning awareness, they can do a\nfew nifty things, but the mechanisms for *creating versions* are very\nlimited. Much of the query / discovery facilities are present, however.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8269344"}, {"subject": "Re: Option abus", "content": "And also given what Geoff said, it is entirely reasonable for an OPTIONS on\n/foo to return an entirely different result than OPTIONS on /bar.\n\nThus, if the two URLs are served by different servers, or they are simply\nconfigured differently, they can return different workspace-collection-set\nvalues.\n\nIMO, it is still quite ridiculous to do some discovery through OPTIONS, and\nother discovery through PROPFIND. OPTIONS is defined to be per-resource (if\nyou want general server options, the use \"*\" for the Request-URI).\nArbitrarily classifying a subset of information as \"more useful in a Depth:\ncontext, so we'll put it into PROPFIND\" is just that: arbitrary. In layman's\nterms, that is a synonym for \"bogus\". :-)\n\nCheers,\n-g\n\nOn Sat, Feb 10, 2001 at 12:11:48AM -0500, Clemm, Geoff wrote:\n> The DAV:workspace-collection set is usually the same for a\n> whole server, so just like the DAV header, there is no need\n> to query it for more than one resource on a given server.\n> \n> In contrast, the supported methods and live properties vary\n> from resource to resource, and therefore are more appropriately\n> marshalled as a property so that it can easily be retrieved\n> in a depth fashion with the other information about that resource.\n> \n> Cheers,\n> Geoff\n> \n> -----Original Message-----\n> From: James J. Hunt [mailto:jjh@allerton.de]\n> Sent: Monday, February 05, 2001 1:15 PM\n> To: Geoffrey M. Clemm\n> Cc: ietf-dav-versioning@w3.org\n> Subject: Re: Option abuse\n> \n> \n> \"Geoffrey M. Clemm\" wrote:\n> \n> >\n> > It really doesn't matter whether we marshall this as an OPTIONS call\n> > or as a PROPFIND for a property.  This used to be marshalled as a\n> > property but a reviewer pointed out that this information seemed more\n> > like an option than a property.\n> >\n> > Can you give some motivation for switching this back to being a property?\n> >\n> > Cheers,\n> > Geoff\n> \n> Dear Geoff,\n> \n> My understanding of an option is \"does the server support x\".  Properties\n> associate values to keys for a given resource.  Let us take\n> DAV:workspace-collection-set.  Especially when you say that the http\n> namespace\n> can be spread over several servers, the question I ask with this tag is not\n> do\n> you support workspaces, rather for a given versionable workspace, where can\n> I\n> create a workspace for it?  In other words, I am asking what is the\n> workspace\n> area associated with this resource.  That seems to me to be a property of\n> that\n> resource, because every resource could answer it differently.\n> \n> Sincerely,\n> James\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8282168"}, {"subject": "OT: Plurals of Acronyms and Initialism", "content": "At first I was surprised by the tendency to treat acronyms (whether\npronounceable as words or not) as nouns with mixed-case plural forms.  In\nalliance with this trend, I have been training myself to use the -s and not\nthe -'s.  Partly because the ODMA specification does that, and I have to\nlive with it.\n\nI checked with a modest but prominent authority:\n\n1. Form the plural of an acronym by adding an s with no apostrophe.  E.g.,\nURLs, GUIDs.\n\n2. Form the plural of a single letter by adding an apostrophe and an s.  The\nletter itself (but not the s) is in italic.  (I have no idea where this came\nfrom.  Sounds like a good reason to avoid having this case, especially when\ndoing mathematics.)\n\n3. Form the plural of a number by adding an s with no apostrophe.  E.g.,\n1950s.\n\nThis is from the Microsoft Manual of Style for Technical Publications.\n\nO'Reilly uses the Chicago Manual of Style, and I don't know what that offers\non this subject, but the DocBook book uses \"DTDs.\"  It looks like the\nauthor/editor of that book found many ways to avoid plurals by rewording.\nThe O'Reilly style sheet lists -s forms in the default spellings for GUIs,\nURLs, and BHOs.\n\nI would say that, unless IETF has a specific style requirement for this,\nthat the -s form is important.  It allows us to speak of URLs and of a URL's\nsomething-or-other.\n\n- OT warning ---- OT warning -\n\nNotice that whether you say \"an URL\" or \"a URL\" is more difficult, because\nit depends on how you pronounce \"URL\" and perhaps on your generation, like\nhaving the final period of a sentence inside an ending quotation.  It's a\nyoo-are-ell, when it's not an oo-rl.  I always want to put \"an U...\" in\nprint, even though at one time it was considered that U with the yoo-sound,\nas in Univac, was not a case of the vowel rule.  But my ear isn't trained\nthat way, and \"an Univac\" sounds smoother to me.  Sigh.  I even say \"an HTML\ndocument ...\" a demonstration that the rule for articles is about\npronunciation, not spelling, for me.  How about you?\n\nReverting to the previous modest authority, the following is on page 1\n(Under Abbreviations and Acronyms):\n\n\"Choose a preceding indefinite article ('a' or 'an') based on the acronym's\npronunciation -- for example, 'an ANSI character set' or 'a WYSIWYG\nsystem.'\"\n\nNotice that ANSI and WYSIWYG are initialisms, but they have also become\nacronyms as pronouncable words (though in some language yet to be named).\nThe ever-modest style-guide authors managed to come up with examples that\nwork for either approach to pronunciation, bless their hearts.\n\n-- Dennis\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Boris\nBokowski/OTT/OTI\nSent: Friday, February 09, 2001 18:58\nTo: ietf-dav-versioning@w3.org\nSubject: Re: minor comments regarding 12.2\n\n\n> > That's always a hard call.  I have consistently used \"URL's\" instead\n> > of \"URLs\" in the document, since URLs can sometimes be confused as\n> > a four letter acronym.  I could change this if anyone cares enough\n> > to support this change request (otherwise it's just 1-1, and the\nauthor\n> > wins all tied trivial formatting issues :-).\n>\n> I tend to use URLs. The 's form always means \"possessive\" to me, rather\nthan\n> \"plural\".\n\nI second that.\n\nSeems like 2-1 to me , at least so far :-)\n\nBoris.\n\n\n\n", "id": "lists-006-8292215"}, {"subject": "Part 1, Comments on draft-ietf-deltav-versioning-12.", "content": "I've only gotten through the first 9 pages of typing in comments,\nso I think I better chunk these and send what I have.\n\nI *think* that most of these comments are editorial; that is, there\nare sentences and phrases in the draft that are confusing, and it\nis quite possible that the confusions could be cleared up editorially\nwithout changing the protocol. However, it is often the case that\nconfusing or ambiguous wording hides errors in protocols. In general,\nthe document is very hard to read. You might argue that \"well, we\nunderstand it, and that's good enough.\" And on the phone conference\nI got some of this pushback, \"we tried clarifying this before with\nexamples and the examples confused other people\".\n\nBut there is no point in bothering with the IETF process if all you\nare going to wind up with is a document that only the authors\nand working group members understand. The value that you get from\n\"IETF Proposed Standard\" comes with a price: writing something\nthat ordinary implementors can sit down and code to. I don't think\nit's impossible to document this protocol clearly.\n\nSpecific comments:\n\n1. \"This document defines WebDAV Versioning extensions, an application of\n HTTP/1.1 ...\"\n\nBut the \"WebDAV Versioning extensions\" are not, by themselves,\nan application of HTTP/1.1. The WebDAV Versioning extensions are\na set of extensions to WebDAV, which, in turn, is a set of extensions\nof HTTP/1.1 ...  In general, the relationship between the versioning\nextensions, WebDAV and HTTP/1.1 needs to be stated clearly. To use\nVersioning extensions, you need to implement WebDAV; to implement\nWebDAV, you need also to implement HTTP/1.1.\n\n2. \"All core versioning functionality MUST be provided by a server\nthat supports versioning.\"\nIn general, a conformance requirement MUST needs to have a definable\nscope and interpretation. Right now, the definition of \"core versioning\"\nis circular; it's defined in terminology as \"the set of properties\nand semantics that MUST be supported\" but that set is defined by\nthe term \"core versioning\". I think you actually want to define\n\"core versioning\" by something like \"the set of methods in Section 2,\nmaking reference to the terms in section 1.4 but without needing\nany of the terms in section 1.4.1.\"\n\nActually, there's no definition of \"a server that supports versioning\".\nA few of the terms in 1.4 mention \"server\", but the relationship\nbetween resources and the servers that serve them isn't clear.\n\n3. Missing reference in \"1.2 Relationship to DAV\"\nIs it DAV or WebDAV? Was the idea to hide the clarifications to\nRFC 2518 or just to remove them? In any case, now that there's no\nlonger a set of clarifications, maybe all of 1.2 should go.\n\n4. Section 1.3 Notational Conventions\n  This is an odd place to put this, since some of these conventions\nare used in previous sections. Since RFC 2068 has been obsoleted,\nit is odd to use that as a source of BNF syntax and BNF production\nrules; In the updates from 2068 to 2616 we may have fixed errors in\nthe BNF.\n\n5. Sec 1.3 \"When a precondition or a postcondition of a method is defined in\nthis document, it can be prefixed by a parenthesized XML element\ntype.\" It's not clear what it is that can be prefixed: the precondition,\nthe postcondition, the method, or the definition. I think you mean\n'the definition can be prefixed', or, rather, 'when the definition is\nprefixed, this means'.  This notational convention may have saved\nyou a few keystrokes, but a little bit of elaboration in place would\nallow you to remove this confusing bit of notational convention.\n\n\n6. 1.4 Terminology\n\nThe entire terminology section is pretty confusing; terms are defined\ncircularly or else make reference to other terms that are not themselves\ndefined. I think that it might be possible to put together a \"model\"\nthat describes the relationship between resources, versionable resources\nand versions that would help a lot, and putting forward references to\nthe places in the actual protocol that use the terms will help\nwith anyone trying to figure out what this stuff really means.\nSome of the terms apply in general (whether or not resources are\nversion-controlled) and others are versioning specific.\n\nSpecific comments below:\n\n7. Core Versioning\nAs above: this term needs a real definition. I think it's a\n\"conformance level\" but I'm not sure what it is or whether it's\nactually a formal term. Each property and method carries its own\nconformance requirement.\n\n7. Terms/Versionable Resouce: \"Put under version control\"\nThis phrase is used to define other terms, but it is not itself\ndefined. Maybe what's needed is a model that places these terms in\nsome context?\n\n8. 1.4 Terms/Version-controlled resource\n\"A version-controlled resource can be \"checked out\" to allow modification\nof its ...\"\nIs the resource modified, or a version modified? The phrase \"put under\nversion control\" isn't defined; what action puts something under\nversion control?\n\n9. 1.4 Terms/Version Resource\nThe term is \"Version Resource\" but the paragraph defines \"Version\".\nIs there no version of a version-controlled resource before the\nfirst check-in, or is the fact that a version is created by\nchecking in a checked-out resource just an example.  The definition\ntalks about what the server must do with URLs, but perhaps this\nbit of conformance requirements belongs somewhere else, in a section\nthat describes what conformant servers MUST and MUST NOT do.\nRight now, in the 'terms' section, you're just defining terminology.\n\n\n10. Section 1.4.1 \"Optional Versioning Terms\"\n\nI think what you mean to say is these terms are only needed by the\n\"Optional methods\" and not by the \"Core versioning\" definitions. So it's\n\"(Optional Versioning) Terms\" rather than \"Optional (Versioning Terms)\".\nWhy is this 1.4.1 instead of making \"Terms for Core Versioning\" section\n1.4.1 and making section 1.4.2 \"Terms for Versioning Options\"?\n\n11. 1.4.1 / Working Resource\n\nDo you check out a \"version\" or a \"version resource\" or a \"version-controlled\nresource\"? Earlier, it seemed like it was a \"version-controlled resource\"\nwas the target of \"check out\". Maybe the term \"check out\" needs to be\ndefined?\n\n12. 1.4.1 Workspace Resource\nThe title is \"Workspace Resource\" but the term defined is \"Workspace\". Which\nis it? Must a Workspace Resource have at least one version-controlled\nresource and at least one non-version-controlled resource? Why?\n\"A workspace MUST NOT contain two different version-controlled resource\nfor the same version history.\" I don't think it's well-defined what\n\"the same version history\" means. It's not clear whether this is a constraint\non clients or on servers or just a general expectation.\n\n13. \"Version-Controlled Collection Resouce\"\n\nThis term is defined by reference to the phrase \"collection that is under\nversion\ncontrol\" but there's no definition anywhere of what it means for a collection\nto be \"under version control\" (except, perhaps, circularly, that it is a\nversion-controlled collection resource).\n\n14. \"Collection Version Resource\"\n\nThis also seems to define \"A version-controlled binding\"; it defines it\nas a binding to a version-controlled resource, but it's not clear if this\nis the binding to the checked-in version or something else.\n\n\n\n", "id": "lists-006-8304020"}, {"subject": "RE: Move and copy,  versioning and overwrite interaction", "content": "I'd like to thank Lisa for producing this detailed document\ndescribing her interpretations of the MOVE and COPY commands.\nAlthough I believe that a tabular form is not the right way\nto define functionality (it makes it easy for you to make all\nsorts of special cases, rather than forcing you to define a\nfew simple orthogonal rules), it is an excellent way to test\nwhether the rules are consistent and understandable.\n\nI looked over Lisa's document carefully, and there are just a \nfew things that need to be fixed.\nRather than correct the document, I'd like to highlight the\nrules in the protocol (or in WebDAV) that would relate to COPY/MOVE,\nand in some cases, propose some additional wording\nfor the protocol, to emphasize these rules.\nThen if at all possible, it would be a great test for this new\nwording if Lisa could try to use these\nrules to fix the table (i.e. this would test whether the document\nnow answers these questions on its own).\n\nLisa: If you do not have time for this exercise, let me know and\nI can just post the fixes.\n\n-------------------------------------------------\n\nI propose we add the following paragraph to 2.1.1:  \n\n\"Note that a versionable resource and a version-controlled resource are not\nnew types of resources (i.e. they introduce no new DAV:resourcetype), but\nrather are any type of resource that supports the methods and live\nproperties defined for them in this document, in addition to all the methods\nand live properties implied by their DAV:resourcetype.  For example, a\ncollection (whose DAV:resourcetype is DAV:collection) is a versionable\nresource if it supports the VERSION-CONTROL method, and is a\nversion-controlled resource if it supports the version-controlled resource\nmethods and live properties.\"\n\nadd the following new postcondition to COPY (2.1.2):\n\n\"(DAV:must-not-copy-versioning-property): A property defined by this\ndocument MUST NOT have been copied to the new resource created by this\nrequest, but instead that property of the new resource MUST have the default\ninitial value it would have had if the new resource had been created by a\nnon-versioning method such as PUT or a MKCOL.\"\n\nand replace the DAV:preserve-history postcondition of MOVE (2.1.3) with:\n\n\"(DAV:preserve-versioning-properties): When a resource is moved from a\nsource URL to a destination URL, a property defined by this document MUST\nhave the same value on the resource at the destination URL as it had when\nthe resource was at the source URL.\"\n\nI'd also like to emphasize the fact that unless we explicitly state\notherwise in the protocol, there is no behavior on PUT/COPY/MOVE beyond\nwhat is specified in RFC 2616 and RFC 2518.  In particular, there is\nno change to the Overwrite behavior beyond what is explicitly stated\nin section 1.8 (i.e. no change to Overwrite behavior with MOVE).\n\nSo using the above rules, a resource loses all of its versioning\ncharacteristics when it is COPY'd, but keeps all of its versioning\ncharacteristics when it is MOVE'd.\n\nJust as a hint, this means that there are not multiple tables to \ndescribe COPY behavior, since a COPY of any of the versioning\nresources is required to be identical to copying a non-version-controlled\nresource with the same dead properties and content.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Friday, February 02, 2001 12:22 AM\nTo: Ietf-Dav-Versioning@W3. Org\nSubject: Move and copy, versioning and overwrite interactions\n\n\n\nThe latest versioning draft made some improvements in specifying how\nMOVE and COPY behave in all the possible combinations of whether the\nsource is versioned, whether the destination is versioned, whether the\ndestination exists, and whether the overwrite header is present.\nHowever, it wasn't sufficient for me to determine what every combination\nwould produce.  I had to make some assumptions, such as assuming that\nwhen overwrite is False the client wants the method not to be performed\nif the destination exists (rather than create a new version).\n\nIn doing this work, I built a set of tables, to make sure I captured\nevery option and combination and could compare them.\nhttp://www.sharemation.com/~milele/public/Versioned-MOVE-COPY3.htm\n\nAuthors, please review every cell in the tables and make sure this is\nwhat you intended.  Also please review my stated assumptions.  It's\nnecessary to do both, because there may be assumptions that I was not\naware of and could not state; or misunderstandings.\n\nOther DeltaV-ers, please glance at it and make sure your assumptions\ncorrespond with mine!\n\nLisa\n\n\n\n", "id": "lists-006-8319139"}, {"subject": "object model and IDL for Delta-", "content": "Folks,\n\nIs there an object model diagram or IDL for the most recent Delta-V protocol\nspecification that you are aware of? If there is one, could you point me to\nit. There was such a thing a long time ago that Jim A produced I think.\n\nThanks\n\nSankar\n\n\n\n", "id": "lists-006-8331241"}, {"subject": "Comments on Baseline option (in 12.3", "content": "Here are some (mostly editorial) comments on the Baseline option in\nthe -12.3 draft.  The only non-editorial comment concerns sub-baselines --\nit's not clear to me why they should be in the document at all.\n\n1. Section 10.3.2 (sub-baselines):\n\n\"The set of versions captured by the DAV:baseline-collection of a baseline\nis logically extended by the versions captured by these other baselines.\"\n\n(a) What does it mean to be \"logically extended\"?  I'm guessing you mean\nsomething like set union here.\n\n(b) What is a subbaseline anyway?  A definition in the introductory text of\nSection 10 would be nice.\n\n(c) From reading the specification, it's unclear to me what the intended use\nis for sub-baselines, and hence why this functionality is in the\nspecification at all.  If sub-baselines were removed, what capability would\nI lose?\n\n(d) When would the server return an error (and what error would it return)\nif a sub-baseline did, in fact, contain more than one version resource from\na single version-controlled resource?  Would this happen on a PROPPATCH to\nthe DAV:subbaseline-set of a checked-out version-controlled configuration?\n\n\n2. Ambiguity in configuration definition:\n\nIn Section 1.4.1, I was a bit thrown off by the definition of\n\"configuration\".  Instead of the first two sentences, I think you meant to\nsay:\n\nA \"configuration\" is a set of resources that consists of a root collection,\nits internal members, and recursively contains all children of contained\ncollections.\n\nIn particular, the second sentence is bad, since it introduces the notion of\n\"effectively\" invoking an HTTP method, and there currently is no such\nconcept.  Either a method is invoked, or it isn't.\n\nFinally, the last sentence, while strictly true, is also confusing:\n\n\"Note that a collection (which is a single resource) is very different from\na configuration (which is a set of resources).\"\n\nWell, yes, a collection is in fact a single resource, but it is used to\n*represent* a set of resources (the internal members).  Similarly, a\nbaseline *represents* the set of resources that comprise a configuration, in\nthis case using a property to hold the URLs of the members.\n\nIt seems to me the differences between the two concepts (configuration and\ncollection) are:\n\n* a configuration holds a recursive traversal of collection, a collection is\njust a single level\n* configuration is represented using a baseline (a set represented in a\nproperty), while a collection is represented as a set of bindings\n* a collection has specific consistency-maintenance semantics defined in RFC\n2518, which a configuration inherits by mirroring the state of a collection\ntree\n\nThat said, I'm not sure what change to make to the third sentence.  Perhaps\nit would be good to add a short paragraph between definitions, decsribing\nthe relationship of collections and configurations, capturing the points\nabove.  Or maybe that's overkill.\n\n\n3. More definitional ambiguity\n\nNext, there is a difference in the definition of configuration given in two\ndifferent places in the specification.\n\nIn Section 1.4.1, the definition of configuration is:\n\nA \"configuration\" is a set of resources that consists of a root collection\nand all members (not just internal members) of that root collection.\n\nIn Section 10, a configuration is defined as:\n\nA \"configuration\" of a collection consists of the state of that collection\nand the state of all members of that collection.\n\nAre these intended to capture the same concept, or is the difference in\nwording intentional?  The Sectin 1.4.1 definition implies the set will be\nrepresented using referential containment, while the Section 10 definition\nimplies the representation will be performed using inclusion containment.\nThe definition of baseline later clears this up, but perhaps it would be\nbest to use the same definition of configuration in both places.\n\n\n4. Difference between baseline and configuration.\n\nSo, after looking at the definitions of baseline and configuration, there\nseems to be difference -- a baseline represents a configuration, with the\nadded restriction that a baseline only represents those members of a\nconfiguration that are under version control. For a configuration of a\ncollection that has versioned and unversioned members, a baseline will be a\nsubset of the configuration (only the version-controlled resources).\n\nIs this the intent?  If so, perhaps the version-controlled-configuration is\nbetter named a version-controlled-baseline?  If not, then it appears the\ndefinition of configuration needs some tightening.\n\n\n5. Section 10.2\n\nThe heading for Section 10.2 is, \"Checked-Out Configuration Properties\", and\nthe section begins with:\n\n\"Since a checked-out configuration is a checked-out resource, ...\"\n\nThis was confusing to me, since I had just got it through my head that a\nconfiguration is, in fact, not a resource at all, but an abstract set. A\nbaseline *represents* a configuration.  So, does this section mean\n\"Checked-out Baseline Properties\", or \"Checked-out Version-Controlled\nConfiguration Properties\"?  I think it means the latter.\n\n\n6. Section 10.3.1 & Section 10.11 (DAV:baseline-collection)\n\nSince this is a protected and computed property, its state is not guaranteed\nto be preserved when a version is made of it, since a version is defined to\nbe (Section 1.4) \"A 'version' is a resource that contains a copy of a\nparticular state (content and dead properties)\".  So, some text is needed to\nensure that DAV:baseline-collection reverts from being a computed property\nto a dead property, when the version-controlled configuration is checked-in.\nThe text in Section 10.11 seems like it is intended to capture this, but\nsince the property is protected and computed, stating what the value is at\nthe moment of checkin doesn't provide any guarantees of its future value...\n\n\n7. Section 10.10 (additional COPY semantics)\n\nThis looks like a cut-and-paste of the previous paragraph, changing only the\nmethod.  Is the intent here that this only applies to COPYs of collections?\n\n\n8. Section 10.6 (definition of BASELINE-CONTROL)\n\n\"If no baseline is specified, a new baseline history is created, and the\nDAV:checked-in version of the version-controlled configuration will be the\n(empty) root baseline of that baseline history.\"\n\nOK, but what happens if a baseline is specified?  I would guess that the\nversion history associated with the version-controlled configuration for the\nbaseline specified in the request body would be used, right?\n\n\n9. GET, PUT OK?\n\nI'm assuming that, since they're not prohibited, GET and PUT on a\nversion-controlled configuration are OK, and wouldn't affect the state of\nthe configuration (since that's represented in a property).\n\n- Jim\n\n\n\n", "id": "lists-006-8338604"}, {"subject": "RE: FW: DeltaV doesn't support a true client workspac", "content": "Marshalling difficulty is a red herring here, and avoids the real issues\nconcerning the semantics of CHECKIN.\n\nI think the principled answer is that CHECKIN with body duplicates the\nfunctionality of PUT, and this is a bad design.\n\n- Jim\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Geoffrey M.\n> Clemm\n> Sent: Friday, February 09, 2001 8:19 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: FW: DeltaV doesn't support a true client workspace\n>\n>\n>\n>    From: \"Fay, Chuck\" <CFay@filenet.com>\n>\n>    ...\n>\n>    CHECKIN /foo.html (with new content in the request body)\n>\n>    I don't see why there should any big objection to this\n> proposal, except on\n>    religious grounds that any real versioning server *must* provide\n>    intermediate storage of working versions.\n>\n> I raised the (non-religious :-) objection in my previous response that\n> this requires that every argument for the CHECKIN request be a new\n> header.  I consider this completely unacceptable, since unlike XML\n> elements, headers are in a single global namespace so it would be\n> infeasible for a server to safely extend the CHECKIN request.\n>\n> Cheers,\n> Geoff\n>\n\n\n\n", "id": "lists-006-8352911"}, {"subject": "Re: DAV:compare-baseline REPOR", "content": "> On Fri, Feb 09, 2001 at 09:50:40PM -0500, Boris Bokowski/OTT/OTI wrote:\n> > > Now that we have the DAV:baseline-collection for a baseline,\n> > > I agree that this is a much more appropriate value for the\n> > > results of this report.  In particular, I'd just return the\n> > > VCR URL from the DAV:baseline-collection (you could get the\n> > > version URL from the DAV:checked-in property, if you cared).\n> > >\n> > > Does anyone object?\n> >\n> > Of course not :-)\n> >\n> > However, now that I have a supporter I can at least try to be\n> > a bit more greedy ;-)\n> >\n> > For my anticipated use of this report, getting the version URLs\n> > as well would be a substantial gain over having to query the\n> > DAV:checked-in property for each change.\n>\n> Agreed.\n>\n> Another alternative to making the DAV:checked-in special (or\n> saying that the version resource URL is explicitly returned),\n> is to simply allow a DAV:prop element to exist in the report\n> request, and each set of properties will be returned for each\n> [VCR] href mentioned in the report.\n\nNah, DAV:prop is obsolete, think DAV:expand-property!\n\nBTW the DAV:baseline-collection is defined as a collection of checked-in\nversion-controlled resources -- I assume that the collection itself is\n'protected', i.e., servers will fail attempts to check-out those VCRs\notherwise the property definition is violated.\n\nTim\n\n\n\n", "id": "lists-006-8362611"}, {"subject": "RE: FW: DeltaV doesn't support a true client workspac", "content": "I agree that the duplication of PUT functionality is the\nprimary objection.\n\nCheers,\nGeoff\n\np.s. But I don't agree that a secondary\nobjection concerning the undesireability of using headers\nas a method argument extension mechanism is either a\nred herring or \"unprincipled\" (:-).\n\n-----Original Message-----\nFrom: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\nSent: Sunday, February 11, 2001 9:54 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: FW: DeltaV doesn't support a true client workspace\n\n\nMarshalling difficulty is a red herring here, and avoids the real issues\nconcerning the semantics of CHECKIN.\n\nI think the principled answer is that CHECKIN with body duplicates the\nfunctionality of PUT, and this is a bad design.\n\n- Jim\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Geoffrey M.\n> Clemm\n> Sent: Friday, February 09, 2001 8:19 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: FW: DeltaV doesn't support a true client workspace\n>\n>\n>\n>    From: \"Fay, Chuck\" <CFay@filenet.com>\n>\n>    ...\n>\n>    CHECKIN /foo.html (with new content in the request body)\n>\n>    I don't see why there should any big objection to this\n> proposal, except on\n>    religious grounds that any real versioning server *must* provide\n>    intermediate storage of working versions.\n>\n> I raised the (non-religious :-) objection in my previous response that\n> this requires that every argument for the CHECKIN request be a new\n> header.  I consider this completely unacceptable, since unlike XML\n> elements, headers are in a single global namespace so it would be\n> infeasible for a server to safely extend the CHECKIN request.\n>\n> Cheers,\n> Geoff\n>\n\n\n\n", "id": "lists-006-8371200"}, {"subject": "RE: Part 1, Comments on draft-ietf-deltav-versioning-12.", "content": "   From: Larry Masinter [mailto:LMM@acm.org]\n   Cc: Dan Brotsky\n\n   I've only gotten through the first 9 pages of typing in comments,\n   so I think I better chunk these and send what I have.\n\nDan: We *really* appreciate a review at this level of detail,\nespecially by a new pair of eyes that haven't already seen it dozens\nof times.  And thanks to Larry for typing the comments in for the\nmailing list!\n\n   I *think* that most of these comments are editorial; that is, there\n   are sentences and phrases in the draft that are confusing, and it\n   is quite possible that the confusions could be cleared up\n   editorially without changing the protocol.\n\nThat does appear to be the case for this first chunk of comments.\n\n   However, it is often the\n   case that confusing or ambiguous wording hides errors in\n   protocols.\n\nConfusing or ambiguous wording is bad, whether or not it\nhides errors (but it is even worse if it does, of course).\n\n   In general, the document is very hard to read. You might\n   argue that \"well, we understand it, and that's good enough.\" And on\n   the phone conference I got some of this pushback, \"we tried\n   clarifying this before with examples and the examples confused\n   other people\".\n\nIt's important to distinguish \"we understand it and that's good\nenough\", which would be a completely unacceptable attitude, from \"we\ntried clarifying it the way you describe, and it confused more people\nthan it helped\", which is just an explanation of why a certain change\nmight be undesireable (but is of course not justification for leaving\nit unfixed).  But none of Dan's comments fall into this category\nof \"tried it already\" (at least, so far), so he's provided us with\nvaluable new insight into what could be improved.\n\n   But there is no point in bothering with the IETF process if all you\n   are going to wind up with is a document that only the authors and\n   working group members understand.\n\nI agree.\n\n   The value that you get from \"IETF\n   Proposed Standard\" comes with a price: writing something that\n   ordinary implementors can sit down and code to. I don't think it's\n   impossible to document this protocol clearly.\n\nI agree with this as well.  (I assume by \"ordinary implementors\",\nyou mean implementors that know how to implement either a versioning\nclient or a versioning server, and expect the protocol to explain\nhow to marshall the communication between a versioning client\nand a versioning server in an interoperable way).\n\n   Specific comments:\n\n   1. \"This document defines WebDAV Versioning extensions, an\n    application of HTTP/1.1 ...\"\n\n   But the \"WebDAV Versioning extensions\" are not, by themselves, an\n   application of HTTP/1.1. The WebDAV Versioning extensions are a set\n   of extensions to WebDAV, which, in turn, is a set of extensions of\n   HTTP/1.1 ...  In general, the relationship between the versioning\n   extensions, WebDAV and HTTP/1.1 needs to be stated clearly. To use\n   Versioning extensions, you need to implement WebDAV; to implement\n   WebDAV, you need also to implement HTTP/1.1.\n\nIt sounds like the \"application of\" language is misleading, and if\nwe just said that the WebDAV Versioning provides extensions to WebDAV,\nit would be clearer?  The \"Relationship to WebDAV\" section then goes\ninto more detail.\n\n   2. \"All core versioning functionality MUST be provided by a server\n   that supports versioning.\"  In general, a conformance requirement\n   MUST needs to have a definable scope and interpretation. Right now,\n   the definition of \"core versioning\" is circular; it's defined in\n   terminology as \"the set of properties and semantics that MUST be\n   supported\" but that set is defined by the term \"core versioning\". I\n   think you actually want to define \"core versioning\" by something\n   like \"the set of methods in Section 2, making reference to the\n   terms in section 1.4 but without needing any of the terms in\n   section 1.4.1.\"\n\nGood point!  I will make that change.  Also, while I'm in there,\nit probably makes sense to follow Chuck's suggestion (I believe it\nwas Chuck ...) which was to move the \"option terms\" forward to\nan \"options\" section.  This would simplify the introduction,\nand avoid the \"without needing 1.4.1\" complication.\n\n   Actually, there's no definition of \"a server that supports\n   versioning\".  A few of the terms in 1.4 mention \"server\", but the\n   relationship between resources and the servers that serve them\n   isn't clear.\n\nI'll get rid of the specific reference that you identify above.\nThe term server is defined in 2616, and I believe that usually\nwe are using it in the standard sense (i.e. a server is something\nthat services requests on a resource).  I'll make a pass through\nthe document looking at where we use the term \"server\" to see\nif they can be changed.  If there are any other specific places\nwhich you feel are problematic, please let me know.\n\n   3. Missing reference in \"1.2 Relationship to DAV\" Is it DAV or\n   WebDAV?\n\nDepends who you ask ... I know Greg likes DAV and JimW prefers\nWebDAV.  But the document should be consistent.  I prefer to keep\nDAV as the namespace, and WebDAV as the name of the working group\nand the protocol, so I've tried to consistently use WebDAV (but\nmissed this obvious place ... thanks for pointing it out!).\n\n   Was the idea to hide the clarifications to RFC 2518 or just\n   to remove them?\n\nJust a gotcha from the Word update references command.  It got\nmoved and Word couldn't find it's new location. \n\n   In any case, now that there's no longer a set of\n   clarifications, maybe all of 1.2 should go.\n\nThere still is the one clarification of the COPY request, so\nI'll keep the pointer to that here.\n\n   4. Section 1.3 Notational Conventions This is an odd place to put\n     this, since some of these conventions are used in previous\n     sections.\n\nYes, another reviewer pointed that out as well.  The section has been\nmoved earlier, to avoid the use before definition problem.\n\n     Since RFC 2068 has been obsoleted, it is odd to use\n     that as a source of BNF syntax and BNF production rules; In the\n     updates from 2068 to 2616 we may have fixed errors in the BNF.\n\nActually, there was only one trivial use of BNF left in the document,\nso I just got rid of that, and then we can get rid of the reference\nto 2068 altogether.\n\n   5. Sec 1.3 \"When a precondition or a postcondition of a method is\n   defined in this document, it can be prefixed by a parenthesized XML\n   element type.\" It's not clear what it is that can be prefixed: the\n   precondition, the postcondition, the method, or the definition. I\n   think you mean 'the definition can be prefixed', or, rather, 'when\n   the definition is prefixed, this means'.  This notational\n   convention may have saved you a few keystrokes, but a little bit of\n   elaboration in place would allow you to remove this confusing bit\n   of notational convention.\n\nI can certainly replace the \"it\" with \"the definition\" to avoid any\nconfusion here.  What in place elaboration did you have in mind?\n\n   6. 1.4 Terminology\n\n   The entire terminology section is pretty confusing; terms are\n   defined circularly or else make reference to other terms that are\n   not themselves defined.\n\nThere will always be some level of circularity in a definition\nsection, but I have tried very hard to minimize the forward references.\nYou make some very good suggestions below, which I will act on.\nCertainly there's no reason to have undefined terms!\n\n   I think that it might be possible to put\n   together a \"model\" that describes the relationship between\n   resources, versionable resources and versions that would help a\n   lot, and putting forward references to the places in the actual\n   protocol that use the terms will help with anyone trying to figure\n   out what this stuff really means.   Some of the terms apply in\n   general (whether or not resources are version-controlled) and\n   others are versioning specific.\n\nThere is a model for these terms in the core versioning semantics\nsection (and even some beautiful ascii art :-).  I'll add\na forward reference to this section from the terminology,\nso that a reader does not mistakenly believe that they should\nbe able to infer the versioning model from the terminology\nsection.  But the terms themselves are used in hundreds of\nlocations throughout the protocol, so I believe a forward reference\nfrom the terms to each of their uses would not end up being\nvery helpful (maybe that's not what you were suggesting?).\n\n   Specific comments below:\n\n   7. Core Versioning As above: this term needs a real definition. I\n   think it's a \"conformance level\" but I'm not sure what it is or\n   whether it's actually a formal term. Each property and method\n   carries its own conformance requirement.\n\nGood point.  Core versioning should be defined as \"what is in\nsection xxx\".\n\n   7. Terms/Versionable Resouce: \"Put under version control\" This\n   phrase is used to define other terms, but it is not itself\n   defined. Maybe what's needed is a model that places these terms in\n   some context?\n\nI think \"version control\" needs to be a defined term.  I'll add one.\n\n   8. 1.4 Terms/Version-controlled resource \"A version-controlled\n   resource can be \"checked out\" to allow modification of its ...\"  Is\n   the resource modified, or a version modified?\n\nI believe the \"it\" is unambiguous, since there is only one noun\nin the sentence (i.e. \"version-controlled resource\").  Could\nyou expand a bit on what was ambiguous (I didn't see any reference\nto a \"version\" in this definition).\n\n   The phrase \"put under\n   version control\" isn't defined; what action puts something under\n   version control?\n\nWe haven't yet defined any of the methods, and were trying to avoid\ndoing so in the terminology section.  But I agree that \"version control\"\nneeds to be a defined term, and I hope that will clarify this statement?\n\n   9. 1.4 Terms/Version Resource The term is \"Version Resource\" but\n   the paragraph defines \"Version\".\n\nI'll fix that.  In many cases, \"xxx resource\" can be abbreviated\nto be just \"xxx\" (e.g. version, activity, workspace), but this should\nbe stated explicitly when the term is defined, not left to the\nreader to guess.\n\n   Is there no version of a\n   version-controlled resource before the first check-in, or is the\n   fact that a version is created by checking in a checked-out\n   resource just an example.\n\nThat should be clear after you've read the versioning model\nsection.  If it is not, please let me know.  (Without a\nforward reference to the model, I agree this definition\nis confusing).\n\n   The definition talks about what the\n   server must do with URLs, but perhaps this bit of conformance\n   requirements belongs somewhere else, in a section that describes\n   what conformant servers MUST and MUST NOT do.  Right now, in the\n   'terms' section, you're just defining terminology.\n\nI agree.  This requirement is actually repeated later, so there is\nno reason to have it here.  I'll get rid of all MUSTs from the\nterminology section.\n\n   10. Section 1.4.1 \"Optional Versioning Terms\"\n\n   I think what you mean to say is these terms are only needed by the\n   \"Optional methods\" and not by the \"Core versioning\" definitions. So\n   it's \"(Optional Versioning) Terms\" rather than \"Optional\n   (Versioning Terms)\".  Why is this 1.4.1 instead of making \"Terms\n   for Core Versioning\" section 1.4.1 and making section 1.4.2 \"Terms\n   for Versioning Options\"?\n\nI agree.  I'll rename it, and move it forward to a \"versioning options\"\nsection, so that it doesn't make core look more complicated than it\nneeds to be.\n\n   11. 1.4.1 / Working Resource\n\n   Do you check out a \"version\" or a \"version resource\" or a\n   \"version-controlled resource\"? Earlier, it seemed like it was a\n   \"version-controlled resource\" was the target of \"check out\". Maybe\n   the term \"check out\" needs to be defined?\n\nThis is intentionally left open (although the ambiguity between\nversion and version needs to be cleared up by explicitly stating\nthat \"version\" is just a shorthand for \"version resource\").\n\nBut to avoid confusion, I agree that \"checked-out\" and \"checked-in\"\nneed to be explicitly defined.  \n\nIn core versioning, a version-controlled resource can be checked\nout.  In the checkout option, a version-controlled resource can\nbe the target of an explicit CHECKOUT request.  In the working\nresource option, a version resource can be the target of an explicit\nCHECKOUT request.\n\n   12. 1.4.1 Workspace Resource The title is \"Workspace Resource\" but\n   the term defined is \"Workspace\". Which is it?\n\nSame problem as before.  They are synonyms.  I'll make this explicit.\n\n   Must a Workspace\n   Resource have at least one version-controlled resource and at least\n   one non-version-controlled resource? Why?\n\nNo it doesn't, but I can see why the current phrasing would lead you\nto think this.  I'll fix this.\n\n  \"A workspace MUST NOT\n   contain two different version-controlled resource for the same\n   version history.\" I don't think it's well-defined what \"the same\n   version history\" means. It's not clear whether this is a constraint\n   on clients or on servers or just a general expectation.\n\nGood point.  I'll put a forward reference from each version options\nterm to the option that defines it.  This should make it clear where\nto look to answer a question like this.\n\n   13. \"Version-Controlled Collection Resouce\"\n\n   This term is defined by reference to the phrase \"collection that is\n   under version control\" but there's no definition anywhere of what\n   it means for a collection to be \"under version control\" (except,\n   perhaps, circularly, that it is a version-controlled collection\n   resource).\n\nYes, the term \"version control\" definitely needs to be defined, so\nthat when it is used, it is not confusing.\n\n   14. \"Collection Version Resource\"\n\n   This also seems to define \"A version-controlled binding\"; it\n   defines it as a binding to a version-controlled resource, but it's\n   not clear if this is the binding to the checked-in version or\n   something else.\n\nThe versioning model section should clear this up, since it\nemphasizes that a version-controlled resource is a very different\nthing from a version resource, so a binding to a version-controlled\nresource is very different from a binding to a version resource.\n(Note: A version-controlled binding is as defined, namely to a\nversion-controlled resource, not to a version resource).\n\nAnd thanks again to Dan (and his scribe, Larry :-) for this great\nreview!  I look forward to getting the rest of it.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-8382123"}, {"subject": "RE: Comments on Baseline option (in 12.3", "content": "   From: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\n\n   Here are some (mostly editorial) comments on the Baseline option in\n   the -12.3 draft.  The only non-editorial comment concerns\n   sub-baselines -- it's not clear to me why they should be in the\n   document at all.\n\nLook at the thread labeled \"Edgar`s comments to 12.1\" (started 1/28/01).\nBasically, it's the way that you group together several existing baselines\nof different collections into a \"system\".  Think of it as a way of\ncomposing systems out of sub-systems.\n\n   1. Section 10.3.2 (sub-baselines):\n\n   \"The set of versions captured by the DAV:baseline-collection of a\n   baseline is logically extended by the versions captured by these\n   other baselines.\"\n\n   (a) What does it mean to be \"logically extended\"?  I'm guessing you mean\n   something like set union here.\n\nYes.  Can you suggest some wording that would make that clearer?\n\n   (b) What is a subbaseline anyway?  A definition in the introductory\n   text of Section 10 would be nice.\n\nGood point!  Will do.  Perhaps that would address your concern \nabout section 10.3.2?\n\n   (c) From reading the specification, it's unclear to me what the\n   intended use is for sub-baselines, and hence why this functionality\n   is in the specification at all.  If sub-baselines were removed,\n   what capability would I lose?\n\nThe ability to form a \"composite\" baseline out of several smaller\nbaselines.  Did you have some other way in mind that this would\nbe accomplished?\n\n   (d) When would the server return an error (and what error would it\n   return) if a sub-baseline did, in fact, contain more than one\n   version resource from a single version-controlled resource?  Would\n   this happen on a PROPPATCH to the DAV:subbaseline-set of a\n   checked-out version-controlled configuration?\n\nGood point!  It actually happens when you try to CHECKIN the new\nversion-controlled configuration, but this is not stated in the\nprotocol.  I'll add this postcondition to the CHECKIN method.\n\n   2. Ambiguity in configuration definition:\n\n   In Section 1.4.1, I was a bit thrown off by the definition of\n   \"configuration\".  Instead of the first two sentences, I think you\n   meant to say:\n\n   A \"configuration\" is a set of resources that consists of a root\n   collection, its internal members, and recursively contains all\n   children of contained collections.\n\nHmm.  I was just using the terminology of 2518.  Although 2518 does\nuse the term \"child\", it doesn't define it, but it does define the\nterms \"member\" and \"internal member\".  What didn't you like about\nthe existing sentence in 1.4.1?  (Note: I don't care that much if\nwe switch, but the review from Dan justifiably took us to task for\nusing undefined terms, so we'd have to define \"child\" if we used\nit, which seems redundant if 2518 already defines the terms\n\"member\" and \"internal member\").\n\n   In particular, the second sentence is bad, since it introduces the\n   notion of \"effectively\" invoking an HTTP method, and there\n   currently is no such concept.  Either a method is invoked, or it\n   isn't.\n\nGood point.  How about \"can be understood as ...\" instead?\n\n   Finally, the last sentence, while strictly true, is also confusing:\n\n   \"Note that a collection (which is a single resource) is very\n   different from a configuration (which is a set of resources).\"\n\n   Well, yes, a collection is in fact a single resource, but it is\n   used to *represent* a set of resources (the internal members).\n\nWhat a collection \"represents\" currently depends on what method\nyou are applying to it.  If you PROPPATCH it, you are just\nPROPPATCH'ing the collection (and definitely not any of its\nmembers).  If you are PROPFIND'ing it, or LOCK'ing it, you\nuse the Depth header to indicate whether you are operating on\nthe Collection (Depth:0) or the Configuration (Depth:infinity).\n\nFor versioning, what matters is whether you are capturing the\nstate of a single resource or a set of resources, which is why\nthe definition of configuration emphasizes that distinction.\n\n   Similarly, a baseline *represents* the set of resources that comprise\n   a configuration, in this case using a property to hold the URLs of the\n   members.\n\nI'd prefer to use the term \"captures\" or \"selects\", but what matters\nis that you have two very different objects: a collection version and\na collection baseline.  When you introduce the key distinction\nbetween a collection (which contains a set of relationships, called\nbindings) and a configuration (which is a set of resources, induced\nrecursively by the binding relationships), it is much easier to\nclearly make the distinction between a version of a collection\nand a baseline of a collection.\n\n   It seems to me the differences between the two concepts\n   (configuration and collection) are:\n\n   * a configuration holds a recursive traversal of collection, a\n   collection is just a single level\n\nIsn't \"a collection and all its members\" a simpler definition?\n\n   * configuration is represented using a baseline (a set represented\n   in a property), while a collection is represented as a set of\n   bindings\n\nActually, a configuration is not represented using a baseline,\nbut rather a baseline captures the state of the version-controlled\nmembers of the configuration.\n\n   * a collection has specific consistency-maintenance semantics\n   defined in RFC 2518, which a configuration inherits by mirroring\n   the state of a collection tree\n\nHmm.  I'm not sure that would help many folks.\n\n   That said, I'm not sure what change to make to the third sentence.\n   Perhaps it would be good to add a short paragraph between\n   definitions, decsribing the relationship of collections and\n   configurations, capturing the points above.  Or maybe that's\n   overkill.\n\nI'm happy to iterate on the collection/configuration distinction,\nbut isn't \"a configuration is a collection and all its members\"\nabout as simple and clear as we can make it?\n\n   3. More definitional ambiguity\n\n   Next, there is a difference in the definition of configuration\n   given in two different places in the specification.\n\n   In Section 1.4.1, the definition of configuration is:\n\n   A \"configuration\" is a set of resources that consists of a root\n   collection and all members (not just internal members) of that root\n   collection.\n\n   In Section 10, a configuration is defined as:\n\n   A \"configuration\" of a collection consists of the state of that\n   collection and the state of all members of that collection.\n\n   Are these intended to capture the same concept, or is the\n   difference in wording intentional?\n\nGood catch!  That was accidental.  I'll change the second definition\nto match the first.\n\n   The Sectin 1.4.1 definition\n   implies the set will be represented using referential containment,\n   while the Section 10 definition implies the representation will be\n   performed using inclusion containment.  The definition of baseline\n   later clears this up, but perhaps it would be best to use the same\n   definition of configuration in both places.\n\nYes, definitely.\n\n   4. Difference between baseline and configuration.\n\n   So, after looking at the definitions of baseline and configuration,\n   there seems to be difference -- a baseline represents a\n   configuration, with the added restriction that a baseline only\n   represents those members of a configuration that are under version\n   control. For a configuration of a collection that has versioned and\n   unversioned members, a baseline will be a subset of the\n   configuration (only the version-controlled resources).\n\n   Is this the intent?\n\nYes.\n\n   If so, perhaps the\n   version-controlled-configuration is better named a\n   version-controlled-baseline?  If not, then it appears the\n   definition of configuration needs some tightening.\n\nWhen you create a \"version\" of something, you always have to define\nwhat is in that version.  In the case of a simple resource, it is the\ncontent and dead properties (not the live properties).  In the case of\na collection, it is the dead properties and the bindings to the\nversion histories of the version controlled internal members of that\ncollection.  In the case of a configuration, it is the DAV:checked-in\nversions of the version-controlled members of that configuration.\n\nSo it is consistent that only a selected part of the state of\na given resource is captured by a version of that resource.\n\n   5. Section 10.2\n\n   The heading for Section 10.2 is, \"Checked-Out Configuration\n   Properties\", and the section begins with:\n\n   \"Since a checked-out configuration is a checked-out resource, ...\"\n\n   This was confusing to me, since I had just got it through my head\n   that a configuration is, in fact, not a resource at all, but an\n   abstract set. A baseline *represents* a configuration.  So, does\n   this section mean \"Checked-out Baseline Properties\", or\n   \"Checked-out Version-Controlled Configuration Properties\"?  I think\n   it means the latter.\n\nActually, it means both a checked-out version-controlled configuration\nand a working configuration.  We should make that explicit, by\nproviding an explicit definition of \"checked-out configuration\" and\n\"working configuration\" in the terms section.  (This is just analagous\nto how a checked-out resource can be either a checked-out\nversion-controlled resource, or a working resource).\n\nI better get some sleep ... I'll finish responding to Jim's comments\ntomorrow.\n\nGreat review Jim!  Thanks!\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-8405073"}, {"subject": "RE: object model and IDL for Delta-", "content": "I did post a new model diagram to the web site a few weeks ago,\nbut it still needs to be fleshed out with details.  Let me know\nif you have any trouble reading it.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Sankar Virdhagriswaran [mailto:sv@hunchuen.crystaliz.com]\nSent: Sunday, February 11, 2001 10:11 AM\nTo: Versioning\nSubject: object model and IDL for Delta-v\n\n\nFolks,\n\nIs there an object model diagram or IDL for the most recent Delta-V protocol\nspecification that you are aware of? If there is one, could you point me to\nit. There was such a thing a long time ago that Jim A produced I think.\n\nThanks\n\nSankar\n\n\n\n", "id": "lists-006-8422631"}, {"subject": "Re: DeltaV doesn't support a true client workspac", "content": "So DeltaV is not a great fit for these two existing systems.  (I won't \nargue\nthat their reliance on a client workspace is necessarily a better design\nthan DeltaV's server workspace.  Rather, I raise it as existing practice\nthat needs to be considered by DeltaV.)\n<jra>\nI think DeltaV will work fine for these systems using auto-versioning. See \nbelow.\n</jra>\n\nOne alternative is to build a core versioning layer for these two systems\nwhich would disallow the DAV:when-locked flavor of DAV:auto-version.  But\nthis would result in a new version for every PUT or PROPPATCH of dead\nproperties done by the client.  Arbitrary DeltaV clients are not likely to\nlimit themselves to one PUT between a LOCK and UNLOCK, so there would \nlikely\nbe a proliferation of unwanted intermediate versions.  Scratch that\nalternative.\n<jra>\nThis solution is already possible. Your client can use auto-versioning \nwhen synchronizing updates between the client's private workspace, and the \nserver (which would represent some shared resource pool). In this case, \nDAV:auto-version is really all you need because your clients only update \non synchronization, not on every PUT. To prevent proliferation of unwanted \nintermediate versions, use other techniques to control client access \nincluding turning off auto-versioning, or access control.\n</jra>\n\n\nA third alternative would be to add a flavor of CHECKOUT-CHECKIN to core\nversioning in DeltaV that allows all changes to accompany the CHECKIN\nmethod.  This is the model used by the existing systems I mentioned.\n<jra>\nThat would couple CHECKIN and PUT and require CHECKIN to have multi-part \nMIME request contents. Sounds tricky, and a compromised design.\n</jra>\n\n\n\n", "id": "lists-006-8430652"}, {"subject": "RE: Comments on Baseline option (in 12.3", "content": "   From: Jim Whitehead [mailto:ejw@cse.ucsc.edu]\n\n   6. Section 10.3.1 & Section 10.11 (DAV:baseline-collection)\n\n   Since this is a protected and computed property,\n\n(actually, I believe it is just a protected, not a computed, property)\n\n   its state is not\n   guaranteed to be preserved when a version is made of it, since a\n   version is defined to be (Section 1.4) \"A 'version' is a resource\n   that contains a copy of a particular state (content and dead\n   properties)\".\n\nA version-controlled configuration does not have a DAV:baseline-collection\nproperty, so I don't see that this issue arises.  It is only a property\nof a baseline.\n\n   So, some text is needed to ensure that\n   DAV:baseline-collection reverts from being a computed property to a\n   dead property, when the version-controlled configuration is\n   checked-in.\n\nSince a version-controlled configuration does not have a\nDAV:baseline-collection, we happily do not have to do that (:-).\n\n   The text in Section 10.11 seems like it is intended to\n   capture this, but since the property is protected and computed,\n   stating what the value is at the moment of checkin doesn't provide\n   any guarantees of its future value...\n\nGood point.\nTim also pointed out that we're missing some pre-conditions that\nmake sure that UPDATE, MERGE, and CHECKOUT cannot be used to change\nthe members of this collection (they are checked-in version-controlled\nresources, so no other methods can be used to change them).\nI'll add these missing preconditions.\n\n\n   7. Section 10.10 (additional COPY semantics)\n\n   This looks like a cut-and-paste of the previous paragraph, changing\n   only the method.  Is the intent here that this only applies to\n   COPYs of collections?\n\nYes.  I'll add some words like \"if the request creates a new\ncollection at the Destination\" to make this clear.\n\n   8. Section 10.6 (definition of BASELINE-CONTROL)\n\n   \"If no baseline is specified, a new baseline history is created,\n   and the DAV:checked-in version of the version-controlled\n   configuration will be the (empty) root baseline of that baseline\n   history.\"\n\n   OK, but what happens if a baseline is specified?  I would guess\n   that the version history associated with the version-controlled\n   configuration for the baseline specified in the request body would\n   be used, right?\n\nYes.  Since the previous paragraph states:\n\n \"If a baseline is specified in the request body, the DAV:checked-in\n version of the new version-controlled configuration will be that\n baseline\"\n\nand since the DAV:version-history is defined to be the\nDAV:version-history of the DAV:checked-in version.\n\n   9. GET, PUT OK?\n\n   I'm assuming that, since they're not prohibited, GET and PUT on a\n   version-controlled configuration are OK, and wouldn't affect the\n   state of the configuration (since that's represented in a\n   property).\n\nYes, we stay deliberately silent about the content of a version-controlled\nconfiguration, an activity, a baseline, a workspace, etc.  We don't have\nany interoperable use for it, but we want to leave the door open for\nus finding one some day.\n\nAgain, thanks for the great review, Jim!\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-8439345"}, {"subject": "RE: Comments on Baseline option (in 12.3", "content": "What is a sub-baseline:\n> Basically, it's the way that you group together several \n> existing baselines\n> of different collections into a \"system\".  Think of it as a way of\n> composing systems out of sub-systems.\n\nIt's a super-baseline!\n\nLisa \"naming is important\" Dusseault\n\n\n\n", "id": "lists-006-8450202"}, {"subject": "RE: Comments on Baseline option (in 12.3", "content": "Currently, the relationship that connects a \"system\" baseline\nto its \"component\" baselines is called the \"sub-baseline\" relationship.\nIt's defined in that direction because when a baseline is created\nit knows what its \"sub-baseline\" list is, but the inverse relationship\n(i.e. super-baseline) changes over time.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Lisa Dusseault [mailto:lisa@xythos.com]\nSent: Monday, February 12, 2001 12:48 PM\nTo: Clemm, Geoff; ietf-dav-versioning@w3.org\nSubject: RE: Comments on Baseline option (in 12.3)\n\n\nWhat is a sub-baseline:\n> Basically, it's the way that you group together several \n> existing baselines\n> of different collections into a \"system\".  Think of it as a way of\n> composing systems out of sub-systems.\n\nIt's a super-baseline!\n\nLisa \"naming is important\" Dusseault\n\n\n\n", "id": "lists-006-8457898"}, {"subject": "RE: Comments on Baseline option (in 12.3", "content": "> Basically, it's the way that you group together several existing baselines\n> of different collections into a \"system\".  Think of it as a way of\n> composing systems out of sub-systems.\n\nAh. It would be good to add text to this effect.\n\n>    1. Section 10.3.2 (sub-baselines):\n>\n>    \"The set of versions captured by the DAV:baseline-collection of a\n>    baseline is logically extended by the versions captured by these\n>    other baselines.\"\n>\n>    (a) What does it mean to be \"logically extended\"?  I'm\n> guessing you mean\n>    something like set union here.\n>\n> Yes.  Can you suggest some wording that would make that clearer?\n\nWell, it seems like there is a lot of functionality hiding under the banner\nof \"logical extension\".  There are namespace composition issues:\n\n(a) do the baselines have different namespace trees, or does one baseline\nfit into the namespace tree of another baseline?\n\nI.e.:\n\n          B1          B2\n        / | \\        / | \\\n     ... ... ...  ... ... ...\n\nThe namespaces are disjoint, and hence would need to be combined by creating\na baseline collection that held them both:\n\n                B0\n               /  \\\n              B1  B2\n             /|\\  /|\\\n             ...  ...\n\nOR\n\n        B1\n        | \\         B2\n       ... ...     / | \\\n                 .. ... ...\n\nIn this case, no new baseline needs to be created, the composition is:\n\n         B1\n       / | \\\n     B2 ... ...\n   / | \\\n... ... ...\n\n\nSo, the wording here would be something like:\n\n(a) If the baseline namespaces are disjoint, create a new baseline, add this\nto the set of subbaselines, and place all subbaselines as children of this\nnew baseline.\n\n(b) If some of the baselines are children of other baselines, then insert\nthese baselines into the \"appropriate\" place in the namespace tree.\n\nBut, it seems that it would be difficult to determine where it should appear\nin the namespace tree -- which namespace would you use as the normative\nnamespace for composing baselines?\n\nOr, maybe I'm not understanding how baselines would be logically composed.\n\n>\n>    (b) What is a subbaseline anyway?  A definition in the introductory\n>    text of Section 10 would be nice.\n>\n> Good point!  Will do.  Perhaps that would address your concern\n> about section 10.3.2?\n\nNo, \"logical extension\" still needs to be defined.\n\n>\n>    (c) From reading the specification, it's unclear to me what the\n>    intended use is for sub-baselines, and hence why this functionality\n>    is in the specification at all.  If sub-baselines were removed,\n>    what capability would I lose?\n>\n> The ability to form a \"composite\" baseline out of several smaller\n> baselines.  Did you have some other way in mind that this would\n> be accomplished?\n\nWell, you could allow resources to belong to more than one baseline (not\nthat I'm advocating this necessarily -- you asked ;-), and then you would\nhave the freedom to create whatever baseline you desired (not\ncompositionally, just by construction).\n\n>    2. Ambiguity in configuration definition:\n>\n>    In Section 1.4.1, I was a bit thrown off by the definition of\n>    \"configuration\".  Instead of the first two sentences, I think you\n>    meant to say:\n>\n>    A \"configuration\" is a set of resources that consists of a root\n>    collection, its internal members, and recursively contains all\n>    children of contained collections.\n>\n> Hmm.  I was just using the terminology of 2518.  Although 2518 does\n> use the term \"child\", it doesn't define it, but it does define the\n> terms \"member\" and \"internal member\".  What didn't you like about\n> the existing sentence in 1.4.1?  (Note: I don't care that much if\n> we switch, but the review from Dan justifiably took us to task for\n> using undefined terms, so we'd have to define \"child\" if we used\n> it, which seems redundant if 2518 already defines the terms\n> \"member\" and \"internal member\").\n\nI didn't like the \"all members\" bit.  Since a collection's members are just\nits level one members, *all* of the members of a collection are just the\nlevel one members.  That's why I explicitly notes that it was the level one\nmembers (the internal members), and then all the level one members of all\nchild collections, recursively.  We never defined child in RFC 2518, since\nwe were using the common definition of the term that is used in introductory\ndata structures texts, and we assumed our reader would have an introduction\nto CS data structures (you have to draw the line someplace ;-).\n\n>    In particular, the second sentence is bad, since it introduces the\n>    notion of \"effectively\" invoking an HTTP method, and there\n>    currently is no such concept.  Either a method is invoked, or it\n>    isn't.\n>\n> Good point.  How about \"can be understood as ...\" instead?\n\nActually, I'd prefer it if the sentence were re-written, or deleted.  I\nreally didn't understand the intent of this sentence -- my interpretation\nwas you were trying to express the \"recursive tree traversal\" aspect, but in\na strange way.\n\n>    It seems to me the differences between the two concepts\n>    (configuration and collection) are:\n>\n>    * a configuration holds a recursive traversal of collection, a\n>    collection is just a single level\n>\n> Isn't \"a collection and all its members\" a simpler definition?\n\nNo -- all the members of a collection == level 1 members.\n\n>    * configuration is represented using a baseline (a set represented\n>    in a property), while a collection is represented as a set of\n>    bindings\n>\n> Actually, a configuration is not represented using a baseline,\n> but rather a baseline captures the state of the version-controlled\n> members of the configuration.\n\nAh, this is more precise.\n\nI'll leave the resolution of this up to you, so long as the current text is\nreplaced.\n\n>    If so, perhaps the\n>    version-controlled-configuration is better named a\n>    version-controlled-baseline?  If not, then it appears the\n>    definition of configuration needs some tightening.\n>\n> When you create a \"version\" of something, you always have to define\n> what is in that version.  In the case of a simple resource, it is the\n> content and dead properties (not the live properties).  In the case of\n> a collection, it is the dead properties and the bindings to the\n> version histories of the version controlled internal members of that\n> collection.  In the case of a configuration, it is the DAV:checked-in\n> versions of the version-controlled members of that configuration.\n\nThe way configuration is defined, a reasonable assumption about a\nversion-controlled configuration (just going by the name, and thinking about\nwhat a configuration, under version control might look like) is that it\nwould include specific version resources, as well as preserved unversioned\nresources. Since a configuration can contain both versioned and unversion\nresources, a versioned configuration might reasonably also contain both\nversioned and unversioned resources.  I'm not advocating that version\ncontrolled configurations should contain unversioned resources -- I'm just\npointing out a reasonable interpretation of the term version-controlled\nconfiguration, and how this diverges from the actual defined meaning of the\nterm.  Such divergences can lead to confusion while reading the spec.\n\nOne possible way of resolving this divergence is to name this a\nversion-controlled baseline.  Since a baseline only contains versioned\nresources, there is no confusion, since there is no expectation that\nunversioned resources might be a part of it.\n\nAnother way of resolving the divergence is to explicitly note it.\n\n- Jim\n\n\n\n", "id": "lists-006-8466477"}, {"subject": "RE: Comments on Baseline option (in 12.3", "content": ">    6. Section 10.3.1 & Section 10.11 (DAV:baseline-collection)\n>\n>    Since this is a protected and computed property,\n>\n> (actually, I believe it is just a protected, not a computed, property)\n\nHmm, then this is another area that needs to be fleshed out.  While a\nbaseline is checked-out, the server automatically maintains the value of the\nbaseline, right?  This would imply that at any time while a baseline is\nchecked out, a client could read the value of the DAV:baseline-collection of\nthe checked-out baseline, and receive an up-to-date, consistent baseline. Is\nthis correct?\n\nIf so, then this sounds like a computed property to me.\n\nOr is it that, when checked-out, there is no DAV:baseline-collection\nproperty, and then when checked-in, this property is created with the\ncorrect value?\n\nAlso, just to make sure I'm not really missing the boat -- the intent is\nthat the client is not responsible for maintaining the value of\nDAV:baseline-collection property directly (i.e., by PROPPATCHing this\nproperty), right?\n\n>    its state is not\n>    guaranteed to be preserved when a version is made of it, since a\n>    version is defined to be (Section 1.4) \"A 'version' is a resource\n>    that contains a copy of a particular state (content and dead\n>    properties)\".\n>\n> A version-controlled configuration does not have a DAV:baseline-collection\n> property, so I don't see that this issue arises.  It is only a property\n> of a baseline.\n\nThis implies that the DAV:baseline-collection property does not exist when a\nbaseline is in checked-out state.  Is that correct?\n\n>    8. Section 10.6 (definition of BASELINE-CONTROL)\n>\n>    \"If no baseline is specified, a new baseline history is created,\n>    and the DAV:checked-in version of the version-controlled\n>    configuration will be the (empty) root baseline of that baseline\n>    history.\"\n>\n>    OK, but what happens if a baseline is specified?  I would guess\n>    that the version history associated with the version-controlled\n>    configuration for the baseline specified in the request body would\n>    be used, right?\n>\n> Yes.  Since the previous paragraph states:\n>\n>  \"If a baseline is specified in the request body, the DAV:checked-in\n>  version of the new version-controlled configuration will be that\n>  baseline\"\n\nMy point was that this says *nothing* about the baseline **history**\nresource in the case where a baseline is specified in the request body.  It\nspecifies what happens to the baseline, and what happens to the\nversion-controlled configuration, but says nothing about the baseline\nhistory.\n\n- Jim\n\n\n\n", "id": "lists-006-8481589"}, {"subject": "Re: DTD Confusio", "content": "   From: \"James J. Hunt\" <jjh@ira.uka.de>\n\n   The last DTD that I posted is in fact one DTD for each message packed\n   together in one file.   There is a lot of common code in it.  I could\n   modify it to have one common section that is included by a short message\n   based DTD header for each message where it is necessary.  The only place\n   where that is actually needed is if one would like to reuse set and\n   friends in LABEL.  I could live with that.\n\nOK, sounds like we're all set there then.\n\n   There are two places in the protocol where I would like to clean up a\n   bit and it is not just a DTD issue.  One is that handling of error\n   return information.  I would like a top level error element as given at\n   the end of my DTD proposal.\n\nThat's OK with me.  For everyone who hasn't read James' DTD, this just\nsays that you get back:\n <DAV:error> <DAV:some-error-element/> </DAV:error>\nI assume this is to allow you to return multiple error elements?\n\nAny objections?\n\n   The second is the way the expand-property\n   report sends information.  I do not want to nest prop elements in prop\n   elements.  I is just not very clean.  I made a suggestion to this effect,\n   but there was almost not comment on it.\n\nI think I'll need more than \"not very clean\".  The mechanism in the\ncurrent protocol is not order sensitive (i.e. does not require that a\nparticular element type be \"first\"), which is better for\nextensibility.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-8491568"}, {"subject": "RE: DAV:compare-baseline REPOR", "content": "Good point!  I'll add the appropriate preconditions to CHECKOUT,\nMERGE, and UPDATE.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n\nBTW the DAV:baseline-collection is defined as a collection of checked-in\nversion-controlled resources -- I assume that the collection itself is\n'protected', i.e., servers will fail attempts to check-out those VCRs\notherwise the property definition is violated.\n\nTim\n\n\n\n", "id": "lists-006-8500150"}, {"subject": "Re: Option abus", "content": "The argument for using PROPFIND to get the information that varies\nfrom resource to resource (as opposed to information that varies\nfrom server to server) is that it allows you to get a consistent\nset of information in one Depth PROPFIND request, whereas if you had to\ndo both PROPFIND and OPTIONS requests, you'd have to first lock\nthat collection to make sure that things didn't get moved around\nbetween your PROPFIND and your OPTIONS requests, and it is always\nunfortunate to have to lock something just for consistent read access.\n\nSo other than it being ridiculous and bogus (:-), what harm is there\nin making DAV:supported-method-set, DAV:supported-live-property-set,\nand DAV:supported-report-set live properties?\n\nCheers,\nGeoff\n\n\n   From: Greg Stein <gstein@lyra.org>\n\n   IMO, it is still quite ridiculous to do some discovery through OPTIONS, and\n   other discovery through PROPFIND. OPTIONS is defined to be per-resource (if\n   you want general server options, the use \"*\" for the Request-URI).\n   Arbitrarily classifying a subset of information as \"more useful in a Depth:\n   context, so we'll put it into PROPFIND\" is just that: arbitrary. In layman's\n   terms, that is a synonym for \"bogus\". :-)\n\n   Cheers,\n   -g\n\n\n\n", "id": "lists-006-8507668"}, {"subject": "Re: Comments on Baseline option (in 12.3", "content": "On Mon, Feb 12, 2001 at 11:01:20AM -0800, Jim Whitehead wrote:\n> >    6. Section 10.3.1 & Section 10.11 (DAV:baseline-collection)\n> >\n> >    Since this is a protected and computed property,\n> >\n> > (actually, I believe it is just a protected, not a computed, property)\n\nIn Subversion, it is computed and protected.\n\n> Hmm, then this is another area that needs to be fleshed out.  While a\n> baseline is checked-out, the server automatically maintains the value of the\n> baseline, right?  This would imply that at any time while a baseline is\n> checked out, a client could read the value of the DAV:baseline-collection of\n> the checked-out baseline, and receive an up-to-date, consistent baseline. Is\n> this correct?\n\nA checked-out baseline is exactly the same as the baseline referred to by\nits DAV:checked-out property. Specifically, there isn't anything that you\ncan do with a working baseline to change its contents. Consistency is\nimplicit, so the DAV:baseline-collection would continue to be valid.\n\nA working baseline is good for storing new (dead) properties on a baseline,\nbut not much else.\n\nThe set of versions captured by a baseline are defined by a relationship\nwith a version-controlled configuration (VCC). A working baseline does not\nhave this relationship, so it cannot affect the set of versions. Other\n\"stuff\" is needed. For example, if you check out a baseline into an\nactivity, then you can find a version-controlled configuration at MERGE time\nby using the DAV:version-controlled-configuration property of the merge\ntarget.\n\n[ there is also a way to create a baseline by checking out the VCC and\n  checking it back in -- it will snapshot the related\n  baseline-controlled-collection. ]\n\n> If so, then this sounds like a computed property to me.\n\nWell... the server always assigns it, and it will typically be constant\nafter that point.\n\n> Or is it that, when checked-out, there is no DAV:baseline-collection\n> property, and then when checked-in, this property is created with the\n> correct value?\n\nIt is definitely created/updated at checkin time. It could exist as a\nprotected property at checkout, per the above notes.\n\n> Also, just to make sure I'm not really missing the boat -- the intent is\n> that the client is not responsible for maintaining the value of\n> DAV:baseline-collection property directly (i.e., by PROPPATCHing this\n> property), right?\n\nCorrect. The server says \"over <there> is a URL namespace that looks like\nthe baseline-controlled-collection at the time the baseline was created.\"\n\n> >    its state is not\n> >    guaranteed to be preserved when a version is made of it, since a\n> >    version is defined to be (Section 1.4) \"A 'version' is a resource\n> >    that contains a copy of a particular state (content and dead\n> >    properties)\".\n> >\n> > A version-controlled configuration does not have a DAV:baseline-collection\n> > property, so I don't see that this issue arises.  It is only a property\n> > of a baseline.\n> \n> This implies that the DAV:baseline-collection property does not exist when a\n> baseline is in checked-out state.  Is that correct?\n\nI think Geoff is mistaken here. Since a VCC is essentially a VCR, then it\nshould have all the properties of its DAV:checked-in value, which is a\nbaseline. Thus, it should have a DAV:baseline-collection property.\n\nI'm not sure what the original issue was (missing some quoted text above, it\nappears).\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8515522"}, {"subject": "Re: DTD Confusio", "content": "Dear Geoff,\n\n      From: \"James J. Hunt\" <jjh@ira.uka.de>\n\n      The last DTD that I posted is in fact one DTD for each message packed\n      together in one file.   There is a lot of common code in it.  I could\n      modify it to have one common section that is included by a short message\n      based DTD header for each message where it is necessary.  The only place\n      where that is actually needed is if one would like to reuse set and\n      friends in LABEL.  I could live with that.\n\n   OK, sounds like we're all set there then.\n\n      There are two places in the protocol where I would like to clean up a\n      bit and it is not just a DTD issue.  One is that handling of error\n      return information.  I would like a top level error element as given at\n      the end of my DTD proposal.\n\n   That's OK with me.  For everyone who hasn't read James' DTD, this just\n   says that you get back:\n    <DAV:error> <DAV:some-error-element/> </DAV:error>\n   I assume this is to allow you to return multiple error elements?\n\nThat and I can use the same construct in propstat in the place of or\nparallel to responsedescription.\n\n   Any objections?\n\n      The second is the way the expand-property\n      report sends information.  I do not want to nest prop elements in prop\n      elements.  I is just not very clean.  I made a suggestion to this effect,\n      but there was almost not comment on it.\n\n   I think I'll need more than \"not very clean\".  The mechanism in the\n   current protocol is not order sensitive (i.e. does not require that a\n   particular element type be \"first\"), which is better for\n   extensibility.\n\nA better explanation is perhaps in order, but I do not see your object\nin regards to order sensitivity.  Your example has an order that is\nimplicit.  There must be an associatition between the variable value or\nrequest at one level and the next set of variable values or requests at\nthe next deeper level.  I would like to make this relationship explicit\nwith multiprop and prop-apply respectively.  No additional order\nconstraints are made.\n\nSincerely,\nJames J. Hunt\n\n\n\n", "id": "lists-006-8525991"}, {"subject": "RE: Auto-version correction", "content": "Here's some revised wording for Section 3.1.2.\nLet me know if you think this is clearer.\n\nCheers,\nGeoff\n\n3.1.2Modifying a Version-Controlled Resource\n\nIn order to use methods like PUT and PROPPATCH to directly modify the\ncontent or dead properties of a version-controlled resource, the\nversion-controlled resource must first be checked out.  When the checked-out\nresource is checked in, a new version is created in the version history of\nthat version-controlled resource.  The version that was checked out is\nremembered as the predecessor of the new version.\n  \nThe DAV:auto-version property (see Section 3.3.2) of a checked-in\nversion-controlled resource determines how it responds to a method that\nattempts to modify its content or dead properties.  The four possible\nresponses are:\n\n- Fail the request.  The resource requires an explicit CHECKOUT request for\nit to be modified (see Sections 5).\n\n- Fail the request unless the resource is write-locked.  If it is\nwrite-locked, automatically checkout the resource and perform the\nmodification.  The resource remains checked-out until the write-lock is\nremoved (either explicitly through a subsequent UNLOCK request or implicitly\nthrough a time-out of the write-lock).  This avoids the proliferation of\nversions that can result if every modification creates a new version.\n\n- Automatically checkout the resource, perform the modification, and then if\nthe resource is not write-locked, automatically checkin the resource.  If\nthe resource is write-locked, it remains checked-out until the write-lock is\nremoved.  This helps a locking client avoid the proliferation of versions,\nwhile still allowing a non-locking client to update the resource.\n\n- Automatically checkout the resource, perform the modification, and\nautomatically checkin the resource.  This ensures that every state of the\nresource is tracked by the server, but can result in an excessive number of\nversions being created.\n\n...\n\n\n\n", "id": "lists-006-8535504"}, {"subject": "Re: Auto-version correction", "content": "Looks very good to me.\n\nCheers,\n-g\n\nOn Tue, Feb 13, 2001 at 06:34:07PM -0500, Clemm, Geoff wrote:\n> Here's some revised wording for Section 3.1.2.\n> Let me know if you think this is clearer.\n> \n> Cheers,\n> Geoff\n> \n> 3.1.2Modifying a Version-Controlled Resource\n> \n> In order to use methods like PUT and PROPPATCH to directly modify the\n> content or dead properties of a version-controlled resource, the\n> version-controlled resource must first be checked out.  When the checked-out\n> resource is checked in, a new version is created in the version history of\n> that version-controlled resource.  The version that was checked out is\n> remembered as the predecessor of the new version.\n>   \n> The DAV:auto-version property (see Section 3.3.2) of a checked-in\n> version-controlled resource determines how it responds to a method that\n> attempts to modify its content or dead properties.  The four possible\n> responses are:\n> \n> - Fail the request.  The resource requires an explicit CHECKOUT request for\n> it to be modified (see Sections 5).\n> \n> - Fail the request unless the resource is write-locked.  If it is\n> write-locked, automatically checkout the resource and perform the\n> modification.  The resource remains checked-out until the write-lock is\n> removed (either explicitly through a subsequent UNLOCK request or implicitly\n> through a time-out of the write-lock).  This avoids the proliferation of\n> versions that can result if every modification creates a new version.\n> \n> - Automatically checkout the resource, perform the modification, and then if\n> the resource is not write-locked, automatically checkin the resource.  If\n> the resource is write-locked, it remains checked-out until the write-lock is\n> removed.  This helps a locking client avoid the proliferation of versions,\n> while still allowing a non-locking client to update the resource.\n> \n> - Automatically checkout the resource, perform the modification, and\n> automatically checkin the resource.  This ensures that every state of the\n> resource is tracked by the server, but can result in an excessive number of\n> versions being created.\n> \n> ...\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8544416"}, {"subject": "RE: Auto-version correction", "content": "Geoff,\nGreat descriptions. Hopefully this will remove the confusion, although I \ndid have to read the third bullet item a number of times to get the \ndifference. Some suggestions:\n\nPut the value of DAV:auto-version in parens at the beginning of each \nparagraph to tie the pieces together.\n\nConsider removing item 3. It seems gratuitous. If you have a locking \nclient, it can either do the lock or not depending on what it wants to \naccomplish. Most clients that manage their own private workspaces will \njust want to do a single PUT when synchronizing their client workspace \nwith the server, and won't need lock. Clients that don't manage their own \nprivate workspaces can use LOCK to have the server manage the temporary \nspace. If you don't have a locking client, then the request should either \nfail or create the new version (auto-version on or off).\n\nYou could also consider removing the first item. A core versioning server \nthat supports the checkout option should still support locking semantics. \nThey're just different ways to do the same thing supporting different \nclients. Adding the checkout option shouldn't remove locking capability. \nAnd having an option to distinguish the two doesn't seem necessary as long \nas locking semantics are defined in terms of checkout/checkin.\n\nDoing these two things makes DAV:auto-version a Boolean again.\n\n\n\n\n\n\"Clemm, Geoff\" <gclemm@rational.com>\nSent by: ietf-dav-versioning-request@w3.org\n02/13/2001 06:34 PM\n\n \n        To:     ietf-dav-versioning@w3.org\n        cc: \n        Subject:        RE: Auto-version corrections\n\n \n\nHere's some revised wording for Section 3.1.2.\nLet me know if you think this is clearer.\n\nCheers,\nGeoff\n\n3.1.2            Modifying a Version-Controlled Resource\n\nIn order to use methods like PUT and PROPPATCH to directly modify the\ncontent or dead properties of a version-controlled resource, the\nversion-controlled resource must first be checked out.  When the \nchecked-out\nresource is checked in, a new version is created in the version history of\nthat version-controlled resource.  The version that was checked out is\nremembered as the predecessor of the new version.\n \nThe DAV:auto-version property (see Section 3.3.2) of a checked-in\nversion-controlled resource determines how it responds to a method that\nattempts to modify its content or dead properties.  The four possible\nresponses are:\n\n- Fail the request.  The resource requires an explicit CHECKOUT request \nfor\nit to be modified (see Sections 5).\n\n- Fail the request unless the resource is write-locked.  If it is\nwrite-locked, automatically checkout the resource and perform the\nmodification.  The resource remains checked-out until the write-lock is\nremoved (either explicitly through a subsequent UNLOCK request or \nimplicitly\nthrough a time-out of the write-lock).  This avoids the proliferation of\nversions that can result if every modification creates a new version.\n\n- Automatically checkout the resource, perform the modification, and then \nif\nthe resource is not write-locked, automatically checkin the resource.  If\nthe resource is write-locked, it remains checked-out until the write-lock \nis\nremoved.  This helps a locking client avoid the proliferation of versions,\nwhile still allowing a non-locking client to update the resource.\n\n- Automatically checkout the resource, perform the modification, and\nautomatically checkin the resource.  This ensures that every state of the\nresource is tracked by the server, but can result in an excessive number \nof\nversions being created.\n\n...\n\n\n\n", "id": "lists-006-8553403"}, {"subject": "RE: Auto-version correction", "content": "I'll just add my comments to Jim's rather than start from scratch...\n\n> -----Original Message-----\n> From: Jim Amsden\n> Put the value of DAV:auto-version in parens at the beginning of each\nparagraph to tie the pieces together.\n\nI was going to say that :)\n\n> Consider removing item 3. It seems gratuitous.\n\nI don't agree.  Item 3 is exactly what I'd prefer to implement.  If\nanything, I suspect item 2 might not be used by any server, but the two\nare definitely distinct in behaviour.\n\nlisa\n\n\n\n", "id": "lists-006-8565000"}, {"subject": "Re: Auto-version correction", "content": "On Wed, Feb 14, 2001 at 10:18:10AM -0500, Jim Amsden wrote:\n>...\n> Consider removing item 3. It seems gratuitous. If you have a locking\n\nAbsolutely not. That is one of the best options. It allows Word 2000 to\ncreate a single version (by waiting for its UNLOCK), and it allows somebody\nusing PUT (no LOCK/UNLOCK) to create a version. It is the right blend.\n\n>...\n> You could also consider removing the first item. A core versioning server \n> that supports the checkout option should still support locking semantics.\n\nSays who? That is a silly statement. Subversion isn't going to support\nlocking semantics at all. You'll get a 405 if you send a LOCK or UNLOCK.\nVersioning servers don't need locking semantics -- they allow multiple\npeople to work on resources simultaneously. Think, \"parallel development\".\nThat is the antithesis of locks.\n\n>...\n> Doing these two things makes DAV:auto-version a Boolean again.\n\nSorry. All four stay :-)\n\nCheers,\n-g\n\n> \n> \n> \n> \n> \n> \"Clemm, Geoff\" <gclemm@rational.com>\n> Sent by: ietf-dav-versioning-request@w3.org\n> 02/13/2001 06:34 PM\n> \n>  \n>         To:     ietf-dav-versioning@w3.org\n>         cc: \n>         Subject:        RE: Auto-version corrections\n> \n>  \n> \n> Here's some revised wording for Section 3.1.2.\n> Let me know if you think this is clearer.\n> \n> Cheers,\n> Geoff\n> \n> 3.1.2            Modifying a Version-Controlled Resource\n> \n> In order to use methods like PUT and PROPPATCH to directly modify the\n> content or dead properties of a version-controlled resource, the\n> version-controlled resource must first be checked out.  When the \n> checked-out\n> resource is checked in, a new version is created in the version history of\n> that version-controlled resource.  The version that was checked out is\n> remembered as the predecessor of the new version.\n>  \n> The DAV:auto-version property (see Section 3.3.2) of a checked-in\n> version-controlled resource determines how it responds to a method that\n> attempts to modify its content or dead properties.  The four possible\n> responses are:\n> \n> - Fail the request.  The resource requires an explicit CHECKOUT request \n> for\n> it to be modified (see Sections 5).\n> \n> - Fail the request unless the resource is write-locked.  If it is\n> write-locked, automatically checkout the resource and perform the\n> modification.  The resource remains checked-out until the write-lock is\n> removed (either explicitly through a subsequent UNLOCK request or \n> implicitly\n> through a time-out of the write-lock).  This avoids the proliferation of\n> versions that can result if every modification creates a new version.\n> \n> - Automatically checkout the resource, perform the modification, and then \n> if\n> the resource is not write-locked, automatically checkin the resource.  If\n> the resource is write-locked, it remains checked-out until the write-lock \n> is\n> removed.  This helps a locking client avoid the proliferation of versions,\n> while still allowing a non-locking client to update the resource.\n> \n> - Automatically checkout the resource, perform the modification, and\n> automatically checkin the resource.  This ensures that every state of the\n> resource is tracked by the server, but can result in an excessive number \n> of\n> versions being created.\n> \n> ...\n> \n> \n> \n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8572367"}, {"subject": "Re: Auto-version correction", "content": ">...\n> You could also consider removing the first item. A core versioning \nserver \n> that supports the checkout option should still support locking \nsemantics.\n\nSays who? That is a silly statement. Subversion isn't going to support\nlocking semantics at all. You'll get a 405 if you send a LOCK or UNLOCK.\nVersioning servers don't need locking semantics -- they allow multiple\npeople to work on resources simultaneously. Think, \"parallel development\".\nThat is the antithesis of locks.\n<jra>\nMaybe I wasn't clear enough. A core versioning server that *supports \nlocking AND* the checkout option should continue to support its locking \nsemantics. I didn't mean to imply that a server that didn't support \nlocking but did support the checkout option needed to support locking. \nNote that locking is still optional even  though its referenced in core \nsince its optional in 2518. So I still think the first item could be \nremoved.\n</jra>\n\n\n\n", "id": "lists-006-8583255"}, {"subject": "RE: Auto-version correction", "content": "I'll stand by Greg and Geoff here;  option 1 allows a server to require\nthat the client be versioning-aware in order to make any changes to the\nresources.  That can be a very useful feature.\n\nGeoff, in your original mail on this topic, you said that this was text\nfor section 3.1.2.  Does that mean that the proposed auto-version\nclarification is not part of Core?\n\nI think it does make sense to talk about checkin/checkout in Core, even\nif the CHECKIN and CHECKOUT methods are not defined in core.  Actually,\nI'd support the auto-version stuff and CHECKIN and CHECKOUT all being\npart of Core.\n\nlisa\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\nSent: Wednesday, February 14, 2001 2:27 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: Auto-version corrections\n\n\n\n>...\n> You could also consider removing the first item. A core versioning\nserver\n> that supports the checkout option should still support locking\nsemantics.\n\nSays who? That is a silly statement. Subversion isn't going to support\nlocking semantics at all. You'll get a 405 if you send a LOCK or UNLOCK.\nVersioning servers don't need locking semantics -- they allow multiple\npeople to work on resources simultaneously. Think, \"parallel\ndevelopment\".\nThat is the antithesis of locks.\n<jra>\nMaybe I wasn't clear enough. A core versioning server that *supports\nlocking AND* the checkout option should continue to support its locking\nsemantics. I didn't mean to imply that a server that didn't support\nlocking but did support the checkout option needed to support locking.\nNote that locking is still optional even  though its referenced in core\nsince its optional in 2518. So I still think the first item could be\nremoved.\n</jra>\n\n\n\n", "id": "lists-006-8591343"}, {"subject": "RE: OPTION", "content": "[freed from spam trap -rrs]\n\n Date: Wed, 14 Feb 2001 21:51:47 -0500 (EST)\n From: \"Kevin Wiggen\" <wiggs@wiggenout.com>\n To: \"John Stracke\" <francis@ecal.com>\n Cc: <w3c-dist-auth-request@w3.org>, <ietf-dav-versioning@w3.org>\n Message-ID: <ONEOJMKKAIDAGPLOPJEDOEFGCMAA.wiggs@wiggenout.com>\n Subject: [Moderator Action] RE: OPTIONS\n\nThe real question on OPTIONS is now, should a server be sending back a\ndifferent OPTIONS answer per resource.  In other words, does a server look\nat the resource that has been requested and answer appropriately.  I am\nCCing the DeltaV group as I have been told this is exactly what they are\nproposing.\n\nThus an \"intelligent\" options request could look that a resource is not a\ndirectory and thus return:\nAllow: GET, HEAD, POST, OPTIONS, TRACE, PROPFIND, COPY, SEARCH, PROPPATCH,\nLOCK, UNLOCK, PUT, DELELTE, MOVE\n\nnotice no MKCOL\n\nIf we are going to make OPTIONS useful to all clients, 2518 should define it\na MUST for a server to return an intelligent OPTIONS response, otherwise a\nclient will never be able to depend on the information.\n\nSome Apache Examples:\nOPTIONS on any resource (existent or not) on Apache returns a 200 with a\nAllow: GET, HEAD, OPTIONS, TRACE\n\nThus one could argue that following suit, a Webdav server for any resource\n(existent or not) could respond: Allow: GET, HEAD, POST, OPTIONS, TRACE,\nPROPFIND, COPY, SEARCH, PROPPATCH, LOCK, UNLOCK, MKCOL, PUT, DELETE, MOVE\n\nShould Webdav 2518 state that a server MUST not do the above but\nintelligently respond to an OPTIONS request?\n\nIf servers are then required to respond intelligently, what does that mean?\nDoes an OPTIONS to a non-existent resource without a parent simply return:\nAllow:  OPTIONS\n\nKevin\n\n\n-----Original Message-----\nFrom: w3c-dist-auth-request@w3.org\n[mailto:w3c-dist-auth-request@w3.org]On Behalf Of John Stracke\nSent: Wednesday, February 14, 2001 8:00 AM\nTo: w3c-dist-auth@w3.org\nSubject: Re: OPTIONS\n\n\nKevin Wiggen wrote:\n\n> 1)  /foo is a directory with no contents.\n>     OPTIONS to /foo returns a 200 with the appropriate headers\n>     OPTIONS to /foo/bar returns??  200 or 404??\n>     OPTIONS to /foo/bar/fee returns a 404\n\n[...]\n\n> Since OPTIONS\n> in 2068\n\n(Side note: you want 2616, which obsoletes 2068.)\n\n> states \"the OPTIONS request applies only to the options that are\n> available when communicating with that resource.\"  Thus to get a 200\n> response a resource must exist!!!\n\nWell, let's see.  Consider PUT, for example; obviously, you can PUT to a\nresource which does not exist (in the sense that GET would return 404).\nTherefore, it is useful for OPTIONS to be able to tell you that PUT is\nallowed\non that resource.\n\n<tries stuff>...OK, let's see.  Running against Apache, if I do OPTIONS\nagainst\na non-existent resource (in a non-existent directory), I get a 200, with the\nexpected data.  GET against the same resource returns 404; SMURF against\nthat\nresource returns 405.\n\nTo me, this seems reasonable.  I believe that *all* resources exist.  A\nresource is an object whose methods are HTTP methods; you can issue an HTTP\nmethod against any Request-URI in the server's namespace; the server will\nrespond.  By definition, the response is the result of that object's method.\nTherefore, there is an object named by that Request-URI.  Note that 2616,\nsection 10.4.5, defines 404 as meaning, \"The server has not found anything\nmatching the Request-URI\".  This is *not* the same as saying that the\nspecified\nresource does not exist.\n\n--\n/==============================================================\\\n|John Stracke    | http://www.ecal.com |My opinions are my own.|\n|Chief Scientist |=============================================|\n|eCal Corp.      |\"Call me a Nervous Nellie, but I am concerned|\n|francis@ecal.com|about the sale of nuclear arms in my general |\n|                |neighborhood.\" -- Dave Barry                 |\n\\==============================================================/\n\n\n\n", "id": "lists-006-8600701"}, {"subject": "REPORT not in COR", "content": "In reading the latest draft, I have to admit that I find it very weird that\nthe REPORT method is introduced before the CORE section of the draft.  Why\nnot make this part of CORE?  I think it would read a lot better and\nstructurally make more sense.\n\nComments?\n\n\n\n", "id": "lists-006-8613356"}, {"subject": "RE: REPORT not in COR", "content": "> In reading the latest draft, I have to admit that I find it very\n> weird that\n> the REPORT method is introduced before the CORE section of the draft.  Why\n> not make this part of CORE?  I think it would read a lot better and\n> structurally make more sense.\n>\n> Comments?\n\nThis makes sense to me as well.  If other protocols wish to use the REPORT\nmethod, it would be possible for a server to implement REPORT, and not the\nrest of core.  Such a server would advertise the existence of REPORT in the\nAllow header returned from an OPTIONS method invocation, or via whatever\nadditional discovery mechanism the protocol supports. Since REPORT is\ndefinitely required as part of core, it should be in the core section.\n\n- Jim\n\n\n\n", "id": "lists-006-8620452"}, {"subject": "possible new property", "content": "For VCRs that are under baseline control, I propose that we add a new\nproperty that specifies their relative path to the \"root\" of the baseline,\nwhere the root is defined by the baseline's DAV:baseline-collection\nproperty.\n\n[ hmm. just noticed something: that property assumes the baseline is not\n  disjoint. fixing that is \"out of scope\" of this message :-) ]\n\n\nWithout the property mentioned above, it would be very difficult to figure\nout where to go in a baseline to find the matching resource. Specifically,\nthe algorithm would be something like:\n\n1) for a resource \"R\", get the DAV:version-controlled-configuration\n   property from the resource (if a collection) or its parent\n2) get the DAV:checked-in property of the VCC to get the baseline\n3) get the DAV:baseline-collection property from the baseline\n4) get the DAV:version-history property of the resource at the root of the\n   baseline-collection\n5) starting at R, set \"current\" to R, then:\n   -) fetch the DAV:version-history of \"current\"\n   -) if it matches the VH from the baseline-collection, then exit loop\n   -) set \"current\" to parent of \"current\". loop.\n6) use the relative path between \"current\" and R to move downwards within\n   the baseline-collection\n\nSteps 4 and 5 just disappear if the baseline-relative-path property is\npresent on the VCR.\n(note that steps 1, 2, and 3 are a single expand-property report; step 6 is\n just URL construction -- there is no server request)\n\nWith the property, we have a single REPORT. (to fetch the relative path, and\nto expand thru the VCC and the baseline to the baseline-collection)\n\nWithout the property, we have a REPORT plus N additional requests.\n\nNote that we can also use the relative path to (hopefully) access other\nbaselines. Presuming the \"current\" baseline defined by the VCC isn't too far\ndifferent from the target baseline, the path will still apply.\n\nAny thoughts?\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8627722"}, {"subject": "I-D ACTION:draft-ietf-deltav-versioning-13.tx", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Web Versioning and Configuration Management Working Group of the IETF.\n\nTitle: Versioning Extensions to WebDAV\nAuthor(s): G. Clemm, J. Amsden, C. Kaler, J. Whitehead\nFilename: draft-ietf-deltav-versioning-13.txt\nPages: 98\nDate: 15-Feb-01\n\nThis document specifies a set of methods, headers, and resource types \nthat define the WebDAV Versioning extensions to the HTTP/1.1 protocol. \nWebDAV Versioning will minimize the complexity of clients that are\ncapable of interoperating with a variety of versioning repository\nmanagers, to facilitate widespread deployment of applications capable of\nutilizing the WebDAV Versioning services.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-13.txt\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-deltav-versioning-13.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-deltav-versioning-13.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n\n\n\nMessage/External-body attachment: stored\n\n\n\n\n", "id": "lists-006-8637004"}, {"subject": "Re: possible new property", "content": "> For VCRs that are under baseline control, I propose that\n> we add a new property that specifies their relative path\n> to the \"root\" of the baseline, where the root is defined\n> by the baseline's DAV:baseline-collection property.\n\nI assume that you are referring to the checked-in VCRs in the\nDAV:baseline-collection.\n\n> [ hmm. just noticed something: that property assumes the\n> baseline is not disjoint. fixing that is \"out of scope\"\n> of this message :-) ]\n\nI'll watch for the other message, I don't know what you mean.\n\n> Without the property mentioned above, it would be very\n> difficult to figure out where to go in a baseline to\n> find the matching resource.\n\nWhat does 'where to go in a baseline' mean?\nCan I assume you mean the DAV:baseline-collection?\n\n> Specifically, the algorithm would be something like:\n>\n> 1) for a resource \"R\", get the DAV:version-controlled-\n> configuration property from the resource (if a collection)\n> or its parent\n> 2) get the DAV:checked-in property of the VCC to get\n> the baseline\n> 3) get the DAV:baseline-collection property from the\n> baseline\n\nOk, I'm with you so far.\n\n> 4) get the DAV:version-history property of the resource\n> at the root of the baseline-collection\n\n> 5) starting at R, set \"current\" to R, then:\n>    -) fetch the DAV:version-history of \"current\"\n>    -) if it matches the VH from the baseline-collection,\n> then exit loop\n>    -) set \"current\" to parent of \"current\". loop.\n\nIf I understand this correctly, you mean find the relative path from the\nbaseline-controlled collection to R.\n\nThe baseline-collection may not in general have a version-history since it\nmay not be a checked-in version-controlled collection (i.e., it may be\nbaselined and not versioned).\n\nWhy not use the relative path you walked in step (1) above when finding the\nDAV:version-controlled-configuration property in step (6), and discard step\n(5) altogether?\n\n> 6) use the relative path between \"current\" and R to\n> move downwards within the baseline-collection\n\nHowever, I think you'd have to do a top down search through the\nDAV:baseline-collection for the matching history resource as R because the\nnamespace may have been 'messed up' and the VCR corresponding to R could be\nin a different spot (heuristically you could look along the same path as\nthe baseline controled collection...)\n\n> Steps 4 and 5 just disappear if the baseline-relative-path\n> property is present on the VCR.\n\nAgreed.  However, the same VCR could be baselined in numerous baselines and\nthe relative paths would not be the same.\n\n> (note that steps 1, 2, and 3 are a single expand-property\n> report; step 6 is just URL construction -- there is no\n> server request)\n\nAgreed.\n\n> With the property, we have a single REPORT. (to fetch\n> the relative path, and to expand thru the VCC and the\n> baseline to the baseline-collection)\n>\n> Without the property, we have a REPORT plus N additional\n> requests.\n\nAgreed.\n\n> Note that we can also use the relative path to (hopefully)\n> access other baselines. Presuming the \"current\" baseline\n> defined by the VCC isn't too far different from the target\n> baseline, the path will still apply.\n\nHmm, I'd be reluctant to introduce a property whose value has a sense of\nprobability.\n\n> Any thoughts?\n>\n> Cheers,\n> -g\n\nTim\n\n\n\n", "id": "lists-006-8645789"}, {"subject": "Re: possible new property", "content": "I began reading this with one assumption, then understood what Greg meant\npart way through, so the first couple of comments no longer apply.\nScratch those I wrote below, and sorry for the (my) confusion.\n\nTim\n\n\n\n> > For VCRs that are under baseline control, I propose that\n> > we add a new property that specifies their relative path\n> > to the \"root\" of the baseline, where the root is defined\n> > by the baseline's DAV:baseline-collection property.\n>\n> I assume that you are referring to the checked-in VCRs in the\n> DAV:baseline-collection.\n\nNo dumbo, that wouldn't be too difficult!\n\n> > [ hmm. just noticed something: that property assumes the\n> > baseline is not disjoint. fixing that is \"out of scope\"\n> > of this message :-) ]\n>\n> I'll watch for the other message, I don't know what you mean.\n\nThis comment still stands.\n\n> > Without the property mentioned above, it would be very\n> > difficult to figure out where to go in a baseline to\n> > find the matching resource.\n>\n> What does 'where to go in a baseline' mean?\n> Can I assume you mean the DAV:baseline-collection?\n\nI still think 'where to go in a baseline' is a strange expression, but I\nknow what you mean now<g>\n\nTim\n\n\n\n", "id": "lists-006-8656464"}, {"subject": "Status-reporting &amp; refusing depth heade", "content": "I've started looking at draft 13...\n\nSection 2.1 says: \"If a Depth request header is included, the request\nMUST be applied separately to the collection itself and to all members\nof the collection that satisfy the Depth value.  \"\n\nThe REPORT method needs a way for the server to say that it DOESN't\nsupport the Depth: header on that particular report.  Reports can be\nexpensive to calculate, and the server needs a way to refuse that\nexpense at will.  At least, by refusing to support depth on certain\nreports, the server has a better option than refusing to support the\nreport altogether.\n\nPlease take a look at the status-reporting draft, section 6.8, for a way\nto deal with this that's quite general-purpose ...\nhttp://www.ietf.org/internet-drafts/draft-ietf-webdav-status-00.txt\n\nThis is clearly my opportunity to introduce the status-reporting draft\non this list. It's a version 00 draft, but the design has already gone\nthrough some review on the dav list, a status list and at the last WG\nmeeting.  It's completely compatible with DeltaV, because it can use the\nDeltaV XML elements as \"detail-code\" elements.  DeltaV leaves this open\nthrough the clause \"unless otherwise negotiated\", and since the\nstatus-reporting draft includes a way for the client to ask for advanced\nstatus-reporting using a special header, there's a way to negotiate.\n\nHowever, it's been pointed out that the extra header could be cut off if\nthe client could be assumed to support advanced status-reporting simply\nby nature of the kind of request being made.  E.g. if the deltaV draft\nrequired clients to support advanced status-reporting, then whenever the\nserver has an error to report on one of the deltaV methods\n(VERSION-CONTROL, REPORT, etc) it could return the advanced\nstatus-reporting body.\n\nFor deltaV clients that already have to parse XML response bodies when\nerror conditions are reported, there is extremely little extra work\nrequired:  just look in the \"response-detail\" element, then in the\n\"status-detail\" element, then in the \"detail-code\" element to find the\nactual error code element.  The rest can be ignored.\n\nlisa\n\n\n\n", "id": "lists-006-8664696"}, {"subject": "Option &quot;pre-requisites&quot", "content": "Section 4 of draft 13 says:  \" The checkout option, update option,\nversion-history option, working-resource option, merge option, label\noption, baseline option, activity option, version-controlled collection\noption, fork-control option, and variant option each require the\nversion-control option. \"\n\nSince the version-control option is now part of \"Core versioning\", is it\nsafe to simply say that ALL versioning options require core?\n\nLisa\n\n\n\n", "id": "lists-006-8673461"}, {"subject": "Overview of Core versionin", "content": "I've noticed that there is a \"rationale\" for versioning options, but not\nfor core versioning.  I think something is needed more than the no-op\ndefinition of \"the set of stuff defined in section 3\".  Core is specific\nenough that we should be able to describe, in a few brief paragraphs,\nprecisely what it accomplishes.  Thus, I've suggested some text which\ncan serve as an introduction to, overview of, and explanation of Core\nVersioning.  It's important to frame and position technical\nrequirements, because readers understand technical specifications much\nbetter if they understand what its for, and what it does, first.\n -- lisa\n\n---\n\n\"Core versioning\" is the set of properties and method semantics defined\nby Section 3 of this document.  Core versioning serves to establish a\ncommon model to organize and understand constructs which exist on any\nversioning server.  Core versioning makes a number of requirements on\nhow servers must handle version-controlled resources, so that clients\nhave a reasonable model for what effect a command will have.\n\nCore versioning makes requirements on servers but not on clients. The\nintent of this choice is that clients be able to rely on a minimum level\nof functionality when they contact a DeltaV-capable server. Since all\nHTTP actions are initiated by the client, the server has no need to know\na priori what functionality the client supports. TO the extent to which\nthe server needs to know, the client can tell it in its requests.\n\nA server which implements Core Versioning can interoperate successfully\nwith a client which is completely ignorant of DeltaV. Unless the client\nrequests versioning functionality, a Core-compliant server will\nautomatically behave like an non-versioning WebDAV server. Thus, a\nversioned resource automatically behaves in an unsurprising way when\noperated upon by WebDAV or HTTP methods.\n\nA client can use OPTIONS to find out if a server supports core\nversioning.  If the server does support core versioning, the client can\nthen be assured that it can:\n\n - Browse version-controlled resources and differentiate them from\nnon-versioned resources,\n - Use VERSION-CONTROL method to put resources under version control,\n - Browse past versions of version-controlled resources,\n - View some basic information about these resources,\n - Find out whether and how new versions will be created automatically\nby the server (auto-version)\n - Predict what effect HTTP/WebDAV operations will have on a given\nresource with a given version history\n\n\n\n", "id": "lists-006-8680340"}, {"subject": "RE: OPTION", "content": "The versioning draft specifies extremely case-by-case response to\nOPTIONS.  I think the OPTIONS response in DeltaV can even vary depending\non the state of a resource at one point in time vs. another.\n\nE.g. if a resource can be turned into a \"version-controlled resource\",\nthen OPTIONS should show the VERSION-CONTROL method, to indicate that it\ncan be converted.\n\nObviously that kind of design presupposes that OPTIONS depends on\nprecisely what resource is named in the URL.\n\nlisa\n\n> -----Original Message-----\n> From: w3c-dist-auth-request@w3.org\n> [mailto:w3c-dist-auth-request@w3.org]On Behalf Of Jason Crawford\n> Sent: Friday, February 16, 2001 7:00 PM\n> To: w3c-dist-auth@w3.org\n> Subject: RE: OPTIONS\n>\n>\n>\n>\n>\n> See Kevin's note below.\n>\n> Does anyone have a client that depends on individual resource\n> (including\n> null resources) to return different values for the OPTIONS method?\n>\n> Does anyone have a client that has *any* expectations for\n> what the OPTIONS\n> method returns that might be URI specific or that alternately\n> assumes that\n> what is true for one resource is true for some others?\n>\n> Does anyone have a server that would be unduly burdened by needing to\n> return URI specific results to OPTIONS requests?\n>\n> I'll modify the spec accordingly, but I need people to speak\n> up if they\n> would be negatively impacted if the spec took any particular stance on\n> this.   (If your answer to this is that you don't use\n> OPTIONS, then just\n> reply to me directly and I'll sumarize for later.)\n>\n> Thanks,\n>\n> J.\n>\n>\n>\n> \"Kevin Wiggen\" <wiggs@wiggenout.com> (by way of \"Ralph R. Swick\"\n> <swick@w3.org>)@w3.org on 02/15/2001 12:49:18 AM\n>\n> Sent by:  ietf-dav-versioning-request@w3.org\n>\n>\n> To:   ietf-dav-versioning@w3.org\n> cc:\n> Subject:  RE: OPTIONS\n>\n>\n>\n> [freed from spam trap -rrs]\n>\n>  Date: Wed, 14 Feb 2001 21:51:47 -0500 (EST)\n>  From: \"Kevin Wiggen\" <wiggs@wiggenout.com>\n>  To: \"John Stracke\" <francis@ecal.com>\n>  Cc: <w3c-dist-auth-request@w3.org>, <ietf-dav-versioning@w3.org>\n>  Message-ID: <ONEOJMKKAIDAGPLOPJEDOEFGCMAA.wiggs@wiggenout.com>\n>  Subject: [Moderator Action] RE: OPTIONS\n>\n> The real question on OPTIONS is now, should a server be sending back a\n> different OPTIONS answer per resource.  In other words, does\n> a server look\n> at the resource that has been requested and answer\n> appropriately.  I am\n> CCing the DeltaV group as I have been told this is exactly\n> what they are\n> proposing.\n>\n> Thus an \"intelligent\" options request could look that a\n> resource is not a\n> directory and thus return:\n> Allow: GET, HEAD, POST, OPTIONS, TRACE, PROPFIND, COPY,\n> SEARCH, PROPPATCH,\n> LOCK, UNLOCK, PUT, DELELTE, MOVE\n>\n> notice no MKCOL\n>\n> If we are going to make OPTIONS useful to all clients, 2518\n> should define\n> it\n> a MUST for a server to return an intelligent OPTIONS\n> response, otherwise a\n> client will never be able to depend on the information.\n>\n> Some Apache Examples:\n> OPTIONS on any resource (existent or not) on Apache returns a\n> 200 with a\n> Allow: GET, HEAD, OPTIONS, TRACE\n>\n> Thus one could argue that following suit, a Webdav server for\n> any resource\n> (existent or not) could respond: Allow: GET, HEAD, POST,\n> OPTIONS, TRACE,\n> PROPFIND, COPY, SEARCH, PROPPATCH, LOCK, UNLOCK, MKCOL, PUT,\n> DELETE, MOVE\n>\n> Should Webdav 2518 state that a server MUST not do the above but\n> intelligently respond to an OPTIONS request?\n>\n> If servers are then required to respond intelligently, what\n> does that mean?\n> Does an OPTIONS to a non-existent resource without a parent\n> simply return:\n> Allow:  OPTIONS\n>\n> Kevin\n>\n>\n> -----Original Message-----\n> From: w3c-dist-auth-request@w3.org\n> [mailto:w3c-dist-auth-request@w3.org]On Behalf Of John Stracke\n> Sent: Wednesday, February 14, 2001 8:00 AM\n> To: w3c-dist-auth@w3.org\n> Subject: Re: OPTIONS\n>\n>\n> Kevin Wiggen wrote:\n>\n> > 1)  /foo is a directory with no contents.\n> >     OPTIONS to /foo returns a 200 with the appropriate headers\n> >     OPTIONS to /foo/bar returns??  200 or 404??\n> >     OPTIONS to /foo/bar/fee returns a 404\n>\n> [...]\n>\n> > Since OPTIONS\n> > in 2068\n>\n> (Side note: you want 2616, which obsoletes 2068.)\n>\n> > states \"the OPTIONS request applies only to the options that are\n> > available when communicating with that resource.\"  Thus to get a 200\n> > response a resource must exist!!!\n>\n> Well, let's see.  Consider PUT, for example; obviously, you\n> can PUT to a\n> resource which does not exist (in the sense that GET would\n> return 404).\n> Therefore, it is useful for OPTIONS to be able to tell you that PUT is\n> allowed\n> on that resource.\n>\n> <tries stuff>...OK, let's see.  Running against Apache, if I\n> do OPTIONS\n> against\n> a non-existent resource (in a non-existent directory), I get\n> a 200, with\n> the\n> expected data.  GET against the same resource returns 404;\n> SMURF against\n> that\n> resource returns 405.\n>\n> To me, this seems reasonable.  I believe that *all* resources\n> exist.  A\n> resource is an object whose methods are HTTP methods; you can\n> issue an HTTP\n> method against any Request-URI in the server's namespace; the\n> server will\n> respond.  By definition, the response is the result of that object's\n> method.\n> Therefore, there is an object named by that Request-URI.\n> Note that 2616,\n> section 10.4.5, defines 404 as meaning, \"The server has not\n> found anything\n> matching the Request-URI\".  This is *not* the same as saying that the\n> specified\n> resource does not exist.\n>\n> --\n> /==============================================================\\\n> |John Stracke    | http://www.ecal.com |My opinions are my own.|\n> |Chief Scientist |=============================================|\n> |eCal Corp.      |\"Call me a Nervous Nellie, but I am concerned|\n> |francis@ecal.com|about the sale of nuclear arms in my general |\n> |                |neighborhood.\" -- Dave Barry                 |\n> \\==============================================================/\n>\n>\n>\n\n\n\n", "id": "lists-006-8689664"}, {"subject": "Re: OPTION", "content": "mod_dav returns different values for the OPTIONS request based on the\nresource identified. (so no, I won't be \"unduly burdened\" :-)\n\nI don't envision changing that, as I believe the \"OPTIONS means server\noptions\" concept (as stated before on the DeltaV list) is bogus. OPTIONS is\nsent to a particular resource. Use OPTIONS * to get server information.\n\n[ this has come up on DeltaV before: I say OPTIONS ought to take a Depth:\n  header; the rebuttal was that it didn't make sense since OPTIONS referred\n  to server capabilities. phphtt. no. ]\n\nThe SVN client expects information on a per-resource basis. I don't want to\nknow if the server has SVN capabilities; I want to know if *that* resource\nis under SVN control. It is silly to take any other position.\n\nJust go read S9.2 of RFC 2616: \"... request for information ... on the\nrequest/response chain identified by the Request-URI.\" and \"If the\nRequest-URI is not an asterisk, ... applies only ... when communicating with\nthat resource.\"\n\nCheers,\n-g\n\np.s. note that, in the example below, Apache doesn't handle OPTIONS well at\n     all. I consider it a problem with Apache's *default* handling of\n     OPTIONS. mod_dav takes particular care to return the correct\n     information for resources under its control. I plan to fix the\n     defaulting handling in Apache 2.0.\n\nOn Fri, Feb 16, 2001 at 09:59:51PM -0500, Jason Crawford wrote:\n> \n> \n> \n> See Kevin's note below.\n> \n> Does anyone have a client that depends on individual resource (including\n> null resources) to return different values for the OPTIONS method?\n> \n> Does anyone have a client that has *any* expectations for what the OPTIONS\n> method returns that might be URI specific or that alternately assumes that\n> what is true for one resource is true for some others?\n> \n> Does anyone have a server that would be unduly burdened by needing to\n> return URI specific results to OPTIONS requests?\n> \n> I'll modify the spec accordingly, but I need people to speak up if they\n> would be negatively impacted if the spec took any particular stance on\n> this.   (If your answer to this is that you don't use OPTIONS, then just\n> reply to me directly and I'll sumarize for later.)\n> \n> Thanks,\n> \n> J.\n> \n> \n> \n> \"Kevin Wiggen\" <wiggs@wiggenout.com> (by way of \"Ralph R. Swick\"\n> <swick@w3.org>)@w3.org on 02/15/2001 12:49:18 AM\n> \n> Sent by:  ietf-dav-versioning-request@w3.org\n> \n> \n> To:   ietf-dav-versioning@w3.org\n> cc:\n> Subject:  RE: OPTIONS\n> \n> \n> \n> [freed from spam trap -rrs]\n> \n>  Date: Wed, 14 Feb 2001 21:51:47 -0500 (EST)\n>  From: \"Kevin Wiggen\" <wiggs@wiggenout.com>\n>  To: \"John Stracke\" <francis@ecal.com>\n>  Cc: <w3c-dist-auth-request@w3.org>, <ietf-dav-versioning@w3.org>\n>  Message-ID: <ONEOJMKKAIDAGPLOPJEDOEFGCMAA.wiggs@wiggenout.com>\n>  Subject: [Moderator Action] RE: OPTIONS\n> \n> The real question on OPTIONS is now, should a server be sending back a\n> different OPTIONS answer per resource.  In other words, does a server look\n> at the resource that has been requested and answer appropriately.  I am\n> CCing the DeltaV group as I have been told this is exactly what they are\n> proposing.\n> \n> Thus an \"intelligent\" options request could look that a resource is not a\n> directory and thus return:\n> Allow: GET, HEAD, POST, OPTIONS, TRACE, PROPFIND, COPY, SEARCH, PROPPATCH,\n> LOCK, UNLOCK, PUT, DELELTE, MOVE\n> \n> notice no MKCOL\n> \n> If we are going to make OPTIONS useful to all clients, 2518 should define\n> it\n> a MUST for a server to return an intelligent OPTIONS response, otherwise a\n> client will never be able to depend on the information.\n> \n> Some Apache Examples:\n> OPTIONS on any resource (existent or not) on Apache returns a 200 with a\n> Allow: GET, HEAD, OPTIONS, TRACE\n> \n> Thus one could argue that following suit, a Webdav server for any resource\n> (existent or not) could respond: Allow: GET, HEAD, POST, OPTIONS, TRACE,\n> PROPFIND, COPY, SEARCH, PROPPATCH, LOCK, UNLOCK, MKCOL, PUT, DELETE, MOVE\n> \n> Should Webdav 2518 state that a server MUST not do the above but\n> intelligently respond to an OPTIONS request?\n> \n> If servers are then required to respond intelligently, what does that mean?\n> Does an OPTIONS to a non-existent resource without a parent simply return:\n> Allow:  OPTIONS\n> \n> Kevin\n> \n> \n> -----Original Message-----\n> From: w3c-dist-auth-request@w3.org\n> [mailto:w3c-dist-auth-request@w3.org]On Behalf Of John Stracke\n> Sent: Wednesday, February 14, 2001 8:00 AM\n> To: w3c-dist-auth@w3.org\n> Subject: Re: OPTIONS\n> \n> \n> Kevin Wiggen wrote:\n> \n> > 1)  /foo is a directory with no contents.\n> >     OPTIONS to /foo returns a 200 with the appropriate headers\n> >     OPTIONS to /foo/bar returns??  200 or 404??\n> >     OPTIONS to /foo/bar/fee returns a 404\n> \n> [...]\n> \n> > Since OPTIONS\n> > in 2068\n> \n> (Side note: you want 2616, which obsoletes 2068.)\n> \n> > states \"the OPTIONS request applies only to the options that are\n> > available when communicating with that resource.\"  Thus to get a 200\n> > response a resource must exist!!!\n> \n> Well, let's see.  Consider PUT, for example; obviously, you can PUT to a\n> resource which does not exist (in the sense that GET would return 404).\n> Therefore, it is useful for OPTIONS to be able to tell you that PUT is\n> allowed\n> on that resource.\n> \n> <tries stuff>...OK, let's see.  Running against Apache, if I do OPTIONS\n> against\n> a non-existent resource (in a non-existent directory), I get a 200, with\n> the\n> expected data.  GET against the same resource returns 404; SMURF against\n> that\n> resource returns 405.\n> \n> To me, this seems reasonable.  I believe that *all* resources exist.  A\n> resource is an object whose methods are HTTP methods; you can issue an HTTP\n> method against any Request-URI in the server's namespace; the server will\n> respond.  By definition, the response is the result of that object's\n> method.\n> Therefore, there is an object named by that Request-URI.  Note that 2616,\n> section 10.4.5, defines 404 as meaning, \"The server has not found anything\n> matching the Request-URI\".  This is *not* the same as saying that the\n> specified\n> resource does not exist.\n> \n> --\n> /==============================================================\\\n> |John Stracke    | http://www.ecal.com |My opinions are my own.|\n> |Chief Scientist |=============================================|\n> |eCal Corp.      |\"Call me a Nervous Nellie, but I am concerned|\n> |francis@ecal.com|about the sale of nuclear arms in my general |\n> |                |neighborhood.\" -- Dave Barry                 |\n> \\==============================================================/\n> \n> \n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8706983"}, {"subject": "BASELINE optio", "content": "Hi Geoff,\nit seems you also made some changes in baselines for draft 13.\nI think it's clearer now. Nevertheless some questions.\nWhen asked a while ago about the difference between version controlled\ncollections and baselines you told me that baselines are a depth 1 thing.\nIf I understood that correctly this would mean that a baseline doesn't\ncapture states of collections and their contents recursively.\nOn the other hand I learned at one time that \"member of collection\" means\n\"normal\" and collection members.\nSo it's not clear to me what you mean here.\nBTW, I use baselines which don't catch collection members. If I want them in my\nbaseline I add them as a subbaseline. Also baselines only exist in the context of\na workspace in my system. So a subbaseline can be identified by it's relative path\nfrom workspace root.\nAs a remark, I'm still not sure why we need the terms \"configuration\" and \"baseline\".\nIsn't a baseline just a version of a configuration ?\nYou argue correctly that a baseline is efficient by containing just version\nand path of the resources it contains.\nThe same is valid for subbaselines. Imagine a medium sized baseline containing\n1000 resources.\nNow you need a bugfix in one resource. You create a new baseline of the configuration\nduplicating 999 entries from the predecessor.\nCompare this with a baseline containing e.g. 10 subbaselines containing 100 resources.\nIf you change a resoure in a subbaseline you get a new version containing\n99 duplicated entries and a new one. I addition you have to update the super baseline\ncontaining 9 old and 1 new entries. A long way to the 1000 new data items you\nget with a single unstructured baseline.\nAnd now imagine how cheap new baselines will become if you work on a lightly \nbigger configuration containing 10000 resources e.g. containing 10 subbaselines\nwith 1000 resources each, compared to a \"simple\" baseline.\nIn 12.2.1 (DAV:subbaseline-set) you write: \"A server MAY reject attempts to modify\nthe DAV:subbaseline-set of a checked out configuration\"\nMy interpretation of this statement is, that a server understanding BASELINE at least\nmust know about checking out subbaselines. This sounds plausible. Because if not\nit couldn't work with any baseline containing subbaselines.\nIf that's right some comments:\nIt MAY reject modifying the subbaseline-set. But probably it can change some\nresources and create a new baseline containing the old subbaselines ?\nSo it already has to know a lot about subaselines, but can't do all with them.\nBut not much is missing here. This can be confusing.\nI think make the whole subbaseline stuff optional or remove the MAY sentence.\n\nCheers, Edgar\n\n\n\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Native Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-8723399"}, {"subject": "Re (3): possible new property", "content": "> > > Without the property mentioned above, it would be very\n> > > difficult to figure out where to go in a baseline to\n> > > find the matching resource.\n> >\n> > What does 'where to go in a baseline' mean?\n> > Can I assume you mean the DAV:baseline-collection?\n> \n> I still think 'where to go in a baseline' is a strange expression, but I\n> know what you mean now<g>\n> \n> Tim\nSorry, I'm still baffled. Greg, could you take a new shot at stating your problem ?\nI guess you want to say that the client has too much to do for some action.\nCould you give an example scenario from where the client starts and what it\nwants to achieve ?\n\nCheers, Edgar\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Native Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-8733174"}, {"subject": "RE: OPTION", "content": "> Just go read S9.2 of RFC 2616: \"... request for information ... on the\n> request/response chain identified by the Request-URI.\" and \"If the\n> Request-URI is not an asterisk, ... applies only ... when\n> communicating with\n> that resource.\"\n>\n\nI concur -- it's pretty clear that OPTIONS in HTTP/1.1 is per-resource,\nunless the Request-URI is \"*\".  It's fairly typical for Web servers to have\ndifferent capabilities in different parts of their namespace.\n\nNote that this doesn't necessarily mean that a server must perform a query\nfor each OPTIONS request -- you could, for example, have OPTIONS code that\nhandles a portion of the namespace.  DeltaV could also add some constraints\nas well, such as, if you support VERSION-CONTROL at one level of a namespace\nhierarchy, all sub-collections also must support VERSION-CONTROL.  So, this\nwould allow clients to avoid sending some kinds of OPTIONS requests, if\nefficiency is a concern.\n\n- Jim\n\n\n\n", "id": "lists-006-8740495"}, {"subject": "Thank you Geoff", "content": "I just wanted to publically thank Geoff Clemm for his recent heroic efforts\nto read and evaluate all of the recent comments sent to the DeltaV list, and\nmake changes to the DeltaV protocol specification based on them.\n\nHaving been on the other side in the past, I know how much work this is, and\nhow thankless it can seem at times.  The phrase, \"no good deed goes\nunpunished,\" seems particularly apt: produce a new draft, and get more\ncomments!\n\nSo, thank you Geoff, for your hard work and dedication -- I very much\nappreciate it.\n\n- Jim\n\n\n\n", "id": "lists-006-8748111"}, {"subject": "Re: possible new property", "content": "Scenario:\n\n    I have a large tree (/B/), with a lot of content, under baseline\n    control. The client desires to fetch a component of it (/B/C1/C2/C3/).\n    To ensure that a consistent baseline is fetched, the client wants to\n    move from .../C3/ over to the baseline-collection and fetch from there\n    (/BCs/b42/C1/C2/C3).\n\n    How does it get from C3 to /BCs/b42/C1/C2/C3/ ?\n\n\nGetting from C3 to /BCs/b42/ is a single REPORT. Locating C3 is difficult.\nWith a property [on /B/C1/C2/C3/] that returned \"C1/C2/C3/\", it would be a\nsnap.\n\nAn alternative is to have a DAV:href directly from the VCR to the specific\ncollection within BC.\n\nIn my scenario, I prefer the relative path because there are situations\nwhere the client says \"get C3 from baseline FOO\". It is acceptable for\nFOO:C3 to be different (i.e. different version history) than CURRENT:C3\nbecause it is the *path* to C3 that is the input to the operation. It is\nalso acceptable for FOO:C3 to simply not exist.\n\nCheers,\n-g\n\nOn Fri, Feb 16, 2001 at 03:52:36AM -0800, Greg Stein wrote:\n> For VCRs that are under baseline control, I propose that we add a new\n> property that specifies their relative path to the \"root\" of the baseline,\n> where the root is defined by the baseline's DAV:baseline-collection\n> property.\n> \n> [ hmm. just noticed something: that property assumes the baseline is not\n>   disjoint. fixing that is \"out of scope\" of this message :-) ]\n> \n> \n> Without the property mentioned above, it would be very difficult to figure\n> out where to go in a baseline to find the matching resource. Specifically,\n> the algorithm would be something like:\n> \n> 1) for a resource \"R\", get the DAV:version-controlled-configuration\n>    property from the resource (if a collection) or its parent\n> 2) get the DAV:checked-in property of the VCC to get the baseline\n> 3) get the DAV:baseline-collection property from the baseline\n> 4) get the DAV:version-history property of the resource at the root of the\n>    baseline-collection\n> 5) starting at R, set \"current\" to R, then:\n>    -) fetch the DAV:version-history of \"current\"\n>    -) if it matches the VH from the baseline-collection, then exit loop\n>    -) set \"current\" to parent of \"current\". loop.\n> 6) use the relative path between \"current\" and R to move downwards within\n>    the baseline-collection\n> \n> Steps 4 and 5 just disappear if the baseline-relative-path property is\n> present on the VCR.\n> (note that steps 1, 2, and 3 are a single expand-property report; step 6 is\n>  just URL construction -- there is no server request)\n> \n> With the property, we have a single REPORT. (to fetch the relative path, and\n> to expand thru the VCC and the baseline to the baseline-collection)\n> \n> Without the property, we have a REPORT plus N additional requests.\n> \n> Note that we can also use the relative path to (hopefully) access other\n> baselines. Presuming the \"current\" baseline defined by the VCC isn't too far\n> different from the target baseline, the path will still apply.\n> \n> Any thoughts?\n> \n> Cheers,\n> -g\n> \n> -- \n> Greg Stein, http://www.lyra.org/\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8755565"}, {"subject": "disjoint baseline", "content": "Consider that I have two resources:\n\n    /non-vcr-1/vcr-a/foo\n    /non-vcr-2/vcr-b/bar\n\nI put both of these resources under baseline control and create a baseline\nfrom them. What does the DAV:baseline-collection collection look like? Does\nit include \"filler\" collections to reach the VCRs that are under baseline\ncontrol?\n\nConcretely, would it look something like:\n\n    /BCs/b72/non-vcr-1/vcr-a/foo\n    /BCs/b72/non-vcr-2/vcr-b/bar\n\nAnd would non-vcr-* contain *only* the children necessary to reach the\nbaselined values? Same applies to \"/\" -- does it contain just non-vcr-*, or\nwould /BCs/b72/ contain other bindings?\n\n[ this doesn't apply in the Subversion scenario, so I'm not personally\n  worried, but it appears to be a \"hole\" in the draft. ]\n\nNote that my property proposal would resolve the situation. Each VCR under\nbaseline control would have a path to its corresponding VCR in the BC. Thus,\nthe BC could look like:\n\n    /BCs/b72/1/vcr-a/foo\n    /BCs/b72/2/vcr-b/bar\n\n(i.e. \"1\" and \"2\" are computed as a way to differentiate each disjoint set\nof resources)\n\nThe paths attached to the \"public\" VCRs would be:\n\n    /non-vcr-1/       n/a\n      vcr-a/          \"1/vcr-a\"\n        foo           \"1/vcr-a/foo\"\n      vcr-b/          \"1/vcr-b\"\n        bar           \"1/vcr-b/bar\"\n\n\nHmm. Actually, to be pedantic, I only put two resources under baseline\ncontrol. The BC would thus look like:\n\n    /BCs/b72/1/foo\n    /BCs/b72/2/bar\n\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8765601"}, {"subject": "Re: possible new property", "content": "On Fri, Feb 16, 2001 at 01:16:49PM +0000, Tim_Ellison@uk.ibm.com wrote:\n>...\n> If I understand this correctly, you mean find the relative path from the\n> baseline-controlled collection to R.\n\nActually, the want the relative path within the DAV:baseline-collection (BC)\nto the VCR that corresponds to R.\n\n> The baseline-collection may not in general have a version-history since it\n> may not be a checked-in version-controlled collection (i.e., it may be\n> baselined and not versioned).\n\nNot sure that I understand this part. Maybe this refers to the situation\nthat I just described regarding \"disjoint\" baselines? i.e. we may have some\n\"filler\" collections to reach the VCRs within the BC.\n\nHmm. Rereading: are you saying that there may be non-versioned resources\n(say, parents of \"public\" VCRs) that are within the baseline? That doesn't\nmake sense to me. A baseline captures versions of resources. Thus, you can't\nhave unversioned resources within a baseline.\n\n> Why not use the relative path you walked in step (1) above when finding the\n> DAV:version-controlled-configuration property in step (6), and discard step\n> (5) altogether?\n\nIf I'm given the URL abspath of \"/A/B/C/D/E/F/\", then what is \"the relative\npath\" and what is the \"base\" that will correspond to the root of the BC?\nWithout walking up that tree comparing version histories, I cannot tell.\n\n> > 6) use the relative path between \"current\" and R to\n> > move downwards within the baseline-collection\n> \n> However, I think you'd have to do a top down search through the\n> DAV:baseline-collection for the matching history resource as R because the\n> namespace may have been 'messed up' and the VCR corresponding to R could be\n> in a different spot (heuristically you could look along the same path as\n> the baseline controled collection...)\n\nIf I'm within the BC corresponding to the DAV:checked-in value of the\nversion-controlled collection, then your comment does not apply. The\nrelative paths must match since the public tree (containing R) is synonymous\nwith the BC.\n[ hmm. maybe not quite. I guess you could have checked out the public tree\n  and begun to make changes before making another baseline. ]\n\nIf I move to a BC corresponding to a different baseline, then yes: I'd need\nan exhaustive search to locate the matching VH.\n\n> > Steps 4 and 5 just disappear if the baseline-relative-path\n> > property is present on the VCR.\n> \n> Agreed.  However, the same VCR could be baselined in numerous baselines and\n> the relative paths would not be the same.\n\nAgreed, but I'm only considering the \"current\" baseline (the DAV:checked-in\nvalue of the VCC).\n\n>...\n> > Note that we can also use the relative path to (hopefully)\n> > access other baselines. Presuming the \"current\" baseline\n> > defined by the VCC isn't too far different from the target\n> > baseline, the path will still apply.\n> \n> Hmm, I'd be reluctant to introduce a property whose value has a sense of\n> probability.\n\nThat's just a side benefit that I'm looking for. It is an effect of the\ndefinition, rather than a requirement.\n\nActually, the bigger problem with relative path appears to be the case where\nthe public VCRs may have been rearranged since the last baseline was\ncreated. But that might still be okay since the relative-public-path does\nnot have to equal relative-BC-path.\n\n[ wow. I just noticed that an UPDATE on the VCC can totally stomp all over\n  changes within the public area ]\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8773714"}, {"subject": "Re: BASELINE optio", "content": "On Sat, Feb 17, 2001 at 03:05:14PM -0500, Edgar@edgarschwarz.de wrote:\n>...\n> When asked a while ago about the difference between version controlled\n> collections and baselines you told me that baselines are a depth 1 thing.\n\nA version-controlled collection (VCC) is a VCR that refers to a baseline\nfrom its DAV:checked-in value.\n\nConceptually, a baseline is simply an unordered, unstructured *set* of hrefs\nto version resources. (depth doesn't really apply: baselines are member\nresources rather than collections)\n\n> If I understood that correctly this would mean that a baseline doesn't\n> capture states of collections and their contents recursively.\n\nIf your collections are versioned, then it certainly does capture their\nstate. Even though the baseline itself is unstructured, you can \"reassemble\"\nthe collections by examination of the DAV:version-controlled-binding-set\nproperties of the collection versions found in the baseline.\n\nLet's say that your baseline has { CV1, V2, V3, V4 } in it. CV1 is a\ncollection version; the others are regular version resources. To reassemble\nthese into a tree, you would fetch the binding-set and the version histories\nfrom the resources:\n\n    Resource  History  Binding-set\n    --------  -------  --------------\n    CV1       H1       { H2, H3, H4 }\n    V2        H2       n/a\n    V3        H3       n/a\n    V4        H4       n/a\n\nAs you can see, the members of CV1 are V2, V3, and V4, by matching up the\nversion histories.\n\nThe above is just the conceptual model. It is actually much easier to see\nthe relationship by simply going to the DAV:baseline-collection of the\nbaseline. That is a set of VCRs that are already arranged for you.\n\n>...\n> BTW, I use baselines which don't catch collection members. If I want them in my\n> baseline I add them as a subbaseline. Also baselines only exist in the context of\n> a workspace in my system. So a subbaseline can be identified by it's relative path\n> from workspace root.\n\nThis is one way to do it. A lot of baselines, but acceptable.\n\n> As a remark, I'm still not sure why we need the terms \"configuration\" and \"baseline\".\n> Isn't a baseline just a version of a configuration ?\n\nI'm not a terminology guy. I'll leave this to somebody else.\n\n> You argue correctly that a baseline is efficient by containing just version\n> and path of the resources it contains.\n\nNope. Just versions. No paths.\n\n> The same is valid for subbaselines. Imagine a medium sized baseline containing\n> 1000 resources.\n> Now you need a bugfix in one resource. You create a new baseline of the configuration\n> duplicating 999 entries from the predecessor.\n\nUntrue. That is an *implementation* detail. Nobody said that you must store\nthe set of versions this way. As a matter of fact, there is no way to\n*retrieve* the set of versions, thus no reason to ever truly keep a copy of\nthem around.\n\nTo query the set of versions, you must walk over the DAV:baseline-collection\nand fetch the DAV:checked-in values.\n\n[ as a counter-point: Subversion doesn't store anything when you \"create\" a\n  new baseline. baselines are synthesized at request time from information\n  within the repository. even then, we only synthesize a portion of the\n  DAV:baseline-collection. even better: it is a very lightweight operation\n  since the repository is logically organized as a set of baselines.\n  concretely, each baseline is merely a diff against the previous baseline ]\n\n>...\n> In 12.2.1 (DAV:subbaseline-set) you write: \"A server MAY reject attempts to modify\n> the DAV:subbaseline-set of a checked out configuration\"\n\nThis is because a server may not support subbaselines, so this is how it\nprevents clients from using the feature.\n\n> My interpretation of this statement is, that a server understanding BASELINE at least\n> must know about checking out subbaselines.\n\nIf you can't set the subbaseline-set, then the client can never create\nsubbaselines. Thus, any subbaselines that exist are due entirely to the\nserver's operation. If it is creating them, then yes: it must fully support\nthem, including checking them out.\n\n> This sounds plausible. Because if not\n> it couldn't work with any baseline containing subbaselines.\n> If that's right some comments:\n> It MAY reject modifying the subbaseline-set. But probably it can change some\n> resources and create a new baseline containing the old subbaselines ?\n> So it already has to know a lot about subaselines, but can't do all with them.\n> But not much is missing here. This can be confusing.\n> I think make the whole subbaseline stuff optional or remove the MAY sentence.\n\nSplitting subbaselines out into another option would be too complicated. It\nis much easier to cut it all off with a simple \"MAY\" sentence in 12.2.1.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8784286"}, {"subject": "Re: Thank you Geoff", "content": "> So, thank you Geoff, for your hard work and dedication -- I very much\n> appreciate it.\n> \n\nI fully second this sentiment!\n\n\n\n", "id": "lists-006-8796011"}, {"subject": "Re: disjoint baseline", "content": "> Consider that I have two resources:\n>\n>     /non-vcr-1/vcr-a/foo\n>     /non-vcr-2/vcr-b/bar\n\nAssuming foo and bar are VCRs themselves.\n\n> I put both of these resources under baseline control and\n> create a baseline from them. What does the DAV:baseline-collection\n> collection look like? Does it include \"filler\" collections to\n> reach the VCRs that are under baseline control?\n>\n> Concretely, would it look something like:\n>\n>     /BCs/b72/non-vcr-1/vcr-a/foo\n>     /BCs/b72/non-vcr-2/vcr-b/bar\n\nYes, this is required for the baseline to capture the namespace of the\nconfiguration.\n\n> And would non-vcr-* contain *only* the children necessary to reach the\nbaselined values?\n\nI'm planning on 'yes', otherwise these would be empty, filler collections\n-- not very useful.\n\n> Same applies to \"/\" -- does it contain just non-vcr-*, or would\n> /BCs/b72/ contain other bindings?\n\nonly those that were required to reach VCRs.\n\n> [ this doesn't apply in the Subversion scenario, so I'm not\n> personally worried, but it appears to be a \"hole\" in the draft. ]\n>\n> Note that my property proposal would resolve the situation. Each\n> VCR under baseline control would have a path to its corresponding\n> VCR in the BC.\n\nAgreed.  Though I've not figured out yet how the proposed property works\nwhen the VCR is a member of multiple baseline-controlled collections.\n\n>  Thus, the BC could look like:\n>\n>     /BCs/b72/1/vcr-a/foo\n>     /BCs/b72/2/vcr-b/bar\n>\n> (i.e. \"1\" and \"2\" are computed as a way to differentiate each\n> disjoint set of resources)\n\nIt is an important property of baselines that they capture the namespace of\nthe configuration, so collapsing the namespace this way into the 'disjoint\nsets' would be a Bad Thing.\n\n> The paths attached to the \"public\" VCRs would be:\n>\n>     /non-vcr-1/       n/a\n>       vcr-a/          \"1/vcr-a\"\n>         foo           \"1/vcr-a/foo\"\n>       vcr-b/          \"1/vcr-b\"\n>         bar           \"1/vcr-b/bar\"\n>\n>\n> Hmm. Actually, to be pedantic, I only put two resources under\n> baseline control. The BC would thus look like:\n>\n>     /BCs/b72/1/foo\n>     /BCs/b72/2/bar\n\nTwo resources?  Then I assume the two resources that you put under baseline\ncontrol are 'vcr-a' and 'vcr-b', so the BC would look like this:\n               /BCsb72/foo\n               /BCs/b88/bar\n\n\nTim\n\n\n\n", "id": "lists-006-8802956"}, {"subject": "Re: BASELINE optio", "content": "> Hi Geoff,\n> it seems you also made some changes in baselines for draft 13.\n> I think it's clearer now. Nevertheless some questions.\n> When asked a while ago about the difference between version controlled\n> collections and baselines you told me that baselines are a depth 1 thing.\n> If I understood that correctly this would mean that a baseline doesn't\n> capture states of collections and their contents recursively.\n\nNo, baselines *do* capture the deep versioned state of a collection (i.e.,\na configuration), but a baseline resource _itself_ is not a collection.\nThis must be what Geoff meant by 'baselines are a depth 1 thing' (actually\ndepth 0).\n\n> On the other hand I learned at one time that \"member of collection\" means\n> \"normal\" and collection members.\n\nRead this sentence a couple of times, but couldn't figure it out.\n\n> So it's not clear to me what you mean here.\n> BTW, I use baselines which don't catch collection members. If I want them\nin my\n> baseline I add them as a subbaseline.\n\nIt is an important part of baselines that they represent the deep versioned\nstate of a collection.  Baselines are 'prerequisite dependencies' on the\nbaseline.\n\n> Also baselines only exist in the context of\n> a workspace in my system. So a subbaseline can be identified by it's\nrelative path\n> from workspace root.\n\n> As a remark, I'm still not sure why we need the terms \"configuration\" and\n\"baseline\".\n> Isn't a baseline just a version of a configuration ?\n\nThere you go, that simple definition is a good reason for the term!\n\n> You argue correctly that a baseline is efficient by containing just\nversion\n> and path of the resources it contains.\n> The same is valid for subbaselines.\n\nSubbaselines are just baselines.  All the characteristics (and no more) of\na baseline are true for subbaselines.\n\n> Imagine a medium sized baseline containing\n> 1000 resources.\n> Now you need a bugfix in one resource. You create a new baseline of the\nconfiguration\n> duplicating 999 entries from the predecessor.\n> Compare this with a baseline containing e.g. 10 subbaselines containing\n100 resources.\n> If you change a resoure in a subbaseline you get a new version containing\n> 99 duplicated entries and a new one. I addition you have to update the\nsuper baseline\n> containing 9 old and 1 new entries. A long way to the 1000 new data items\nyou\n> get with a single unstructured baseline.\n\nYep, though most people would implement a single baseline as deltas too.\nBut your observation is valid.\n\n> And now imagine how cheap new baselines will become if you work on a\nlightly\n> bigger configuration containing 10000 resources e.g. containing 10\nsubbaselines\n> with 1000 resources each, compared to a \"simple\" baseline.\n\n> In 12.2.1 (DAV:subbaseline-set) you write: \"A server MAY reject attempts\nto modify\n> the DAV:subbaseline-set of a checked out configuration\"\n> My interpretation of this statement is, that a server understanding\nBASELINE at least\n> must know about checking out subbaselines.\n\nAgain, subbaselines are baselines.  This MAY clause is because there are\n(heavy?) semantics for changing the value of the DAV:subbaseline-set, i.e.,\nensuring that there is only once VCR per history in the resulting\ncombo-baseline.\n\n> This sounds plausible. Because if not\n> it couldn't work with any baseline containing subbaselines.\n> If that's right some comments:\n> It MAY reject modifying the subbaseline-set. But probably it can change\nsome\n> resources and create a new baseline containing the old subbaselines ?\n> So it already has to know a lot about subaselines, but can't do all with\nthem.\n> But not much is missing here. This can be confusing.\n> I think make the whole subbaseline stuff optional or remove the MAY\nsentence.\n\nMaking this one property optionally mutable does make 'the whole\nsubbaseline stuff optional'.\n\n\nTim\n\n\n\n", "id": "lists-006-8812529"}, {"subject": "Re: possible new property", "content": "> > ...\n> > If I understand this correctly, you mean find the relative path from\nthe\n> > baseline-controlled collection to R.\n>\n> Actually, the want the relative path within the DAV:baseline-collection\n(BC)\n> to the VCR that corresponds to R.\n\nI understand this is the goal, but my comment was in context of step (5) of\nthe algorithm that was trying to find the relative path within the\nbaseline-controlled collection.  So we agree.\n\n> > The baseline-collection may not in general have a version-history since\nit\n> > may not be a checked-in version-controlled collection (i.e., it may be\n> > baselined and not versioned).\n>\n> Not sure that I understand this part. Maybe this refers to the situation\n> that I just described regarding \"disjoint\" baselines? i.e. we may have\nsome\n> \"filler\" collections to reach the VCRs within the BC.\n\nPrecisely, just to note that you can baseline-control any collection, not\njust a version-controlled collection.\n\n> Hmm. Rereading: are you saying that there may be non-versioned resources\n> (say, parents of \"public\" VCRs) that are within the baseline? That\ndoesn't\n> make sense to me. A baseline captures versions of resources. Thus, you\ncan't\n> have unversioned resources within a baseline.\n\nBut you have to have these filler collection to capture the namespace, and\nthese need not be VCRs.  So yes, you can have unversioned resources within\na baseline that have no (direct) corresponding resource in normal URL\nspace.\n\n> > Why not use the relative path you walked in step (1) above when finding\nthe\n> > DAV:version-controlled-configuration property in step (6), and discard\nstep\n> > (5) altogether?\n>\n> If I'm given the URL abspath of \"/A/B/C/D/E/F/\", then what is \"the\nrelative\n> path\" and what is the \"base\" that will correspond to the root of the BC?\n> Without walking up that tree comparing version histories, I cannot tell.\n\nYou described in already as step (1):\n> 1) for a resource \"R\", get the DAV:version-controlled-\n> configuration property from the resource (if a collection)\n> or its parent\n\ni.e., look upwards for the first occurance of a\nDAV:version-controlled-configuration property, the collection that you\nfound that property on becomes the base, and the path you walked to get to\nit is the relative path (inverted!).\n\n> > > 6) use the relative path between \"current\" and R to\n> > > move downwards within the baseline-collection\n> >\n> > However, I think you'd have to do a top down search through the\n> > DAV:baseline-collection for the matching history resource as R because\nthe\n> > namespace may have been 'messed up' and the VCR corresponding to R\ncould be\n> > in a different spot (heuristically you could look along the same path\nas\n> > the baseline controled collection...)\n>\n> If I'm within the BC corresponding to the DAV:checked-in value of the\n> version-controlled collection, then your comment does not apply. The\n> relative paths must match since the public tree (containing R) is\nsynonymous\n> with the BC.\n> [ hmm. maybe not quite. I guess you could have checked out the public\ntree\n>   and begun to make changes before making another baseline. ]\n\nExactly, between baselines clients can restructure the tree with MOVEs etc.\nand 'mess it up'<g>.\nNow there is no correspondence between the URLs in the 'normal' namespace\nand those in the baseline namespace.  This of course is a good argument for\nyour proposed property.\n\nHowever, there is nothing to stop a client baselining /A/ aswell as /A/B/C/\nso what would be the value of the property for the VCR /A/B/C/D ?\n\n> If I move to a BC corresponding to a different baseline, then yes: I'd\nneed\n> an exhaustive search to locate the matching VH.\n\nI think you'd need to do this anyway unless the namespace was not 'messed\nup'.\n\n> > > Steps 4 and 5 just disappear if the baseline-relative-path\n> > > property is present on the VCR.\n> >\n> > Agreed.  However, the same VCR could be baselined in numerous baselines\nand\n> > the relative paths would not be the same.\n>\n> Agreed, but I'm only considering the \"current\" baseline (the\nDAV:checked-in\n> value of the VCC).\n\nI meant numerous baseline scopes rather than numerous baseline versions.\n\n> >...\n> > > Note that we can also use the relative path to (hopefully)\n> > > access other baselines. Presuming the \"current\" baseline\n> > > defined by the VCC isn't too far different from the target\n> > > baseline, the path will still apply.\n> >\n> > Hmm, I'd be reluctant to introduce a property whose value has a sense\nof\n> > probability.\n>\n> That's just a side benefit that I'm looking for. It is an effect of the\n> definition, rather than a requirement.\n\nack.\n\n> Actually, the bigger problem with relative path appears to be the case\nwhere\n> the public VCRs may have been rearranged since the last baseline was\n> created. But that might still be okay since the relative-public-path does\n> not have to equal relative-BC-path.\n>\n> [ wow. I just noticed that an UPDATE on the VCC can totally stomp all\nover\n>   changes within the public area ]\n\nAbsolutely, it is the way to roll-back to a previous configuration version.\n\nTim\n\n\n\n", "id": "lists-006-8823137"}, {"subject": "Re: possible new property", "content": "[ okay, I think I have an answer; see below. there are still a few open\n  questions, though, on other facets of baselines ]\n\nOn Sun, Feb 18, 2001 at 03:02:40PM +0000, Tim_Ellison@uk.ibm.com wrote:\n>...\n> > > Why not use the relative path you walked in step (1) above when finding the\n> > > DAV:version-controlled-configuration property in step (6), and discard step\n> > > (5) altogether?\n> >\n> > If I'm given the URL abspath of \"/A/B/C/D/E/F/\", then what is \"the relative\n> > path\" and what is the \"base\" that will correspond to the root of the BC?\n> > Without walking up that tree comparing version histories, I cannot tell.\n> \n> You described in already as step (1):\n> > 1) for a resource \"R\", get the DAV:version-controlled-\n> > configuration property from the resource (if a collection)\n> > or its parent\n> \n> i.e., look upwards for the first occurance of a\n> DAV:version-controlled-configuration property, the collection that you\n> found that property on becomes the base, and the path you walked to get to\n> it is the relative path (inverted!).\n\nThis is the disconnect.\n\nI've envisioned *every* collection in my \"public space\" to have this\nproperty, all pointing at the same VCC. Each of those VCRs is being\ncontrolled by a baseline, so each has the property.\n\nIf I need to scan upwards to find the thing, then yes: I'd agree that *that*\nscan would accomplish (nearly?) the same task as a property.\n\nBut I don't see anywhere that says that some arbitrary root of the public\nspace is the only thing with that property. All the collections are\ncontrolled.\n\n>...\n> > [ hmm. maybe not quite. I guess you could have checked out the public tree\n> >   and begun to make changes before making another baseline. ]\n> \n> Exactly, between baselines clients can restructure the tree with MOVEs etc.\n> and 'mess it up'<g>.\n> Now there is no correspondence between the URLs in the 'normal' namespace\n> and those in the baseline namespace.  This of course is a good argument for\n> your proposed property.\n> \n> However, there is nothing to stop a client baselining /A/ aswell as /A/B/C/\n> so what would be the value of the property for the VCR /A/B/C/D ?\n\nHadn't thought of that, since (in my little world) clients cannot create\narbitrary baselines like this.\n\nAlthough... I'd have to say that you couldn't have /A/ *and* /A/B/C/ both\nunder baseline control. Wouldn't they conflict with each other? ... Oh wait.\nYou're talking about creating a baseline; not necessarily using the two\nbaselines for controlling /A/ and /A/B/C.\n\nHmm. Yes, this would pose a problem. A given version-history can appear in\nmultiple baselines. Thus, any property along these lines would need to have\na mapping of baseline-to-path.\n\n> > If I move to a BC corresponding to a different baseline, then yes: I'd need\n> > an exhaustive search to locate the matching VH.\n> \n> I think you'd need to do this anyway unless the namespace was not 'messed\n> up'.\n\nIn my use-case, no. In general, I just remembered the DAV:locate-history\nREPORT.\n\nIn fact, maybe that is my answer: forget the property and depend upon using\nDAV:locate-history on the BC. It solves each of the problems above.\n\nHunh. I believe that I can live with that one. Seem reasonable?\n\n>...\n> > [ wow. I just noticed that an UPDATE on the VCC can totally stomp all over\n> >   changes within the public area ]\n> \n> Absolutely, it is the way to roll-back to a previous configuration version.\n\nWell, sure, but boy... talk about dangerous :-)\n\nIt might be nice to define a DAV:discouraged type of result if you try this\nand there are any checked-out resources in the baseline-controlled\ncollection.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8835730"}, {"subject": "Re: disjoint baseline", "content": "On Sun, Feb 18, 2001 at 02:39:49PM +0000, Tim_Ellison@uk.ibm.com wrote:\n> \n> > Consider that I have two resources:\n> >\n> >     /non-vcr-1/vcr-a/foo\n> >     /non-vcr-2/vcr-b/bar\n> \n> Assuming foo and bar are VCRs themselves.\n\nOf course :-)\n\n> > I put both of these resources under baseline control and\n> > create a baseline from them. What does the DAV:baseline-collection\n> > collection look like? Does it include \"filler\" collections to\n> > reach the VCRs that are under baseline control?\n> >\n> > Concretely, would it look something like:\n> >\n> >     /BCs/b72/non-vcr-1/vcr-a/foo\n> >     /BCs/b72/non-vcr-2/vcr-b/bar\n> \n> Yes, this is required for the baseline to capture the namespace of the\n> configuration.\n\nEuh. Baselines capture a set of versions. Who said they capture the layout\nof the namespace in which the VCRs appear?\n\nGiven my current understanding of baselines, I don't believe your statement\nnecessarily follows.\n\nOops. Reset. Somebody changed the definition on me in the past couple months\n:-) ... I just read the intro to the baseline section. \"... and their names\nrelative to the collection, ...\"\n\nSigh.\n\n> > And would non-vcr-* contain *only* the children necessary to reach the\n> baselined values?\n> \n> I'm planning on 'yes', otherwise these would be empty, filler collections\n> -- not very useful.\n\nAgreed.\n\n> > Same applies to \"/\" -- does it contain just non-vcr-*, or would\n> > /BCs/b72/ contain other bindings?\n> \n> only those that were required to reach VCRs.\n\nAgreed.\n\n> > [ this doesn't apply in the Subversion scenario, so I'm not\n> > personally worried, but it appears to be a \"hole\" in the draft. ]\n> >\n> > Note that my property proposal would resolve the situation. Each\n> > VCR under baseline control would have a path to its corresponding\n> > VCR in the BC.\n> \n> Agreed.  Though I've not figured out yet how the proposed property works\n> when the VCR is a member of multiple baseline-controlled collections.\n\nRight. I'm thinking: toss the property proposal, depend upon locate-history.\n\n>...\n> It is an important property of baselines that they capture the namespace of\n> the configuration, so collapsing the namespace this way into the 'disjoint\n> sets' would be a Bad Thing.\n\nSeeing the current definition of \"baseline\" ... I agree.\n\n\nOkay... so maybe I'll go write a FAQ entry -- non-versioned collections can\nappear in a BC as a way to reach the VCRs.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-8846568"}, {"subject": "Schedule information for Minneapolis IET", "content": "OK, the WebDAV and DeltaV working group meeting slots have been assigned in\nthe *Draft* schedule for the Minneapolis IETF.  At present, the meeting\nslots are:\n\nWebDAV: Thursday, March 22, 2001: 9AM-11:30AM\n\nDeltaV: Thursday, March 22, 2001: 3:30PM-5:30PM\n\nPlease note that the meeting days and times are subject to change (that's\nwhat \"Draft\" implies), although a change in day would be pretty atypical.\n\nThe entire Draft Agenda for the Minneapolis IETF can be found at:\n\nhttp://www.ietf.org/meetings/agenda_50.txt\n\nInformation on the Minneapolis IETF meeting, including registration, hotel,\nand venue information, can be found at:\n\nhttp://www.ietf.org/meetings/IETF-50.html\n\n- Jim\n\n\n\n", "id": "lists-006-8855871"}, {"subject": "Re: possible new property", "content": "> > i.e., look upwards for the first occurance of a\n> > DAV:version-controlled-configuration property, the collection that you\n> > found that property on becomes the base, and the path you walked to get\nto\n> > it is the relative path (inverted!).\n>\n> This is the disconnect.\n>\n> I've envisioned *every* collection in my \"public space\" to have this\n> property, all pointing at the same VCC. Each of those VCRs is being\n> controlled by a baseline, so each has the property.\n>\n> If I need to scan upwards to find the thing, then yes: I'd agree that\n*that*\n> scan would accomplish (nearly?) the same task as a property.\n>\n> But I don't see anywhere that says that some arbitrary root of the public\n> space is the only thing with that property. All the collections are\n> controlled.\n\nHardly arbitrary, it is the collection that was baseline controlled and is\nthe 'root' of the baseline.\nThis should be made explicit in the doc.\n\n<<snip>>\n\n> In fact, maybe that is my answer: forget the property and depend upon\nusing\n> DAV:locate-history on the BC. It solves each of the problems above.\n>\n> Hunh. I believe that I can live with that one. Seem reasonable?\n\nErr, yes.  Shoot, didn't think about the fact that the VCR could/will be in\nthe DAV:baseline-collection, so much for computing that property lazily :-(\n\n> >...\n> > > [ wow. I just noticed that an UPDATE on the VCC can totally stomp all\nover\n> > >   changes within the public area ]\n> >\n> > Absolutely, it is the way to roll-back to a previous configuration\nversion.\n>\n> Well, sure, but boy... talk about dangerous :-)\n>\n> It might be nice to define a DAV:discouraged type of result if you try\nthis\n> and there are any checked-out resources in the baseline-controlled\n> collection.\n\nAnyone else want this?\n\nTim\n\n\n\n", "id": "lists-006-8863393"}, {"subject": "Re (2): possible new property", "content": "> > > > [ wow. I just noticed that an UPDATE on the VCC can totally stomp all\n> over\n> > > >   changes within the public area ]\n> > >\n> > > Absolutely, it is the way to roll-back to a previous configuration\n> version.\n> >\n> > Well, sure, but boy... talk about dangerous :-)\n> >\n> > It might be nice to define a DAV:discouraged type of result if you try\n> this\n> > and there are any checked-out resources in the baseline-controlled\n> > collection.\n> \n> Anyone else want this?\nI would prefer the client to warn it's user that he's doing something dangerous\nin this case instead of adding to the protocol.\nAt least if it's not too difficult for the client to check.\n\nCheers, Edgar\n\n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Native Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-8871992"}, {"subject": "RE: object model and IDL for Delta-", "content": "Any chance you could produce IDL from the Rose model you're using or make\nthe Rose model available for the WebDAV object model?\n\n\n\n", "id": "lists-006-8879442"}, {"subject": "draft-ietf-deltav-versioning-14 has been submitted to ietf-draft", "content": "First an apology ... our IT staff turned off the mail address I had been\nusing for\nboth the deltav and webdav mailing lists a couple of weeks ago, which goes \na long way towards explaining why mail on the list has appeared so sparse\nthe last couple of weeks ... I still got a few messages that were explicitly\nCC'ed\nto me, which hid the fact of the email disconnect ... happily Jim Whitehead\nnoticed the bounces to my address, so I am now catching up ... looks like\nsome interesting threads got started!\n\nSo version 14 just has suggested changes that Chris Kaler mailed directly\nto me (i.e. improvements to the security section and moving REPORT\nback into core).  I didn't have time to post version 14 to the web site yet\n(in theory I'm on vacation all this week), but I'll get that done sometime\nearly next week.  \n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-8886916"}, {"subject": "RE: OPTION", "content": "<<\nI concur -- it's pretty clear that OPTIONS in HTTP/1.1 is per-resource,\nunless the Request-URI is \"*\".  It's fairly typical for Web servers to have\ndifferent capabilities in different parts of their namespace.\n>>\nSo do we want 2518 to say anything or leave this for HTTP/1.1?  It sounds\nto me that all the questions asked here about OPTIONS in the last two weeks\nare probably best left to the HTTP/1.1 spec.  (I just wish that spec said\nmore.)\n\nJ.\n\n\n\n", "id": "lists-006-8894445"}, {"subject": "Re: Comments on Baseline option (in 12.3", "content": "   From: Greg Stein <gstein@lyra.org>\n\n   On Mon, Feb 12, 2001 at 11:01:20AM -0800, Jim Whitehead wrote:\n\n   > >    6. Section 10.3.1 & Section 10.11 (DAV:baseline-collection)\n   > >    Since this is a protected and computed property,\n\n   > > (actually, I believe it is just a protected, not a computed,\n   > > property)\n\n   In Subversion, it is computed and protected.\n\nIn the versioning protocol, the term \"computed\" has a specific meaning\nwhen applied to a property value (section 1.4.3).  Basically, it says\nthat the property value is defined in terms of a specific computation,\nas opposed to being defined in the postconditions of the method that\nupdates it.  The DAV:baseline-collection is defined in the\npostconditions of the method that creates it (i.e. CHECKIN and\nBASELINE-CONTROL) and therefore DAV:baseline-collection is marked as\nbeing \"protected\" but not \"computed\".\n\nI did notice that the BASELINE-CONTROL method only indirectly defines\nthe DAV:baseline-collection property of the root baseline of a new\nbaseline history.  I'll fix this to be more explicit.\n\n   > Hmm, then this is another area that needs to be fleshed out.\n   > While a baseline is checked-out, the server automatically\n   > maintains the value of the baseline, right?  This would imply\n   > that at any time while a baseline is checked out, a client could\n   > read the value of the DAV:baseline-collection of the checked-out\n   > baseline, and receive an up-to-date, consistent baseline. Is this\n   > correct?\n\nA resource type has a given live property iff the protocol says that\nit does.  According to the protocol, only a baseline is defined as\nhaving a DAV:baseline-collection.  A working configuration (which is\nthe result of checking out a baseline) is not defined to have a\nDAV:baseline-collection, nor is a version-controlled configuration.\n\n   A checked-out baseline is exactly the same as the baseline referred\n   to by its DAV:checked-out property. Specifically, there isn't\n   anything that you can do with a working baseline to change its\n   contents. Consistency is implicit, so the DAV:baseline-collection\n   would continue to be valid.\n\nIf it had one, which it doesn't (:-).\n\n   A working baseline is good for storing new (dead) properties on a\n   baseline, but not much else.\n\nActually it is also good for setting the ever popular\nDAV:subbaseline-set property (:-).\n\n   The set of versions captured by a baseline are defined by a\n   relationship with a version-controlled configuration (VCC). A\n   working baseline does not have this relationship, so it cannot\n   affect the set of versions. Other \"stuff\" is needed. For example,\n   if you check out a baseline into an activity, then you can find a\n   version-controlled configuration at MERGE time by using the\n   DAV:version-controlled-configuration property of the merge target.\n\nYes.\n\n   [ there is also a way to create a baseline by checking out the VCC and\n     checking it back in -- it will snapshot the related\n     baseline-controlled-collection. ]\n\nYes.\n\n   > If so, then this sounds like a computed property to me.\n\nYes, by the standard English meaning of the term \"computed\", but not\nby the DeltaV definition (which is all about where to look in the\nspecification for the definition of the semantics of the property).\n\n   Well... the server always assigns it, and it will typically be constant\n   after that point.\n\nYes.\n\n   > Or is it that, when checked-out, there is no DAV:baseline-collection\n   > property, and then when checked-in, this property is created with the\n   > correct value?\n\nYes.\n\n   > Also, just to make sure I'm not really missing the boat -- the intent\nis\n   > that the client is not responsible for maintaining the value of\n   > DAV:baseline-collection property directly (i.e., by PROPPATCHing this\n   > property), right?\n\n   Correct. The server says \"over <there> is a URL namespace that looks like\n   the baseline-controlled-collection at the time the baseline was created.\"\n\nYes.\n\n   > > A version-controlled configuration does not have a\n   > > DAV:baseline-collection property, so I don't see that this\n   > > issue arises.  It is only a property of a baseline.\n\n   > This implies that the DAV:baseline-collection property does not\n   > exist when a baseline is in checked-out state.  Is that correct?\n\n   I think Geoff is mistaken here. Since a VCC is essentially a VCR, then it\n   should have all the properties of its DAV:checked-in value, which is a\n   baseline. Thus, it should have a DAV:baseline-collection property.\n\nOnly the dead properties of a VCR have the same values as the\ncorresponding properties of its DAV:checked-in version.  There are\nmany live properties of a version that do not appear on a VCR\n(DAV:successor-set, DAV:version-name, DAV:label-name-set, ...).\n\nA VCC is a VCR, so it has all the live properties of a VCR (since it\nis a VCR), but it is not a baseline, so it does not have all the\nlive properties of a baseline.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-8901948"}, {"subject": "Re: Overview of Core versionin", "content": "   From: Lisa Dusseault (lisa@xythos.com)\n\n   I've noticed that there is a \"rationale\" for versioning options,\n   but not for core versioning.  I think something is needed more than\n   the no-op definition of \"the set of stuff defined in section 3\".\n   Core is specific enough that we should be able to describe, in a\n   few brief paragraphs, precisely what it accomplishes.  Thus, I've\n   suggested some text which can serve as an introduction to, overview\n   of, and explanation of Core Versioning.  It's important to frame\n   and position technical requirements, because readers understand\n   technical specifications much better if they understand what its\n   for, and what it does, first.\n\nLisa: Sorry I didn't get to this in time for version 14, but I'll get\nthese changes made during the IESG last call period.\n\n   \"Core versioning\" is the set of properties and method semantics\n   defined by Section 3 of this document.  Core versioning serves to\n   establish a common model to organize and understand constructs\n   which exist on any versioning server.  Core versioning makes a\n   number of requirements on how servers must handle\n   version-controlled resources, so that clients have a reasonable\n   model for what effect a command will have.\n\n   Core versioning makes requirements on servers but not on\n   clients. The intent of this choice is that clients be able to rely\n   on a minimum level of functionality when they contact a\n   DeltaV-capable server. Since all HTTP actions are initiated by the\n   client, the server has no need to know a priori what functionality\n   the client supports. TO the extent to which the server needs to\n   know, the client can tell it in its requests.\n\nIn Yaron Golan's review, he vehemently objected to statements that are\ngenerically true for all HTTP protocol extensions.  I believe that the\nprevious paragraph suffers from this problem, i.e. these statements\nare true, but have nothing in particular to do with versioning.\n\nWhat do other folks think?\n\n   A server which implements Core Versioning can interoperate successfully\n   with a client which is completely ignorant of DeltaV. Unless the client\n   requests versioning functionality, a Core-compliant server will\n   automatically behave like an non-versioning WebDAV server. Thus, a\n   versioned resource automatically behaves in an unsurprising way when\n   operated upon by WebDAV or HTTP methods.\n\nYes, this definitely needs to be said!  I'll make this point in the\n\"Relationship to WebDAV\" section.\n\n   A client can use OPTIONS to find out if a server supports core\n   versioning.  If the server does support core versioning, the client can\n   then be assured that it can:\n\n    - Browse version-controlled resources and differentiate them from\n   non-versioned resources,\n\ngood\n\n    - Use VERSION-CONTROL method to put resources under version control,\n\ngood\n\n    - Browse past versions of version-controlled resources,\n\ngood\n\n    - View some basic information about these resources,\n\nthat seems a bit vague to me.\n\n    - Find out whether and how new versions will be created automatically\n   by the server (auto-version)\n\ngood\n\n    - Predict what effect HTTP/WebDAV operations will have on a given\n   resource with a given version history\n\nthat also seems a bit vague to me.\n\nIf nobody objects, I'll add this enumeration of core versioning\nfeatures to the Introduction.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-8914123"}, {"subject": "Design team meetings at IETF 5", "content": "Even though we've made it through a couple of last calls, and we're on the \npath to IETF last call and Proposed Standard, I'd still like to schedule \nsome design team meetings during IETF 50. How about 3-5pm on Wed to \nprepare for the Working Group meeting, 11-3pm on Thu for detailed \ndiscussions, and a 9-12 on Fri to followup on any post-Working Group \nissues?\n\n\n\n", "id": "lists-006-8924560"}, {"subject": "RE: Design team meetings at IETF 5", "content": "Those times work for me.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Amsden [mailto:jamsden@us.ibm.com]\nSent: Monday, February 26, 2001 11:14 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Design team meetings at IETF 50\n\n\n\nEven though we've made it through a couple of last calls, and we're on the\npath to IETF last call and Proposed Standard, I'd still like to schedule\nsome design team meetings during IETF 50. How about 3-5pm on Wed to prepare\nfor the Working Group meeting, 11-3pm on Thu for detailed discussions, and a\n9-12 on Fri to followup on any post-Working Group issues? \n\n\n\n", "id": "lists-006-8931855"}, {"subject": "RE: Design team meetings at IETF 5", "content": "I may have to leave a little early on Friday to make a flight.\n\nChris\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@rational.com] \nSent: Monday, February 26, 2001 9:08 AM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: Design team meetings at IETF 50\n\n\nThose times work for me.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Jim Amsden [mailto:jamsden@us.ibm.com]\nSent: Monday, February 26, 2001 11:14 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Design team meetings at IETF 50\n\n\n\nEven though we've made it through a couple of last calls, and we're on the\npath to IETF last call and Proposed Standard, I'd still like to schedule\nsome design team meetings during IETF 50. How about 3-5pm on Wed to prepare\nfor the Working Group meeting, 11-3pm on Thu for detailed discussions, and a\n9-12 on Fri to followup on any post-Working Group issues? \n\n\n\n", "id": "lists-006-8939893"}, {"subject": "I-D ACTION:draft-ietf-deltav-versioning-14.tx", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Web Versioning and Configuration Management Working Group of the IETF.\n\nTitle: Versioning Extensions to WebDAV\nAuthor(s): G. Clemm, J. Amsden, C. Kaler, J. Whitehead\nFilename: draft-ietf-deltav-versioning-14.txt\nPages: 98\nDate: 26-Feb-01\n\nThis document specifies a set of methods, headers, and resource types \nthat define the WebDAV Versioning extensions to the HTTP/1.1 protocol. \nWebDAV Versioning will minimize the complexity of clients that are\ncapable of interoperating with a variety of versioning repository\nmanagers, to facilitate widespread deployment of applications capable of\nutilizing the WebDAV Versioning services.\n\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-deltav-versioning-14.txt\n\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-deltav-versioning-14.txt\".\n\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html \nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt\n\n\nInternet-Drafts can also be obtained by e-mail.\n\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-deltav-versioning-14.txt\".\n\nNOTE:The mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages.\n\n\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft.\n\n\n\n\n\n\nMessage/External-body attachment: stored\n\n\n\n\n", "id": "lists-006-8949354"}, {"subject": "Design team meetings at IETF 5", "content": "Looks like our DeltaV Working Group meeting got moved to Friday 9:00 to \n11:30. So I propose the following new schedule for the DeltaV design team \nmeetings:\n\nThursday   9:00 to 11:30 WebDAV Working Group Meeting\nThursday 11:30 to 5:00 DeltaV Design Team Meeting: Prepare for the Working \nGroup meeting and detailed discussion on remaining issues\nFriday         9:00 to 11:30 DeltaV Working Group Meeting\nFriday       11:30 to 3:00 DeltaV Design Team Meeting: Wrapup and address \nissues that were raised in the Working Group Meeting.\n\n\n----- Forwarded by Jim Amsden/Raleigh/IBM on 02/27/2001 12:57 PM -----\n\n\nJim Amsden\n02/26/2001 11:13 AM\n\n \n        To:     dav-versioning\n        cc: \n        From:   Jim Amsden/Raleigh/IBM@IBMUS\n        Subject:        Design team meetings at IETF 50\n\n \n\nEven though we've made it through a couple of last calls, and we're on the \npath to IETF last call and Proposed Standard, I'd still like to schedule \nsome design team meetings during IETF 50. How about 3-5pm on Wed to \nprepare for the Working Group meeting, 11-3pm on Thu for detailed \ndiscussions, and a 9-12 on Fri to followup on any post-Working Group \nissues?\n\n\n\n", "id": "lists-006-8958155"}, {"subject": "RE: OPTION", "content": "I agree that rfc2616 doesn't say nearly enough about OPTIONS and Allow:.\nI do wish it would say for example if OPTIONS should list GET on a resource\nthat will return 404 Not Found for a GET on that URI.   Or not list GET.\nOr if OPTIONS itself should return 404.  (As per jigsaw.) That would give\nus a feel for the philosophy behind OPTIONS.  Their current philosophy\nseems to be to say little about OPTIONS and that's why I suggested that we\ndo the same.\n\nAnyone else have any opinions on this\n\nJ.\n\n------------------------------------------\nPhone: 914-784-7569,   ccjason@us.ibm.com\n\n\n\n", "id": "lists-006-8966414"}, {"subject": "RE: OPTION", "content": "[freed from spam trap -rrs]\n\n Date: Thu, 1 Mar 2001 13:53:55 -0500 (EST)\n From: \"Kevin Wiggen\" <wiggs@wiggenout.com>\n To: \"Jason Crawford\" <ccjason@us.ibm.com>, <w3c-dist-auth@w3.org>,\n         <ietf-dav-versioning@w3.org>\n Message-ID: <ONEOJMKKAIDAGPLOPJEDCEMACMAA.wiggs@wiggenout.com>\n In-Reply-To: <OFE1B3A375.FEE5441B-ON852569FD.0015EB52@pok.ibm.com>\n Subject: RE: OPTIONS\n\nI do not think the HTTP spec says enough, and for OPTIONS to be useful to\nclients, I think we need to specify what the behavior is.\n\nIt's useful to look at a few use cases and discuss what the server should\nrespond.\n\nTake for instance:\n\n/foo is an empty directory\n\nOPTIONS /foo\nAllow: GET, HEAD, POST, OPTIONS, TRACE, PROPFIND, COPY, SEARCH\nIf the /foo is writeable add PROPPATCH, LOCK, UNLOCK\n\nOPTIONS /foo/bar\nAllow: OPTIONS\nIf /foo is writeable add MKCOL, PUT, LOCK\n\nOPTIONS /foo/bar/fee\nAllow: OPTIONS\n\nThis is one way of handling the OPTIONS, I can think of other permutations\nthat might make sense.  Again for this to be truly useful information to a\nclient, I believe we need to state what a server should respond with to a\nclient in each case.\n\nKevin\n\n\n-----Original Message-----\nFrom: w3c-dist-auth-request@w3.org\n[mailto:w3c-dist-auth-request@w3.org]On Behalf Of Jason Crawford\nSent: Friday, February 23, 2001 8:09 PM\nTo: w3c-dist-auth@w3.org; ietf-dav-versioning@w3.org\nSubject: RE: OPTIONS\n\n\n\n\n<<\nI concur -- it's pretty clear that OPTIONS in HTTP/1.1 is per-resource,\nunless the Request-URI is \"*\".  It's fairly typical for Web servers to have\ndifferent capabilities in different parts of their namespace.\n>>\nSo do we want 2518 to say anything or leave this for HTTP/1.1?  It sounds\nto me that all the questions asked here about OPTIONS in the last two weeks\nare probably best left to the HTTP/1.1 spec.  (I just wish that spec said\nmore.)\n\nJ.\n\n\n\n", "id": "lists-006-8974438"}, {"subject": "How to supply an activity for VERSION-CONTROL", "content": "Under section 11 \"ACTIVITY OPTION\", I can't find a way to specify an\nactivity with the VERSION-CONTROL request.\n\nHow do I supply an activity to track that a versionable-resource has become\na version-controlled-resource?\n\nA follow-on question to this is...Can a server that supports activities\nrequire that an activity be given to all updates (PUT, CHECKIN, etc.)?\n\nThanks in advance,\nSteve Speicher\nsspeiche@us.ibm.com\n\n\n\n", "id": "lists-006-8984789"}, {"subject": "RE: How to supply an activity for VERSION-CONTROL", "content": "Good point.  If you support the workspace option, then the\ninitial version created by the VERSION-CONTROL request would\nbe determined by the DAV:current-activity of the workspace,\nbut without workspaces, you'd probably like a DAV:activity\nelement in the request body to specify this.\n\nDoes anyone object to this being added?\n\nFor the follow-on question, I'd be against adding a header to\nPUT to allow an activity to be specified, but a server could\ncertainly fail a CHECKIN attempt that is not accompanied by\nan activity.  I personally would not do that, since you are\nmaking your server non-interoperable with a non-activity-aware\nclient, but that is of course your choice.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Steve K Speicher [mailto:sspeiche@us.ibm.com]\nSent: Monday, March 05, 2001 3:41 PM\nTo: ietf-dav-versioning@w3.org\nSubject: How to supply an activity for VERSION-CONTROL?\n\n\nUnder section 11 \"ACTIVITY OPTION\", I can't find a way to specify an\nactivity with the VERSION-CONTROL request.\n\nHow do I supply an activity to track that a versionable-resource has become\na version-controlled-resource?\n\nA follow-on question to this is...Can a server that supports activities\nrequire that an activity be given to all updates (PUT, CHECKIN, etc.)?\n\nThanks in advance,\nSteve Speicher\nsspeiche@us.ibm.com\n\n\n\n", "id": "lists-006-8993148"}, {"subject": "Re: FW: webDAV - web authoring or flexible two-way web interface ", "content": "Stuart,\nWebDAV can be used for dynamic resources, and would provide properties and\n(potentially) locking semantics (and in the future access control).\nGenerally the server would be configured with virtual hosts or directories\nthat are DAV enabled to distinguish between access to the source of a\ndynamic resource vs. its result. So I think WebDAV would be a good fit for\nyour application if you need to organize your resources in a collection\nhierarchy (modeling containment associations), and you need additional\nmeta-data about the resources stored as WebDAV properties.\n\n\n\nAccidentally caught by the spam filter.  I've added Stuart to the accept2\nlist, so future emails will get sent through to the list.\n\n- Jim\n\n-----Original Message-----\nFrom: Connelly, Stuart [mailto:sconnelly@ordsvy.gov.uk]\nSent: Monday, March 05, 2001 6:38 AM\nTo: 'w3c-dist-auth@w3.org'\nSubject: [Moderator Action] webDAV - web authoring or flexible two-way\nweb interface ?\n\n\n\nCan I use this forum to ask a dumb question? Already have....\n\nSay I have a large database of geographic features; points/lines/areas.\nAll\nfeatures have a unique id.  The supply of data to read access clients is\nbased on a cgi script executing a query and then returning dynamic content.\n(e.g. All objects in a given rectangle).\n\nNow I want to give clients the ability to update this database via the web.\nOne method would be to define lock/transaction interfaces that embed\ninformation within HTTP POST messages. (I think this is termed\nRPC-via-POST?).\n\nPerhaps another method would be to use the WebDAV extensions. But reading\nthe WebDAV information on the web it isn't clear if WebDAV can be used for\ndynamic web pages - it all seems geared-up for editing of text pages. Am I\nbarking up the wrong tree in looking at WebDAV?\n\nOut of my depth but not drowning yet,\n\nStuart Connelly\n\n\n\n", "id": "lists-006-9002548"}, {"subject": "Re: How to supply an activity for VERSION-CONTROL", "content": "Steve,\nWe thought of an activity as describing related changes on versioned\nresources, not the initial versions themselves as there is not versioning\nmeta-data to associate with the non-versioned resource. This is a fine\ndetail though. Is it a problem?\n\nA WebDAV server can't require activities since activities are an option.\nHowever, a particular client could be written to require a server that\nsupports activities, and to ensure an activity is provided for each update\noperation. The protocol is interested in presenting a set of mechanisms\nthat support many versioning, configuration management, and team management\npolicies. However, we have tried very hard to avoid specifying specific\npolicies. That is really the clients' role. The protocol ensures\ninteroperability across the mechanisms, but does not dicticate particular\npolicies.\n\n\n\n                                                                                                            \n                    \"Steve K                                                                                \n                    Speicher\"            To:     ietf-dav-versioning@w3.org                                 \n                    <sspeiche@us.i       cc:                                                                \n                    bm.com>              Subject:     How to supply an activity for VERSION-CONTROL?        \n                                                                                                            \n                    03/05/2001                                                                              \n                    03:40 PM                                                                                \n                                                                                                            \n                                                                                                            \n\n\n\nUnder section 11 \"ACTIVITY OPTION\", I can't find a way to specify an\nactivity with the VERSION-CONTROL request.\n\nHow do I supply an activity to track that a versionable-resource has become\na version-controlled-resource?\n\nA follow-on question to this is...Can a server that supports activities\nrequire that an activity be given to all updates (PUT, CHECKIN, etc.)?\n\nThanks in advance,\nSteve Speicher\nsspeiche@us.ibm.com\n\n\n\n", "id": "lists-006-9011892"}, {"subject": "Re: How to supply an activity for VERSION-CONTROL", "content": "Jim,\nIt would seem that if someone would want to track all the changes for a\ngiven activity, that the initial version would be part of those tracked\nchanges.  I would think it would be a problem for someone who would want to\nsee what the \"reason\" was to bring the activity into existence.   The\nfigure in section 11 shows the resource \"foo.html\" with version \"V1\"\nassociated with activity \"Act-1\".  How is it possible to have this\nsituation if VERSION-CONTROL doesn't accept the DAV:activity property as\ndescribed by Geoff?\n\nIt seems that in order to maintain the integrity of controlled resources, a\nserver may want to restrict a given namespace to require an activity on all\nupdates.  Why shouldn't the protocol support this?  I realize that this\ncould render many non-activity aware clients useless.\n\nThanks,\nSteve Speicher\nsspeiche@us.ibm.com\n\n\n\n", "id": "lists-006-9022217"}, {"subject": "Re: How to supply an activity for VERSION-CONTROL", "content": "Steve,\n\nTo be precise, an activity selects a set of resources, it does not track\nthe methods applied to the resources.\nThat is to say, while it may be a convenient short-hand to add a\nDAV:activity to VERSION-CONTROL it is not capturing the fact that 'a\nversionable resource was version controlled', but rather 'this version is\nassociated with this activity'.\n\nIn fact, my answer would have been that you should PROPPATCH the\nDAV:activity-set property of the root version created by the\nVERSION-CONTROL -- but I do not object to the shorthand extension to the\nVERSION-CONTROL method.\n\nUsing activities to track changes to a resource requires that you\nreconstruct the changes that took place based on the set of resources\ncaptured by the activity.\n\nRegards,\n\nTim Ellison\nJava Technology Centre, MP146\nIBM UK Laboratory, Hursley Park, Winchester, UK. SO21 2JN\ntel: +44 (0)1962 819872  internal: 249872  MOBx: 270452\n\n\n|--------+------------------------>\n|        |          \"Steve K      |\n|        |          Speicher\"     |\n|        |          <sspeiche@us.i|\n|        |          bm.com>       |\n|        |                        |\n|        |          2001-03-06    |\n|        |          03:28 PM      |\n|        |          Please respond|\n|        |          to \"Steve K   |\n|        |          Speicher\"     |\n|        |                        |\n|--------+------------------------>\n  >--------------------------------------------------------------------|\n  |                                                                    |\n  |      To:     ietf-dav-versioning@w3.org                            |\n  |      cc:                                                           |\n  |      Subject:     Re: How to supply an activity for                |\n  |       VERSION-CONTROL?                                             |\n  |                                                                    |\n  |                                                                    |\n  >--------------------------------------------------------------------|\n\n\n\n\n\n\nJim,\nIt would seem that if someone would want to track all the changes for a\ngiven activity, that the initial version would be part of those tracked\nchanges.  I would think it would be a problem for someone who would want to\nsee what the \"reason\" was to bring the activity into existence.   The\nfigure in section 11 shows the resource \"foo.html\" with version \"V1\"\nassociated with activity \"Act-1\".  How is it possible to have this\nsituation if VERSION-CONTROL doesn't accept the DAV:activity property as\ndescribed by Geoff?\n\nIt seems that in order to maintain the integrity of controlled resources, a\nserver may want to restrict a given namespace to require an activity on all\nupdates.  Why shouldn't the protocol support this?  I realize that this\ncould render many non-activity aware clients useless.\n\nThanks,\nSteve Speicher\nsspeiche@us.ibm.com\n\n\n\n", "id": "lists-006-9030777"}, {"subject": "RE: Design team meetings at IETF 5", "content": "Jim,\n\nI plan to be at all of these meetings as well.\n\n    Thanks,\n\n    Mark\n\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\nSent: Monday, February 26, 2001 8:14 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Design team meetings at IETF 50\n\n\n\nEven though we've made it through a couple of last calls, and we're on the\npath to IETF last call and Proposed Standard, I'd still like to schedule\nsome design team meetings during IETF 50. How about 3-5pm on Wed to prepare\nfor the Working Group meeting, 11-3pm on Thu for detailed discussions, and a\n9-12 on Fri to followup on any post-Working Group issues?\n\n\n\n", "id": "lists-006-9041315"}, {"subject": "DAVers guide to the Minneapolis IET", "content": "The following is a brief guide to WebDAV and DeltaV activities at the\nMinneapolis IETF meeting.  For location, hotel, and registration information\nfor the IETF meeting, see:\n\nhttp://www.ietf.org/meetings/IETF-50.html\n\nWednesday, March 21\n-------------------\n\n1:00-3:00 :: Informal WebDAV meeting to discuss RFC 2518 open issues.\n             Location: TBD, look on IETF message board\n\nThursday, March 22\n------------------\n\n9:00-11:30 :: WebDAV Working Group meeting\n              Location: Rochester room, Minneapolis Hilton and Towers\n\n11:30-5:00 :: DeltaV Design Team Meeting\n              Location: TBD (will be announced during WebDAV WG meeting)\n\nFriday, March 23\n----------------\n\n9:00-11:30 :: DeltaV Working Group meeting\n              Location: Rochester room, Minneapolis Hilton and Towers\n\n11:30-3:00 :: DeltaV Design Team meeting\n              Location: TBD (will be announced in DeltaV WG meeting)\n\n\nThe Minneapolis Hilton and Towers is located at:\n1001 Marquette Avenue\nMinneapolis, MN 55403 USA\n\nNote that the IETF message board is a bulletin board typically located near\nthe registration counter.\n\nAlso, if you have not yet made your hotel arrangements, I recommend doing so\npronto.  I had significant difficulty finding a hotel when I made my\narrangements last week...\n\n- Jim\n\n\n\n", "id": "lists-006-9050013"}, {"subject": "No OPTIONS response for the variant option", "content": "I just noticed (in draft 14) that the Variant option does not specify any\naddition to the OPTIONS response, to indicate that a server supports the\noption. Shouldn't it?\n\nJohn\n\n\n\n", "id": "lists-006-9058084"}, {"subject": "Re: No OPTIONS response for the variant option", "content": "> I just noticed (in draft 14) that the Variant option does\n> not specify any addition to the OPTIONS response, to indicate\n> that a server supports the option. Shouldn't it?\n\nYes, I guess it should -- at least to indicate the valid VERSION-CONTROL\nbody elements.\n\np.s.  You're not the first person to refer to a draft -14, so how is it\nthat I only see a -13 on the delta-v webpage?  Did I miss something?\n\n\nTim\n\n\n\n", "id": "lists-006-9065749"}, {"subject": "Questions/clarification on MKACTIVITY metho", "content": "Reference draft #13\n\n- How could the MKACTIVITY method be used to indicate a server-defined\n\"activity\" at a server-defined activity collection?  It appears that the\nCHECKOUT method (section 11.10) has the ability to have the server\nautomatically create an \"activity\", why doesn't the MKACTIVITY method have\nthis (or if it does, how)?\n\n- I noticed in section 11.5 \"Marshalling\", there is mention of an\nXML-element \"mkactivity\" as part of the MKACTIVITY method.  What is this\nintended to be used for and what are the possible values for it?\n\n- To minimize client/server communication, could it be possible for the\nMKACTIVITY method to NOT specify the collection, just the activity name?\nSince the client would have to solicit the server for the valid collection\nlocaiton before building the request (i.e. eliminating the\nDAV:activity-collection-set OPTIONS request).\n\nMany thanks,\nSteve Speicher\nsspeiche@us.ibm.com\n\n\n\n", "id": "lists-006-9073431"}, {"subject": "RE: Questions/clarification on MKACTIVITY metho", "content": "   From: Steve K Speicher [mailto:sspeiche@us.ibm.com]\n\n   Reference draft #13\n\n   - How could the MKACTIVITY method be used to indicate a\n   server-defined \"activity\" at a server-defined activity collection?\n   It appears that the CHECKOUT method (section 11.10) has the ability\n   to have the server automatically create an \"activity\", why doesn't\n   the MKACTIVITY method have this (or if it does, how)?\n\nThe purpose of the \"new activity\" option for CHECKOUT is to allow\na lightweight client to easily interoperate with a server that\nrequires activities.  A client with full activity support (i.e.\none that utilizes MKACTIVITY) can use a DAV:activity-set-collection\nOPTIONS request to determine where it can allocate activities.\n\nIn an earlier draft of the spec, I had the MKACTIVITY request always\nallocate an activity at a server defined location, and the request-URL\nwas just a \"hint\" to the server for what the client wanted that\nactivity named.  Other members of the design team felt it is\nbetter/simpler to fail the MKACTIVITY request if the request-URL is\nnot a valid name for a new activity.\n\n   - I noticed in section 11.5 \"Marshalling\", there is mention of an\n   XML-element \"mkactivity\" as part of the MKACTIVITY method.  What is\n   this intended to be used for and what are the possible values for\n   it?\n\nThis ensures that any extensions that add arguments to the MKACTIVITY\nmethod do so in a \"consistent\" fashion.\n\n   - To minimize client/server communication, could it be possible for\n   the MKACTIVITY method to NOT specify the collection, just the\n   activity name?  Since the client would have to solicit the server\n   for the valid collection locaiton before building the request\n   (i.e. eliminating the DAV:activity-collection-set OPTIONS request).\n\nA request has to go to a particular resource, which is then\nresponsible for handling the request.  What would be the request-URL\nof the MKACTIVITY method in this case?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9082509"}, {"subject": "RE: Questions/clarification on MKACTIVITY metho", "content": ">The purpose of the \"new activity\" option for CHECKOUT is to allow\n>a lightweight client to easily interoperate with a server that\n>requires activities.  A client with full activity support (i.e.\n>one that utilizes MKACTIVITY) can use a DAV:activity-set-collection\n>OPTIONS request to determine where it can allocate activities.\n\nHow is a client with full activity support intended to know what a valid\nactivity name is without much trial-and-error?  I was hoping for something\nlike:\n   MKACTIVITY * HTTP/1.1\n\nThis way the client can programmatically maintain the activity information\nand the end-user could perform simple routines like: \"new activity\" and\n\"done with activity\" without concern about coming up with a valid activity\nidentifier.\n\n>A request has to go to a particular resource, which is then\n>responsible for handling the request.  What would be the request-URL\n>of the MKACTIVITY method in this case?\n\nSince the client is already aware of the DAV/activity-enabled part of a\nURL, couldn't it be used without the additional activity location since the\nactivity location is not handled by a separate handler, right?\n\nSo if the URL http://repo.webdav.org/test-23 and \"/\" is\nDAV/activity-enabled, then could the request be something like this?\n\n   MKACTIVITY /test-23 HTTP/1.1\n   Host: repo.webdav.org\n   Content-Type: text/xml; charset=\"utf-8\"\n   Content-Length: long\n\n   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <D:mkactivity xmlns:D=\"DAV:\">\n     <D:activity-collection-set>\n        <D:automatic/>\n     </D:activity-collection-set>\n   </D:mkactivity>\n\nIs the additional XML really needed if the server would \"assume\" that the\nclient meant for the server to specify the correct collection?\n\nThanks,\nSteve\n\nP.S. Your responses to my newbie questions are greatly appreciated.\n\n\n\n", "id": "lists-006-9091973"}, {"subject": "RE: Questions/clarification on MKACTIVITY metho", "content": "   From: Steve K Speicher [mailto:sspeiche@us.ibm.com]\n\n   >A client with full activity support (i.e.  one that utilizes\n   >MKACTIVITY) can use a DAV:activity-collection-set OPTIONS request\n   >to determine where it can allocate activities.\n\n   How is a client with full activity support intended to know what a valid\n   activity name is without much trial-and-error?  I was hoping for\nsomething\n   like:\n      MKACTIVITY * HTTP/1.1\n\nIt shouldn't require much trial and error.  You can just use some\nGUID generator in the client to ensure that the activity name is\nunique.\n\nIn general, there are multiple modules/servers that handle different\nsubtrees at a web site, and often the DAV module will not handle\n\"/\", but rather some subtree such as \"/dav\".  Assuming that a request\nto \"*\" gets handled by the module that handles \"/\", the \nMKACTIVITY request will not be understood.  In addition, if there\nare multiple DAV modules handling different parts of the namespace,\neach with its own activity store, it is important that the \nactivity gets created in the right activity collection (not something\nthat can be inferred from \"MKACTIVITY *\".\n\n   This way the client can programmatically maintain the activity\ninformation\n   and the end-user could perform simple routines like: \"new activity\" and\n   \"done with activity\" without concern about coming up with a valid\nactivity\n   identifier.\n\nA client can simulate this behavior by using a GUID for the\nname of a new activity (putting the activity in a randomly \nselected member of the DAV:activity-collection-set).\n\n   >A request has to go to a particular resource, which is then\n   >responsible for handling the request.  What would be the request-URL\n   >of the MKACTIVITY method in this case?\n\n   Since the client is already aware of the DAV/activity-enabled part of a\n   URL, couldn't it be used without the additional activity location since\nthe\n   activity location is not handled by a separate handler, right?\n\n   So if the URL http://repo.webdav.org/test-23 and \"/\" is\n   DAV/activity-enabled, then could the request be something like this?\n\n      MKACTIVITY /test-23 HTTP/1.1\n      Host: repo.webdav.org\n      Content-Type: text/xml; charset=\"utf-8\"\n      Content-Length: long\n\n      <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n      <D:mkactivity xmlns:D=\"DAV:\">\n<D:activity-collection-set>\n   <D:automatic/>\n</D:activity-collection-set>\n      </D:mkactivity>\n\n   Is the additional XML really needed if the server would \"assume\" that the\n   client meant for the server to specify the correct collection?\n\nYes, something like that would be just fine.  As far as I know,\nthe only argument against this was that this functionality was\nnot required since a client could just allocate a GUID for this\npurpose, so the protocol is simpler without this option.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9101251"}, {"subject": "RE: Questions/clarification on MKACTIVITY metho", "content": "One final comment *hopefully* ;-)\n\n>In general, there are multiple modules/servers that handle different\n>subtrees at a web site, and often the DAV module will not handle\n>\"/\", but rather some subtree such as \"/dav\".  Assuming that a request\n>to \"*\" gets handled by the module that handles \"/\", the\n>MKACTIVITY request will not be understood.  In addition, if there\n>are multiple DAV modules handling different parts of the namespace,\n>each with its own activity store, it is important that the\n>activity gets created in the right activity collection (not something\n>that can be inferred from \"MKACTIVITY *\".\n\nI guess my example was too simple (and wrong perhaps).  In order for a\nclient to find out what activity-collection to use it must first issue an\nOPTIONS request with a given URL, say http://repo.dav/dav/ and gets the\nproperty DAV:activity-collections-set.  Why couldn't I form a request,\nlike:\n   MKACTIVITY /dav/* HTTP/1.1\n\nAnd get the response (implicity do an OPTIONS request to get\nDAV:activity-collections-set):\n   HTTP/1.1 201 Created\n   Location: http://repo.dav/dav/act/123\n?\nOr am I completely wrong in thinking it would be a valid operation of a\nactivity-enabled server to assign an activity identifier using MKACTIVITY?\nMost bug-tracking servers have an option/configuration to automatically\nassign a number but I'm trying to determine if this is outside the scope of\nthis protocol.\n\nThanks again,\nSteve\n\n\n\n", "id": "lists-006-9111749"}, {"subject": "RE: No OPTIONS response for the variant option", "content": "Yes, that was just an oversight.  I'll add an OPTIONS\nsection to the Variant option.\n\nAs for draft-14, it's available in text form at the ietf internet\ndrafts site, but you are correct that I have neglected to upload\nit to the deltav web site ... (sorry about that!).\nI will do so as soon as IT restores\nour internet connection (which has been down all day ...!).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Monday, March 12, 2001 6:08 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: No OPTIONS response for the variant option?\n\n\n\n\n> I just noticed (in draft 14) that the Variant option does\n> not specify any addition to the OPTIONS response, to indicate\n> that a server supports the option. Shouldn't it?\n\nYes, I guess it should -- at least to indicate the valid VERSION-CONTROL\nbody elements.\n\np.s.  You're not the first person to refer to a draft -14, so how is it\nthat I only see a -13 on the delta-v webpage?  Did I miss something?\n\n\nTim\n\n\n\n", "id": "lists-006-9120621"}, {"subject": "draft-14 is now up on the deltav web site", "content": "<http://www.webdav.org/deltav/protocol/draft-ietf-deltav-versioning-14.htm>\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Clemm, Geoff [mailto:gclemm@Rational.Com]\nSent: Monday, March 12, 2001 3:02 PM\nTo: ietf-dav-versioning@w3.org\nSubject: RE: No OPTIONS response for the variant option?\n\n\nAs for draft-14, it's available in text form at the ietf internet\ndrafts site, but you are correct that I have neglected to upload\nit to the deltav web site ... (sorry about that!).\nI will do so as soon as IT restores\nour internet connection (which has been down all day ...!).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\nSent: Monday, March 12, 2001 6:08 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: No OPTIONS response for the variant option?\n\n\n\n\n> I just noticed (in draft 14) that the Variant option does\n> not specify any addition to the OPTIONS response, to indicate\n> that a server supports the option. Shouldn't it?\n\nYes, I guess it should -- at least to indicate the valid VERSION-CONTROL\nbody elements.\n\np.s.  You're not the first person to refer to a draft -14, so how is it\nthat I only see a -13 on the delta-v webpage?  Did I miss something?\n\n\nTim\n\n\n\n", "id": "lists-006-9129330"}, {"subject": "RE: Questions/clarification on MKACTIVITY metho", "content": "This would by no means be wrong (and in one draft of the protocol\nwas the *only* way that MKACTIVITY worked).  But other members of\nthe design team felt that it was simpler/better to have this be\nunder client control, i.e. a client can allocate a GUID for the activity\nname if it so desired, but the server's job is just to instantiate\nthe activity with the name specified by the client.\n\nPersonally, I can live with either way, but to minimize protocol\ncomplexity, I'd probably prefer us to support one way or the other\nway, but not both (i.e. not add a flag to MKACTIVITY for this).\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Steve K Speicher [mailto:sspeiche@us.ibm.com]\n\nOne final comment *hopefully* ;-)\n\n>In general, there are multiple modules/servers that handle different\n>subtrees at a web site, and often the DAV module will not handle\n>\"/\", but rather some subtree such as \"/dav\".  Assuming that a request\n>to \"*\" gets handled by the module that handles \"/\", the\n>MKACTIVITY request will not be understood.  In addition, if there\n>are multiple DAV modules handling different parts of the namespace,\n>each with its own activity store, it is important that the\n>activity gets created in the right activity collection (not something\n>that can be inferred from \"MKACTIVITY *\".\n\nI guess my example was too simple (and wrong perhaps).  In order for a\nclient to find out what activity-collection to use it must first issue an\nOPTIONS request with a given URL, say http://repo.dav/dav/ and gets the\nproperty DAV:activity-collections-set.  Why couldn't I form a request,\nlike:\n   MKACTIVITY /dav/* HTTP/1.1\n\nAnd get the response (implicity do an OPTIONS request to get\nDAV:activity-collections-set):\n   HTTP/1.1 201 Created\n   Location: http://repo.dav/dav/act/123\n?\nOr am I completely wrong in thinking it would be a valid operation of a\nactivity-enabled server to assign an activity identifier using MKACTIVITY?\nMost bug-tracking servers have an option/configuration to automatically\nassign a number but I'm trying to determine if this is outside the scope of\nthis protocol.\n\nThanks again,\nSteve\n\n\n\n", "id": "lists-006-9138553"}, {"subject": "DAV:version-controlled-configuratio", "content": "A while back, Tim and I were discussing where DAV:vcc property appears\nwithin \"normal\" collections. Tim said \"only on the root\" and I said \"on all\ncollections under the root\". I believe we need to figure out the right\nanswer here.\n\nTim says it appears only on the resource that BASELINE-CONTROL was applied\nto (or implicitly applied by the server). I'm not sure of the basis or\nexplanation for this since I don't agree :-) ... Tim will speak up.\n\nI believe it should be on the root and everything below it. All of those\ncollections *are* under baseline control. If the baseline changes, they will\nalso change. A change in the baseline ripples down through the entire URL\nnamespace, so those collection truly are controlled by the baseline (well,\nthe version-controlled configuration).\n\n\nIn Tim's scheme, to determine whether something is controlled, you must\nissue a bunch of PROPFINDs, walking up the hierarchy, to determine whether\nsomething is controlled. In mine, a single PROPFIND will do it.\n\nOriginally, I had a problem with determine where the VCR appeared within a\nbaseline-collection (BC) (i.e. a VCR's relative path from the root of the\nbaseline). Tim's scheme can determine this by how far up you walk, and\napplying that relative path against the BC. I resolved mine as a\nDAV:locate-history report on the BC.\n\n\nThoughts?\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-9147894"}, {"subject": "Re: DAV:version-controlled-configuratio", "content": "Greg wrote:\n\n> A while back, Tim and I were discussing where DAV:vcc\n> property appears within \"normal\" collections. Tim said\n> \"only on the root\" and I said \"on all collections under\n> the root\". I believe we need to figure out the right\n> answer here.\n>\n> Tim says it appears only on the resource that BASELINE-\n> CONTROL was applied to (or implicitly applied by the\n> server). I'm not sure of the basis or explanation for\n> this since I don't agree :-) ... Tim will speak up.\n\nThere are a couple of reasons:\n\n(1)\nIf you believe that nested baselines makes sense then the\nDAV:version-controlled-configuration (DAV:vcc) property must be either only\non the root of the baseline controlled collection, or the property must\nsupport multiple values to represent the nesting.\n\n(Incidently, the property definition in draft-13 12.4.1 refers to applying\nthe property to '...a collection when it is created, or [brought under\nBASELINE-CONTROL]...'.  If the property is applied to multiple collections\nthis should be made explicit.)\n\n(2)\nFurthermore, if all resources in a configuration had a DAV:vcc property it\nwould be very confusing for the client to know the scope of a baseline.  A\nclient may check out/in a vcc and get a new version of a baseline with a\nfar wider scope than the configuration rooted at the source of the DAV:vcc.\n\nFor example, getting the DAV:vcc from /a/b/c/d/ and creating a new version\nof the vcc would capture a baseline that includes everything below\n/a/b/c/d/; however, the baseline may have been created for /a/ and the\noperation would have actually captured a larger scope.  The only way to\nfigure out the true scope would be to walk up the 'normal' namespace\nhierarchy to find the root.\n\n> I believe it should be on the root and everything below\n> it. All of those collections *are* under baseline control.\n\nI agree that the collections are under baseline control, but it is the root\nof the configuration that defines the baseline scope.  If a child\ncollection is MOVEd out of the baseline controlled configuration it should\nnot take it's DAV:version-controlled-configuration property with it.  The\nroot's the guy!<g>\n\n> If the baseline changes, they will also change.\n\nNot sure what you mean here -- I'd state it the other way around, if they\nchange that implies a change to the baseline when the vcc is checked\nout/in.\n\n> A change\n> in the baseline ripples down through the entire URL\n> namespace, so those collection truly are controlled by\n> the baseline (well, the version-controlled configuration).\n\nOh, you are probably referring to the 'destructive replace' postcondition\nof UPDATE?\n\n> In Tim's scheme, to determine whether something is\n> controlled, you must issue a bunch of PROPFINDs, walking\n> up the hierarchy, to determine whether something is\n> controlled. In mine, a single PROPFIND will do it.\n\nIf this is objectionable, a trivial new REPORT would fix it.\n\n> Originally, I had a problem with determine where the\n> VCR appeared within a baseline-collection (BC) (i.e. a\n> VCR's relative path from the root of the baseline). Tim's\n> scheme can determine this by how far up you walk, and\n> applying that relative path against the BC. I resolved\n> mine as a DAV:locate-history report on the BC.\n\nI now believe that the DAV:locate-history is preferrable, due to the\n'messed-up namespace' problem we discussed at the time.\n\nI see your approach, and I am not fundamentally opposed to it; however, I\nthink we should agree on just one <g> and there are therefore some clarity\nissues that should be addressed in the spec.\n\nTim\n\n\n\n", "id": "lists-006-9156283"}, {"subject": "RE: DAV:version-controlled-configuratio", "content": "   From: Tim_Ellison@uk.ibm.com [mailto:Tim_Ellison@uk.ibm.com]\n\n   Greg wrote:\n\n   > A while back, Tim and I were discussing where DAV:vcc\n   > property appears within \"normal\" collections. Tim said\n   > \"only on the root\" and I said \"on all collections under\n   > the root\". I believe we need to figure out the right\n   > answer here.\n\nI agree.\n\n   > Tim says it appears only on the resource that BASELINE-\n   > CONTROL was applied to (or implicitly applied by the\n   > server). I'm not sure of the basis or explanation for\n   > this since I don't agree :-) ... Tim will speak up.\n\nTim is correct, in that the protocol currently only requires it to be\nset on the root, but I believe Greg makes a good case that it should\nbe set on every member of the baselined collection, so I support that\naddition to the protocol (it's actually an upwardly compatible change,\nin that this does not conflict with anything that is currently stated\nin the protocol).\n\n   (1)\n   If you believe that nested baselines makes sense then the\n   DAV:version-controlled-configuration (DAV:vcc) property must be\n   either only on the root of the baseline controlled collection, or\n   the property must support multiple values to represent the nesting.\n\nI disagree.  Every version controlled resource should be in exactly\none baseline controlled collection (i.e. its nearest parent that is\nunder baseline control).  If you want to glue together multiple\nbaseline controlled collections, you would use the DAV:subbaseline-set\nproperty.  Making the change Greg requested will make this clear,\nwhich is another benefit of making the change.\n\n   (Incidently, the property definition in draft-13 12.4.1 refers to\n   applying the property to '...a collection when it is created, or\n   [brought under BASELINE-CONTROL]...'.  If the property is applied\n   to multiple collections this should be made explicit.)\n\nYes.\n\n   (2)\n   Furthermore, if all resources in a configuration had a DAV:vcc\n   property it would be very confusing for the client to know the\n   scope of a baseline.  A client may check out/in a vcc and get a new\n   version of a baseline with a far wider scope than the configuration\n   rooted at the source of the DAV:vcc.\n\nA client that cares could ask for the\nDAV:baseline-controlled-collection of the version-controlled\nconfiguration, to determine the root collection of that configuration.\n\n   For example, getting the DAV:vcc from /a/b/c/d/ and creating a new\n   version of the vcc would capture a baseline that includes\n   everything below /a/b/c/d/; however, the baseline may have been\n   created for /a/ and the operation would have actually captured a\n   larger scope.  The only way to figure out the true scope would be\n   to walk up the 'normal' namespace hierarchy to find the root.\n\nIf you ask for the DAV:baseline-controlled-collection of the\nDAV:version-controlled-configuration of /a/b/c/d, it would tell\nyou that /a is the root.\n\n   > I believe it should be on the root and everything below\n   > it. All of those collections *are* under baseline control.\n\n   I agree that the collections are under baseline control, but it is\n   the root of the configuration that defines the baseline scope.  If\n   a child collection is MOVEd out of the baseline controlled\n   configuration it should not take it's\n   DAV:version-controlled-configuration property with it.  The root's\n   the guy!<g>\n\nYes, but we can just define DAV:version-controlled-configuration to be\na computed property (similar to DAV:workspace), so that this semantics\nis clear.\n\n   > If the baseline changes, they will also change.\n\n   Not sure what you mean here -- I'd state it the other way around,\n   if they change that implies a change to the baseline when the vcc\n   is checked out/in.\n\nI think Greg was just saying that if the baseline changes, the content\nand members of all of the collections in that baseline can change, so\nthat the content and members of the nested collections are reasonably\nthought of as being \"under baseline control\".\n\n   > A change in the baseline ripples down through the entire URL\n   > namespace, so those collection truly are controlled by the\n   > baseline (well, the version-controlled configuration).\n\n   Oh, you are probably referring to the 'destructive replace'\n   postcondition of UPDATE?\n\nYes, although \"destructive\" seems a rather harsh adjective for a\nsimple update (:-).\n\n   > In Tim's scheme, to determine whether something is\n   > controlled, you must issue a bunch of PROPFINDs, walking\n   > up the hierarchy, to determine whether something is\n   > controlled. In mine, a single PROPFIND will do it.\n\n   If this is objectionable, a trivial new REPORT would fix it.\n\nWe only use reports if \"additional parameters are required\".  So it\nmakes sense to make this be a property rather than a report.\n\n   > Originally, I had a problem with determine where the\n   > VCR appeared within a baseline-collection (BC) (i.e. a\n   > VCR's relative path from the root of the baseline). Tim's\n   > scheme can determine this by how far up you walk, and\n   > applying that relative path against the BC. I resolved\n   > mine as a DAV:locate-history report on the BC.\n\n   I now believe that the DAV:locate-history is preferrable, due to the\n   'messed-up namespace' problem we discussed at the time.\n\n   I see your approach, and I am not fundamentally opposed to it; however, I\n   think we should agree on just one <g> and there are therefore some\nclarity\n   issues that should be addressed in the spec.\n\nTotally agree.  So it sounds like Greg and I are in favor of the\naddition, and Tim is not against it.  Anyone object?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9167057"}, {"subject": "DAV:lockdiscovery on a checked-out resourc", "content": "Given a VCR that has been checked-out by userA. userB's versioning unaware\nclient performs a PROPFIND of DAV:lockdiscovery on that VCR.  Should the\nDAV:lockdiscovery value be the same as if userA had performed a LOCK\nrequest?\n\nThanks,\nSteve\n\n\n\n", "id": "lists-006-9180084"}, {"subject": "Re: DAV:lockdiscovery on a checked-out resourc", "content": "If it was \"checked out\" with a LOCK (server doesn't support, or client \ndidn't use CHECKOUT), then yes. Otherwise no. There are other properties \nthat can be used to determine if a resource is checked out.\n\n\nGiven a VCR that has been checked-out by userA. userB's versioning unaware\nclient performs a PROPFIND of DAV:lockdiscovery on that VCR.  Should the\nDAV:lockdiscovery value be the same as if userA had performed a LOCK\nrequest?\n\nThanks,\nSteve\n\n\n\n", "id": "lists-006-9189148"}, {"subject": "Re: DAV:lockdiscovery on a checked-out resourc", "content": "I guess I wasn't too clear...\n\nUserA performs a CHECKOUT on a VCR.\nUserB performs a PROPFIND of DAV:lockdiscovery to determine if the resource\nis \"locked\" (since the client is versioning unaware, ie only a class 2 DAV\nclient)\n\nWhat will DAV:lockdiscovery be?\n\nIf UserB's client is unaware of the DAV:checked-out property, then how will\nthey know it is \"locked\"?\n\nThanks,\nSteve\n\n\n\n", "id": "lists-006-9196881"}, {"subject": "Re: DAV:lockdiscovery on a checked-out resourc", "content": "Steve,\nIf UserA does a CHECKOUT, the resource won't be locked, it will just be \nchecked out. PROPFIND on DAV:lockdiscovery won't show any locks to anyone. \nNow UserB doesn't know anything about versioning. If UserB just looks for \nlocks and upon not finding any assumes the resource is writable, the write \nwill fail because the resource is already checked out. LOCK will also fail \nfor the same reason, it tries to do an implicit checkout. We assume that \nversioning unaware clients are not DAV unaware. That is, they can use \nPROPFIND and look at properties, including properties that indicate \nsomething is checked out. Its actually the user that's interperting this \ninformation, not the client. The client doesn't have to support any \nversioning specific protocol to access these properties. Although such \nclients make their users do extra work.\n\n\n\n\n\nI guess I wasn't too clear...\n\nUserA performs a CHECKOUT on a VCR.\nUserB performs a PROPFIND of DAV:lockdiscovery to determine if the \nresource\nis \"locked\" (since the client is versioning unaware, ie only a class 2 DAV\nclient)\n\nWhat will DAV:lockdiscovery be?\n\nIf UserB's client is unaware of the DAV:checked-out property, then how \nwill\nthey know it is \"locked\"?\n\nThanks,\nSteve\n\n\n\n", "id": "lists-006-9204554"}, {"subject": "RE: DAV:lockdiscovery on a checked-out resourc", "content": "That's impossible. Many clients won't show properties that they're not aware\nof.  C.F. Web Folders.\n\nlisa\n  -----Original Message-----\n  From: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim Amsden\n  Sent: Thursday, March 22, 2001 2:42 PM\n  To: ietf-dav-versioning@w3.org\n  Subject: Re: DAV:lockdiscovery on a checked-out resource\n\n\n\n  Steve,\n  If UserA does a CHECKOUT, the resource won't be locked, it will just be\nchecked out. PROPFIND on DAV:lockdiscovery won't show any locks to anyone.\nNow UserB doesn't know anything about versioning. If UserB just looks for\nlocks and upon not finding any assumes the resource is writable, the write\nwill fail because the resource is already checked out. LOCK will also fail\nfor the same reason, it tries to do an implicit checkout. We assume that\nversioning unaware clients are not DAV unaware. That is, they can use\nPROPFIND and look at properties, including properties that indicate\nsomething is checked out. Its actually the user that's interperting this\ninformation, not the client. The client doesn't have to support any\nversioning specific protocol to access these properties. Although such\nclients make their users do extra work.\n\n\n\n\n\n  I guess I wasn't too clear...\n\n  UserA performs a CHECKOUT on a VCR.\n  UserB performs a PROPFIND of DAV:lockdiscovery to determine if the\nresource\n  is \"locked\" (since the client is versioning unaware, ie only a class 2 DAV\n  client)\n\n  What will DAV:lockdiscovery be?\n\n  If UserB's client is unaware of the DAV:checked-out property, then how\nwill\n  they know it is \"locked\"?\n\n  Thanks,\n  Steve\n\n\n\n", "id": "lists-006-9213320"}, {"subject": "RE: DAV:lockdiscovery on a checked-out resourc", "content": "   From: Steve K Speicher [mailto:sspeiche@us.ibm.com]\n\n   I guess I wasn't too clear...\n\n   UserA performs a CHECKOUT on a VCR.\n   UserB performs a PROPFIND of DAV:lockdiscovery to determine\n   if the resource is \"locked\" (since the client is versioning\n   unaware, ie only a class 2 DAV client)\n\n   What will DAV:lockdiscovery be?\n\nIt will be whatever it was before the CHECKOUT.  A CHECKOUT does\nnot affect the DAV:lockdiscovery property of a resource.\n\n   If UserB's client is unaware of the DAV:checked-out property, then\n   how will they know it is \"locked\"?\n\nThe DAV:checked-out property has nothing to do with the locked status\nof a resource.  If you want to know if a resource is in the\nchecked-out state, you look to see if it has a non-null\nDAV:checked-out property.  If you want to know if a resource is\nlocked, you look at the DAV:lockdiscovery property.\n\n   From: Jim Amsden\n\n   If UserA does a CHECKOUT, the resource won't be locked, it will\n   just be checked out. PROPFIND on DAV:lockdiscovery won't show any\n   locks to anyone.\n\nRight.\n\n   Now UserB doesn't know anything about\n   versioning. If UserB just looks for locks and upon not finding any\n   assumes the resource is writable, the write will fail because the\n   resource is already checked out.\n\nThe write will succeed unless the locks and acl's of a resource\ndo not allow it (it is irrelevant whether userA or userB did the\nCHECKOUT ... the result is a writeable checked-out resource).\n\n   LOCK will also fail for the same\n   reason, it tries to do an implicit checkout.\n\nLOCK does not do an implicit CHECKOUT.  When the DAV:auto-version\nproperty is set, a write operation on a write-locked *checked-in*\nresource can automatically cause a CHECKOUT, but it is the write\noperation, not the LOCK that does the CHECKOUT, and this only occurs\nwhen the write-locked resource is in a *checked-in* state.\n\n   We assume that versioning unaware clients are not DAV unaware. That\n   is, they can use PROPFIND and look at properties, including\n   properties that indicate something is checked out. Its actually the\n   user that's interperting this information, not the client. The\n   client doesn't have to support any versioning specific protocol to\n   access these properties. Although such clients make their users do\n   extra work.\n\n   From: Lisa Dusseault [mailto:lisa@xythos.com]\n\n   That's impossible. Many clients won't show properties that they're\n   not aware of.  C.F. Web Folders.\n\nImpossible is a bit strong ... a WebDAV clients can (and arguably\nshould) show properties they are not aware of (otherwise dead\nproperties become rather useless).  And for clients that choose\nto display only the properties they know about, it is pretty much\ninevitable that a user of such a client will not be able to find\nout about protocol extensions such as versioning.\n\nCheers,\n\n\n\n", "id": "lists-006-9223235"}, {"subject": "Re: DAV:lockdiscovery on a checked-out resourc", "content": "Jim Amsden wrote:\n> If UserA does a CHECKOUT, the resource won't be locked, it will just be\nchecked\n> out.  PROPFIND on DAV:lockdiscovery won't show any locks to anyone.\n\nActually, the resource will have the same locked status as before the\nCHECKOUT.\n\n> Now UserB doesn't know anything about versioning. If UserB just looks for\n> locks and upon not finding any assumes the resource is writable, the\nwrite\n> will fail because the resource is already checked out.\n\nBeing checked-out does not make writes fail!  I'm not sure what you were\nthinking of here Jim, but when User B shows up, there is a checked-out VCR\nso, from a versioning point of view it is mutable.  The fact that it was\nUser A that did the CHECKOUT and User B that does the PUT is irrelevant in\nthe versioning story.  (Of course there is still the lock status that\nexisted before the checkout and acls etc to clear before you can be assured\nthat the write will succeed.)\n\n> LOCK will also fail for the same reason, it tries to do an implicit\ncheckout.\n\nLOCK doesn't do an implicit CHECKOUT -- ever.  Are you thinking of\nauto-versioning of a checked-in version-controlled resource?\n\n> We assume that versioning unaware clients are not DAV unaware. That\n> is, they can use PROPFIND and look at properties, including properties\n> that indicate something is checked out.\n\nWithin the versioning protocol we don't assume that version unaware clients\nhave any knowledge of the versioning properties to make things work, and we\nhave not put any such requirements on RFC2518, so I'm not sure what you\nmean here.\n\n> Its actually the user that's interperting this\n> information, not the client. The client doesn't have to support any\n> versioning specific protocol to access these properties. Although\n> such clients make their users do extra work.\n\nThat would require the user to be versioning aware, which is almost the\nsame thing.\n\nTim\n\n\n\n", "id": "lists-006-9233821"}, {"subject": "Re: DAV:lockdiscovery on a checked-out resourc", "content": "I guess all this boils down to is that UserA should first do a LOCK then a\nCHECKOUT?  ...or a CHECKOUT then a LOCK?\n\nBut section 4 \"CHECKOUT Option\" states: \"The checkout option provides an\nalternative method that avoids the complexity of the locking protocol\".\nHow am I to interpret this sentence based on what I've heard in this\nthread?\n\nThanks,\nSteve\n\n\n\n", "id": "lists-006-9243031"}, {"subject": "RE: DAV:lockdiscovery on a checked-out resourc", "content": "UserA's client could do it in either order.  It really doesn't matter.\nIf the client does the LOCK first, it maximizes the chance that UserA\nwill beat someone else who's trying to get a LOCK as well, but if\nsomeone else gets in with the LOCK of the checked out resource before\nyou, it just means you have to wait until they are done to make your\nchanges.\n\nAs for \"providing an alternative method\", this assumes you have\nmultiple workspaces or are using working resources.  In these\ncases, you just do CHECKOUT, update, CHECKIN.  No need really for\na LOCK, since you have your own private workspace or working\nresource.  Of course, you have\nto resolve merges in case you ended up doing this in parallel,\nso you avoid complexity only in cases where you don't end up in\na merge situation.\n\nIf you believe the \"avoids complexity\" sentence is misleading, let\nme know and I'll revise/remove it.\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Steve K Speicher [mailto:sspeiche@us.ibm.com]\nSent: Friday, March 23, 2001 7:08 AM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: DAV:lockdiscovery on a checked-out resource\n\n\n\nI guess all this boils down to is that UserA should first do a LOCK then a\nCHECKOUT?  ...or a CHECKOUT then a LOCK?\n\nBut section 4 \"CHECKOUT Option\" states: \"The checkout option provides an\nalternative method that avoids the complexity of the locking protocol\".\nHow am I to interpret this sentence based on what I've heard in this\nthread?\n\nThanks,\nSteve\n\n\n\n", "id": "lists-006-9250710"}, {"subject": "RE: DAV:lockdiscovery on a checked-out resourc", "content": "> If you believe the \"avoids complexity\" sentence is misleading, let\n> me know and I'll revise/remove it.\nIMHO: Since the sentence didn't state that it \"avoids complexity\" with the\nuse of workspaces or working-resources, I think it should be revised.\n\nSteve\n\n\n\n", "id": "lists-006-9259932"}, {"subject": "Re: DAV:lockdiscovery on a checked-out resourc", "content": "> I guess all this boils down to is that UserA should\n> first do a LOCK then a CHECKOUT?  ...or a CHECKOUT\n> then a LOCK?\n\nActually, it all boils down to 'what are you trying to do'?<g>\n\nLOCKing is designed to prevent the lost update problem.\nCHECKOUT marks a version-controlled resource as mutable, and is used with\nCHECKIN to create a new version.\n\nAcquiring a LOCK on a checked-in version-controlled resource is harmless,\nbut versioning semantics will prevent the content of the checked-in\nversion-controlled resource from changing anyway.\n\nSo it depends upon your client goals -- a typical sequence for updating\ncontent and capturing it in version history would be:\nLOCK /foo\nCHECKOUT /foo\nGET /foo\nPUT /foo\nCHECKIN /foo\nUNLOCK /foo\n\n(or even GET after LOCK and before CHECKOUT).\n\nThis will guarantee that the update that you PUT is based on the content\nthat you GET, and that the new state is captured in the version history.\nHowever, your initial LOCK does not prevent others from checking the\nresource out 'in parallel' and creating a 'branch' (there are other\nsolutions for that if it is of concern).\n\n> But section 4 \"CHECKOUT Option\" states: \"The checkout\n> option provides an alternative method that avoids the\n> complexity of the locking protocol\".\n> How am I to interpret this sentence based on what I've\n> heard in this thread?\n\nWell, to be fair you have to take that sentence in context.\nThe preceding sentence talks about the undesirable proliferation of\nversions that can occur if every modification is a new version, and how\nLOCK can be used to bound the version creation.  The locking protocol is\nonly 'complex' in that it obviously requires a DAV 2 server and client\n(i.e. capable of composing and parsing locking messages, considering the\nIf: header, remembering the lock token, etc.)  Maybe 'complexity' should be\nrewritten as 'overhead' or something a little less onerous.\n\nTim\n\n\n\n", "id": "lists-006-9267541"}, {"subject": "Re: DAV:lockdiscovery on a checked-out resourc", "content": "> Acquiring a LOCK on a checked-in version-controlled resource is harmless,\n> but versioning semantics will prevent the content of the checked-in\n> version-controlled resource from changing anyway.\n\nTake the following typical actions of a non-versioning aware client:\nLOCK /foo\nGET /foo\nPUT/foo\nUNLOCK /foo\n\nIf the resource is a VCR, then I think what you are saying is that the LOCK\nwill succeed and the PUT will fail (if DAV:auto-version is \"never\"), since\nthe resource is DAV:checked-in and modifying it would therefore change an\nalready existing version of /foo (not good).\nThough, if the PUT would fail with Locked status-code (assuming it would)\nbut the client would realize that they owned the lock on the resource and\nthink, \"Now what do I do?\".\n\nI realize that wanting your versioning server to be DAV class 2 compatible,\nyou wouldn't/shouldn't have DAV:auto-version  of \"never\".  Do I have a\npoint?  I guess I just want some justification on my interpretation of this\nand if the PUT does fail, with what status-code: \"423 Locked\", ???\n\nThanks,\nSteve\n\n\n\n", "id": "lists-006-9276779"}, {"subject": "RE: DAV:lockdiscovery on a checked-out resourc", "content": "   From: Steve K Speicher [mailto:sspeiche@us.ibm.com]\n\n   > Acquiring a LOCK on a checked-in version-controlled resource is\n   > harmless, but versioning semantics will prevent the content of\n   > the checked-in version-controlled resource from changing anyway.\n\n   Take the following typical actions of a non-versioning aware client:\n   LOCK /foo\n   GET /foo\n   PUT/foo\n   UNLOCK /foo\n\n   If the resource is a VCR, then I think what you are saying is that\n   the LOCK will succeed and the PUT will fail (if DAV:auto-version is\n   \"never\"), since the resource is DAV:checked-in and modifying it\n   would therefore change an already existing version of /foo (not\n   good).\n\nYes, modifying the body of a checked in version controlled resource is\nforbidden (in Section 2.10).\n\nNote: The PUT is being applied to a VCR, not a version, so it wouldn't\nchange an existing version of /foo in any case.\n\n   Though, if the PUT would fail with Locked status-code (assuming it\n   would) but the client would realize that they owned the lock on the\n   resource and think, \"Now what do I do?\".\n\nIt would not fail with a Locked status code (remember, a checkin is\nnot a lock).\n\n   I realize that wanting your versioning server to be DAV class 2\n   compatible, you wouldn't/shouldn't have DAV:auto-version of\n   \"never\".\n\nCorrect.\n\n   Do I have a point?  I guess I just want some justification on my\n   interpretation of this\n\nI'm not sure what you have in mind by \"justification\".  You can't\nmodify a checked-in VCR, since that would break the semantics that the\ncontent of the VCR is the same as its DAV:checked-in version.\n\n   and if the PUT does fail, with what status-code: \"423 Locked\", ???\n\nThe error response (defined in section 2.10, \"Additional PUT\nSemantics\"), would be a 403 (if the resource couldn't be checked out)\nor a 409 (if the resource could be checked out) with a\nDAV:cannot-modify-version-controlled-content tag in the response body.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9285420"}, {"subject": "Re: DAV:lockdiscovery on a checked-out resourc", "content": "If you're going to have DAV:auto-version == \"never\", then I'd simply suggest\nrefusing the LOCK request.\n\nAs an empirical data point, mod_dav with Subversion for a back-end will NOT\nsupport locking at all (nor auto-versioning). Some future version, maybe.\nInstead, we will simply require a version-aware client (which is fine; the\nSVN command line client is our only required client at this time, and it is\ncertainly aware :-)\n\nCheers,\n-g\n\nOn Mon, Mar 26, 2001 at 09:39:38AM -0500, Steve K Speicher wrote:\n> \n> > Acquiring a LOCK on a checked-in version-controlled resource is harmless,\n> > but versioning semantics will prevent the content of the checked-in\n> > version-controlled resource from changing anyway.\n> \n> Take the following typical actions of a non-versioning aware client:\n> LOCK /foo\n> GET /foo\n> PUT/foo\n> UNLOCK /foo\n> \n> If the resource is a VCR, then I think what you are saying is that the LOCK\n> will succeed and the PUT will fail (if DAV:auto-version is \"never\"), since\n> the resource is DAV:checked-in and modifying it would therefore change an\n> already existing version of /foo (not good).\n> Though, if the PUT would fail with Locked status-code (assuming it would)\n> but the client would realize that they owned the lock on the resource and\n> think, \"Now what do I do?\".\n> \n> I realize that wanting your versioning server to be DAV class 2 compatible,\n> you wouldn't/shouldn't have DAV:auto-version  of \"never\".  Do I have a\n> point?  I guess I just want some justification on my interpretation of this\n> and if the PUT does fail, with what status-code: \"423 Locked\", ???\n> \n> Thanks,\n> Steve\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-9294563"}, {"subject": "Proposed Simplifications to the DeltaV protoco", "content": "In Minneapolis, during the deltav design meeting and working group\nsession, we focused on looking for opportunities to simplify the\nprotocol.\n\nThe full minutes of the DeltaV meeting at Minneapolis should be\navailable soon, but I wanted to start a thread on issues that\ndirectly affect the protocol.  In particular, our area director\n(Ned) stated that there is only one group ahead of us for review,\nwhich means that we need to get a new draft prepared in a couple\nof weeks to keep our place in the queue.\n\nThe first proposed simplification came as a result of the Area\nDirector meeting the evening before.  A good part of that meeting was\noccupied with internationalization issues, especially when\ninternationalizable strings appeared in difficult-to-internationalize\ncontexts (such as request URL's and headers).\n\nThis immediately raised a red flag on the Label header, which is\nproposing to place internationalizable strings in exactly such a\ndifficult-to-internationalize context (i.e. a header).\n\nThe consensus of the room at the DeltaV working group session was that\nwe should remove the Label header, to avoid this internationalization\nproblems.  Since the Label header is an optimization (i.e. you can use\nPROPFIND to determine the information), this was considered the\nappropriate response to the area directors concern.  Note, the proposal\nis not to remove the LABEL method, just to remove the Label header.\n\nAny objections?\n\nThe second proposed simplification was to defer the \"Variant Option\".\nThis feature has received the least attention, and it was the\nconsensus of the room that it would be better to defer this feature\nuntil it has been reviewed by a wider group (since many people that\naren't interested in versioning are interested in variants).  Note: we\nstarted to use the term \"feature\" instead of the term \"option\".\n\nAny objections?\n\nThe third proposed simplification was to defer the \"Update Option\",\nwith the intention of leaving it out of the protocol unless its\naddition is more strongly motivated than it is currently.  In\nparticular, if you want to expose an older version of a VCR, you can\njust check out that VCR, copy that older version into the checked-out\nresource, and then check it back in.  This has the added advantage\nthat this does not block future work on a linear versioning server,\nthe way an UPDATE would (i.e. you can only check out the tip in a\nlinear versioning server).  It also has the advantage that it is more\ncompatible with the baseline and activity features, that want to\ndefine states as merges of baselines and activities, rather than\nmanipulations of individual versions.\n\nAny objections?\n\nThe fourth proposed simplification was to fold the \"branch control\"\nfeature into \"core\".  The idea here is that every versioning server\nshould expose whether or not it supports branching on checkout or\ncheckin, and that the additional \"branch-ok\" option to CHECKOUT and\nCHECKIN is simple enough to require of all servers.\n\nAny objections?\n\nThe fifth (and final) proposed simplification was to define a set of\nfour feature \"packages\", and to state that a versioning server SHOULD\nsupport at least one of those packages.  This then allows a versioning\nclient to look for one of the four defined feature packages, rather\nthan worrying about all possible combinations of features.  Note: a\nserver still exposes its functionality as a set of features.\n\nThe four packages proposed are:\n\nbasic versioning:\n   core\n   checkout\n\nclient workspace:\n   core\n   working resource\n   label\n\nconfiguration management:\n   core\n   checkout\n   version-history\n   workspace\n   merge\n   label\n   baseline\n   activity\n   version-controlled-collection\n\nclient workspace configuration management:\n   core\n   version-history\n   working-resource\n   merge\n   label\n   baseline\n   activity\n   version-controlled-collection\n\nAny objections to these packages?\n\nIf you'd like to contribute to this thread, please do so ASAP,\nso that we can meet the 2 week goal for a new internet draft.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9303714"}, {"subject": "Re: Proposed Simplifications to the DeltaV protoco", "content": "On Tue, Mar 27, 2001 at 12:40:51AM -0500, Clemm, Geoff wrote:\n>...\n> The consensus of the room at the DeltaV working group session was that\n> we should remove the Label header, to avoid this internationalization\n> problems.  Since the Label header is an optimization (i.e. you can use\n> PROPFIND to determine the information), this was considered the\n> appropriate response to the area directors concern.  Note, the proposal\n> is not to remove the LABEL method, just to remove the Label header.\n> \n> Any objections?\n\nHmm. I believe that I do. In my particular scenario, I have a VCC and need\nto PROPFIND one of many baselines, using a Label as the selector. Without\nthe Label header, I'd have to PROPFIND every single baseline to find the\nright one, wouldn't I? Is there something that I'm missing?\n\nAssuming that I haven't missed something, then yes: I would object. I can't\nsee how to create similar functionality in other ways.\n\n>... defer the Variant Option ...\n> \n> Any objections?\n\nDeferral is fine with me. I have no interest in this, and I honestly don't\nsee it as a useful feature for any versioning server. (IOW, with my personal\nhat on, and my independent hat on, I see no/little utility)\n\n> The third proposed simplification was to defer the \"Update Option\",\n> with the intention of leaving it out of the protocol unless its\n> addition is more strongly motivated than it is currently.  In\n> particular, if you want to expose an older version of a VCR, you can\n> just check out that VCR, copy that older version into the checked-out\n> resource, and then check it back in.  This has the added advantage\n> that this does not block future work on a linear versioning server,\n> the way an UPDATE would (i.e. you can only check out the tip in a\n> linear versioning server).  It also has the advantage that it is more\n> compatible with the baseline and activity features, that want to\n> define states as merges of baselines and activities, rather than\n> manipulations of individual versions.\n> \n> Any objections?\n\nI'm not sure about the proposed workaround (that appears to alter the tip,\nrather than expose an older resource), but I see little use for the\nUPDATE method, too. Consider: if you have a VCR that you intend to point at\nan old version for a long period of time, then why not just give out the\nversion resource URL to begin with? \n\nA server could also use bindings to establish a collection of older items.\nYou could use baselines. Lastly, you could expose a workspace that has been\nsmacked with MERGE to point at old resources.\n\nIOW, I tend to see VCRs as always floating to the latest. Tweaking their\nvalue (other than as part of a checkin) seems of little utility.\n\nI'm happy to defer/punt the feature.\n\n>... folding branch control into the core ...\n> \n> Any objections?\n\nTotally fine. That isn't a big change/imposition.\n\n>... packages ...\n> client workspace configuration management:\n>    core\n>    version-history\n>    working-resource\n>    merge\n>    label\n>    baseline\n>    activity\n>    version-controlled-collection\n\nHey! That looks like Subversion :-)\n\n> Any objections to these packages?\n\nNope.\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-9315653"}, {"subject": "Eliminating the Label heade", "content": "> Since the Label header is an optimization (i.e. you can use\n> PROPFIND to determine the information), this was considered the\n> appropriate response to the area directors concern.\n\nIt seems like a pretty significant optimization. Is there any other way for\na client to implement the \"find labeled version\" function other than getting\nthe label-name-set property on every single version in a history? Yes, this\ncan be done with a single request, using the version-tree report, but\ncomputing the response can be very expensive for a server (having thousands\nof versions in a history will not be unusual, at least in our installed\nbase).\n\nA server may have a much more efficient way to find a version with a label.\nIf the find-labeled-version function seems useful, how about adding a report\nfor it? (The function seems useful to me; I'm thinking of the number of\ntimes I want to compare two versions of something, where at least one of\nthem is denoted by a label.)\n\nJohn\n\n\n\n", "id": "lists-006-9326005"}, {"subject": "RE: Eliminating the Label heade", "content": "   From: Vasta, John [mailto:jvasta@Rational.Com]\n\n   > Since the Label header is an optimization (i.e. you can use\n   > PROPFIND to determine the information), this was considered the\n   > appropriate response to the area directors concern.\n\n   It seems like a pretty significant optimization. Is there any other\n   way for a client to implement the \"find labeled version\" function\n   other than getting the label-name-set property on every single\n   version in a history? Yes, this can be done with a single request,\n   using the version-tree report, but computing the response can be\n   very expensive for a server (having thousands of versions in a\n   history will not be unusual, at least in our installed base).\n\n   A server may have a much more efficient way to find a version with\n   a label.  If the find-labeled-version function seems useful, how\n   about adding a report for it? (The function seems useful to me; I'm\n   thinking of the number of times I want to compare two versions of\n   something, where at least one of them is denoted by a label.)\n\nGood point.  We do need to resurrect the \"DAV:labeled-version\" report\n(analogous to the DAV:latest-activity-version report), so you can get\nthis information in an efficient standard way.\n\nSo I will amend the proposal to say \"replace the Label header with the\nDAV:labeled-version report\" (note: the report does not have the Label\nheader internationalization problems, because the label is marshalled\nas XML).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9334025"}, {"subject": "Re: Proposed Simplifications to the DeltaV protoco", "content": ">The fifth (and final) proposed simplification was to define a set of\n>four feature \"packages\", and to state that a versioning server SHOULD\n>support at least one of those packages.  This then allows a versioning\n>client to look for one of the four defined feature packages, rather\n>than worrying about all possible combinations of features.  Note: a\n>server still exposes its functionality as a set of features.\n\nAre these \"packages\" going to be represented as \"DAV Compliance Classes\"?\nFor example, classes 3, 4, 5 & 6.\n\nJust curious.  Thanks,\nSteve\n\n\n\n", "id": "lists-006-9343026"}, {"subject": "RE: Proposed Simplifications to the DeltaV protoco", "content": "No, we would not propose that the \"feature sets\" have defined\n\"compliance level\" tags.  The intent is to allow \nnew \"feature sets\" to be created,\nwithout requiring a new \"tag\" to be defined for compliance checking.\n\nIn particular, suppose you define a new feature set that is\nsome old feature set (e.g. \"a\", \"b\", \"c\") plus features \"x\" and \"y\".\nInstead of having to add another tag, you can just publish that\n\"a\", \"b\", \"c\", \"x\", \"y\" is now a \"package\", and then a server\nthat supports that package would return:\n\"a\", \"b\", \"c\", \"x\", \"y\".\n\nThe old clients will check if \"a\", \"b\", \"c\" are all in\nthe supported feature set of a server,\nand if so, they will talk to it.\n\nThe new clients will check if \"a\", \"b\", \"c\", \"x\", \"y\" are all in\nthe feature set.\n\nAnd for non-standard clients that just care about \"do you support\nfeature x\", they will be able to find that out as well.\n\nCheers,\nGeoff\n\n\n-----Original Message-----\nFrom: Steve K Speicher [mailto:sspeiche@us.ibm.com]\nSent: Tuesday, March 27, 2001 2:51 PM\nTo: ietf-dav-versioning@w3.org\nSubject: Re: Proposed Simplifications to the DeltaV protocol\n\n\n\n\n>The fifth (and final) proposed simplification was to define a set of\n>four feature \"packages\", and to state that a versioning server SHOULD\n>support at least one of those packages.  This then allows a versioning\n>client to look for one of the four defined feature packages, rather\n>than worrying about all possible combinations of features.  Note: a\n>server still exposes its functionality as a set of features.\n\nAre these \"packages\" going to be represented as \"DAV Compliance Classes\"?\nFor example, classes 3, 4, 5 & 6.\n\nJust curious.  Thanks,\nSteve\n\n\n\n", "id": "lists-006-9350948"}, {"subject": "Re: Eliminating the Label heade", "content": "On Tue, Mar 27, 2001 at 01:35:13PM -0500, Clemm, Geoff wrote:\n>    From: Vasta, John [mailto:jvasta@Rational.Com]\n>...\n>    A server may have a much more efficient way to find a version with\n>    a label.  If the find-labeled-version function seems useful, how\n>    about adding a report for it? (The function seems useful to me; I'm\n>    thinking of the number of times I want to compare two versions of\n>    something, where at least one of them is denoted by a label.)\n> \n> Good point.  We do need to resurrect the \"DAV:labeled-version\" report\n> (analogous to the DAV:latest-activity-version report), so you can get\n> this information in an efficient standard way.\n\nNot completely efficient... it adds a round trip.\n\nWith the Label header, I can \"redirect through\" the VCR and operate against\nthe Version Resource. Using the report, I send one request to run the report\nand get the VR, then a second request to operate against the VR.\n\nWhat would be really neat is a way to specify a label within an\nexpand-property report. For my particular use-case, that would collapse a\nwhole sequence of PROPFINDs into a single report. Is there any interest in\nallowing this? (i.e. should I propose a syntax?)\n\nCheers,\n-g\n\n-- \nGreg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-9360924"}, {"subject": "Re: Eliminating the Label heade", "content": "I'd be tempted to not add this yet ... if you are just asking about one\nresource, then an extra round trip is not very significant.  If you are\nfaking baselines with labels, then we are recommending that you just\nexpose this as baselines (which have a baseline-collection property that\nyou can run the standard property report against).\n\nIf in practice we find this extra round trip to be prohibitively\nexpensive, we could always extend the property report later (but\nlooking at the extra syntax now would be a good way to confirm that\nwe could easily add it later).\n\nCheers,\nGeoff\n\n\n   Date: Tue, 27 Mar 2001 17:28:09 -0800\n   From: Greg Stein <gstein@lyra.org>\n\n   On Tue, Mar 27, 2001 at 01:35:13PM -0500, Clemm, Geoff wrote:\n   >    From: Vasta, John [mailto:jvasta@Rational.Com]\n   >...\n   >    A server may have a much more efficient way to find a version with\n   >    a label.  If the find-labeled-version function seems useful, how\n   >    about adding a report for it? (The function seems useful to me; I'm\n   >    thinking of the number of times I want to compare two versions of\n   >    something, where at least one of them is denoted by a label.)\n   > \n   > Good point.  We do need to resurrect the \"DAV:labeled-version\" report\n   > (analogous to the DAV:latest-activity-version report), so you can get\n   > this information in an efficient standard way.\n\n   Not completely efficient... it adds a round trip.\n\n   With the Label header, I can \"redirect through\" the VCR and operate against\n   the Version Resource. Using the report, I send one request to run the report\n   and get the VR, then a second request to operate against the VR.\n\n   What would be really neat is a way to specify a label within an\n   expand-property report. For my particular use-case, that would collapse a\n   whole sequence of PROPFINDs into a single report. Is there any interest in\n   allowing this? (i.e. should I propose a syntax?)\n\n   Cheers,\n   -g\n\n   -- \n   Greg Stein, http://www.lyra.org/\n\n\n\n", "id": "lists-006-9369503"}, {"subject": "RE: Proposed Simplifications to the DeltaV protoco", "content": "I love it.\n\nI'm not going to look for fine details that may be impacted by this and need\nto be caught.  Others who have been living with the spec every day will do\nthat.\n\nI am fully supportive of the kind of simplification this represents and the\nclarity with which it is arrived at.\n\nThis is exciting.  I can see that you are in the home stretch.\n\n-- Dennis\n\nAIIM DMware Technical Coordinator\nAIIM DMware http://www.infonuovo.com/dmware\nODMA Support http://www.infonuovo.com/odma\n------------------\nDennis E. Hamilton            tel. +1-425-793-0283\nmailto:orcmid@email.com       fax. +1-425-430-8189\n\n\n\n-----Original Message-----\nFrom: ietf-dav-versioning-request@w3.org\n[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\nSent: Monday, March 26, 2001 21:41\nTo: ietf-dav-versioning@w3.org\nSubject: Proposed Simplifications to the DeltaV protocol\n\n\n\nIn Minneapolis, during the deltav design meeting and working group\nsession, we focused on looking for opportunities to simplify the\nprotocol.\n\nThe full minutes of the DeltaV meeting at Minneapolis should be\navailable soon, but I wanted to start a thread on issues that\ndirectly affect the protocol.  In particular, our area director\n(Ned) stated that there is only one group ahead of us for review,\nwhich means that we need to get a new draft prepared in a couple\nof weeks to keep our place in the queue.\n\nThe first proposed simplification came as a result of the Area\nDirector meeting the evening before.  A good part of that meeting was\noccupied with internationalization issues, especially when\ninternationalizable strings appeared in difficult-to-internationalize\ncontexts (such as request URL's and headers).\n\nThis immediately raised a red flag on the Label header, which is\nproposing to place internationalizable strings in exactly such a\ndifficult-to-internationalize context (i.e. a header).\n\nThe consensus of the room at the DeltaV working group session was that\nwe should remove the Label header, to avoid this internationalization\nproblems.  Since the Label header is an optimization (i.e. you can use\nPROPFIND to determine the information), this was considered the\nappropriate response to the area directors concern.  Note, the proposal\nis not to remove the LABEL method, just to remove the Label header.\n\nAny objections?\n\nThe second proposed simplification was to defer the \"Variant Option\".\nThis feature has received the least attention, and it was the\nconsensus of the room that it would be better to defer this feature\nuntil it has been reviewed by a wider group (since many people that\naren't interested in versioning are interested in variants).  Note: we\nstarted to use the term \"feature\" instead of the term \"option\".\n\nAny objections?\n\nThe third proposed simplification was to defer the \"Update Option\",\nwith the intention of leaving it out of the protocol unless its\naddition is more strongly motivated than it is currently.  In\nparticular, if you want to expose an older version of a VCR, you can\njust check out that VCR, copy that older version into the checked-out\nresource, and then check it back in.  This has the added advantage\nthat this does not block future work on a linear versioning server,\nthe way an UPDATE would (i.e. you can only check out the tip in a\nlinear versioning server).  It also has the advantage that it is more\ncompatible with the baseline and activity features, that want to\ndefine states as merges of baselines and activities, rather than\nmanipulations of individual versions.\n\nAny objections?\n\nThe fourth proposed simplification was to fold the \"branch control\"\nfeature into \"core\".  The idea here is that every versioning server\nshould expose whether or not it supports branching on checkout or\ncheckin, and that the additional \"branch-ok\" option to CHECKOUT and\nCHECKIN is simple enough to require of all servers.\n\nAny objections?\n\nThe fifth (and final) proposed simplification was to define a set of\nfour feature \"packages\", and to state that a versioning server SHOULD\nsupport at least one of those packages.  This then allows a versioning\nclient to look for one of the four defined feature packages, rather\nthan worrying about all possible combinations of features.  Note: a\nserver still exposes its functionality as a set of features.\n\nThe four packages proposed are:\n\nbasic versioning:\n   core\n   checkout\n\nclient workspace:\n   core\n   working resource\n   label\n\nconfiguration management:\n   core\n   checkout\n   version-history\n   workspace\n   merge\n   label\n   baseline\n   activity\n   version-controlled-collection\n\nclient workspace configuration management:\n   core\n   version-history\n   working-resource\n   merge\n   label\n   baseline\n   activity\n   version-controlled-collection\n\nAny objections to these packages?\n\nIf you'd like to contribute to this thread, please do so ASAP,\nso that we can meet the 2 week goal for a new internet draft.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9378637"}, {"subject": "Re: Proposed Simplifications to the DeltaV protoco", "content": "> In Minneapolis, during the deltav design meeting\n> and working group session, we focused on looking\n> for opportunities to simplify the protocol.\n>\n> The full minutes of the DeltaV meeting at Minneapolis\n> should be available soon,\n\nI shall eagery await them.\n\n> but I wanted to start a thread on issues that directly\n> affect the protocol.  In particular, our area director\n> (Ned) stated that there is only one group ahead of us\n> for review, which means that we need to get a new draft\n> prepared in a couple of weeks to keep our place in the\n> queue.\n\nGreat.\n\n> The first proposed simplification came as a result of\n> the Area Director meeting the evening before.  A good\n> part of that meeting was occupied with internationalization\n> issues, especially when internationalizable strings\n> appeared in difficult-to-internationalize contexts\n> (such as request URL's and headers).\n>\n> This immediately raised a red flag on the Label header,\n> which is proposing to place internationalizable strings\n> in exactly such a difficult-to-internationalize context\n> (i.e. a header).\n\nI don't see what the problem is here.  We have declared the character\nencoding for the label header (UTF-8) to be inclusive of multiple character\nrepresentations.  We are not faced with national language issues, since\nclients will not be rendering the labels in different languages -- if it is\nlabelled 'release 1.0' that will not be translated into the equivalent\nFrench, German, or whatever.  So as I understand it we need only address\nthe encoding scheme; and this has been done.\nAre you suggesting that that language should also be retained with the\nlabel?\n\n> The consensus of the room at the DeltaV working group\n> session was that we should remove the Label header, to\n> avoid this internationalization problems.\n\nI need to see the explaination of the problem.\n\n> Since the Label header is an optimization (i.e. you can\n> use PROPFIND to determine the information), this was\n> considered the appropriate response to the area directors\n> concern.  Note, the proposal is not to remove the LABEL\n> method, just to remove the Label header.\n>\n> Any objections?\n\nI think this is unnecessary.\nUnless servers are required to retain the language information declared in\nthe body of the LABEL it seems pointless.\nIn addition, I agree with John that this is a significant optimization\n(even if there were a label report) that was added to the document early\non, did not cause any objections, and we should strive to keep it in.\n\n> The second proposed simplification was to defer the\n> \"Variant Option\".  This feature has received the least\n> attention, and it was the consensus of the room that\n> it would be better to defer this feature until it has\n> been reviewed by a wider group (since many people that\n> aren't interested in versioning are interested in variants).\n> Note: we started to use the term \"feature\" instead of\n> the term \"option\".\n>\n> Any objections?\n\nNo.  Good riddance.\n\n> The third proposed simplification was to defer the\n> \"Update Option\", with the intention of leaving it out\n> of the protocol unless its addition is more strongly\n> motivated than it is currently.  In particular, if you\n> want to expose an older version of a VCR, you can just\n> check out that VCR, copy that older version into the\n> checked-out resource, and then check it back in.  This\n> has the added advantage that this does not block future\n> work on a linear versioning server, the way an UPDATE\n> would (i.e. you can only check out the tip in a linear\n> versioning server).  It also has the advantage that it\n> is more compatible with the baseline and activity\n> features, that want to define states as merges of\n> baselines and activities, rather than manipulations of\n> individual versions.\n>\n> Any objections?\n\nI strongly object to this one.  If you have any respect for version history\nthen using UPDATE to expose the older version of a vcr is *significantly*\ndifferent to extending the tip with an equivalent version.  Disallowing\nUPDATE will cause significant growth in the number of versions for those\nsystems that routinely roll time back-and-forth for a set of resources.\n\nGreg's suggestion of using version url's is unsatisfactory since it does\nnot allow for documents that contain links (based on vcr names).\n\n> The fourth proposed simplification was to fold the \"branch\n> control\" feature into \"core\".  The idea here is that every\n> versioning server should expose whether or not it supports\n> branching on checkout or checkin, and that the additional\n> \"branch-ok\" option to CHECKOUT and CHECKIN is simple enough\n> to require of all servers.\n>\n> Any objections?\n\nThat's fine.\n\n> The fifth (and final) proposed simplification was to define\n> a set of four feature \"packages\", and to state that a\n> versioning server SHOULD support at least one of those\n> packages.  This then allows a versioning client to look for\n> one of the four defined feature packages, rather than\n> worrying about all possible combinations of features.  Note:\n> a server still exposes its functionality as a set of features.\n>\n> The four packages proposed are:\n>\n> basic versioning:\n>    core\n>    checkout\n>\n> client workspace:\n>    core\n>    working resource\n>    label\n\nHow do you create a working resource if you don't have checkout?\n\n> configuration management:\n>    core\n>    checkout\n>    version-history\n>    workspace\n>    merge\n>    label\n>    baseline\n>    activity\n>    version-controlled-collection\n>\n> client workspace configuration management:\n>    core\n>    version-history\n>    working-resource\n>    merge\n>    label\n>    baseline\n>    activity\n>    version-controlled-collection\n\nDitto -- for checkout.\n\n> Any objections to these packages?\n\nSince they are only SHOULD's it would be difficult to object <g>.\nAre they useful ... ?\n\n> If you'd like to contribute to this thread, please do so ASAP,\n> so that we can meet the 2 week goal for a new internet draft.\n\nDone.\n\nTim\n\n\n\n", "id": "lists-006-9392387"}, {"subject": "Save UPDATE ", "content": "> > The third proposed simplification was to defer the\n> > \"Update Option\", with the intention of leaving it out\n> > of the protocol unless its addition is more strongly\n> > motivated than it is currently.  In particular, if you\n> > want to expose an older version of a VCR, you can just\n> > check out that VCR, copy that older version into the\n> > checked-out resource, and then check it back in.  This\n> > has the added advantage that this does not block future\n> > work on a linear versioning server, the way an UPDATE\n> > would (i.e. you can only check out the tip in a linear\n> > versioning server).  It also has the advantage that it\n> > is more compatible with the baseline and activity\n> > features, that want to define states as merges of\n> > baselines and activities, rather than manipulations of\n> > individual versions.\n> >\n> > Any objections?\n> \n> I strongly object to this one.  If you have any respect for version history\n> then using UPDATE to expose the older version of a vcr is *significantly*\n> different to extending the tip with an equivalent version.\nI agree.\nBTW, could you expose an older version in a workspace without UPDATE ?\n\nCheers, Edgar  \n\n-- \nedgar@edgarschwarz.de                    http://www.edgarschwarz.de\n*          DOSenfreie Zone.        Running Native Oberon.         *\nMake it as simple as possible, but not simpler.     Albert Einstein\n\n\n\n", "id": "lists-006-9405736"}, {"subject": "RE: Proposed Simplifications to the DeltaV protoco", "content": "This isn't exactly what I understood from the meeting.  I was very excited\nabout the \"feature sets\" idea because I understood that these would be a\nnormative part of the specification, not merely an informative thing.\nLanguage is always so slippery....\n\nMy assumption: If anybody can create a new \"feature set\" and inform the\nworld what their set is, then there's no value to feature sets.\n\nI do, however, understand that some servers will want to support a feature\nset plus an extra feature or two.  So I propose that there be some way to\nname each feature set, plus to name features on top.  Then the OPTIONS\nresponse for my server would indicate:\n - I support BASE feature set\n - I also support features X and Y (which are not part of BASE)\n\nAnother server might support BASE, feature X, Y and also Z.  If BASE + X + Y\n+ Z == FEATURE_SET_1, then the OPTIONS response would only have one string\nfor this server:\n - I support FEATURE_SET_1\n\nAlso, I would propose that BASE replace the concept of CORE.  It's way too\nconfusing to have a difference.  BASE should be the set of features that all\nservers must implement:  the old concept of core, plus checkout, plus\nfork-control parsing (even if disallowed).\n\nTaking these steps puts few actual restrictions on the servers.  They can\nstill decide to support an arbitrary set of features.  There is only a\npsychological pressure (which I think is a good thing) to implement a\ndefined package rather than a random set of features.  The next value of\nthis is that it's much easier for a client to identify their supported\nfeature sets.\n\nlisa\n\n\n> -----Original Message-----\n> From: ietf-dav-versioning-request@w3.org\n> [mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Clemm, Geoff\n> Sent: Tuesday, March 27, 2001 3:05 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: RE: Proposed Simplifications to the DeltaV protocol\n>\n>\n> No, we would not propose that the \"feature sets\" have defined\n> \"compliance level\" tags.  The intent is to allow\n> new \"feature sets\" to be created,\n> without requiring a new \"tag\" to be defined for compliance checking.\n>\n> In particular, suppose you define a new feature set that is\n> some old feature set (e.g. \"a\", \"b\", \"c\") plus features \"x\" and \"y\".\n> Instead of having to add another tag, you can just publish that\n> \"a\", \"b\", \"c\", \"x\", \"y\" is now a \"package\", and then a server\n> that supports that package would return:\n> \"a\", \"b\", \"c\", \"x\", \"y\".\n>\n> The old clients will check if \"a\", \"b\", \"c\" are all in\n> the supported feature set of a server,\n> and if so, they will talk to it.\n>\n> The new clients will check if \"a\", \"b\", \"c\", \"x\", \"y\" are all in\n> the feature set.\n>\n> And for non-standard clients that just care about \"do you support\n> feature x\", they will be able to find that out as well.\n>\n> Cheers,\n> Geoff\n>\n>\n> -----Original Message-----\n> From: Steve K Speicher [mailto:sspeiche@us.ibm.com]\n> Sent: Tuesday, March 27, 2001 2:51 PM\n> To: ietf-dav-versioning@w3.org\n> Subject: Re: Proposed Simplifications to the DeltaV protocol\n>\n>\n>\n>\n> >The fifth (and final) proposed simplification was to define a set of\n> >four feature \"packages\", and to state that a versioning server SHOULD\n> >support at least one of those packages.  This then allows a versioning\n> >client to look for one of the four defined feature packages, rather\n> >than worrying about all possible combinations of features.  Note: a\n> >server still exposes its functionality as a set of features.\n>\n> Are these \"packages\" going to be represented as \"DAV Compliance Classes\"?\n> For example, classes 3, 4, 5 & 6.\n>\n> Just curious.  Thanks,\n> Steve\n\n\n\n", "id": "lists-006-9413620"}, {"subject": "Version-controlled collection resources - I am still missing somethin", "content": "Well, its been a day or two since my last question (or was it just the\nweekend? :-), so here goes.\n\nI am still missing a vital point (which may have been explained, but my\nneurons have not connected yet) relating to version-controlled collection\nresources. Either that or it was a good weekend and I cannot remember\nwhat was said last week (blush)...\n\nI can use VERSION-CONTROL to create a new version controlled resource\n(VCR) by identifying a version resource (VR). If the VR holds the\nversioning information for a collection, then the VCR will be a\ncollection resource.\n\nWhat bindings will be in the VCR collection resource? Will it be an\nempty directory? Or will it automatically have bindings to version\nhistories? (and what does this mean??) Or...\n\nBasically I am trying to understand how to create a workspace, then\npopulate it with with non-checked-out version control instances.\nWhat commands do I need to do? If I do a VERSION-CONTROL command,\nI can get a version-controlled-resource referencing a version-resource.\nI understand this for a non-collection resource. But what about a\ncollection resource? I guess I get a collection with bindings to\nversion histories(????). Do I then use VERSION-CONTROL to replace the\nbindings to version-history resources with bindings to version-controlled\nresources? Or using VERSION-CONTROL to get a collection, does it\nmagically walk the whole collection tree from that point down creating\nversion-controlled-resource instances to all the resources in the\nwhole collection tree?\n\nHmmm. Not sure if the above makes much sense. Put simply, I have\na project with a tree of files. I want to create a workspace (for\nserver side versioning) then get a read-only copy of all the files\n(\"Get Latest Version\" in Microsoft Visual Source Safe) in the project.\nI do not want to check them out yet. I want to do that later.\nI just want to read the files then later check out the files I\nactually want to modify. I am not sure of the complete sequence\nof commands to do this. (With an example of such a sequence, all\nmy other questions probably go away.)\n\nI tried to work it out reading the spec. (Don't both commenting on\nthe following if you have replied already clearly to the above.)\nI think the answer to the above makes a big difference to my understanding\nof the following. The DeltaV spec I have says\n\n    14 Version-Controlled-Collection Feature\n    Although a collection version only records the version-controlled\n    bindings of a collection, a version controlled collection MAY\n    contain both version-controlled and non-version-controlled\n    bindings. Non-version-controlled bindings are not under version\n    control, and therefore can be added or deleted without checking\n    out the version-controlled collection.\n    \nSo collections can contain both version-controlled and\nnon-version-controlled resources at the same time.\nI assume that I can create and delete non-version-controlled resources\nin the directory whether the collection is checked-out or not.\n\nThis continues with text talking about Lock Null resources.\n\n    This feature is essential for the support of lock null resources,\n    since a lock null resource is a temporary internal member of a\n    collection that should only exist for the duration of the lock, and\n    should not be captured in the version history of tha coolection.\n\nIf we do not have lock null resources, does this mean that we no\nlonger need to be able to create non-version-controlled-resources\nunder a version-controlled collection? (My guess this is not the case,\nbut it seemed topical.)\n\n    14.10 Additional CHECKOUT Semantics\n    ... If the request has been applied to a collection version, the\n    new working collection MUST be initalized to contain a binding to\n    each of the history resources identified in the\n    DAV:version-controlled-binding-set of that collection version.\n\nDoes this delete references to any other bindings to non-version-controlled\nresources that are in the working directory? My guess is not. But what\nif there is a collision? (Eg: a non-version-controlled resource\nis created called FOO then the collection is checked out which contains\na FOO binding. Does the CHECKOUT fail? etc.)\n\nOr, if using VERSION-CONTROL to get a collection resource does\npopulate it with all bindings (ie, the working collection is not\nempty), then the only way to get a collision is to have deleted\nthe binding before hand (in which case there is probably no danger\nas you probably are not permitted to delete a resource-controlled\nbinding if the collection resource is not checked out).\n\nThanks as always.\n\nAlan\n\nps: Boy this can be a tounge/brain twister!\n\n\n\n", "id": "lists-006-9779547"}, {"subject": "RE: Version-controlled collection resources - I am still missing  somethin", "content": "   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n\n   I can use VERSION-CONTROL to create a new version controlled\n   resource (VCR) by identifying a version resource (VR). If the VR\n   holds the versioning information for a collection, then the VCR\n   will be a collection resource.\n\nYes.\n\n   What bindings will be in the VCR collection resource? Will it be an\n   empty directory? Or will it automatically have bindings to version\n   histories? (and what does this mean??) Or...\n\nGood catch!  The intent was for the semantics of VERSION-CONTROL for a\ncollection version to be the same as the semantics of UPDATE for a\ncollection version (see Section 14.12), but this of course should be\nstated explicitly.  In particular, the new version-controlled\ncollection should have a version-controlled member for each version\ncontrolled binding specified in the DAV:version-controlled-binding-set\nof that collection version.\n\nSo following text should have appeared in section 14.9 (additional\nVERSION-CONTROL semantics for version-controlled collections):\n\n Additional Postconditions:\n\n (DAV:new-version-controlled-collection): If the request body\n identified a collection version, the collection at the request-URL\n MUST contain a version-controlled internal member for each\n DAV:version-controlled-binding specified in the\n DAV:version-controlled-binding-set of the collection version, where\n the name and DAV:version-history of the internal member MUST be the\n DAV:binding-name and the DAV:version-history specified by the\n DAV:version-controlled-binding.  If the internal member is a member of\n a workspace, and there is another member of the workspace for the same\n version history, the DAV:version of the internal member MUST be the\n DAV:version of that other member; otherwise, the DAV:version MUST be\n the DAV:root-version of the version history.\n\nIf nobody has any objections to this text, I'll add this to the\nnext working draft.\n\n   Basically I am trying to understand how to create a workspace, then\n   populate it with with non-checked-out version control instances.\n   What commands do I need to do?\n\nYou need to do an initial VERSION-CONTROL request to get the\nfirst version-controlled collection into the workspace, and\nthen do a sequence of MERGE (or UPDATE) requests to populate\nthe members of that collection with the desired versions.\n\nIf you put a collection under baseline-control, you can set the\nversions of all the members of that collection with a single MERGE of\na baseline into that baseline-controlled collection.\n\n   If I do a VERSION-CONTROL command,\n   I can get a version-controlled-resource referencing a version-resource.\n\nYes (the version resource is referenced by the DAV:checked-in\nproperty of the VCR).\n\n   I understand this for a non-collection resource. But what about a\n   collection resource? I guess I get a collection with bindings to\n   version histories(????).\n\nYou get a version-controlled collection whose members are \nnew version-controlled resources for those version histories\n(initially selecting the DAV:root-version of those version\nhistories).\n\n   Do I then use VERSION-CONTROL to replace the\n   bindings to version-history resources with bindings to version-controlled\n   resources?\n\nYou would use MERGE to adust the DAV:checked-in version of the\ninternal members.\n\n   Or using VERSION-CONTROL to get a collection, does it\n   magically walk the whole collection tree from that point down creating\n   version-controlled-resource instances to all the resources in the\n   whole collection tree?\n\nA collection version doesn't specify what versions of its members\nshould be selected, but a baseline (i.e. a configuration version)\ndoes.  So to create a whole version-controlled collection tree in a\nsingle requests from an existing baseline, you can use\nBASELINE-CONTROL.\n\n   Hmmm. Not sure if the above makes much sense. Put simply, I have\n   a project with a tree of files. I want to create a workspace (for\n   server side versioning) then get a read-only copy of all the files\n   (\"Get Latest Version\" in Microsoft Visual Source Safe) in the project.\n   I do not want to check them out yet. I want to do that later.\n   I just want to read the files then later check out the files I\n   actually want to modify. I am not sure of the complete sequence\n   of commands to do this. (With an example of such a sequence, all\n   my other questions probably go away.)\n\nVERSION-CONTROL /ws/alan/src \n<D:version> <D:href> http://repo/coll-ver/345 </D:href> </D:version>\n\n# assume that coll-ver/345 has bindings named a.html, sub, and othersub\n# in its DAV:version-controlled-binding-set\n\nMERGE /ws/alan/src/a.html\n<D:source> <D:href> http://repo/ver/4901 </D:href> </D:source>\n\nMERGE /ws/alan/sub\n<D:source> <D:href> http://repo/coll-ver/234 </D:href> </D:source>\n\n# assume that coll-ver/234 has a binding named b.html\n# in its DAV:version-controlled-binding-set\n\nMERGE /ws/alan/sub/b.html\n<D:source> <D:href> http://repo/ver/3244 </D:href> </D:source>\n\n# assume that there is a baseline for othersub\n\nBASELINE-CONTROL /ws/alan/othersub\n<D:baseline> <D:href> http://repo/bl/267 </D:href> </D:baseline>\n\n   The DeltaV spec I have says\n\n       14 Version-Controlled-Collection Feature\n       Although a collection version only records the version-controlled\n       bindings of a collection, a version controlled collection MAY\n       contain both version-controlled and non-version-controlled\n       bindings. Non-version-controlled bindings are not under version\n       control, and therefore can be added or deleted without checking\n       out the version-controlled collection.\n\n   So collections can contain both version-controlled and\n   non-version-controlled resources at the same time.\n\nYes, a version-controlled collection can (but note that only\nthe version-controlled bindings are captured by a collection\nversion, so the non-version-controlled members are not \"shared\"\nby other workspaces).\n\n   I assume that I can create and delete non-version-controlled resources\n   in the directory whether the collection is checked-out or not.\n\nYes.\n\n   This continues with text talking about Lock Null resources.\n\n       This feature is essential for the support of lock null resources,\n       since a lock null resource is a temporary internal member of a\n       collection that should only exist for the duration of the lock, and\n       should not be captured in the version history of tha coolection.\n\n   If we do not have lock null resources, does this mean that we no\n   longer need to be able to create non-version-controlled-resources\n   under a version-controlled collection? (My guess this is not the case,\n   but it seemed topical.)\n\nThere are other reasons to have non-version-controlled bindings.\nIn particular, if your server supports server-side build management,\nthen the derived files (e.g. results of compilation or other kinds\nof processing) are commonly stored as non-version-controlled\nbindings.  Other kinds of derived resources are index resources that\nspeed up searching within a collection (like the emacs TAG files).\n\n       14.10 Additional CHECKOUT Semantics\n       ... If the request has been applied to a collection version, the\n       new working collection MUST be initalized to contain a binding to\n       each of the history resources identified in the\n       DAV:version-controlled-binding-set of that collection version.\n\n   Does this delete references to any other bindings to\n   non-version-controlled resources that are in the working directory?\n   My guess is not.  But what if there is a collision? (Eg: a\n   non-version-controlled resource is created called FOO then the\n   collection is checked out which contains a FOO binding. Does the\n   CHECKOUT fail? etc.)\n\nNote that applying a CHECKOUT to a collection version is only\ndone with the client-workspace package.  There you are not checking\nout the version-controlled collection, but rather creating a\nfresh new working collection, with bindings to version histories\n(very different from what happens when you CHECKOUT a\nversion-controlled collection).\n\nWhen you CHECKOUT a version-controlled collection, there never\nis a collision because a CHECKOUT of a VCC does not change any\nof the bindings of that VCC.\n\nBUT, you can create the collision you describe with an UPDATE or MERGE\nrequest.  In this case, the rules in section 14.1.1 apply (the dreaded\n\"eclipsed-set\" that Tim referred to earlier :-).  The rule is pretty\nsimple though ... if a version-controlled collection has a\nversion-controlled binding that has the same name as a\nnon-version-controlled binding, the non-version-controlled binding is\nthe one that is visible.\n\n   Or, if using VERSION-CONTROL to get a collection resource does\n   populate it with all bindings (ie, the working collection is not\n   empty), then the only way to get a collision is to have deleted\n   the binding before hand (in which case there is probably no danger\n   as you probably are not permitted to delete a resource-controlled\n   binding if the collection resource is not checked out).\n\n   ps: Boy this can be a tounge/brain twister!\n\nWe *really* appreciate you working through all the tricky bits!  The\nrest of us have been up and down this road too long to notice the\nmissing signposts (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9790689"}, {"subject": "Clarifying subbaseline MERGE and UPDATE semantic", "content": "While reviewing the protocol to answer Alan's questions about\nversion-controlled collections, it appeared to me that the\n(DAV:merge-baseline) postcondition in section 12.14 (additional MERGE\nsemantics for baselines) could probably use some clarification.  In\nparticular, I think it would be clearer if the subbaseline merge\nbehavior was separated out into its own postcondition.  This makes the\nDAV:merge-baseline simpler for implementors that are not implementing\nsubbaselines (they can just ignore the DAV:merge-subbaseline\npostcondition).\n\nSo for you die-hard deltav fans, here's the proposed rewording\nof the DAV:merge-baseline postcondition:\n\n (DAV:merge-baseline): If the merge target is a version-controlled\n configuration whose DAV:checked-out baseline is not a descendant of\n the merge baseline, then the merge baseline MUST have been added to\n the DAV:auto-merge-set of a version-controlled configuration.  The\n DAV:checked-in version of each member of the DAV:baseline-collection\n of that baseline MUST have been merged into the\n DAV:baseline-controlled-collection of that version-controlled\n configuration.\n\n (DAV:merge-subbaselines): If the merge target is a version-controlled\n configuration whose DAV:baseline-controlled-collection contains a\n baseline-controlled member for one of the subbaselines of the merge\n baseline, then that subbaseline MUST have been merged into the\n version-controlled configuration of that baseline-controlled member.\n If the merge target is a version-controlled configuration whose\n DAV:baseline-controlled-collection is a member of a workspace that\n contains a baseline-controlled member for one of the subbaselines of\n the merge baseline, then that subbaseline MUST have been merged into\n the version-controlled configuration of that baseline-controlled\n member.\n\nSimilarly, section 12.13 (additional UPDATE semantics for baselines)\nalso needs a DAV:update-subbaselines postcondition):\n\n (DAV:update-subbaselines): If the request updated a version-controlled\n configuration whose DAV:baseline-controlled-collection contains a\n baseline-controlled member for one of the subbaselines of the request\n baseline, then the DAV:checked-in property of the version-controlled\n configuration of that baseline-controlled member MUST have been\n updated to be that subbaseline.  If the request updated a\n version-controlled configuration whose\n DAV:baseline-controlled-collection is a member of a workspace that\n contains a baseline-controlled member for one of the subbaselines of\n the request baseline, then the DAV:checked-in property of the\n version-controlled configuration of that baseline-controlled member\n MUST have been updated to be that subbaseline.\n\nAny comments/objections on this proposed clarifications?\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9809694"}, {"subject": "Re: Version-controlled collection resources - I am still missing  somethin", "content": "On Mon, Jul 02, 2001 at 10:41:27AM -0400, Clemm, Geoff wrote:\n> So following text should have appeared in section 14.9 (additional\n> VERSION-CONTROL semantics for version-controlled collections):\n> \n>  Additional Postconditions:\n> \n>  (DAV:new-version-controlled-collection): If the request body\n>  identified a collection version, the collection at the request-URL\n>  MUST contain a version-controlled internal member for each\n>  DAV:version-controlled-binding specified in the\n>  DAV:version-controlled-binding-set of the collection version, where\n>  the name and DAV:version-history of the internal member MUST be the\n>  DAV:binding-name and the DAV:version-history specified by the\n>  DAV:version-controlled-binding.\n\nI assume this is applied recursively down the project collection tree.\n(And if so, should it be explicitly stated?)\n\n>  If the internal member is a member of\n>  a workspace, and there is another member of the workspace for the same\n>  version history, the DAV:version of the internal member MUST be the\n>  DAV:version of that other member;\n\nI thought I had read somewhere that a single workspace must never have\ntwo occurrences of a resource from the same configuration or else\nambiguities can result in some of the operations. Eg: if UPDATE was\nused to change one of the two VCR's but not the other, then you did\na baseline operation.\n\n>  otherwise, the DAV:version MUST be\n>  the DAV:root-version of the version history.\n\nI am trying to write up a spec for the programmers to work on.\nCurrently my plan is to implement WebDAV but not the DeltaV protocol.\nHowever, we do support versioning, so we will make a higher level\nAPI to our versioning system compatible with DeltaV to make it\neasy to glue in the protocol later when there are more clients\naround. Hence my need to understand exactly what goes on. I have\nto explain it to someone else! :-)\n\nI am finding, as a matter of interest, that for each operation I\nneed to define semantics of operations on collection and non-collection\nresources separately in almost every case. I don't see this as a\nproblem, but it may be useful to keep in mind the next time someone\ndoes a read through of the spec - \"does this section make sense for\nboth types of resources?\".\n\nGetting there...\n\nAlan\n\n\n\n", "id": "lists-006-9819119"}, {"subject": "Re: Version-controlled collection resources - I am still missing  somethin", "content": "On Mon, Jul 02, 2001 at 10:41:27AM -0400, Clemm, Geoff wrote:\n> VERSION-CONTROL /ws/alan/src \n> <D:version> <D:href> http://repo/coll-ver/345 </D:href> </D:version>\n...\n\nOk, thanks, just one final little question to make sure I completely\nunderstand it. Is /ws/alan a workspace? or /ws/alan/src?\nThat is, do I do the VERSION-CONTROL on the workspace or under\nthe workspace?\n\nI am a CVS user so I find things easy to relate back to CVS. In my mind,\nthe area on my local hard disk where I check out files is semantically\nsimilar to a server-side workspace. (I know, the CVS area on my hard\ndisk is more like a client-side workspace, but I am just trying to\nwork out clean semantics to describe it to others with.)\n\nOur source code is broken up into multiple CVS modules. So when\nI do a cvs co, for a new 'workspace' I need to use cvs co to\nget the modules (top level directories) that I want for that\nworkspace. For example,\n\n    % mkdir ~/work/DMS\n    % cd ~/work/DMS\n    % cvs co DMS TOOLS SUPPORT\n\n    % mkdir ~/work/WEB\n    % cd ~/work/WEB\n    % cvs co WEB WEBADMIN SUPPORT\n\nI might also check out a branch to fix a bug using a label.\n\n    % mkdir ~/work/WEB.rel1\n    % cd ~/work/WEB.rel1\n    % cvs co -r release-1 WEB WEBADMIN SUPPORT\n\nIn the above model, I would say ~/work is not a workspace - I have\ndifferent versions of the same resources checked out which is not\npermitted in a workspace.\n\nSo I guess ~/work/DMS ~/work/WEB and ~/work/WEB.rel1 are the\nequivalent to workspaces.\n\nThe CVS repository consists of\n\n    .../cvsroot/DMS\n    .../cvsroot/SUPPORT\n    .../cvsroot/TOOLS\n    .../cvsroot/WEB\n    .../cvsroot/WEBADMIN\n\nIf .../cvsroot is a project in DeltaV, then the above CVS example is\nnot possible using DeltaV (I think). Because you would do a VERSION-CONTROL\non .../cvsroot to ~/work/DMS or whatever and get all of the DMS, SUPPORT,\nTOOLS, WEB, and WEBADMIN directories created locally.\n\n    MKWORKSPACE /work/DMS\n    VERSION-CONTROL /work/DMS\n    <D:version> <D:href> http://repo/coll-ver/345 </D:href> </D:version>\n<!-- where coll-ver/345 is .../cvsroot -->\n\nThe above makes me slightly uneasy in that I first created a workspace,\nbut then I have replaced it (?) (augmented it? modified it?) with a\nVCR for the root collection. Maybe I have to create one additional\nlayer of subdirectory so the root of the project tree appears under\nthe workspace directory instead(?).\n\nOr I guess I can use VERSION-CONTROL to get sub-directories of the\nproject(?).\n\n    MKWORKSPACE /work/DMS\n    VERSION-CONTROL /work/DMS/DMS\n    <D:version> <D:href> http://repo/coll-ver/999 </D:href> </D:version>\n<!-- where coll-ver/999 is .../cvsroot/DMS -->\n    VERSION-CONTROL /work/DMS/TOOLS\n    <D:version> <D:href> http://repo/coll-ver/888 </D:href> </D:version>\n<!-- where coll-ver/888 is .../cvsroot/TOOLS -->\n    VERSION-CONTROL /work/DMS/SUPPORT\n    <D:version> <D:href> http://repo/coll-ver/777 </D:href> </D:version>\n<!-- where coll-ver/777 is .../cvsroot/SUPPORT -->\n\nAre both of these OK? My understanding is DeltaV was being proposed\nas a possible replacement for the underlying CVS protocol, in which\ncase my example must somehow be possible. Have I understood things\ncorrectly?\n\nAlan\n\n\n\n", "id": "lists-006-9829001"}, {"subject": "RE: Version-controlled collection resources - I am still missing  somethin", "content": "   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n\n   On Mon, Jul 02, 2001 at 10:41:27AM -0400, Clemm, Geoff wrote:\n   > So following text should have appeared in section 14.9 (additional\n   > VERSION-CONTROL semantics for version-controlled collections):\n   > \n   >  Additional Postconditions:\n   > \n   >  (DAV:new-version-controlled-collection): If the request body\n   >  identified a collection version, the collection at the request-URL\n   >  MUST contain a version-controlled internal member for each\n   >  DAV:version-controlled-binding specified in the\n   >  DAV:version-controlled-binding-set of the collection version, where\n   >  the name and DAV:version-history of the internal member MUST be the\n   >  DAV:binding-name and the DAV:version-history specified by the\n   >  DAV:version-controlled-binding.\n\n   I assume this is applied recursively down the project collection tree.\n   (And if so, should it be explicitly stated?)\n\nYes, that would probably be worth making explicit.  I will add that in.\n\n   >  If the internal member is a member of\n   >  a workspace, and there is another member of the workspace for the same\n   >  version history, the DAV:version of the internal member MUST be the\n   >  DAV:version of that other member; otherwise, the DAV:version MUST be\n   >  the DAV:root-version of the version history.\n\n   I thought I had read somewhere that a single workspace must never have\n   two occurrences of a resource from the same configuration or else\n   ambiguities can result in some of the operations. Eg: if UPDATE was\n   used to change one of the two VCR's but not the other, then you did\n   a baseline operation.\n\nActually, the requirement is that only one version-controlled resource\nfrom a given version history can be a member of a given workspace.\nThis sentence should be rewritten to make that clear.  How about:\n\n If the internal member is a member of a workspace, and there is\n another member of the workspace for the same version history, those\n two members MUST identify the same version-controlled resource.\n\n   I am finding, as a matter of interest, that for each operation I\n   need to define semantics of operations on collection and non-collection\n   resources separately in almost every case.\n\nYes, the presence of \"members\" for a collection means that you\nalmost always have to say what the meaning of an operation is\nfor those members, in addition to the effect on the collection\n\"itself\".\n\n   I don't see this as a\n   problem, but it may be useful to keep in mind the next time someone\n   does a read through of the spec - \"does this section make sense for\n   both types of resources?\".\n\nAnd because versioning introduces other kinds of resources\n(version histories, baselines, activities), and other \"flavors\"\nof existing kinds of resources (version-controlled, baseline-controlled,\nversion, working resource), you have to extend this question for\nmany of the basic operations (MOVE, COPY, DELETE, LOCK, UNLOCK) to say\n\"does this section make sense for all the 2518 and deltav categories\nof resources\".  Keeps one on one's toes (:-).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9840155"}, {"subject": "RE: Version-controlled collection resources - I am still missing  somethin", "content": "   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n\n   On Mon, Jul 02, 2001 at 10:41:27AM -0400, Clemm, Geoff wrote:\n   > VERSION-CONTROL /ws/alan/src \n   > <D:version> <D:href> http://repo/coll-ver/345 </D:href> </D:version>\n   ...\n\n   Ok, thanks, just one final little question to make sure I completely\n   understand it. Is /ws/alan a workspace? or /ws/alan/src?\n\nIt was /ws/alan.\n\n   That is, do I do the VERSION-CONTROL on the workspace or under\n   the workspace?\n\nThe protocol wouldn't let you specify VERSION-CONTROL with\na specified version on the workspace, so you could only apply\nVERSION-CONTROL to the workspace itself if you were willing\nto create a new version history for the workspace collection.\n\n   I am a CVS user so I find things easy to relate back to CVS. In my mind,\n   the area on my local hard disk where I check out files is semantically\n   similar to a server-side workspace. (I know, the CVS area on my hard\n   disk is more like a client-side workspace, but I am just trying to\n   work out clean semantics to describe it to others with.)\n\nThis analogy works fine.  Imagine that you wanted to support\nclients that had no local persistent storage.  Then your CVS server\nwould allow these clients to create work areas on the server,\nwhere they could create whatever VCR's they needed.\n\n   Our source code is broken up into multiple CVS modules. So when\n   I do a cvs co, for a new 'workspace' I need to use cvs co to\n   get the modules (top level directories) that I want for that\n   workspace. For example,\n\n       % mkdir ~/work/DMS\n       % cd ~/work/DMS\n       % cvs co DMS TOOLS SUPPORT\n\nAssuming that /home/alan is your server side \"home\" and /cvsroot is\nyour repository:\n\nMKWORKSPACE /home/alan/work/DMS\n\nPROPFIND /cvsroot/DMS\n<D:prop> <D:checked-in/> </D:prop>\n=> /version-url-23\nVERSION-CONTROL /home/alan/work/DMS/DMS\n<D:version> <D:href> /version-url-23 </D:href> <D:version>\nMERGE /home/alan/work/DMS\n<D:source> /cvsroot/DMS </D:source>\n\nPROPFIND /cvsroot/TOOLS\n<D:prop> <D:checked-in/> </D:prop>\n=> /version-url-29\nVERSION-CONTROL /home/alan/work/DMS/TOOLS\n<D:version> <D:href> /version-url-29 </D:href> <D:version>\nMERGE /home/alan/work/DMS\n<D:source> /cvsroot/TOOLS </D:source>\n\nPROPFIND /cvsroot/SUPPORT\n<D:prop> <D:checked-in/> </D:prop>\n=> /version-url-35\nVERSION-CONTROL /home/alan/work/DMS/SUPPORT\n<D:version> <D:href> /version-url-35 </D:href> <D:version>\nMERGE /home/alan/work/DMS\n<D:source> /cvsroot/SUPPORT </D:source>\n\n       % mkdir ~/work/WEB\n       % cd ~/work/WEB\n       % cvs co WEB WEBADMIN SUPPORT\n\nMKWORKSPACE /home/alan/work/WEB\n\nPROPFIND /cvsroot/DMS\n<D:prop> <D:checked-in/> </D:prop>\n=> /version-url-43\nVERSION-CONTROL /home/alan/work/WEB/WEB\n<D:version> <D:href> /version-url-43 </D:href> <D:version>\nMERGE /home/alan/work/WEB\n<D:source> /cvsroot/WEB </D:source>\n\nPROPFIND /cvsroot/WEBADMIN\n<D:prop> <D:checked-in/> </D:prop>\n=> /version-url-49\nVERSION-CONTROL /home/alan/work/WEB/WEBADMIN\n<D:version> <D:href> /version-url-49 </D:href> <D:version>\nMERGE /home/alan/work/WEB\n<D:source> /cvsroot/WEBADMIN </D:source>\n\nPROPFIND /cvsroot/SUPPORT\n<D:prop> <D:checked-in/> </D:prop>\n=> /version-url-45\nVERSION-CONTROL /home/alan/work/WEB/SUPPORT\n<D:version> <D:href> /version-url-45 </D:href> <D:version>\nMERGE /home/alan/work/WEB\n<D:source> /cvsroot/SUPPORT </D:source>\n\n   I might also check out a branch to fix a bug using a label.\n\n       % mkdir ~/work/WEB.rel1\n       % cd ~/work/WEB.rel1\n       % cvs co -r release-1 WEB WEBADMIN SUPPORT\n\nAssuming you model labels as special workspaces (why introduce all the\nugliness of labels when you can just use workspaces consistently :-),\nand assuming your label workspaces are at /cvsroot_labels :\n\nMKWORKSPACE /home/alan/work/WEB.rel1\n\nPROPFIND /cvsroot_labels/release-1/DMS\n<D:prop> <D:checked-in/> </D:prop>\n=> /version-url-63\nVERSION-CONTROL /home/alan/work/WEB.rel1/WEB\n<D:version> <D:href> /version-url-63 </D:href> <D:version>\nMERGE /home/alan/work/WEB.rel1\n<D:source> /cvsroot_labels/release-1/WEB </D:source>\n\nPROPFIND /cvsroot_labels/release-1/WEBADMIN\n<D:prop> <D:checked-in/> </D:prop>\n=> /version-url-69\nVERSION-CONTROL /home/alan/work/WEB.rel1/WEBADMIN\n<D:version> <D:href> /version-url-69 </D:href> <D:version>\nMERGE /home/alan/work/WEB.rel1\n<D:source> /cvsroot_labels/release-1/WEBADMIN </D:source>\n\nPROPFIND /cvsroot_labels/release-1/SUPPORT\n<D:prop> <D:checked-in/> </D:prop>\n=> /version-url-65\nVERSION-CONTROL /home/alan/work/WEB.rel1/SUPPORT\n<D:version> <D:href> /version-url-65 </D:href> <D:version>\nMERGE /home/alan/work/WEB.rel1\n<D:source> /cvsroot_labels/release-1/SUPPORT </D:source>\n\n   In the above model, I would say ~/work is not a workspace - I have\n   different versions of the same resources checked out which is not\n   permitted in a workspace.\n\nCorrect.\n\n   So I guess ~/work/DMS ~/work/WEB and ~/work/WEB.rel1 are the\n   equivalent to workspaces.\n\nYes.\n\n   The CVS repository consists of\n\n       .../cvsroot/DMS\n       .../cvsroot/SUPPORT\n       .../cvsroot/TOOLS\n       .../cvsroot/WEB\n       .../cvsroot/WEBADMIN\n\n   If .../cvsroot is a project in DeltaV, then the above CVS example is\n   not possible using DeltaV (I think).\n\nDeltaV has no special \"project\" resource.  You would probably\nmodel /cvsroot as a collection (possibly under version control,\npossibly a workspace).\n\n   Because you would do a VERSION-CONTROL\n   on .../cvsroot to ~/work/DMS or whatever and get all of the DMS, SUPPORT,\n   TOOLS, WEB, and WEBADMIN directories created locally.\n\nCurrently, the workspace collection itself cannot share a version\nhistory with another workspace, so you can't do something like that.\nThis is because you can only specify an existing version if the\nrequest-URL of the VERSION-CONTROL identifies an unmapped URI.\nI suppose we could relax that constraint, if folks thought this\nwas an important use case (this was just an error check, to make\nsure clients didn't blow away the current state of the resource\nat the request-URL).\n\n       MKWORKSPACE /work/DMS\n       VERSION-CONTROL /work/DMS\n       <D:version> <D:href> http://repo/coll-ver/345 </D:href> </D:version>\n   <!-- where coll-ver/345 is .../cvsroot -->\n\nYou couldn't use VERSION-CONTROL with a specified version on\na collection that exists, unless we relaxed the constraint\nI mentioned above.\n\n   The above makes me slightly uneasy in that I first created a workspace,\n   but then I have replaced it (?) (augmented it? modified it?) with a\n   VCR for the root collection.\n\nWell, if we leave in the current constraints, there is no need to\nbe uneasy (:-).\n\n   Maybe I have to create one additional\n   layer of subdirectory so the root of the project tree appears under\n   the workspace directory instead(?).\n\nYes.\n\n   Or I guess I can use VERSION-CONTROL to get sub-directories of the\n   project(?).\n\n       MKWORKSPACE /work/DMS\n       VERSION-CONTROL /work/DMS/DMS\n       <D:version> <D:href> http://repo/coll-ver/999 </D:href> </D:version>\n   <!-- where coll-ver/999 is .../cvsroot/DMS -->\n       VERSION-CONTROL /work/DMS/TOOLS\n       <D:version> <D:href> http://repo/coll-ver/888 </D:href> </D:version>\n   <!-- where coll-ver/888 is .../cvsroot/TOOLS -->\n       VERSION-CONTROL /work/DMS/SUPPORT\n       <D:version> <D:href> http://repo/coll-ver/777 </D:href> </D:version>\n   <!-- where coll-ver/777 is .../cvsroot/SUPPORT -->\n\nYes.  (That's the approach I used above).\n\n   Are both of these OK? My understanding is DeltaV was being proposed\n   as a possible replacement for the underlying CVS protocol, in which\n   case my example must somehow be possible. Have I understood things\n   correctly?\n\nYes!  The only thing you missed was that constraint that you can't\napply VERSION-CONTROL with a specified version to an existing resource.\nBut we could certainly remove that \"error check\" if folks believe \nwe should (I'm happy either way).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9851617"}, {"subject": "Re: Version-controlled collection resources - I am still missing  somethin", "content": "> Actually, the requirement is that only one version-controlled resource\n> from a given version history can be a member of a given workspace.\n> This sentence should be rewritten to make that clear.  How about:\n> \n>  If the internal member is a member of a workspace, and there is\n>  another member of the workspace for the same version history, those\n>  two members MUST identify the same version-controlled resource.\n\nThis made a big difference to my understanding, and made a big difference\nto our planned implementation. I was planning to only permit collection\nresources have one parent. That is, allow non-collection resources to\nhave multiple bindings to them (that is, appear in multiple parent\ncollections). But the above indicates that I need to do this for\ncollections too.\n\nI was discussing it here internally saying\n\n    You can create a workspace, then pick whatever collection in the\n    project tree you want to make available to work on. [Project tree\n    is my jargon, not WebDAV/DeltaV]\n\n    For example, if I had a project with the following collections\n\n/DMS\n/DMS/src\n/DMS/src/cpp\n/DMS/src/perl\n/DMS/src/java\n/DMS/doc\n/DMS/doc/txt\n/DMS/doc/html\n\n    Then a user may create a workspace /usr/ajk/myws then use\n    VERSION-CONTROL to choose to make the /DMS/doc tree available\n    as /usr/ajk/myws/doc. The tree would look like\n    \n/usr/ajk/myws/doc\n/usr/ajk/myws/doc/txt\n/usr/ajk/myws/doc/html\n\nI was then asked what happens if it was suddenly discovered that some\nof the documentation to be changed was JavaDOC so the java files also\nneeded to be obtained.\n\n    Well, you can just add them to your workspace using VERSION-CONTROL\n    again as /usr/ajk/myws/java, so you end up with\n\n/usr/ajk/myws/doc\n/usr/ajk/myws/doc/txt\n/usr/ajk/myws/doc/html\n/usr/ajk/myws/java\n\nI was then asked, what happens if it was suddenly realised that changes\nalso needed to be made to all the source code to change a badly designed\nAPI. The user does not want to loose any changes made so far, or any\nnew files introduced etc. but not committed yet.\n\nMy new understanding is I can use VERSION-CONTROL again to say \"lets\nget the whole lot\". This would end up with a tree of\n\n/usr/ajk/myws/doc\n/usr/ajk/myws/doc/txt\n/usr/ajk/myws/doc/html\n/usr/ajk/myws/java\n/usr/ajk/myws/DMS\n/usr/ajk/myws/DMS/src\n/usr/ajk/myws/DMS/src/cpp\n/usr/ajk/myws/DMS/src/perl\n/usr/ajk/myws/DMS/src/java\n/usr/ajk/myws/DMS/doc\n/usr/ajk/myws/DMS/doc/txt\n/usr/ajk/myws/DMS/doc/html\n\nWhere /usr/ajk/myws/doc IS the same resource as identified by\n/usr/ajk/myws/DMS/doc. Similarly, /usr/ajk/myws/java IS the same\nresource as bound to /usr/ajk/myws/DMS/src/java.\nThis is fine as I have not introduced cycles.\n\nSo why on earth am I mailing all this? I guess I am saying yes, I think\nthe additional text is worth while. It also highlights to me that it\nmakes life much easier if a collection resource can have multiple\nbindings to it, not just for non-collection resources as I had originally\nplanned.\n\nTim asked previously if I was interested in writing up the answers I\nhave been getting for the FAQ. I might, but what I am first trying\nto write up is a 'one way to implement WebDAV and DeltaV on top of\na DMA implementaiton.' DMA is a more generic document model with\nversioning etc, but it maps quite nicely to DeltaV (phew!).\nI find writing this sort of document forces me to understand all\nthe concepts in their entirety.\n\nAlan\n\n\n\n", "id": "lists-006-9868378"}, {"subject": "RE: Version-controlled collection resources - I am still missing  somethin", "content": "Yes, to everything Alan says below here.  Unless there are\nany objections, I will use the rewording that Alan prefers.\n\nAlan: If you you do get a writeup of mapping DMA to DeltaV,\nplease let me know so I can get a copy or a link posted on\nthe DeltaV web site.\n\nCheers,\nGeoff\n\n-----Original Message-----\nFrom: Alan Kent [mailto:ajk@mds.rmit.edu.au]\nSent: Tuesday, July 03, 2001 4:14 AM\nTo: DeltaV\nSubject: Re: Version-controlled collection resources - I am still\nmissing something\n\n\n> Actually, the requirement is that only one version-controlled resource\n> from a given version history can be a member of a given workspace.\n> This sentence should be rewritten to make that clear.  How about:\n> \n>  If the internal member is a member of a workspace, and there is\n>  another member of the workspace for the same version history, those\n>  two members MUST identify the same version-controlled resource.\n\nThis made a big difference to my understanding, and made a big difference\nto our planned implementation. I was planning to only permit collection\nresources have one parent. That is, allow non-collection resources to\nhave multiple bindings to them (that is, appear in multiple parent\ncollections). But the above indicates that I need to do this for\ncollections too.\n\nI was discussing it here internally saying\n\n    You can create a workspace, then pick whatever collection in the\n    project tree you want to make available to work on. [Project tree\n    is my jargon, not WebDAV/DeltaV]\n\n    For example, if I had a project with the following collections\n\n/DMS\n/DMS/src\n/DMS/src/cpp\n/DMS/src/perl\n/DMS/src/java\n/DMS/doc\n/DMS/doc/txt\n/DMS/doc/html\n\n    Then a user may create a workspace /usr/ajk/myws then use\n    VERSION-CONTROL to choose to make the /DMS/doc tree available\n    as /usr/ajk/myws/doc. The tree would look like\n    \n/usr/ajk/myws/doc\n/usr/ajk/myws/doc/txt\n/usr/ajk/myws/doc/html\n\nI was then asked what happens if it was suddenly discovered that some\nof the documentation to be changed was JavaDOC so the java files also\nneeded to be obtained.\n\n    Well, you can just add them to your workspace using VERSION-CONTROL\n    again as /usr/ajk/myws/java, so you end up with\n\n/usr/ajk/myws/doc\n/usr/ajk/myws/doc/txt\n/usr/ajk/myws/doc/html\n/usr/ajk/myws/java\n\nI was then asked, what happens if it was suddenly realised that changes\nalso needed to be made to all the source code to change a badly designed\nAPI. The user does not want to loose any changes made so far, or any\nnew files introduced etc. but not committed yet.\n\nMy new understanding is I can use VERSION-CONTROL again to say \"lets\nget the whole lot\". This would end up with a tree of\n\n/usr/ajk/myws/doc\n/usr/ajk/myws/doc/txt\n/usr/ajk/myws/doc/html\n/usr/ajk/myws/java\n/usr/ajk/myws/DMS\n/usr/ajk/myws/DMS/src\n/usr/ajk/myws/DMS/src/cpp\n/usr/ajk/myws/DMS/src/perl\n/usr/ajk/myws/DMS/src/java\n/usr/ajk/myws/DMS/doc\n/usr/ajk/myws/DMS/doc/txt\n/usr/ajk/myws/DMS/doc/html\n\nWhere /usr/ajk/myws/doc IS the same resource as identified by\n/usr/ajk/myws/DMS/doc. Similarly, /usr/ajk/myws/java IS the same\nresource as bound to /usr/ajk/myws/DMS/src/java.\nThis is fine as I have not introduced cycles.\n\nSo why on earth am I mailing all this? I guess I am saying yes, I think\nthe additional text is worth while. It also highlights to me that it\nmakes life much easier if a collection resource can have multiple\nbindings to it, not just for non-collection resources as I had originally\nplanned.\n\nTim asked previously if I was interested in writing up the answers I\nhave been getting for the FAQ. I might, but what I am first trying\nto write up is a 'one way to implement WebDAV and DeltaV on top of\na DMA implementaiton.' DMA is a more generic document model with\nversioning etc, but it maps quite nicely to DeltaV (phew!).\nI find writing this sort of document forces me to understand all\nthe concepts in their entirety.\n\nAlan\n\n\n\n", "id": "lists-006-9879453"}, {"subject": "draft-ietf-deltav-versioning-16 now availabl", "content": "I decided to go ahead and roll up the current set of\neditorial changes into a new internet draft for the\nupcoming IETF meeting.  The main change is the addition\nof Tim Ellison's resource classification appendix.\nDraft 16 should appear soon on the ietf site, but it is\ncurrently available in the usual locations on the deltav site:\nhttp://www.webdav.org/deltav/protocol/draft-ietf-deltav-versioning-16.htm\nhttp://www.webdav.org/deltav/protocol/draft-ietf-deltav-versioning-16.doc\n\nI did include the proposed DAV:auto-update property in\nthis new draft.  A list of all changes since draft 15,\nas well as the open issues can be found at:\nhttp://www.webdav.org/deltav/protocol/changes-and-issues.htm\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9891337"}, {"subject": "RE: Version-controlled collection resources - I am still missing   somethin", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n> ...\n> So following text should have appeared in section 14.9\n> (additional VERSION-CONTROL semantics for version-controlled\n> collections):\n>\n>  Additional Postconditions:\n>\n>  (DAV:new-version-controlled-collection): If the request\n> body identified a collection version, the collection at\n> the request-URL MUST contain a version-controlled internal\n> member for each DAV:version-controlled-binding specified\n> in the DAV:version-controlled-binding-set of the collection\n> version, where the name and DAV:version-history of the\n> internal member MUST be the DAV:binding-name and the\n> DAV:version-history specified by the\n> DAV:version-controlled-binding.  If the internal member\n> is a member of a workspace, and there is another member of\n> the workspace for the same version history, the\n> DAV:version of the internal member MUST be the DAV:version\n> of that other member; otherwise, the DAV:version MUST be\n>  the DAV:root-version of the version history.\n>\n> If nobody has any objections to this text, I'll add this to\n> the next working draft.\n\nI guess that picking the DAV:root-version is the obvious choice from a\nprotocol-writer's perspective since it is well defined in the spec.  It\nalso provides behavior that is predictable by the client since they know\nthe root version.  However, it would seem to me that clients would 99.9% of\nthe time have to UPDATE / MERGE all of the version-controlled resources\ncreated using this rule.\n\nHow do you feel about making the new version-controlled resources have a\nDAV:checked-in of the (chronologically) latest version instead?\nI have no great desire for this, but just think it may be more client\nfriendly.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-9898906"}, {"subject": "RE: Version-controlled collection resources - I am still missing  somethin", "content": "   From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n\n   \"Clemm, Geoff\" <gclemm@rational.com> wrote:\n   > ... the\n   > DAV:version of the internal member MUST be the DAV:version\n   > of that other member; otherwise, the DAV:version MUST be\n   >  the DAV:root-version of the version history.\n\n   I guess that picking the DAV:root-version is the obvious choice\n   from a protocol-writer's perspective since it is well defined in\n   the spec.  It also provides behavior that is predictable by the\n   client since they know the root version.  However, it would seem to\n   me that clients would 99.9% of the time have to UPDATE / MERGE all\n   of the version-controlled resources created using this rule.\n\nI think the probability is significantly lower than this because a\nusers often only wants a subset of the components of a system in their\nworkspaces.  If an implementation has the root version of a collection\nhistory always be an empty collection (which is a very sensible\nchoice), then all of the sub-directories you don't care about will by\ndefault show up in their empty initial state.  This allows you to\nlimit the expense of Depth PROPFIND's on a workspace.\n\nAlso, since you can initialize your entire collection with a single\nMERGE or UPDATE request, it makes sense to chose a default that will\nproduce the most minimal initial configuration, which is what the root\nversion is likely to produce.\n\n   How do you feel about making the new version-controlled resources\n   have a DAV:checked-in of the (chronologically) latest version\n   instead?  I have no great desire for this, but just think it may be\n   more client friendly.\n\nIn the presence of forking, \"latest\" is a very bad choice, because it\nwould cause the initial state to unpredictably jump from one line of\ndescent to another.  So I believe that selecting the DAV:root-version\nis significantly superior.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9908812"}, {"subject": "Re: Version-controlled collection resources - I am still missing  somethin", "content": ">    How do you feel about making the new version-controlled resources\n>    have a DAV:checked-in of the (chronologically) latest version\n>    instead?  I have no great desire for this, but just think it may be\n>    more client friendly.\n> \n> In the presence of forking, \"latest\" is a very bad choice, because it\n> would cause the initial state to unpredictably jump from one line of\n> descent to another.  So I believe that selecting the DAV:root-version\n> is significantly superior.\n\nDMA \"solved\" this problem by using a slightly different versioning\nconstruct to DeltaV (I am not suggesting DeltaV change - I bring it\nup for comparison only). In DMA, a \"Config History\" is the equivalent\nto \"version history\". Each Config History has multiple \"Version Series\".\nEach Version Series is a linear list of versions. Branching is supported\nby having a primary Version Series then other Version Series split off\nfrom existing version series (branch) and possibly terminate into existing\nversion series (merge).\n\nSo in DMA, you could make the default the 'most recent version in the\nprimary version series'.\n\nBut I agree that the current semantics seem quite inefficient. 99% of\nthe time, getting the first version in a series will not be what is\nwanted. For a CVS repository for our code, we would update/check out\npotentially thousands of files in a single request. We don't keep\na small number of files per 'workspace' when using CVS. We get the\nwhole lot because when compiling subsystem 'X', it includes header\nfiles from subsystems 'A', 'B', .... 'W' all which need to be available.\n\nI have not read the spec closely enough, but if its not possible now,\nis there a way to say 'VERSION-CONTROL using label'? If so, maybe\nlabels could be used to 'get most popular choice' or something??\nOr during checkin etc, is it worth having a property on a version\nsaying \"I am now the best default choice\" - similar to the DMA concept\nof the latest version in the primary version series.\n\nAlan\n\n\n\n", "id": "lists-006-9919318"}, {"subject": "RE: Version-controlled collection resources - I am still missing  somethin", "content": "   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n\n   But I agree that the current semantics seem quite inefficient. 99% of\n   the time, getting the first version in a series will not be what is\n   wanted.\n\nThere may be some confusion here between what is done on the server\nand what is done on the client.  A server does not need to \"get\" any\nversion, since an efficient implementation will just set the\nDAV:checked-in property of the VCR, and not make an actual copy\nof the content and dead properties of the version.\n\nAlso, remember that the only time this \"pick the initial version\"\nfunctionality is invoked is when your server supports versioned\ncollections, and you are using VERSION-CONTROL to create a new\nversion-controlled collection from a specified version of an existing\nversion history.  Only in this case does a version need to be selected\nfor the internal members of that new version-controlled collection.\nWhen you use VERSION-CONTROL to create a new (non-collection)\nversion-controlled resource, you explicitly specify what version you\nwant in the VERSION-CONTROL request.\n\nAnd in the version-controlled collection case, if your server is\nsensible, and has the root version of a collection always be an empty\ncollection, then the server does no extra work for the VERSION-CONTROL\nrequest, because it just creates the\nversion-controlled collection with no members at all.  You then use\nUPDATE or MERGE to initialize this collection.\n\n   For a CVS repository for our code, we would update/check out\n   potentially thousands of files in a single request. We don't keep\n   a small number of files per 'workspace' when using CVS. We get the\n   whole lot because when compiling subsystem 'X', it includes header\n   files from subsystems 'A', 'B', .... 'W' all which need to be available.\n\nI assume by get, you mean using the HTTP GET method to get the content\nfrom the server?  If so, you wouldn't be requesting this until you\nhave configured your workspace properly, i.e. after you have done the\nMERGE that causes the workspace collection to display the versions you\nwant.\n\n   I have not read the spec closely enough, but if its not possible now,\n   is there a way to say 'VERSION-CONTROL using label'? If so, maybe\n   labels could be used to 'get most popular choice' or something??\n\nSince we're talking about configuring workspaces, we would need to use\nfunctionality provided in the server-workspace package, which would be\nbaselines, not labels.  And yes, you could use a single\nBASELINE-CONTROL request to initialize the collection in one round\ntrip.\n\nNote that if your server does support labels, you can use UPDATE\nwith a Depth and Label header to configure the workspace.  Since\nthe initial VERSION-CONTROL request is inexpensive, there would be\nno reason to bundle the UPDATE functionality into the VERSION-CONTROL\nrequest (2 round trips is not an unreasonable number of requests\nto configure a workspace).\n\n   Or during checkin etc, is it worth having a property on a version\n   saying \"I am now the best default choice\" - similar to the DMA concept\n   of the latest version in the primary version series.\n\nThe \"best default choice\" is appropriately modeled as a workspace\n(for the server-workspace packages) or a label (for the client-workspace\npackages).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9929034"}, {"subject": "Re: Version-controlled collection resources - I am still missing  somethin", "content": "On Thu, Jul 05, 2001 at 12:54:57AM -0400, Clemm, Geoff wrote:\n> There may be some confusion here between what is done on the server\n> and what is done on the client.  A server does not need to \"get\" any\n> version, since an efficient implementation will just set the\n> DAV:checked-in property of the VCR, and not make an actual copy\n> of the content and dead properties of the version.\n\nI had used the term \"get\" loosely - I did not mean a HTTP get.\nWhen you use VERSION-CONTROL to create a new version-controlled\ncollection, it (as you described previously) will create a complete\ntree of collection and leaf non-collection resources. No content\nwill be retrieved. Then the client must use UPDATE on every single\nbinding in the whole tree created to change it to the desired version.\n\nMy comment on performance was not volume of data (you do not download\nthe content of the resources), just the number of individual requests\nrequired. You need at least one HTTP request/response per recource\nin the tree created from the VERSION-CONTROL command.\n\n> And in the version-controlled collection case, if your server is\n> sensible, and has the root version of a collection always be an empty\n> collection, then the server does no extra work for the VERSION-CONTROL\n> request, because it just creates the\n> version-controlled collection with no members at all.  You then use\n> UPDATE or MERGE to initialize this collection.\n\nThis is a useful trick to remember.\n\nHowever, as soon as you UPDATE the collection to a later version, it will\nthen populate one level down in the tree. For every internal member,\nyou then need to UPDATE it to the desired version (possibly creating\nnew child version-controlled collection resources). The client really\nneeds to start from the top and recursively do UPDATE requests on each\nrequest one by one until you get down to the bottom. So there are lots\nof little requests required.\n\n> The \"best default choice\" is appropriately modeled as a workspace\n> (for the server-workspace packages) or a label (for the client-workspace\n> packages).\n\nFor server-workspace package how does this work? I create a new\nworkspace for the first time, then want to populate it. So no existing\nworkspace exists? \n\nOr if I have a workspace and want to update everything to the latest\nversisions (since other people have made changes), then again, I need\nto potentially do lots of separate requests.\n\nI think the answer is \"tough luck\" (or use baselines - I have not tried\nto understand them yet). Unless the version history of versions modelled\na primary version series with other branches off to the side (ala CVS),\nit is not possible to say 'VERSION-CONTROL at this time point for the\nwhole tree'.\n\nI am assuming introducing the concept of multiple linear version series\nis too much for the DeltaV community to swallow in terms of change.\nIt would support the CVS and DMA approaches quite closely. (eg:\nCreate version-controlled resources for 'whatever version existed at\ndate X' / 'latest version' for the version series called 'primary'/'1.1.1'/\n'with label Y'). It would allow a single VERSION-CONTROL command to get\nthe correct version across a hole collection tree. But it is not possible\nwith the current simplistic model of versions having predecessors and\nsuccessors. It requires something such as the more detailed model of\nidentifying linear series of versions (so you can find the last in a\nlinear series - you cannot find the last in a graph and have it make sense).\n\nAlan\n\n\n\n", "id": "lists-006-9940630"}, {"subject": "RE: Version-controlled collection resources - I am still missing   somethin", "content": "\"Clemm, Geoff\" <gclemm@rational.com> wrote:\n\n>    From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n>\n>    But I agree that the current semantics seem quite\n>    inefficient. 99% of the time, getting the first\n>    version in a series will not be what is wanted.\n>\n> There may be some confusion here between what is done on\n> the server and what is done on the client.  A server does\n> not need to \"get\" any version, since an efficient\n> implementation will just set the DAV:checked-in property\n> of the VCR, and not make an actual copy of the content and\n> dead properties of the version.\n\nAgreed.\n\n> Also, remember that the only time this \"pick the initial\n> version\" functionality is invoked is when your server\n> supports versioned collections, and you are using\n> VERSION-CONTROL to create a new version-controlled\n> collection from a specified version of an existing version\n> history.  Only in this case does a version need to be selected\n> for the internal members of that new version-controlled\n> collection.\n\nAgreed.  The crux for me is how likely this is to occur.  Is there a common\nuse case that relies on this (rhetorical)?\n\n> When you use VERSION-CONTROL to create a new (non-collection)\n> version-controlled resource, you explicitly specify what\n> version you want in the VERSION-CONTROL request.\n\nAgreed.\n\n> And in the version-controlled collection case, if your\n> server is sensible,\n\nWait-up<g> I agree with Alan that this is a useful implementation trick to\navoid this cascading of root versions, but if the act of creating a new\nversion-controlled collection is very rare, I would rather my versioning\nserver _didn't_ create 'bogus' empty root versions.\n\nFrom the client's perspective, is it any better to have no members of the\nversion-controlled collection (and have to fill them in explicitly), or\nhave the root versions for each member (and likely have to go and update\nthem explicitly)?  I accept that for the server it is easier to not create\nmembers.\n\n> and has the root version of a collection\n> always be an empty collection, then the server does no\n> extra work for the VERSION-CONTROL request, because it\n> just creates the version-controlled collection with no\n> members at all.  You then use UPDATE or MERGE to\n> initialize this collection.\n>\n>    For a CVS repository for our code, we would\n>    update/check out potentially thousands of files\n>    in a single request. We don't keep a small\n>    number of files per 'workspace' when using CVS.\n>    We get the whole lot because when compiling\n>    subsystem 'X', it includes header files from\n>    subsystems 'A', 'B', .... 'W' all which need\n>    to be available.\n>\n> I assume by get, you mean using the HTTP GET method to\n> get the content from the server?  If so, you wouldn't\n> be requesting this until you have configured your\n> workspace properly, i.e. after you have done the MERGE\n> that causes the workspace collection to display the\n> versions you want.\n>\n>    I have not read the spec closely enough, but\n>    if its not possible now, is there a way to\n>    say 'VERSION-CONTROL using label'? If so, maybe\n>    labels could be used to 'get most popular choice'\n>    or something??\n>\n> Since we're talking about configuring workspaces, we\n> would need to use functionality provided in the\n> server-workspace package, which would be baselines,\n> not labels.  And yes, you could use a single\n> BASELINE-CONTROL request to initialize the collection\n> in one round trip.\n\nI guess that I've always though of clients using this mechanism to update a\nworkspace en-masse.\n\n> Note that if your server does support labels, you can\n> use UPDATE with a Depth and Label header to configure\n> the workspace.  Since the initial VERSION-CONTROL request\n> is inexpensive,\n\n'inexpensive' -- if the server does this empty root version trick,\notherwise it would have to create the deep tree of version-controlled\nresources, which is unknown cost.\n\n> there would be no reason to bundle the UPDATE functionality\n> into the VERSION-CONTROL request (2 round trips is not\n> an unreasonable number of requests to configure a workspace).\n\nI agree that bundling the update with the version-control is not right.\n\n>    Or during checkin etc, is it worth having a property\n>    on a version saying \"I am now the best default choice\"\n>    - similar to the DMA concept of the latest version in\n>    the primary version series.\n>\n> The \"best default choice\" is appropriately modeled as a\n> workspace (for the server-workspace packages) or a label\n> (for the client-workspace packages).\n\nor a baseline if you do those.\n\n\nThe members of a version-controlled collection created from a collection\nversion are:\n(1) the DAV:root-version of the member's history (as proposed)\nan implementation note should be added to state that severs may chose to\nmake root-versions of versioned collections empty to avoid cascading\nversion-controlled collections.\n\n(2) undefined and have to be explictly created by another\nversion-control/merge request.\ni.e. when the version-controlled collection is created a PROPFIND depth 1\nwould answer the internal member names, but attempts to GET them would\nreturn 404 Not Found.\n\n(3) the spec is silent and servers do what they choose.\nIt seems that clients are very likely going to have to go and fix-up all\nthe members anyway so who cares about the initial value.\n\n(4) forget that I even mentioned \"latest\" :-(\nGeoff wrote:\n> \"latest\" is a very bad choice ... I believe that selecting\n> the DAV:root-version is significantly superior.\nI agree that leaping around across branches is less than optimal, I was\nstumbing towards Alan's notion of the \"linear series\"\n\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-9952235"}, {"subject": "Re: Version-controlled collection resources - I am still missing   somethin", "content": "Alan Kent <ajk@mds.rmit.edu.au> wrote:\n>\n> On Thu, Jul 05, 2001 at 12:54:57AM -0400, Clemm, Geoff wrote:\n> > There may be some confusion here between what is done on the server\n> > and what is done on the client.  A server does not need to \"get\" any\n> > version, since an efficient implementation will just set the\n> > DAV:checked-in property of the VCR, and not make an actual copy\n> > of the content and dead properties of the version.\n>\n> I had used the term \"get\" loosely - I did not mean a HTTP get.\n> When you use VERSION-CONTROL to create a new version-controlled\n> collection, it (as you described previously) will create a complete\n> tree of collection and leaf non-collection resources. No content\n> will be retrieved. Then the client must use UPDATE on every single\n> binding in the whole tree created to change it to the desired version.\n>\n> My comment on performance was not volume of data (you do not download\n> the content of the resources), just the number of individual requests\n> required. You need at least one HTTP request/response per recource\n> in the tree created from the VERSION-CONTROL command.\n\nI agree with this analysis, and figure that the only solution is to use the\nroot-version-is-empty trick, or explicitly state that creating a\nversion-controlled collection this way does not have any members.\n\n> > And in the version-controlled collection case, if your server is\n> > sensible, and has the root version of a collection always be an empty\n> > collection, then the server does no extra work for the VERSION-CONTROL\n> > request, because it just creates the\n> > version-controlled collection with no members at all.  You then use\n> > UPDATE or MERGE to initialize this collection.\n>\n> This is a useful trick to remember.\n>\n> However, as soon as you UPDATE the collection to a later version, it will\n> then populate one level down in the tree. For every internal member,\n> you then need to UPDATE it to the desired version (possibly creating\n> new child version-controlled collection resources). The client really\n> needs to start from the top and recursively do UPDATE requests on each\n> request one by one until you get down to the bottom. So there are lots\n> of little requests required.\n>\n> > The \"best default choice\" is appropriately modeled as a workspace\n> > (for the server-workspace packages) or a label (for the\nclient-workspace\n> > packages).\n>\n> For server-workspace package how does this work? I create a new\n> workspace for the first time, then want to populate it. So no existing\n> workspace exists?\n>\n> Or if I have a workspace and want to update everything to the latest\n> versisions (since other people have made changes), then again, I need\n> to potentially do lots of separate requests.\n>\n> I think the answer is \"tough luck\" (or use baselines - I have not tried\n> to understand them yet). Unless the version history of versions modelled\n> a primary version series with other branches off to the side (ala CVS),\n> it is not possible to say 'VERSION-CONTROL at this time point for the\n> whole tree'.\n\nYup, use baselines would be my answer.\n\n> I am assuming introducing the concept of multiple linear version series\n> is too much for the DeltaV community to swallow in terms of change.\n> It would support the CVS and DMA approaches quite closely. (eg:\n> Create version-controlled resources for 'whatever version existed at\n> date X' / 'latest version' for the version series called\n'primary'/'1.1.1'/\n> 'with label Y'). It would allow a single VERSION-CONTROL command to get\n> the correct version across a hole collection tree. But it is not possible\n> with the current simplistic model of versions having predecessors and\n> successors. It requires something such as the more detailed model of\n> identifying linear series of versions (so you can find the last in a\n> linear series - you cannot find the last in a graph and have it make\nsense).\n\nor activities.\n\nRegards,\nTim\n\n\n\n", "id": "lists-006-9966439"}, {"subject": "RE: Version-controlled collection resources - I am still missing    somethin", "content": "   From: Tim Ellison [mailto:Tim_Ellison@uk.ibm.com]\n\n   > And in the version-controlled collection case, if your\n   > server is sensible, and has the root version of a collection\n   > always be an empty collection, \n\n   Wait-up<g> I agree with Alan that this is a useful implementation trick\nto\n   avoid this cascading of root versions, but if the act of creating a new\n   version-controlled collection is very rare, I would rather my versioning\n   server _didn't_ create 'bogus' empty root versions.\n\nIntroducing an empty root version will have no significant\nimplementation cost, and logically, it is very reasonable to say that\nevery new collection starts out empty, so there is no conceptual\nproblem here with users encountering a root version that is empty.\n\nBut whether or not an empty root version is \"bogus\" or \"sensible\" (:-),\nthe VERSION-CONTROL request is not expensive, because a server can\neasily leave an \"uninitialized\" value for any such binding, and only\nretrieve the root version if the client actually requests a value\nfrom an unitialized binding.\n\n   From the client's perspective, is it any better to have no members of the\n   version-controlled collection (and have to fill them in explicitly),   or\n   have the root versions for each member (and likely have to go and update\n   them explicitly)?  I accept that for the server it is easier to not\ncreate\n   members.\n\nThe server can use basically the same implementation in either case.\nThe only question is whether it returns some \"uninitialized\" status\nwhen you encounter one of those internal members, or returns the root\nversion.  Note that since the client is extremely likely to follow the\nVERSION-CONTROL request with the appropriate MERGE or UPDATE request,\na client won't be encountering these \"uninitialized\" bindings very\noften anyway.\n\n   The members of a version-controlled collection created from a collection\n   version are:\n   (1) the DAV:root-version of the member's history (as proposed)\n   an implementation note should be added to state that severs may chose to\n   make root-versions of versioned collections empty to avoid cascading\n   version-controlled collections.\n\nor could just implement them as \"uninitialized\", and only retrieve the\nroot version if the binding is used before it is explicitly\ninitialized.\n\n   (2) undefined and have to be explictly created by another\n   version-control/merge request.\n   i.e. when the version-controlled collection is created a PROPFIND depth 1\n   would answer the internal member names, but attempts to GET them would\n   return 404 Not Found.\n\nI considered this, but it introduced what appears to be an unnecessary\nobscure case (you'd need a DAV:uninitialized-binding-set so that a\nclient could discover what was going on here).  Note: I'm not against\nthis, but just thought the current way was simpler.\n\n   (3) the spec is silent and servers do what they choose.\n   It seems that clients are very likely going to have to go and fix-up all\n   the members anyway so who cares about the initial value.\n\nYes, although I think it is better to define the behavior, so I\nprefer 1 or 2.\n\n   (4) forget that I even mentioned \"latest\" :-(\n   Geoff wrote:\n   > \"latest\" is a very bad choice ... I believe that selecting\n   > the DAV:root-version is significantly superior.\n   I agree that leaping around across branches is less than optimal, I was\n   stumbing towards Alan's notion of the \"linear series\"\n\nNote that this effectively would bundle \"MERGE from activity\" into the\nVERSION-CONTROL request.  One of the reasons I resist bundling any of\nthese into the VERSION-CONTROL is that any variant of the MERGE or\nUPDATE request is reasonable following the VERSION-CONTROL request, so\nwe'd have to give VERSION-CONTROL all the semantics of MERGE and\nUPDATE if we wanted to do this cleanly.  Since I believe that there\nare several techniques a server can use to make the initial\nVERSION-CONTROL request very inexpensive (described above) , I think\nit is cleaner to keep them separate.\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9978188"}, {"subject": "RE: Version-controlled collection resources - I am still missing  somethin", "content": "   From: Alan Kent [mailto:ajk@mds.rmit.edu.au]\n\n   When you use VERSION-CONTROL to create a new version-controlled\n   collection, it (as you described previously) will create a complete\n   tree of collection and leaf non-collection resources. No content\n   will be retrieved. Then the client must use UPDATE on every single\n   binding in the whole tree created to change it to the desired version.\n   My comment on performance was not volume of data (you do not download\n   the content of the resources), just the number of individual requests\n   required. You need at least one HTTP request/response per recource\n   in the tree created from the VERSION-CONTROL command.\n\nNo, a single UPDATE is sufficient if the configuration you want is\nbaselined or labeled, and a single MERGE is sufficient if the\nconfiguration you want is the latest in an activity (i.e. along a\nsingle line of descent), or in another workspace.\n\n   However, as soon as you UPDATE the collection to a later version,\n   it will then populate one level down in the tree. For every\n   internal member, you then need to UPDATE it to the desired version\n   (possibly creating new child version-controlled collection\n   resources). The client really needs to start from the top and\n   recursively do UPDATE requests on each request one by one until you\n   get down to the bottom. So there are lots of little requests\n   required.\n\nSee above.  The server would get just one UPDATE or MERGE request.  It\nwould pick the default version if your request did not specify a\nversion for that version history.\n\n   > The \"best default choice\" is appropriately modeled as a workspace\n   > (for the server-workspace packages) or a label (for the\nclient-workspace\n   > packages).\n\n   For server-workspace package how does this work? I create a new\n   workspace for the first time, then want to populate it. So no existing\n   workspace exists? \n\nIf your \"best default choice\" is implemented as a workspace, then you\ndo have to have your /ws/best-default-choice workspace created before\nyou can specify what your best default choice is for a version\nhistory.  A server that wants to \"build in\" the best default choice\nfunctionality would create such a workspace when that server is\ninitialized on a host.\n\nThe point here is that the only way to have the \"best default choice\"\nscale is to allow different \"best default choices\" for different\ngroups of users.  A simple server can just support a single best\ndefault choice, but the concept needs to be able to scale up for\ngroups of users for which there is not a single best default choice.\n\n   Or if I have a workspace and want to update everything to the latest\n   versisions (since other people have made changes), then again, I need\n   to potentially do lots of separate requests.\n\nYou can just MERGE one workspace to another, if you want to initialize\none workspace with the contents of another.\n\n   I think the answer is \"tough luck\" (or use baselines - I have not tried\n   to understand them yet).\n\nWe try to avoid the \"tough luck\" answer as much as possible (:-).\nIn this case, the answer is \"MERGE\".\n\n   Unless the version history of versions modelled a primary version\n   series with other branches off to the side (ala CVS), it is not\n   possible to say 'VERSION-CONTROL at this time point for the whole\n   tree'.\n\nThat is correct, you need either a single BASELINE-CONTROL operation,\nor two operations: VERSION-CONTROL followed by either a single MERGE\n(for duplicating a workspace or line of descent) or a single UPDATE\n(for selecting a label or a baseline).\n\n   I am assuming introducing the concept of multiple linear version series\n   is too much for the DeltaV community to swallow in terms of change.\n\nThis is covered by the \"activity\" concept.  Each activity is required\nto be linear sequence of versions.  If you want to identify one\nactivity as your \"primary\" activity, that is fine (we in fact do so in\nour product, we call it the \"main\" activity).\n\n   It would support the CVS and DMA approaches quite closely. (eg:\n   Create version-controlled resources for 'whatever version existed at\n   date X' / 'latest version' for the version series called\n'primary'/'1.1.1'/\n   'with label Y'). It would allow a single VERSION-CONTROL command to get\n   the correct version across a hole collection tree. But it is not possible\n   with the current simplistic model of versions having predecessors and\n   successors. It requires something such as the more detailed model of\n   identifying linear series of versions (so you can find the last in a\n   linear series - you cannot find the last in a graph and have it make\nsense).\n\nIf you want to use this concept, you would MERGE the primary activity\ninto your workspace to get what you want.  But you do need two operations,\na single VERSION-CONTROL (to specify the root of your collection) and a\nsingle MERGE (to indicate what linear series you want to populate the\ncollection).\n\nCheers,\nGeoff\n\n\n\n", "id": "lists-006-9989693"}]