{
    "mails": [
        {
            "subject": "Data Model 3.",
            "content": "I have a number of specific suggestions to make regarding Chapter 3.3 of the \nData Model WD.\n\n1. In the first paragraph the PSVI is referred to without a link. Either a \nlink should be provided to W3C XML Schema Part I or (probably better) a \nself-contained document should be provided introducing PSVI in a clear, \nmanner and, if possible, avoiding newcomers to XQuery having to grapple with \nW3C XML Schema Part I.\n\n2. Reference is made to \"schema-validated\" documents and \"DTD-valid\" \ndocuments. The terms should structured the same way.\n\n3. When reference is made to documents not conforming to Namespaces in XML a \nreference should be added to clarify whether version 1.0 or 1.1 is being \nreferred to. By the time XQuery 1.0 gets to REC this may be a practical \nissue. A link should be added to whichever is relevant.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "Suggest XQuery/XSLT/XPath Part 0 document(s",
            "content": "I would like to suggest that the WG provide, in due course, an XQuery Part 0, \nby which I mean an introductory document analogous to W3C XML Schema Part 0. \nThis should, in my view, be published as a REC in the way that Part 0 of W3C \nXML Schema was.\n\nAlready concerns are being expressed about the difficulty in accessing the \nmeaning of XQuery 1.0. Since those comments are coming from those more \ntowards the cutting edge of XML the need for succinct introductory \ninformation can only be anticipated to increase, as others with more general \ninterests come to grapple with XQuery.\n\nThe Use Cases document might be usefully adapted to provide useful tutorial \nlevel information.\n\nDepending on the route the WGs take to clarify/resolve a number of concerns \nraised about XPath 2.0 and XSLT 2.0 in relation to XQuery there may also be a \nneed for one or two additional \"Part 0\" type documents for XPath and XSLT \nusers.\n\nFor many current users of XSLT 1.0 and XPath 1.0 the learning burden brought \nby XQuery is substantial. It would be sad to see XSLT 2.0 and XPath 2.0 \nlanguish in the way that XHTML 1.0 has. \n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "RE: Suggest XQuery/XSLT/XPath Part 0 document(s",
            "content": "Thanks for the suggestion. I agree that tutorial material is often useful,\nthough in my view a normative spec should be written to be readable on its\nown by anyone with a computer science education, and for those without such\nan education, the job is best done by commercial publishers or interested\nindividuals.\n\nIn the end it comes down to finding someone who has the time, inclination,\nand skill to do the writing.\n\nMichael Kay\n\n> -----Original Message-----\n> From: AndrewWatt2001@aol.com [mailto:AndrewWatt2001@aol.com] \n> Sent: 11 May 2002 14:43\n> To: public-qt-comments@w3.org\n> Subject: Suggest XQuery/XSLT/XPath Part 0 document(s)\n> \n> \n> I would like to suggest that the WG provide, in due course, \n> an XQuery Part 0, \n> by which I mean an introductory document analogous to W3C XML \n> Schema Part 0. \n> This should, in my view, be published as a REC in the way \n> that Part 0 of W3C \n> XML Schema was.\n> \n> Already concerns are being expressed about the difficulty in \n> accessing the \n> meaning of XQuery 1.0. Since those comments are coming from \n> those more \n> towards the cutting edge of XML the need for succinct introductory \n> information can only be anticipated to increase, as others \n> with more general \n> interests come to grapple with XQuery.\n> \n> The Use Cases document might be usefully adapted to provide \n> useful tutorial \n> level information.\n> \n> Depending on the route the WGs take to clarify/resolve a \n> number of concerns \n> raised about XPath 2.0 and XSLT 2.0 in relation to XQuery \n> there may also be a \n> need for one or two additional \"Part 0\" type documents for \n> XPath and XSLT \n> users.\n> \n> For many current users of XSLT 1.0 and XPath 1.0 the learning \n> burden brought \n> by XQuery is substantial. It would be sad to see XSLT 2.0 and \n> XPath 2.0 \n> languish in the way that XHTML 1.0 has. \n> \n> Andrew Watt\n> \n\n\n\n"
        },
        {
            "subject": "RE: XPath 2.0  Implications of typing for XPointe",
            "content": "> If XPath 2.0 is to support XPointer is there not a case for a \n> much smaller \n> XPath 2.0 specification which (as with XPath 1.0) corresponds \n> to common \n> functionality of XSLT and XPointer? \n\nThe subject of subsetting XPath comes up fairly frequently. Unfortunately\nnot everyone wants the same subset. But we're certainly open to defining\nsubsets where they are needed - XSLT itself does so in its syntax for match\npatterns.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "RE: xpath 2.0 comment",
            "content": " \n\n-----Original Message-----\nFrom: bryan [mailto:bry@itnisk.com] \nSent: 10 May 2002 13:47\nTo: public-qt-comments@w3.org\nSubject: xpath 2.0 comments\n\n\n \nStuff I don't like:\n    \n    1.  if, for expressions, leave that to scripting technologies, xsl-t\nthat use xpath.  \n \nI'm surprised that you don't recognize the need for conditional expressions\nin XPath. Most experienced XSLT users have at some stage hit a problem like\ndefining a sort key that is @qty if present, or 0 if not. This is very hard\nto do in XSLT 1.0. Putting conditional expressions in XPath solves this:\n \n<xsl:sort select=\"if (@qty) then @qty else 0\"/>\n \nSimilarly, most XSLT users have at some stage encountered the need to do\nsummation of a computed value, the traditional example being totalling\n@price times @quantity. The introduction of scalar sequences and for\nexpressions in XPath solves this nicely:\n \n<xsl:value-of select=\"sum(for $i in item return $i/@price * $i/@qty)\"/>\n \nIt has been argued that 90% of the requirements could be met with a simpler\n\"for\" expression that didn't use range variables, and this is something we\nare still considering. But the form with range variables is needed for join\nproblems, something that arises frequently in \"data-oriented\" transformation\nas distinct from \"document-oriented\" styling.\n \n \n    2. comments, I think this will just increase the illegibility of an\nxpath, it's a pretty compact syntax and comments in the middle will do the\nopposite of what people hope comments will, i.e improve legibility. Envision\ncomments in complicated regular expressions. \n \nI'm inclined to agree with you that XSLT users will not often want to put\ncomments in the middle of XPath expressions. But I don't think that\nnecessarily makes it a bad feature.\n \n    3.  I've been a pain elsewhere talking against the tight integration\nwith xml schema, this seems to me especially wrong headed. But hell I guess\nit's coming. \n \nXML Schema arouses strong feelings. We have worked very hard to make XPath\nusable with schemas; we still have some work to do to make sure that it is\nalso usable without them - but that is definitely our intent. \n \nMichael Kay\n\n\n\n"
        },
        {
            "subject": "Re: [xml-dev] XPath 2.0  how much of XQuery should it include",
            "content": "Jeni Tennison <jeni@jenitennison.com> wrote:\n> There seems like there should be a qualitative distinction between the\n> jobs that XPath and XSLT carry out. I've demonstrated through my posts\n> here that I'm surpremely unable to articulate what the distinction\n> should be, but I know it ain't the one that's being made at the\n> moment.\n\nJeni, I haven't kept up on all your threads and the replies (some of them),\nbut, if it hasn't been pointed out before: one articulation of the\ndifference between the responsibilities of XPath and XSLT:\n\nXPath:\n1) An addressing mechanism into trees and sequences.\n2) Constructs sequences of values.\n(And, yes, it might be interesting to try and separate (1) into a subset,\nthough I have my doubts given complex predicates).\n\nXSLT:\n1) Constructs trees.\n\nThe separation of these responsibilities helps to reduce the complexity of\neither.  Each is a tool tuned to it's respective task.  Each can be\nexpected to have some redundant mechanism, such as iteration and\nconditional evaluation.\n\nThe question is where you draw the line.  From your previous posts I\nunderstand you think the line might be drawn in a different place.  While I\nthink we have it divided just about correctly now, obviously this may well\nbe an area of contention for years to come.\n\n==================\n\n> To be honest, I doubt whether many people have had the energy to go\n> through the WDs, so any opinion they do have will have been formed by\n> the generally positive demonstrations of XSLT 2.0 that there have been\n> on the list or by the generally negative impression that XPath 2.0 is\n> based on the PSVI and therefore hideously complex because XML Schema\n> is hideously complex.\n\nYes, that's the general problem, not only with the mulberry list.\n\nWhile your posts have been thought provoking, in terms of seeing the\nhideously complex, I think you should keep in mind that you're still seeing\nvery intermediate results.  Hopefully some functionality is yet to be\npruned, some seemingly complex functionality needs polishing, and a few bad\n(or incomplete) ideas need to fixed.  The question is, do we need a general\nchange of direction?  Given the many opinions and 3 years (or whatever it's\nbeen) of discussion, I actually think we're doing fairly well, and the\nresults will be a healthy design balance, with very positive connotations\nfor the Web.  Certainly the results will not be perfect.  But I think we're\non a pretty reasonable track, with light being seen at the end of the long\ntunnel.\n\nOur design center(s) drives down to some very fundamental questions, such\nas what is XML?  ASCII text that is tagged, or semantically rich typed\ndata?  With the introduction of schemas, the answer evolves somewhat from\nthe first to include the second.  I truly believe that even document users\nwill need and want the rich typed data, whether they know it yet or not,\nand visa versa with data users.  Surely people will use XML in both\ndomains.  This is the magic, challenge, and risk of XML: trying to be all\nthings to all people.  To some extent, XPath 2.0 has to inherit these\nchallenges and risks.\n\n-scott\n(Speaking for myself... these are not necessarily representative views of\nmy company, or the XSL Working Group).\n\n\n\n"
        },
        {
            "subject": "RE: XPath 2.0 Requirements  Suggestion",
            "content": "Andrew, this requirements document was issued after public consultation over\na year ago, and we're not planning to reissue it in the immediate future,\nand will only do so if there is a significant change in direction. Although\nthere was no formal deadline for submitting comments on the requirements\ndocument, the project is now well beyond the requirements phase. If you have\nsubstantive comments asking that particular requirements be added or\nremoved, that input will still be useful, but editorial comments asking that\nthe document be rewritten with extra justification material are (in my view)\nnot something that we can act upon just now. That's not an official WG view,\njust my guess as to what the official WG response would be, given the other\ndemands on our time.\n\nYour comment does provide us with a reminder that we sometimes need to\ninclude justification material in our other publications, for example in the\nspecs themselves or in the use cases. In the XSLT 2.0 draft we removed a lot\nof rationale for existing features like keys, but have added rationale for\nnew features like grouping, and I have an action to draft additional\ndescriptive text for the integration with Schema.\n\nMichael Kay\nSoftware AG\n\n> -----Original Message-----\n> From: AndrewWatt2001@aol.com [mailto:AndrewWatt2001@aol.com] \n> Sent: 10 May 2002 14:18\n> To: public-qt-comments@w3.org\n> Subject: XPath 2.0 Requirements - Suggestions\n> \n> \n> I would like to suggest that the title of the document is \n> updated to read \n> \"XPath Version 2.0 Requirements\" rather than its current form.\n> \n> I would also like to suggest that the Working Group replace \n> the phrase \"XPath \n> 2.0 has the following goals\" in 1. Goals with something less \n> fatuous. Such \n> anthropomorphic references to a technology serve only to conceal the \n> rationale for a particular approach. And the rationale for \n> the approach taken \n> to XPath 2.0 is something that deserves more open discussion.\n> \n> Perhaps change the phrase to, \"The XPath 2.0 Working Group \n> has the following \n> goals for XPath 2.0 ...\".\n> \n> For each goal I would suggest a brief statement be added \n> describing the \n> benefits anticipated for/from the goal, and a description of \n> who benefits and \n> who is disadvantaged by the change.\n> \n> I would also like to suggest that an explicit Goal \"That \n> XPath 2.0 does not \n> add unnecessary and irrelevant complexity for users of XSLT\" \n> be added to an \n> updated Requirements document.\n> \n> Andrew Watt\n> \n\n\n\n"
        },
        {
            "subject": "RE: F&amp;O WD: Issue 150: Should we support comparisons  of date/tim   e types that return indeterminate results",
            "content": "Jeni, perhaps you should just take our failure to include partial ordering\nof durations as evidence that we share your concern about the complexity of\nthe specs and the need to avoid adding features that increase this\ncomplexity.\n\nIf we all agreed which features are really useful and which are\ncomplications that we can live without, then life would be a great deal\neasier. We all have our own hit lists, but every feature currently in the\nspecs has a champion who will argue for its retention.\n\nMichael Kay\n\n> -----Original Message-----\n> From: Jeni Tennison [mailto:jeni@jenitennison.com] \n> Sent: 11 May 2002 01:43\n> To: public-qt-comments@w3.org\n> Subject: Re: F&O WD: Issue 150: Should we support comparisons \n> of date/tim e types that return indeterminate results?\n> \n> \n> Mike wrote:\n> > Dealing with partial ordering causes many problems, and therefore \n> > surprises. For example it means that the user (and the \n> optimizer) can \n> > no longer rely on invariants such as A<B => not(A>=B). It causes \n> > particular problems for implementors (such as Microsoft) \n> who want to \n> > map XQuery to an underlying SQL database. We've been hoping \n> to find a \n> > way of avoiding this level of complexity. In the case of durations, \n> > one solution I proposed was to achieve a total ordering by \n> equating a \n> > month to 365.242199 div 12 days; this would mean 12 months \n> > 365 days \n> > and 12 months < 366 days, which would at least be \n> comprehensible even \n> > if not always what the user wanted. Unfortunately it gets \n> complicated \n> > when you look at the interactions with addition of \n> durations to dates, \n> > where you want some invariants like DATE1 + DURATION1 < DATE1 + \n> > DURATION2 iff DURATION1 < DURATION2. So we decided to park \n> the problem \n> > on the back burner by disallowing the awkward cases for the time \n> > being. Better to disallow them now than to allow them with \n> semantics \n> > that we will regret later.\n> \n> When you say \"for the time being\" are you talking about \"for \n> the next couple of iterations on the WDs\" or are you talking \n> about \"for this version of XQuery/XPath 2.0\"? If it's the \n> latter, I think that's a big mistake. If it's the former, put \n> this message on ice until you come to reviewing your decision.\n> \n> Perhaps the problem is similar to that of strings. When you \n> ask whether one string is less than another string, the \n> answer is \"it depends\". What about defining collations for \n> dates, which might use specific dates against which to test \n> durations? Or, better, using three-valued logic, which you \n> already have some support for by way of error values?\n> \n> The direct results of this decision on usability are:\n> \n>   - the inability for people to manipulate durations that don't fit\n>     neatly into those categories, such as:\n>     - values that internally mix months and days (e.g. prison\n>       sentences: \"man sentenced to a year and a day\")\n>     - values of types that might be in months or days (e.g. durations\n>       between checkups: \"come to see me every six months\"; \"I think I\n>       need to see you once a week\")\n>     \n>   - the inability for people to use existing schemas that involve\n>     xs:duration without casting to the more specific types within\n>     their query or stylesheet\n> \n>   - even more hugely long function names\n> \n> At the very least, couldn't you allow people to add all kinds \n> of durations to dateTimes \n> (http://www.w3.org/TR/xmlschema-2/#adding-durations-to-dateTim\nes)?\nThen users could get around the lack of xs:duration support by choosing a\ndate, adding the durations to it, and comparing them.\n\nOr have you made the order of addition flexible so that you can optimise by\ndoing the calculations in whatever order you like? If so, you still have\nproblems:\n\n  (2000-02-29 + P1Y) + P1M => 2001-03-28\n  (2000-02-29 + P1M) + P1Y => 2001-03-29\n\nCheers,\n\nJeni\n\n---\nJeni Tennison\nhttp://www.jenitennison.com/\n\n\n\n"
        },
        {
            "subject": "RE: [xml-dev] XPath 2.0  how much of XQuery should it include",
            "content": "Jeni Tennison wrote:\n> To be honest, I think that the kind of merger that people \n> have in mind when they talk about using XQuery and XSLT \n> together is to replace XSLT with XQuery. \n\nI guess different people have very different things in mind, but I haven't\nheard anyone suggesting that XQuery should aim to replace XSLT. The WGs are\nnot talking about such a merger: it isn't on the agenda. I personally see\nXSLT and XQuery co-existing in the roles of report-writer and database\naccess language: XQuery gets the data, XSLT arranges it in the form required\nby the client. Of course both languages do things that aren't strictly\nnecessary to those roles, but that's because this isn't the only usage\nscenario.\n\nOccasionally some of us dream about a successor language that replaces both\nXSLT and XQuery, but to be realistic I suspect that's ten years away, and it\ncan only be designed with the benefit of seeing what works and what doesn't\nin the languages we are designing today. \n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "RE: XSLT 2.0 light",
            "content": "> But you can't very well tell people to go have a look at e.g. \n> www.w3.org/TR/query-semantics before they ask any more stupid \n> questions. Can you?\n\nI agree. This is why we are trying to write the main XPath 2.0 specification\nas a complete and free-standing description of the language, that relies on\nthe formal semantics only for exceptionally complex situations, for example\nsome of the type subsumption rules. The formal semantics document is written\nfor implementors, not for users.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "Re: [xml-dev] XPath 2.0  how much of XQuery should it include",
            "content": "Hi Scott,\n\n> XPath:\n> 1) An addressing mechanism into trees and sequences.\n> 2) Constructs sequences of values.\n> (And, yes, it might be interesting to try and separate (1) into a\n> subset, though I have my doubts given complex predicates).\n>\n> XSLT:\n> 1) Constructs trees.\n>\n> The separation of these responsibilities helps to reduce the\n> complexity of either. Each is a tool tuned to it's respective task.\n> Each can be expected to have some redundant mechanism, such as\n> iteration and conditional evaluation.\n\nYes, Mike's explained that distinction, and I can see that it is\ninternally consistent one to make. I'm sure that there are those in\nthe WG that have made the following points, but just in case...\n\n1. When you're writing the code, it's much easier to work out how to\nachieve a task based on what you want to do rather than what you want\nto do it to. The thought process \"OK, I want to have a loop that\ncreates a sequence of atomic values, so I have to do that using XPath,\nwhich means using a for expression\" is less intuitive than the thought\nprocess \"OK, I want to loop, so I need to use xsl:for-each\". I think\nthat we'll often get situations where users will know how to achieve a\ntask when using XSLT but not understand how to achieve the comparable\ntask when using XPath (and vice versa), particularly since the\napproach to looping is fairly different.\n\n2. I don't buy the separation-reduces-complexity argument. XPath is\ncertainly more complex, and XSLT is no less complex with the current\nseparation. Aside from the ability to create an atomic value, what\nsavings have been made on the XSLT side due to the extra complexity of\nXPath?\n\n3. Mike's made an argument that the tools are easier to write because\nthey can focus on the optimisation of the XPath side of the equation.\nBut XQuery has a single approach:\n\n  for $i in $list                 for $i in $list\n  return <foo />                  return 'foo'\n\nAside from syntax, I can't see a difference between these queries and\nthe XSLT:\n\n  <xsl:for-each select=\"$list\">   <xsl:for-each select=\"$list\">\n    <foo />                         <xsl:item select=\"'foo'\" />\n  </xsl:for-each>                 </xsl:for-each>\n\nPerhaps XQuery implementers have some ideas about telling the\ndifference that could help.\n  \n4. There are things that are lacking in the XPath version of sequence\nmanipulation that are present in the XSLT version of sequence\nmanipulation that I believe will make the XPath version a lot harder\nto deal with. In particular, I'm thinking of variable assignment and\nthe ability to keep track of the context position of an item in a\nsequence. I think that people are going to have to create their own\nfunctions so that they can use XSLT variable assignment to get around\nthose problems, and I think that's a bad idea on usability grounds,\nand because I think function use should be a choice rather than a\nnecessity in a programming language.\n\n> While your posts have been thought provoking, in terms of seeing the\n> hideously complex, I think you should keep in mind that you're still\n> seeing very intermediate results. Hopefully some functionality is\n> yet to be pruned, some seemingly complex functionality needs\n> polishing, and a few bad (or incomplete) ideas need to fixed.\n\nSure. I understand from personal experience how frustrating it is to\nreceive feedback on areas that you already *know* need work. I'd like\nto direct comments on the areas that you're interested in getting\nfeedback on; on the other hand, it seems risky to wait until the WDs\nbecome Candidate Recommendations before I comment on a feature that\ndoesn't seem right to me -- I think you'd be even more irritated by my\ncomments if they came later in the process. Perhaps it would help, in\nthe drafts or separately, for you to list those sections that you're\npretty certain are representative of how you intend things to be, so\nthat we can focus our reading and comments on them. Or perhaps there's\na particular style of comments that you'd prefer?\n\n> The question is, do we need a general change of direction? Given the\n> many opinions and 3 years (or whatever it's been) of discussion, I\n> actually think we're doing fairly well, and the results will be a\n> healthy design balance, with very positive connotations for the Web.\n> Certainly the results will not be perfect. But I think we're on a\n> pretty reasonable track, with light being seen at the end of the\n> long tunnel.\n\nI'm very glad that you feel like that; I'd be worried if the driver\nwas wandering through the train checking the map. Sitting here in the\ncarriage, I'm seeing increasing unease on the faces of many of the\nother passengers as the names of stations flash past. Perhaps we all\ngot on the wrong train; perhaps this is an alternative route we don't\nknow about and once we emerge from the tunnel we'll be reassured; or\nperhaps the driver didn't realise that the train was supposed to be\nheading somewhere else. Whichever case it is, it's not going to get\nresolved by us hiding behind our newspapers hoping that everything's\nOK or that someone else is talking to the crew.\n\nPlease understand: by making comments at all, I'm trying to be\nconstructive by supplying an external, user perspective, not trying to\nmake trouble by destroying the delicate balance of compromises that\nhave led to the current design. I suggest alternatives because I\nbelieve that's more useful than abstract critiques, not because I have\nparticularly fixed ideas about what a solution should look like. I\nknow that the WGs have an incredibly difficult task on their hands,\nand that you've all put in a lot of work to get to where you are now,\nand I do appreciate that effort, even if I don't agree with the\noutcome.\n\nCheers,\n\nJeni\n\n---\nJeni Tennison\nhttp://www.jenitennison.com/\n\n\n\n"
        },
        {
            "subject": "F&amp;O W",
            "content": "Hi Jonathan,\n\nI promised some more detailed comments on the F&O WD, so here you are.\nAs usual, these come from my perspective as an XSLT user rather than\nanything else. I've ignored the constructors and casting sections,\nsince I know they're under review anyway.\n\nI guess my guiding principal is that if a function is just a shorthand\nfor something that can be implemented without a recursive function,\nthen it shouldn't be included in the core set of XPath 2.0 functions.\nBoth XQuery and XSLT have methods of defining extension functions, so\nI think that it's more important to focus on the functions that are\nimpossible or difficult to implement in XQuery/XSLT rather than those\nthat are simply convenience functions.\n\nCheers,\n\nJeni\n\n---\n\nThe new functions, added on to XPath 1.0, are the following. I've put\n* by the ones that I think should stay, - by those that I think should\ngo, and + by those on which I'm equivocal:\n\n  - node-kind() -- I've hardly ever seen a problem that's required\n    this functionality. I think it would be more flexible to use the\n    \"instance of\" operator to work out what kind of node you're\n    looking at; it would be easy enough to define your own function to\n    give you the name of the node type on the rare cases that's\n    required. In other words, you should be able to get at the type of\n    a node and the type of an atomic value in the same way.\n  \n  + node-name() -- This used to be the name() function; I wonder\n    whether it would be possible to merge this with the name()\n    function. It would be great if that could be done so that the\n    name() function works in the way that people think it works, such\n    that \"name() = 'pfx:name'\" is equivalent to \"self::pfx:name\"; this\n    would be backwards-incompatible with XPath 1.0, but would be more\n    intuitive for users.\n\n  * data() -- Certainly required now, but as with a lot of these\n    functions, I wonder whether it would be helpful to have it follow\n    the pattern of existing functions, like name() and string(), and\n    have it return the typed value of the context node if it doesn't\n    have an argument passed to it. I know that the F&O document\n    purposefully tries to avoid overloaded functions, but for users,\n    both those used to XPath 1.0 and those coming new to XPath 2.0, it\n    will be confusing that different functions work in different ways\n    depending on which version they were introduced in.\n\n  * base-uri() -- Certainly very useful; we often get questions asking\n    how to get the URL of the file that's being used as the source of\n    the transformation.\n\n  - unique-ID() -- I've never known anyone to have to get hold of the\n    value of the ID attribute on a given element. If they do, they\n    know the name of the attribute and can get its value through\n    normal mechanisms. I'm also worried that this function will get\n    confused with the generate-id() function.\n\n  * compare() -- We do need this facility although not as much as\n    you might think, in my opinion. I have to say that personally I\n    find a return value of -1, 0 or 1 difficult to work with: I always\n    get confused about which way round the arguments are related. It\n    would be great if there was an alternative design, but I doubt\n    that there is and since we'll rarely have to use different\n    collations, I don't think that's too much of a problem.\n\n  - normalize-unicode() -- As far as I understand the character\n    model for the WWW, all text on the Internet should be normalized,\n    and specifications should require unicode normalized (NFC) text. I\n    can't recall ever seeing someone need to do unicode normalization;\n    I suspect that such operations would be better done at a lower\n    level in the application (normalize early) and that the data model\n    should dictate that text is normalized.\n\n  * upper-case() and lower-case() -- There's definitely a strong\n    requirement for these, although allowing case-insensitive\n    comparisons (which I think is supported with collations?) will go\n    most of the way towards supporting the usual reason for\n    case-changing. As I think I might have mentioned before, I believe\n    that technically there should be a title-case() function as well,\n    since the title case version of a letter is not always the same as\n    the upper case version of a letter (ref.\n    http://www.unicode.org/unicode/reports/tr21/)\n\n  + string-pad() -- Repeating the same string is a fairly common\n    operation, although it is one that's particularly easy to\n    accomplish now with a user-defined function and a simple\n    iteration. I therefore don't think that this function is vital,\n    and if you want to save space, I think it should be dropped.\n\n  * match() and replace() -- I think that you know that we need more\n    regular expression support than this; I believe that you're\n    working on that and that I've already commented on it.\n\n  + duration/dateTime functions -- I've already commented on these in\n    a separate thread. I think that this is the poorest section of the\n    spec. The kinds of things that people want to do with dates are:\n\n      - reformat them (which I believe is being supported separately\n        in XSLT 2.0, though it's not there yet)\n\n      - get a date from the common \"seconds since\n        1970-01-01T00:00:00Z\" representation (for all its faults)\n\n      - perform calculations between them\n\n    Dates have a fixed format, so it's not hard to extract individual\n    components from a date; I don't think that the set of functions to\n    do so are necessary. It's harder to extract information from a\n    duration because it doesn't have a fixed format, but not\n    drastically so, and I think it's really very rare that you need to\n    know get that kind of information from a duration.\n\n    One thing that *is* difficult, and is useful, is to get values\n    like \"the number of seconds represented by this duration\" (i.e.\n    the reverse of dayTimeDuration-from-seconds()) -- it's useful\n    because that enables you to perform calculations with durations\n    (adding them, dividing them) that you can't do otherwise.\n\n  * get-local-name() and get-namespace-uri() -- Makes me wish that\n    the structured data types such as QNames, dates, durations and so\n    on could be treated as virtual elements, so you could do\n    $qname/local-name or $date/year. These are certainly handy\n    functions, though.\n\n  * resolve-URI() -- I imagine this will be very handy.\n\n    URI manipulation is, I think, the primary reason for the\n    requirement for string manipulation functions like\n    subtring-after-last() or index-of-last(). Perhaps a\n    get-file-name() method would be useful; I'm not sure.\n\n  + deep-equal() -- I wouldn't personally say that this was a\n    high-priority function. My guess would be that people would use it\n    for the common task of moving through two documents to see where\n    differences lie between them, and in that context I think it would\n    be very expensive. But others might have use cases that I'm\n    unaware of.\n\n  - root() -- I think that root($node) does the same thing as\n    $node/ancestor::node()[last()]. Given that the function is\n    possible with very little effort, and that you rarely need to get\n    from a node to the root node of that document, I don't really see\n    the point of this function.\n\n  - if-absent() and if-empty() are shorthands for:\n    if (not($node)) then $default else $node and\n    if (not($node) or not($node/node())) then $default else $node\n    I don't find these expressions so burdensome that they require\n    shorthand functions, especially not compared to some of the other\n    functionality that's currently missing from the spec.\n\n  * index-of() -- definitely required, though I have no doubt that\n    people will use it like:\n\n    $nodes[index-of(for $n in $nodes return string(), 'foo')]\n\n  - empty() -- empty($seq) seems to be equivalent to\n    not(boolean($seq)); as with other shorthands for easy expressions,\n    I don't think this one's necessary, although it's true that the\n    casting of empty sequences to boolean false can be non-obvious for\n    beginners.\n\n  - exists() -- seems to be equivalent to not(empty($seq)) or exactly\n    equivalent to boolean($seq). I don't think this is necessary;\n    empty() is more useful if you didn't want to use boolean() in the\n    way that it's been used in XPath 1.0.\n\n  + distinct-nodes() -- This obviously doesn't arise in XSLT 1.0\n    because it's impossible to create a node set that contains more\n    than one of a particular node. Given that node sequences are (or\n    should/can be) created with duplicates automatically removed, I\n    doubt that this will come into play very often; there aren't any\n    use cases for it in the XQuery use case document either. On the\n    other hand, the equivalent expression (distinct-nodes($nodes) is\n    the same as union(() | $nodes)) is a bit of a hack and might not\n    get you precisely what you want (since it also reorders into\n    document order), so it's probably best to be on the safe side.\n\n  * distinct-values() -- This functionality is required (and\n    lacking) in XSLT 1.0, but the grouping facilities in XSLT 2.0 mean\n    that it wouldn't be nearly as important there. I can see places\n    where it would be handy, though (for example to write things like\n    \"there are 4 groups...\", and to allow me to apply templates to\n    distinct nodes in order to get more flexibility in my stylesheet).\n    Since this function is likely to be much more heavily used than\n    distinct-nodes(), I think it should be shortened to distinct().\n\n  - insert() -- I can't really see the point, given that there's a\n    concat(), a subsequence() and an index-of() and I don't think that\n    there will often be times when you need to insert items into the\n    middle of a sequence.\n\n  - remove() -- Again, I don't see why this is needed, given that you\n    can use a predicate to do the same thing: $target[position() !=\n    $position].\n\n  * subsequence() -- I imagine would be useful.\n\n  + sequence-deep-equal() and sequence-node-equal() -- I'm not sure\n    about sequence-deep-equal(), for the same reason I'm not sure\n    about deep-equal(). The most useful, I would imagine, would be a\n    plain sequence-equal() that compared the two sequences to see if\n    they were the same on an item-by-item basis, with nodes being\n    assessed based on identity, and values being assessed on their\n    value.\n\n  - avg() -- I'm not personally convinced (since the equivalent\n    expression of sum() div count() really isn't difficult).\n\n  * max() and min() -- Definitely. This is a requirements that's\n    probably even greater than date formatting or regular expressions.\n    It would be even more helpful if there was a quick way of getting\n    to the node(s) that has the min/max value, rather than just\n    getting the value itself. I imagine we're going to see rather a\n    lot of $nodes[. = max($nodes)] otherwise, although I guess that\n    could be optimised.\n\n  - idref() -- As I've said elsewhere, id() turns out to be hardly\n    used in XSLT because of the issues to do with requiring a DTD be\n    present for the link to be any use. Where you need a reverse link,\n    you can generally set up a key instead. I'd rather see keys from\n    XML Schema supported than a specific idref() function introduced.\n\n  - filter() -- I think this is potentially very useful, but, like\n    copy() and shallow(), it has to do with creating nodes, which\n    means that it shouldn't live at the XPath level.\n\n  - collection() -- I don't really understand how this is different\n    from the document() function.\n\n  * input() -- Sounds reasonable.\n\n  - context-item() -- I assume that this is not a real function, but\n    actually just a backup for the shorthand '.'? It should say so.\n\n  * current-dateTime() -- Definitely required; XForms calls this\n    function now(), which has the advantage of being short and\n    avoiding the mixed case convention difficulties.\n\nAside from those mentioned above, functions that are missing are:\n\n  * tokenize(), which people ask for all the time, particularly for\n    splitting strings into lines or words\n\n  + possibly sqrt(), sin() and cos(), which are particularly useful\n    when creating graphic formats such as SVG and aren't that easy to\n    implement in XSLT\n\n  * random() (create random numbers) and more usefully, I think,\n    randomize() (randomly alter the order of items in a sequence),\n    both with obvious side-effect issues; again these are impossible\n    to implement using XSLT\n\n  * function-available() to support the idea that XPath function\n    libraries could be provided by particular implementations.\n\n  * system-property() to support getting information about the XPath\n    implementation version and so on.\n\nFWIW, on the issues front:\n\n  14: (operator-function-signatures) I agree, some of the\n      signatures are confusing; I read the spec as indicating the\n      required types for the functions, such that if you're using\n      XPath the casting to those types is done automatically.\n\n  20: (operator-codepoint-vs-character) I agree that the spec\n      should be clear about whether it's talking about code points or\n      characters, but I think that the character model spec recommends\n      talking about character strings rather than code unit strings\n      (ref. http://www.w3.org/TR/charmod/#sec-Strings)\n\n  21: (operator-function-return-types) In my opinion, the return\n      type of a function should be fixed, and not change based on the\n      actual type passed as the argument of a function.\n\n  37: (semantic-contains) I think that adding linguistic/semantic\n      contains is a huge effort for very little benefit, at least for\n      XPath 2.0. I can see that XQuery might want it, but I wouldn't\n      want XSLT to be burdened, as the primary task of XSLT is\n      transformation rather than querying.\n\n  44: (operator-collation-specification) I think that XPath 2.0 should\n      follow the pattern of XPath/XSLT 1.0 and use qualified names\n      rather than URIs, for consistency and because it makes them\n      easier to use.\n\n  63: (operator-augment-index-of) I find the distinction between\n      performing operations on nodes vs. performing operations on\n      their values fiddly. In the case of index-of(), it strikes me\n      that it wouldn't be difficult to perform index-of-value() if you\n      had support for an index-of() that matched by node identity or\n      simple type value (by creating a sequence of the node values and\n      getting the index of the value you were after).\n\n  66: (operator-docorder-function) Like distinct-nodes(), the\n      requirement (or lack of it) for this function isn't yet apparent\n      because it's not an issue in XSLT 1.0. Personally, I don't think\n      that it will be used that often, but it may be best to be on the\n      safe side as it wouldn't be particularly easy to replicate this\n      functionality without removing duplicate nodes at the same time.\n\n  67: (operator-remove-dupes) Since location paths do remove\n      duplicates, and there thus isn't any backwards incompatibility\n      with XPath 1.0, I don't think there's any reason for count() or\n      sum() to remove duplicates.\n\n  73: (operator-compare-between) I don't think that a\n      compare-between() function is required.\n\n  77: (operator-string-from-char) chars aren't data types in XML\n      Schema -- are they in XPath? If not, then this issue isn't\n      relevant.\n\n  94: (operator-within-window) As with (semantic-contains), I don't\n      think this is a high priority for XPath 2.0.\n\n 108: (operators-always-normalize) I don't think that we should need\n      to worry about unicode normalization within XPath 2.0.\n\n 136: (function-datetime-timezone-conversion) In XML Schema, the\n      timezone isn't part of the value space of a dateTime. Adding a\n      timezone to a dateTime is essentially a formatting function.\n\n 139: (need-fuller-definition-of-error-behavior-and-handling) Yes. We\n      need to be able to test if an item is an error, and then be able\n      to get information about that error, most importantly an error\n      message that describes it and probably some information about\n      the context in which the error occurred (e.g. what the context\n      node was). I'm sure that you already have something on the cards\n      here. Another point of confusion is that the empty sequence is\n      sometimes used as a kind of error value, but at other times an\n      error object is returned. I haven't yet worked out what the\n      underlying heuristic is there, assuming that there is one.\n\n 141: (does-string-equality-use-codepoint-or-default-collation) I\n      think it should use the default collation, like the other string\n      manipulation functions.\n\n 142: (what-should-floor-ceiling-round-return) For compatibility, this\n      should really return a xs:double (I believe). However, I think\n      that returning an xs:integer, with an empty sequence used\n      instead of NaN, would also be reasonable.\n\n 143: (need-tokenize-function) As above, we definitely need a\n      tokenize() function, preferably one that defaults to breaking on\n      whitespace.\n\n 144: (should-concat-accept-sequence-arguments) It would be useful,\n      but highly incompatible. Perhaps a separate concat-sequence()\n      function should be invented. (In XSLT 2.0, you can achieve\n      the same effect with an xsl:value-of and an empty separator\n      attribute, but since XSLT shouldn't be used for general sequence\n      construction (apparently), this isn't ideal.\n\n 150: (should-comparison-that-return-indeterminate-results-be-supported)\n      As I've said before, yes. This is far more important than\n      supporting matching of 'nearby' strings and so on, in my\n      opinion.\n\n 151: (comparison-functions-for-other-date-and-time-types) Yes, there\n      should be comparison functions for other date and time types,\n      although a basic rule about how the comparisons are carried out\n      would be better than listing every possible combination of\n      comparisons.\n\n 152: (parameterized-extraction-functions-for-date-and-times) I view\n      the extraction functions as superfluous, in the face of\n      substring() and the prospect of a format-date() function. If you\n      have them here, then I do think that they should be\n      parameterised.\n\n 154: (second-order-distinct-function) Like the other second-order\n      functions, it would be great, but I don't think it's worth\n      entering that territory at this stage.\n\n 157: (boolean-from-string-legal-literals) Absolutely.\n\n 162: (can-the-node-parameter-to-root-be-omitted) As I mentioned\n      above, I think that having single-argument functions default to\n      using the context item is a very useful tactic, and one that\n      XPath 1.0 users are used to exploiting. It would be good, for\n      consistency, if the new functions supported this shorthand.\n\n 164: (for-complex-types-what-should-data-return) I don't have a\n      strong opinion either way, but it should be consistent with the\n      description of the typed value accessor in the data model. Since\n      the string value is readily accessible in other ways, I think\n      data() should probably not return the string value of the\n      element if it has a complex type with complex content.\n\n 166: (current-dateTime-convenience-functions) On the principal of\n      having as few functions as possible, I don't think these\n      convenience functions are necessary. They are easy to define for\n      people who want them.\n\n 168: (should-id-take-a-list-of-strings) id() definitely should be\n      compatible with id() in XPath 1.0, and therefore accept a list\n      of IDs.\n\n---\nJeni Tennison\nhttp://www.jenitennison.com/\n\n\n\n"
        },
        {
            "subject": "RE: [xml-dev] XPath 2.0  how much of XQuery should it include",
            "content": "Jeni Tennison wrote:\n\n> 3. Mike's made an argument that the tools are easier to write \n> because they can focus on the optimisation of the XPath side \n> of the equation. But XQuery has a single approach:\n> \n>   for $i in $list                 for $i in $list\n>   return <foo />                  return 'foo'\n> \n> Aside from syntax, I can't see a difference between these \n> queries and the XSLT:\n> \n>   <xsl:for-each select=\"$list\">   <xsl:for-each select=\"$list\">\n>     <foo />                         <xsl:item select=\"'foo'\" />\n>   </xsl:for-each>                 </xsl:for-each>\n> \n> Perhaps XQuery implementers have some ideas about telling the \n> difference that could help.\n>   \n\nThe <xsl:item> idea is not unattractive, and we haven't ruled it out. But I\nthink if we go this way it will tend to increase the amount of duplication\nbetween the two languages rather than decrease it. If we had full\ncomposability between XSLT and XPath expressions then we could put the\nfunctionality where we liked. We haven't; and functionality that we put into\nXPath is available in a wider variety of contexts than the same\nfunctionality in XSLT. (Including to XPath hosts other than XSLT of course).\nWe all know the limitations of keys and sort keys having to be defined as a\nsingle XPath expression. I don't think we can remove sequence construction\nand mapping from XPath, so I would rather not duplicate them in XSLT.\n\nI also want to keep the idea that an XSLT stylesheet is a template for the\nresult document. Literal result elements and text nodes in the stylesheet\nare copied directly to the result; instructions generate groups of nodes in\nthe result. I thinnk that's a useful metaphor.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "RE: F&amp;O W",
            "content": "Jeni:\nThanks for your comments.  We are all at a W3C meeting this week.  Will get back to you next week.\nAshok\n\n-----Original Message----- \nFrom: Jeni Tennison [mailto:jeni@jenitennison.com] \nSent: Mon 5/13/2002 4:01 AM \nTo: Jonathan Robie \nCc: public-qt-comments@w3.org \nSubject: F&O WD\n\n\n\nHi Jonathan,\n\nI promised some more detailed comments on the F&O WD, so here you are.\nAs usual, these come from my perspective as an XSLT user rather than\nanything else. I've ignored the constructors and casting sections,\nsince I know they're under review anyway.\n\nI guess my guiding principal is that if a function is just a shorthand\nfor something that can be implemented without a recursive function,\nthen it shouldn't be included in the core set of XPath 2.0 functions.\nBoth XQuery and XSLT have methods of defining extension functions, so\nI think that it's more important to focus on the functions that are\nimpossible or difficult to implement in XQuery/XSLT rather than those\nthat are simply convenience functions.\n\nCheers,\n\nJeni\n\n---\n\nThe new functions, added on to XPath 1.0, are the following. I've put\n* by the ones that I think should stay, - by those that I think should\ngo, and + by those on which I'm equivocal:\n\n  - node-kind() -- I've hardly ever seen a problem that's required\n    this functionality. I think it would be more flexible to use the\n    \"instance of\" operator to work out what kind of node you're\n    looking at; it would be easy enough to define your own function to\n    give you the name of the node type on the rare cases that's\n    required. In other words, you should be able to get at the type of\n    a node and the type of an atomic value in the same way.\n \n  + node-name() -- This used to be the name() function; I wonder\n    whether it would be possible to merge this with the name()\n    function. It would be great if that could be done so that the\n    name() function works in the way that people think it works, such\n    that \"name() = 'pfx:name'\" is equivalent to \"self::pfx:name\"; this\n    would be backwards-incompatible with XPath 1.0, but would be more\n    intuitive for users.\n\n  * data() -- Certainly required now, but as with a lot of these\n    functions, I wonder whether it would be helpful to have it follow\n    the pattern of existing functions, like name() and string(), and\n    have it return the typed value of the context node if it doesn't\n    have an argument passed to it. I know that the F&O document\n    purposefully tries to avoid overloaded functions, but for users,\n    both those used to XPath 1.0 and those coming new to XPath 2.0, it\n    will be confusing that different functions work in different ways\n    depending on which version they were introduced in.\n\n  * base-uri() -- Certainly very useful; we often get questions asking\n    how to get the URL of the file that's being used as the source of\n    the transformation.\n\n  - unique-ID() -- I've never known anyone to have to get hold of the\n    value of the ID attribute on a given element. If they do, they\n    know the name of the attribute and can get its value through\n    normal mechanisms. I'm also worried that this function will get\n    confused with the generate-id() function.\n\n  * compare() -- We do need this facility although not as much as\n    you might think, in my opinion. I have to say that personally I\n    find a return value of -1, 0 or 1 difficult to work with: I always\n    get confused about which way round the arguments are related. It\n    would be great if there was an alternative design, but I doubt\n    that there is and since we'll rarely have to use different\n    collations, I don't think that's too much of a problem.\n\n  - normalize-unicode() -- As far as I understand the character\n    model for the WWW, all text on the Internet should be normalized,\n    and specifications should require unicode normalized (NFC) text. I\n    can't recall ever seeing someone need to do unicode normalization;\n    I suspect that such operations would be better done at a lower\n    level in the application (normalize early) and that the data model\n    should dictate that text is normalized.\n\n  * upper-case() and lower-case() -- There's definitely a strong\n    requirement for these, although allowing case-insensitive\n    comparisons (which I think is supported with collations?) will go\n    most of the way towards supporting the usual reason for\n    case-changing. As I think I might have mentioned before, I believe\n    that technically there should be a title-case() function as well,\n    since the title case version of a letter is not always the same as\n    the upper case version of a letter (ref.\n    http://www.unicode.org/unicode/reports/tr21/)\n\n  + string-pad() -- Repeating the same string is a fairly common\n    operation, although it is one that's particularly easy to\n    accomplish now with a user-defined function and a simple\n    iteration. I therefore don't think that this function is vital,\n    and if you want to save space, I think it should be dropped.\n\n  * match() and replace() -- I think that you know that we need more\n    regular expression support than this; I believe that you're\n    working on that and that I've already commented on it.\n\n  + duration/dateTime functions -- I've already commented on these in\n    a separate thread. I think that this is the poorest section of the\n    spec. The kinds of things that people want to do with dates are:\n\n      - reformat them (which I believe is being supported separately\n        in XSLT 2.0, though it's not there yet)\n\n      - get a date from the common \"seconds since\n        1970-01-01T00:00:00Z\" representation (for all its faults)\n\n      - perform calculations between them\n\n    Dates have a fixed format, so it's not hard to extract individual\n    components from a date; I don't think that the set of functions to\n    do so are necessary. It's harder to extract information from a\n    duration because it doesn't have a fixed format, but not\n    drastically so, and I think it's really very rare that you need to\n    know get that kind of information from a duration.\n\n    One thing that *is* difficult, and is useful, is to get values\n    like \"the number of seconds represented by this duration\" (i.e.\n    the reverse of dayTimeDuration-from-seconds()) -- it's useful\n    because that enables you to perform calculations with durations\n    (adding them, dividing them) that you can't do otherwise.\n\n  * get-local-name() and get-namespace-uri() -- Makes me wish that\n    the structured data types such as QNames, dates, durations and so\n    on could be treated as virtual elements, so you could do\n    $qname/local-name or $date/year. These are certainly handy\n    functions, though.\n\n  * resolve-URI() -- I imagine this will be very handy.\n\n    URI manipulation is, I think, the primary reason for the\n    requirement for string manipulation functions like\n    subtring-after-last() or index-of-last(). Perhaps a\n    get-file-name() method would be useful; I'm not sure.\n\n  + deep-equal() -- I wouldn't personally say that this was a\n    high-priority function. My guess would be that people would use it\n    for the common task of moving through two documents to see where\n    differences lie between them, and in that context I think it would\n    be very expensive. But others might have use cases that I'm\n    unaware of.\n\n  - root() -- I think that root($node) does the same thing as\n    $node/ancestor::node()[last()]. Given that the function is\n    possible with very little effort, and that you rarely need to get\n    from a node to the root node of that document, I don't really see\n    the point of this function.\n\n  - if-absent() and if-empty() are shorthands for:\n    if (not($node)) then $default else $node and\n    if (not($node) or not($node/node())) then $default else $node\n    I don't find these expressions so burdensome that they require\n    shorthand functions, especially not compared to some of the other\n    functionality that's currently missing from the spec.\n\n  * index-of() -- definitely required, though I have no doubt that\n    people will use it like:\n\n    $nodes[index-of(for $n in $nodes return string(), 'foo')]\n\n  - empty() -- empty($seq) seems to be equivalent to\n    not(boolean($seq)); as with other shorthands for easy expressions,\n    I don't think this one's necessary, although it's true that the\n    casting of empty sequences to boolean false can be non-obvious for\n    beginners.\n\n  - exists() -- seems to be equivalent to not(empty($seq)) or exactly\n    equivalent to boolean($seq). I don't think this is necessary;\n    empty() is more useful if you didn't want to use boolean() in the\n    way that it's been used in XPath 1.0.\n\n  + distinct-nodes() -- This obviously doesn't arise in XSLT 1.0\n    because it's impossible to create a node set that contains more\n    than one of a particular node. Given that node sequences are (or\n    should/can be) created with duplicates automatically removed, I\n    doubt that this will come into play very often; there aren't any\n    use cases for it in the XQuery use case document either. On the\n    other hand, the equivalent expression (distinct-nodes($nodes) is\n    the same as union(() | $nodes)) is a bit of a hack and might not\n    get you precisely what you want (since it also reorders into\n    document order), so it's probably best to be on the safe side.\n\n  * distinct-values() -- This functionality is required (and\n    lacking) in XSLT 1.0, but the grouping facilities in XSLT 2.0 mean\n    that it wouldn't be nearly as important there. I can see places\n    where it would be handy, though (for example to write things like\n    \"there are 4 groups...\", and to allow me to apply templates to\n    distinct nodes in order to get more flexibility in my stylesheet).\n    Since this function is likely to be much more heavily used than\n    distinct-nodes(), I think it should be shortened to distinct().\n\n  - insert() -- I can't really see the point, given that there's a\n    concat(), a subsequence() and an index-of() and I don't think that\n    there will often be times when you need to insert items into the\n    middle of a sequence.\n\n  - remove() -- Again, I don't see why this is needed, given that you\n    can use a predicate to do the same thing: $target[position() !=\n    $position].\n\n  * subsequence() -- I imagine would be useful.\n\n  + sequence-deep-equal() and sequence-node-equal() -- I'm not sure\n    about sequence-deep-equal(), for the same reason I'm not sure\n    about deep-equal(). The most useful, I would imagine, would be a\n    plain sequence-equal() that compared the two sequences to see if\n    they were the same on an item-by-item basis, with nodes being\n    assessed based on identity, and values being assessed on their\n    value.\n\n  - avg() -- I'm not personally convinced (since the equivalent\n    expression of sum() div count() really isn't difficult).\n\n  * max() and min() -- Definitely. This is a requirements that's\n    probably even greater than date formatting or regular expressions.\n    It would be even more helpful if there was a quick way of getting\n    to the node(s) that has the min/max value, rather than just\n    getting the value itself. I imagine we're going to see rather a\n    lot of $nodes[. = max($nodes)] otherwise, although I guess that\n    could be optimised.\n\n  - idref() -- As I've said elsewhere, id() turns out to be hardly\n    used in XSLT because of the issues to do with requiring a DTD be\n    present for the link to be any use. Where you need a reverse link,\n    you can generally set up a key instead. I'd rather see keys from\n    XML Schema supported than a specific idref() function introduced.\n\n  - filter() -- I think this is potentially very useful, but, like\n    copy() and shallow(), it has to do with creating nodes, which\n    means that it shouldn't live at the XPath level.\n\n  - collection() -- I don't really understand how this is different\n    from the document() function.\n\n  * input() -- Sounds reasonable.\n\n  - context-item() -- I assume that this is not a real function, but\n    actually just a backup for the shorthand '.'? It should say so.\n\n  * current-dateTime() -- Definitely required; XForms calls this\n    function now(), which has the advantage of being short and\n    avoiding the mixed case convention difficulties.\n\nAside from those mentioned above, functions that are missing are:\n\n  * tokenize(), which people ask for all the time, particularly for\n    splitting strings into lines or words\n\n  + possibly sqrt(), sin() and cos(), which are particularly useful\n    when creating graphic formats such as SVG and aren't that easy to\n    implement in XSLT\n\n  * random() (create random numbers) and more usefully, I think,\n    randomize() (randomly alter the order of items in a sequence),\n    both with obvious side-effect issues; again these are impossible\n    to implement using XSLT\n\n  * function-available() to support the idea that XPath function\n    libraries could be provided by particular implementations.\n\n  * system-property() to support getting information about the XPath\n    implementation version and so on.\n\nFWIW, on the issues front:\n\n  14: (operator-function-signatures) I agree, some of the\n      signatures are confusing; I read the spec as indicating the\n      required types for the functions, such that if you're using\n      XPath the casting to those types is done automatically.\n\n  20: (operator-codepoint-vs-character) I agree that the spec\n      should be clear about whether it's talking about code points or\n      characters, but I think that the character model spec recommends\n      talking about character strings rather than code unit strings\n      (ref. http://www.w3.org/TR/charmod/#sec-Strings)\n\n  21: (operator-function-return-types) In my opinion, the return\n      type of a function should be fixed, and not change based on the\n      actual type passed as the argument of a function.\n\n  37: (semantic-contains) I think that adding linguistic/semantic\n      contains is a huge effort for very little benefit, at least for\n      XPath 2.0. I can see that XQuery might want it, but I wouldn't\n      want XSLT to be burdened, as the primary task of XSLT is\n      transformation rather than querying.\n\n  44: (operator-collation-specification) I think that XPath 2.0 should\n      follow the pattern of XPath/XSLT 1.0 and use qualified names\n      rather than URIs, for consistency and because it makes them\n      easier to use.\n\n  63: (operator-augment-index-of) I find the distinction between\n      performing operations on nodes vs. performing operations on\n      their values fiddly. In the case of index-of(), it strikes me\n      that it wouldn't be difficult to perform index-of-value() if you\n      had support for an index-of() that matched by node identity or\n      simple type value (by creating a sequence of the node values and\n      getting the index of the value you were after).\n\n  66: (operator-docorder-function) Like distinct-nodes(), the\n      requirement (or lack of it) for this function isn't yet apparent\n      because it's not an issue in XSLT 1.0. Personally, I don't think\n      that it will be used that often, but it may be best to be on the\n      safe side as it wouldn't be particularly easy to replicate this\n      functionality without removing duplicate nodes at the same time.\n\n  67: (operator-remove-dupes) Since location paths do remove\n      duplicates, and there thus isn't any backwards incompatibility\n      with XPath 1.0, I don't think there's any reason for count() or\n      sum() to remove duplicates.\n\n  73: (operator-compare-between) I don't think that a\n      compare-between() function is required.\n\n  77: (operator-string-from-char) chars aren't data types in XML\n      Schema -- are they in XPath? If not, then this issue isn't\n      relevant.\n\n  94: (operator-within-window) As with (semantic-contains), I don't\n      think this is a high priority for XPath 2.0.\n\n 108: (operators-always-normalize) I don't think that we should need\n      to worry about unicode normalization within XPath 2.0.\n\n 136: (function-datetime-timezone-conversion) In XML Schema, the\n      timezone isn't part of the value space of a dateTime. Adding a\n      timezone to a dateTime is essentially a formatting function.\n\n 139: (need-fuller-definition-of-error-behavior-and-handling) Yes. We\n      need to be able to test if an item is an error, and then be able\n      to get information about that error, most importantly an error\n      message that describes it and probably some information about\n      the context in which the error occurred (e.g. what the context\n      node was). I'm sure that you already have something on the cards\n      here. Another point of confusion is that the empty sequence is\n      sometimes used as a kind of error value, but at other times an\n      error object is returned. I haven't yet worked out what the\n      underlying heuristic is there, assuming that there is one.\n\n 141: (does-string-equality-use-codepoint-or-default-collation) I\n      think it should use the default collation, like the other string\n      manipulation functions.\n\n 142: (what-should-floor-ceiling-round-return) For compatibility, this\n      should really return a xs:double (I believe). However, I think\n      that returning an xs:integer, with an empty sequence used\n      instead of NaN, would also be reasonable.\n\n 143: (need-tokenize-function) As above, we definitely need a\n      tokenize() function, preferably one that defaults to breaking on\n      whitespace.\n\n 144: (should-concat-accept-sequence-arguments) It would be useful,\n      but highly incompatible. Perhaps a separate concat-sequence()\n      function should be invented. (In XSLT 2.0, you can achieve\n      the same effect with an xsl:value-of and an empty separator\n      attribute, but since XSLT shouldn't be used for general sequence\n      construction (apparently), this isn't ideal.\n\n 150: (should-comparison-that-return-indeterminate-results-be-supported)\n      As I've said before, yes. This is far more important than\n      supporting matching of 'nearby' strings and so on, in my\n      opinion.\n\n 151: (comparison-functions-for-other-date-and-time-types) Yes, there\n      should be comparison functions for other date and time types,\n      although a basic rule about how the comparisons are carried out\n      would be better than listing every possible combination of\n      comparisons.\n\n 152: (parameterized-extraction-functions-for-date-and-times) I view\n      the extraction functions as superfluous, in the face of\n      substring() and the prospect of a format-date() function. If you\n      have them here, then I do think that they should be\n      parameterised.\n\n 154: (second-order-distinct-function) Like the other second-order\n      functions, it would be great, but I don't think it's worth\n      entering that territory at this stage.\n\n 157: (boolean-from-string-legal-literals) Absolutely.\n\n 162: (can-the-node-parameter-to-root-be-omitted) As I mentioned\n      above, I think that having single-argument functions default to\n      using the context item is a very useful tactic, and one that\n      XPath 1.0 users are used to exploiting. It would be good, for\n      consistency, if the new functions supported this shorthand.\n\n 164: (for-complex-types-what-should-data-return) I don't have a\n      strong opinion either way, but it should be consistent with the\n      description of the typed value accessor in the data model. Since\n      the string value is readily accessible in other ways, I think\n      data() should probably not return the string value of the\n      element if it has a complex type with complex content.\n\n 166: (current-dateTime-convenience-functions) On the principal of\n      having as few functions as possible, I don't think these\n      convenience functions are necessary. They are easy to define for\n      people who want them.\n\n 168: (should-id-take-a-list-of-strings) id() definitely should be\n      compatible with id() in XPath 1.0, and therefore accept a list\n      of IDs.\n\n---\nJeni Tennison\nhttp://www.jenitennison.com/\n\n\n\n\n\n"
        },
        {
            "subject": "Re: [xml-dev] XPath 2.0  how much of XQuery should it include",
            "content": "Hi Mike,\n\n> The <xsl:item> idea is not unattractive, and we haven't ruled it\n> out. But I think if we go this way it will tend to increase the\n> amount of duplication between the two languages rather than decrease\n> it. If we had full composability between XSLT and XPath expressions\n> then we could put the functionality where we liked. We haven't; and\n> functionality that we put into XPath is available in a wider variety\n> of contexts than the same functionality in XSLT. (Including to XPath\n> hosts other than XSLT of course). We all know the limitations of\n> keys and sort keys having to be defined as a single XPath\n> expression. I don't think we can remove sequence construction and\n> mapping from XPath, so I would rather not duplicate them in XSLT.\n\nOf course there's not full composability, but then neither design\ngives you that (or at least not as I understand it). In the current\ndesign, there are the duplications:\n\n   - xsl:choose   vs. if\n   - xsl:for-each vs. for\n   - xsl:variable vs. range variables\n   - xsl:sort     vs. sort()\n\nxsl:item would eliminate the requirement for the last two of these\nduplications. I'm not sure what duplications it would add in their\nplace?\n\nOn the xsl:sort and xsl:key front, I'm fairly sure that the majority\nof struggles that people experience with defining keys/sort values\nwill be addressed by general steps and by simple versions of the\nconditional and mapping expressions. There is always the ability to\nuse a function for those rare occasions where it's not.\n\n> I also want to keep the idea that an XSLT stylesheet is a template\n> for the result document. Literal result elements and text nodes in\n> the stylesheet are copied directly to the result; instructions\n> generate groups of nodes in the result. I thinnk that's a useful\n> metaphor.\n\nI agree that's a useful metaphor, but I think that XSLT has gone\nbeyond it, especially by abolishing result tree fragments. I think\npeople now quite often create things in the stylesheet that they have\nno intention of copying through to the result.\n\nCheers,\n\nJeni\n\n---\nJeni Tennison\nhttp://www.jenitennison.com/\n\n\n\n"
        },
        {
            "subject": "XQuery Formal Semantics: normalizatio",
            "content": "XQuery 1.0 Formal Semantics \nW3C Working Draft 26 March 2002\n\n2.5.3 Normalization rules\n(By the way, this section is missing from the Table of Contents.)\n\n\"All normalization rules have the following structure:\n     [Expr]\n       ==\n    coreExpr\nThe [ Expr ] above the == sign denotes an expression in the XQuery language\nbefore translation and the coreExpr beneath the == sign denotes an\nequivalent expression in the XQuery core.\"\n\nOf course, the right-hand-side of a normalization rule is usually not a core\nexpression, because it contains \"normalization calls\" which are obviously\nnot in the XQuery language. But the intent seems to be that if those calls\nare expanded (with respect to a particular subject expression) and so on\nrecursively, the result will indeed be a core expression. Which suggests\nthat if I've got a query q, and I want to normalize it, all I have to do\nis compute the expansion of [[q]] (using double-brackets as the plain-text\nequivalent of the big bold normalization brackets).\n\nThere are some problems with this interpretation, though:\n\n(1) In some rules, the RHS contains non-core constructs outside of\n    normalization calls. This means that [[q]] isn't necessarily a core\n    expression.\n\n    For instance, in 4.3.5, the rules for\n        // RelativePathExpr\n    and\n        StepExpr // RelativePathExpr\n    have occurrences of '/' outside normalization calls.\n    (Contrast this with the rules in 4.3, where the only RHS-occurrence of\n    '/' is within a normalization call.)\n\n    And in 4.5-4.7, many of the right-hand sides use a LetClause that binds\n    multiple variables, which is not allowed in the core.\n\n    Are these just mistakes?\n\n(2) Some normalization rules are missing. This means that [[q]] isn't\n    necessarily even defined.\n\n    In some cases, the absence of the rules is probably just oversight.\n    For instance, 4.10 has a normalization rule for SortSpecList but not\n    one for SortExpr.\n\n    And in other cases, you just haven't got there yet (e.g., 4.8.1\n    Element Constructors).\n\n    But in other cases, it's quite intentional that the rules are missing.\n    For instance, 4.2.1 says  \"All literals are core expressions, therefore\n    there are no normalization rules for literals.\" Rather than no rules,\n    I believe you need \"identity\" rules, e.g.\n        [[ IntegerLiteral ]] == IntegerLiteral\n\nIt's possible that your intent for normalization was more of a term-\nrewriting system, in which rewrite rules are applied, repeatedly, anywhere\nin the query, until no more rewrites are possible. But most of the evidence\nindicates otherwise. Moreover, in such a system, I believe it would be\nharder to prove (a) termination, and (b) correctness.\n\nClarification would be nice.\n\n-Michael Dyck\n\n\n\n"
        },
        {
            "subject": "Re: XSLT 2.0 light",
            "content": "Thanks for the prompt reply!\n\nKay, Michael wrote:\n> Thanks for the comments. You're not alone in finding XML Schema Part 1\n> difficult to digest. Clearly in writing specs it's not our job to produce a\n> tutorial, but we can certainly bear your comments in mind. In particular, I\n> think we probably need to be clearer about how processing happens in the\n> absence of a schema: at the moment we rather rely on people knowing that\n> this is just a special case of the PSVI, and the specs concentrate on\n> describing the general case which is of course much more complex.\n\nI (of course) agree that the spec should not be a tutorial.\n\nOn the other hand, it is quite handy to be able to tell people to \nconsult the spec when they've made a mistake. You can do that with \nXSLT/XPath 1 (and, when the time comes, with the XSLT part of the new \nspec). But you can't very well tell people to go have a look at e.g. \nwww.w3.org/TR/query-semantics before they ask any more stupid questions. \nCan you?\n\n> I think some features of the XPath 2.0 type system are things you are just\n> going to have to live with. The introduction of sequences, I think, brings\n> many benefits. The expansion from the three scalar types (boolean, double,\n> and string) of XPath 1.0 to the 19 primitive types of XML Schema is a larger\n> expansion than many of us would have liked, but many of the primitive types\n> will hardly ever be used so you will be able to ignore them most of the\n> time. Complex types arise only when using schemas, and again I hope we can\n> ensure that when you don't use a schema, you don't really need to be aware\n> of them.\n\nThis is where we don't agree. I have never really bought the \"you don't \nhave to pay for what you don't use\" argument when it comes to C++ \n(another incredibly complex language): before you know it, you have to \nunderstand or maintain other people's code. If they use the complexities \nyou've decided to do without, you have to pay anyway. I fear the same \nwill apply to XPath 2.\n\n> There will probably be a conformance level in XSLT 2.0 that doesn't require\n> schema support; defining conformance levels is something we have not yet\n> tackled.\n\nThat's really good to hear! I just hope that the conformance level isn't \njust provided for the benefit of lazy implementors, but for lazy users \nas well (and by lazy I mean those who can't/don't want to learn \neverything about XML Schema and its data types).\n\nFor example: A \"disable-schema='true'\", or \"version='2.0-light'\", \ninstruction in XSLT would tell me that this is an XSLT stylesheet that I \ncan understand, and it is a requirement that I can communicate to others.\n\n/dan\n\n\n\n"
        },
        {
            "subject": "Data Model  Wrong Namespace name in ",
            "content": "The namespace URIs given in Chapter 2 of the Data Model WD for the Functions \nand Operators namespaces are incorrect and do not correspond to the URIs \ngiven in 1.5 of Functions and Operators.\n\nThey require to be updated, in my view.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "Data Model Chapter 2  list of functions and  operator",
            "content": "In Chapter 2 (as the final part of the chapter) of Data Model a list is given \nof functions and operators.\n\nThe purpose of the list is not clear and the explanatory text needs to be \nimproved in my view.\n\nThe list, quite obviously, is a not complete list of functions and operators \nbut it is not clear why that is not the case.\n\nIn addition, reference is made in the list to an xf:sublist function that I \nwas unable to find in the current WD for Functions and Operators.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "Data Model  names used for information item",
            "content": "The XML Infoset REC refers to a \"document type declaration\" information item.\n\nThe Data Model WD (for example in Chapter 2) refers to a \"doctype\" \ninformation item.\n\nIn my view the terms in the Data Model WD (and possibly elsewhere among the \nXQuery / XPath  2.0 / XSLT 2.0 WDs) should be aligned with the terminology in \nthe Infoset REC.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "Re: [xml-dev] XPath 2.0  how much of XQuery  should it include? [fwd",
            "content": "[Forwarded; original posted to XML-DEV]\n-----\nOn Fri, May 10, 2002 at 01:57:47PM +0100, Jeni Tennison wrote:\n> In XSLT+XPath 1.0, the two syntaxes are complementary.\n[...]\n\n> [In XSLT+XPath 2.0] There are roughly the same features in both: XSLT\n> uses xsl:for-each, XPath uses for; XSLT uses xsl:choose, XPath uses if;\n> XSLT uses xsl:sort, XPath uses sort-by();\n[...]\n\n> My argument is that it would be perfectly possible for XSLT and XPath\n> 2.0 to work in a complementary way again. We could redraw the line\n> where it was before, but allow a couple of extra shorthand features in\n> the text-based syntax, namely conditional expressions and a simple\n> mapping operator. But these should be shorthand features that are used\n> for the most common kinds of looping and conditional expressions, not\n> mirrors of the full functionality of XSLT.\n\n[...]\n\nMichael, Jonathan, et alia:\n    as one of XML-DEV's lurking hundreds (thousands?) I think I should\n    chip in with a \"me too\".  As far as I'm concerned, Jeni's observations\n    in general, and this suggestion specifically, have been spot on.\n\n    In particular, XPath 2.0/XSLT 2.0 should be fixing known problems and\n    omissions in the 1.0 versions, without blowing out excessively.\n    XPath is there to provide core functionality; other standards can\n    extend on that, as required.\n\n    For example, XSLT 1.0.  Based on XPath 1.0, it added an extra data type\n    (the result tree fragment), an extra grammar production (the Pattern),\n    and extra functions (document(), key(), ...) (document(), key(), etc.).\n    \n    In hindsight, keeping XPath 2.0/XSLT 2.0 clean and tight should\n    have been a design goal.\n    \n    I suspect many of the lurking XML-DEVers (and XSL-LISTers, for that\n    matter) are similarly in agreement with Jeni.  Silence doesn't\n    necessarily mean apathy: there's simply been no need to add anything\n    to what Jeni's said, other than a \"me too\" such as this.\n\n    (Hmmm: should I also post this to public-qt-comments?)\n    \nCheers,\nMichael Fuller\n\n-----\n\n\n\n"
        },
        {
            "subject": "xslt2 complexit",
            "content": "<quote src='xslt-list-mailer'>\nPersonally, I've been hesitating for close to year about \nwhether moving from DTDs to Schemas really buys me anything. \nIt's obviously more consistent, has some really nice mechanism \nfor 'specialization' and a few (read that as less than 6) \ndata types that could be useful in a minor way. \n\nBut the cost is pretty steep. The language is longer and more complex. \nPlus, I have to use namespaces even if I don't need them. And Schemas \ncompletely ignored the issue of entity declarations for characters \nor strings within the local document which is a *big* deal \nfor people on the document side. This does not add up to \n\"the cornerstone of XML technology\" in my book.\n\nSo, if I don't move to schemas which is likely, what has \nthe wait for XSLT 2.0 bought me? Over a year's worth of wait \nfor functionality that was proposed for version 1.1, based \non real implementation issues from the user community, to \nmake 2.0 compatible with Schemas which I don't need. And \na very clear addition of complexity (compare the number of \npages in the specs) that again doesn't buy me much. \n</quote>\n\nThis expresses quite succinctly my feelings.\nI was initially interested as a development of DTD's\nbut I really can't find either\na) A use\nb) the tools\nc) the incentive to move from DTD's to schema.\n\nThe second para, asking what has been gained by the wait,\nis also a good summary. The support for schema in the XSLT\nlist appears minimal on the mulberrytech list, its benefits\nare minimal in the world of XSLT for a large majority,\n\nI'm questioning the benefit of the increased complexity\non both implementor and end user. The sense of the comments\non the XSLT list appear to support \na)The lack of delivery of the feature set 'demanded' by end users.\nb)The purpose of schema support when so little is gained.\n\nIs it a case of the WG running wild with what could be done?\n\nThe goal was to <quote>Simplify manipulation of XML Schema-typed content\n</quote>\nand <quote>Improve ease of use </quote>\nThe way the document is approaching epic proportions, it would\nappear these goals will not be met.\n\n\n\nRegards DaveP\nAC RNIB.\n\n\n\n\n\n************snip here************** \n\n- \n\nNOTICE: The information contained in this email and any attachments is \nconfidential and may be legally privileged. If you are not the \nintended recipient you are hereby notified that you must not use, \ndisclose, distribute, copy, print or rely on this email's content. If \nyou are not the intended recipient, please notify the sender \nimmediately and then delete the email and any attachments from your \nsystem.\n\nRNIB has made strenuous efforts to ensure that emails and any \nattachments generated by its staff are free from viruses. However, it \ncannot accept any responsibility for any viruses which are \ntransmitted. We therefore recommend you scan all attachments.\n\nPlease note that the statements and views expressed in this email \nand any attachments are those of the author and do not necessarily \nrepresent those of RNIB.\n\nRNIB Registered Charity Number: 226227\n\nWebsite: http://www.rnib.org.uk \n\n14th June 2002 is RNIB Look Loud Day - visit http://www.lookloud.org.uk to\nfind out all about it.\n\n\n\n"
        },
        {
            "subject": "Data Model  Inconsistent",
            "content": "I am currently wrestling with what the 30th April Data Model WD. It seems to \nme that there is a fundamental inconsistency in expression relating to what a \nnode or information item is, as described in the WD. I hope that the \ndifficulty is only in terms of how ideas have been expressed.\n\nIn 1. Introduction it is stated that \"The data model is based on the \nInformation Set\". I took that to indicate that XPath 2.0 Data Model \nincorporates all of the Infoset REC.\n\nHowever, in 4.1 the description of a document node omits several properties \nof the document information item as described in the Infoset REC.\n\nFurther, it is stated in 1. that \"An item is either a node or an atomic \nvalue.\". I read that to refer to an \"information item\".\n\nIf that is the case then an \"information item\" is essentially identical to a \n\"node\".\n\nHowever an Infoset \"information item\" has a number of properties which a \n\"node\" at least as described in XPath 1.0 does not possess. So, it seems that \nan XPath 2.0 node is fundamentally different from an XPath 1.0 node in that \nit now possesses a full set of Infoset properties.\n\nYet in 4.1 it is stated \"Document nodes and XPath 1.0 root nodes are \nessentially identical.\".\n\nYet if an XPath 2.0 document node \"is\" (as quoted from 1. above) an \"item\" \nand if an \"item\" is intended to be the same as an Infoset \"information item\" \nit is not possible for an XPath 2.0 document node (which must possess Infoset \nproperties) to be \"essentially identical\" to an XPath 1.0 root node (which \npossessed no Infoset properties).\n\nI hope I have conveyed something coherent of what I perceive as the \ninconsistency of descriptions.\n\nMy questions now include, What did the WG intend to say about the \nrelationships of an XPath 2.0 \"node\" and an XPath 2.0 \"item\"? Does an XPath \n2.0 node have (or not have) a full complement of Infoset properties? How, \nprecisely, does an XPath 2.0 node differ from an XPath 1.0 node?\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "Data Model  4. Node",
            "content": "The final part of Chapter 4, Nodes, reads as follows:\n\"Every node belongs to exactly one tree, and every tree has exactly one root \nnode. A tree whose root node is a document node is referred to as a document. \nA tree whose root node is some other kind of node is referred to as a \nfragment.\".\n\nSince XPath/XQuery operate on the infoset and the infoset is only defined for \nthe scenario where there is a document node since according to the Infoset \nRec it applies only to well-formed XML documents, I don't see where these \nsentences are leading.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XPath 2.0 WD  2.",
            "content": "There appears to be an error in 2.1 where the namespace associated with the \nprefix xf is wrongly described. The namespace URI given is for the op prefix \nand the namespace URI associated with the xf prefix appears to have been \nomitted.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "Base URI as used by documen",
            "content": "The XQuery spec section 2.1.1.1 mentions \"Base URI\" as part of the\nstatic context, and that it is used by xf:document.  However, it\ndoesn't actually define it.  The Functions and Operator spec says\nthe default base URI is \"of the stylesheet element containing the\ncall to the document function\".  But what is a \"stylesheet\nelement\"?  Is it defined anywhere?  The only thing I can think of is\nthat it is the uri of the actual XQuery source code.  But this seems\nrather useless.  It's like saying that the default directory used\nby a fopen in a C program is the directory containing the C program\nsource.\n\nIf an XQuery program can be compiled on one machine, and then moved\nto a completely different machine (which of course it can) then the\nconcept of \"base URI of the stylesheet element contaning the call to\nthe document function\" becomes are really bad idea.\n\nI suggest changing it so the the Base URI is defined by the execution\nenevironment, not the compilation environment, of the XQuery program,\nand in an implementation-defined manner.\n-- \n--Per Bothner\nper@bothner.com   http://www.bothner.com/per/\n\n\n\n"
        },
        {
            "subject": "Data Model 3.4 &quot;ExpandedQName&quot",
            "content": "Reference is made in 3.4 of Data Model to the term \"Expanded-QName\".\n\nIt was not clear whether an \"expanded-QName\" is or is not the same as the \nmore familiar terms \"expanded name\" or \"expanded-name\".\n\nIf the two terms differ then I suggest it would be useful to describe the \nessential difference(s) when the term \"expanded-QName\" is first introduced in \n3.4.\n\nIf the two terms mean the same what is the purpose of adding a new term with \nessentially the same meaning?\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "RE: XPath 2.0 WD  2.",
            "content": "You are correct that Section 2.1 needs to be revised and corrected.  We\nwill do this in the next edition.\n\n/paulc\n\nPaul Cotton, Microsoft Canada \n17 Eleanor Drive, Nepean, Ontario K2E 6A3 \nTel: (613) 225-5445 Fax: (425) 936-7329 \n<mailto:pcotton@microsoft.com> \n\n\n> -----Original Message-----\n> From: AndrewWatt2001@aol.com [mailto:AndrewWatt2001@aol.com]\n> Sent: Monday, May 13, 2002 12:33 PM\n> To: public-qt-comments@w3.org\n> Subject: XPath 2.0 WD - 2.1\n> \n> There appears to be an error in 2.1 where the namespace associated\nwith\n> the\n> prefix xf is wrongly described. The namespace URI given is for the op\n> prefix\n> and the namespace URI associated with the xf prefix appears to have\nbeen\n> omitted.\n> \n> Andrew Watt\n\n\n\n"
        },
        {
            "subject": "RE: Data Model  4. Node",
            "content": "> Since XPath/XQuery operate on the infoset\n\nThis is not a correct assertion.  XPath/XQuery operate on the Data Model\nwhich can be constructed from an Infoset (and PSVI).  They do not\nactually operator on the Infoset since the Data Model is not isomorphic\nto the Infoset.\n\nNote as well that XQuery/XPath operators can change the Data Model\ninstance and we do not define the reverse mappings to an Infoset\nrepresentation of these modified Data Model instances.  Eventually we\nwill define how to serialize a Data Model instance into XML and this\nwill in affect indirectly define the Infoset representation of the\ninstance.\n\n/paulc\nChair, XML Query WG\n\nPaul Cotton, Microsoft Canada \n17 Eleanor Drive, Nepean, Ontario K2E 6A3 \nTel: (613) 225-5445 Fax: (425) 936-7329 \n<mailto:pcotton@microsoft.com> \n\n\n> -----Original Message-----\n> From: AndrewWatt2001@aol.com [mailto:AndrewWatt2001@aol.com]\n> Sent: Monday, May 13, 2002 9:25 AM\n> To: public-qt-comments@w3.org\n> Subject: Data Model - 4. Nodes\n> \n> The final part of Chapter 4, Nodes, reads as follows:\n> \"Every node belongs to exactly one tree, and every tree has exactly\none\n> root\n> node. A tree whose root node is a document node is referred to as a\n> document.\n> A tree whose root node is some other kind of node is referred to as a\n> fragment.\".\n> \n> Since XPath/XQuery operate on the infoset and the infoset is only\ndefined\n> for\n> the scenario where there is a document node since according to the\nInfoset\n> Rec it applies only to well-formed XML documents, I don't see where\nthese\n> sentences are leading.\n> \n> Andrew Watt\n\n\n\n"
        },
        {
            "subject": "RE: Data Model  Wrong Namespace name in ",
            "content": "You are correct.  The text:\n\n\"They are associated with the namespace names\nhttp://www.w3.org/2001/12/xquery-functions and\nhttp://www.w3.org/2001/12/xquery-operators respectively.\n\nshould be changed to:\n\nThey are associated with the namespace names\nhttp://www.w3.org/2002/04/xquery-functions and\nhttp://www.w3.org/2002/04/xquery-operators respectively.\n\nWe will fix this in the next version of the Data Model.\n\nActually I recommend that we do not attempt to include the Namespace\nURI's in the Data Model specification in the future and I recommend that\nthe Editors change this text to point to the appropriate section in the\nFunctions and Operators document where the Namespace URIs are defined.\n\n/paulc \n\nPaul Cotton, Microsoft Canada \n17 Eleanor Drive, Nepean, Ontario K2E 6A3 \nTel: (613) 225-5445 Fax: (425) 936-7329 \n<mailto:pcotton@microsoft.com> \n\n\n> -----Original Message-----\n> From: Svgdeveloper@aol.com [mailto:Svgdeveloper@aol.com]\n> Sent: Monday, May 13, 2002 8:18 AM\n> To: public-qt-comments@w3.org\n> Subject: Data Model - Wrong Namespace name in 2\n> \n> The namespace URIs given in Chapter 2 of the Data Model WD for the\n> Functions\n> and Operators namespaces are incorrect and do not correspond to the\nURIs\n> given in 1.5 of Functions and Operators.\n> \n> They require to be updated, in my view.\n> \n> Andrew Watt\n\n\n\n"
        },
        {
            "subject": "RE: Data Model  Inconsistent",
            "content": "I think an Editor of the Data Model may be able to answer your detailed\nquestions but I wanted to reiterate what I said in a previous reply.  \n\nThe text \"The data model is based on the Information Set\" must not be\nread to mean that there is an isomorphic mapping between the Data Model\nand the Information Set.  The DM document tells you how to construct a\nDM instance from the Infoset (and PSVI).  You should not assume you are\nthen operating on an Infoset.  Please remember that the Infoset is just\nset of terms that describe what an XML parser returns.\n\n/paulc\nChair, XML Query WG\n\nPaul Cotton, Microsoft Canada \n17 Eleanor Drive, Nepean, Ontario K2E 6A3 \nTel: (613) 225-5445 Fax: (425) 936-7329 \n<mailto:pcotton@microsoft.com> \n\n\n> -----Original Message-----\n> From: AndrewWatt2000@aol.com [mailto:AndrewWatt2000@aol.com]\n> Sent: Monday, May 13, 2002 10:10 AM\n> To: public-qt-comments@w3.org\n> Subject: Data Model - Inconsistent?\n> \n> I am currently wrestling with what the 30th April Data Model WD. It\nseems\n> to\n> me that there is a fundamental inconsistency in expression relating to\n> what a\n> node or information item is, as described in the WD. I hope that the\n> difficulty is only in terms of how ideas have been expressed.\n> \n> In 1. Introduction it is stated that \"The data model is based on the\n> Information Set\". I took that to indicate that XPath 2.0 Data Model\n> incorporates all of the Infoset REC.\n> \n> However, in 4.1 the description of a document node omits several\n> properties\n> of the document information item as described in the Infoset REC.\n> \n> Further, it is stated in 1. that \"An item is either a node or an\natomic\n> value.\". I read that to refer to an \"information item\".\n> \n> If that is the case then an \"information item\" is essentially\nidentical to\n> a\n> \"node\".\n> \n> However an Infoset \"information item\" has a number of properties which\na\n> \"node\" at least as described in XPath 1.0 does not possess. So, it\nseems\n> that\n> an XPath 2.0 node is fundamentally different from an XPath 1.0 node in\n> that\n> it now possesses a full set of Infoset properties.\n> \n> Yet in 4.1 it is stated \"Document nodes and XPath 1.0 root nodes are\n> essentially identical.\".\n> \n> Yet if an XPath 2.0 document node \"is\" (as quoted from 1. above) an\n\"item\"\n> and if an \"item\" is intended to be the same as an Infoset \"information\n> item\"\n> it is not possible for an XPath 2.0 document node (which must possess\n> Infoset\n> properties) to be \"essentially identical\" to an XPath 1.0 root node\n(which\n> possessed no Infoset properties).\n> \n> I hope I have conveyed something coherent of what I perceive as the\n> inconsistency of descriptions.\n> \n> My questions now include, What did the WG intend to say about the\n> relationships of an XPath 2.0 \"node\" and an XPath 2.0 \"item\"? Does an\n> XPath\n> 2.0 node have (or not have) a full complement of Infoset properties?\nHow,\n> precisely, does an XPath 2.0 node differ from an XPath 1.0 node?\n> \n> Andrew Watt\n\n\n\n"
        },
        {
            "subject": "RE: Data Model  4. Node",
            "content": "> The final part of Chapter 4, Nodes, reads as follows:\n> \"Every node belongs to exactly one tree, and every tree has \n> exactly one root \n> node. A tree whose root node is a document node is referred \n> to as a document. \n> A tree whose root node is some other kind of node is referred to as a \n> fragment.\".\n> \n> Since XPath/XQuery operate on the infoset and the infoset is \n> only defined for \n> the scenario where there is a document node since according \n> to the Infoset \n> Rec it applies only to well-formed XML documents, I don't see \n> where these \n> sentences are leading.\n\nXQuery builds documents \"bottom up\": it is possible to construct, and\nmanipulate, element nodes that have not yet been connected into a document\n(and perhaps never will be). The data model therefore needs to describe\nthese \"partial InfoSets\", which can exist transiently even though they\ncannot be obtained by parsing source XML documents.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "RE: Data Model 3.4 &quot;ExpandedQName&quot",
            "content": "Yes, we should explain this term better.\n\nWe had a problem because the term \"QName\", which traditionally (and in the\nNamespaces REC) is used to mean a construct of the form prefix:local-name,\nis used in the Schema recommendation to refer to a data type whose lexical\nform is prefix:local-name and whose value space consists of (namespace-uri,\nlocal-name) tuples. XPath 1.0 referred to this as an expanded name. To avoid\nambiguous use of the term \"QName\", we decided to use \"expanded-QName\" to\nrepresent these tuples.\n\nMichael Kay\n\n> -----Original Message-----\n> From: AndrewWatt2001@aol.com [mailto:AndrewWatt2001@aol.com] \n> Sent: 13 May 2002 13:49\n> To: public-qt-comments@w3.org\n> Subject: Data Model 3.4 \"Expanded-QName\"\n> \n> \n> Reference is made in 3.4 of Data Model to the term \"Expanded-QName\".\n> \n> It was not clear whether an \"expanded-QName\" is or is not the \n> same as the \n> more familiar terms \"expanded name\" or \"expanded-name\".\n> \n> If the two terms differ then I suggest it would be useful to \n> describe the \n> essential difference(s) when the term \"expanded-QName\" is \n> first introduced in \n> 3.4.\n> \n> If the two terms mean the same what is the purpose of adding \n> a new term with \n> essentially the same meaning?\n> \n> Andrew Watt\n> \n\n\n\n"
        },
        {
            "subject": "RE: Data Model  Inconsistent",
            "content": "> \n> In 1. Introduction it is stated that \"The data model is based on the \n> Information Set\". I took that to indicate that XPath 2.0 Data Model \n> incorporates all of the Infoset REC.\n> \n> However, in 4.1 the description of a document node omits \n> several properties \n> of the document information item as described in the Infoset REC.\n\nThe model is based on the InfoSet, but it doesn't necessarily include\neverything that's in the InfoSet.\n> \n> Further, it is stated in 1. that \"An item is either a node or \n> an atomic \n> value.\". I read that to refer to an \"information item\".\n\nNo, the term \"item\" used in the XPath data model is quite unrelated to the\nterm \"information item\" as used in the InfoSet. We probably need to make\nthis clearer!\n> \n> If that is the case then an \"information item\" is essentially \n> identical to a \"node\".\n\nYes, a node in the XPath model and an \"information item\" in the InfoSet\ncorrespond pretty closely.\n> \n> However an Infoset \"information item\" has a number of \n> properties which a \n> \"node\" at least as described in XPath 1.0 does not possess. \n> So, it seems that \n> an XPath 2.0 node is fundamentally different from an XPath \n> 1.0 node in that \n> it now possesses a full set of Infoset properties.\n\nNo, XPath 2.0 nodes are essentially the same as XPath 1.0 nodes which are\nessentially the same as InfoSet information items (though XPath 1.0 was\npublished before the InfoSet).\n> \n> Yet in 4.1 it is stated \"Document nodes and XPath 1.0 root nodes are \n> essentially identical.\".\n> \nIndeed they are.\n> \n> \n> My questions now include, What did the WG intend to say about the \n> relationships of an XPath 2.0 \"node\" and an XPath 2.0 \"item\"? \n\nThe result of an XPath 2.0 expression is a sequence of zero or more items.\nEach item is either a node or an atomic-value. A node is, for example, an\nelement node or an attribute node. An atomic-value is, for example, a string\nor a number. \n\nI hope that makes it clearer.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "RE: Base URI as used by documen",
            "content": "> The XQuery spec section 2.1.1.1 mentions \"Base URI\" as part \n> of the static context, and that it is used by xf:document.  \n> However, it doesn't actually define it.  The Functions and \n> Operator spec says the default base URI is \"of the stylesheet \n> element containing the call to the document function\".  But \n> what is a \"stylesheet element\"?  Is it defined anywhere?\n\nThis is a cut-and-paste error; the specification of the document() function\nwas transferred from the XSLT specification. The reference should now be to\nthe static context. And XQuery needs to define how this variable in the\nstatic context will be initialized (it will probably just say that it's\nimplementation dependent).\n\n\n  The \n> only thing I can think of is that it is the uri of the actual \n> XQuery source code.  But this seems rather useless.\n\nPossibly. But it's the normal convention on the web that when one file\ncontains a reference to another, the reference is considered to be relative\nto the file in which the reference was contained. Yes, this makes it\ndifficult to move files around: which is one reason xml:base was invented.\nBut of course, an XQuery expression, not being an XML document, cannot take\nadvantage of xml:base. In practice I think it's most likely that queries\nwill use absolute URIs.\n\nThanks for the comment.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "RE: [xml-dev] XPath 2.0  how much of XQuery  should it include?  [fwd",
            "content": "> From: Michael Fuller [mailto:msf@mds.rmit.edu.au] \n> \n> > [In XSLT+XPath 2.0] There are roughly the same features in \n> both: XSLT \n> > uses xsl:for-each, XPath uses for; XSLT uses xsl:choose, XPath uses \n> > if; XSLT uses xsl:sort, XPath uses sort-by();\n\nXSLT/XPath is a two-language system. It's closely analogous to using, say\nJSP+SQL. Each of the two languages fulfils a particular purpose: XSLT\ndefines elements to be written to the result document, XPath defines\ninformation to be fetched from the source document.\n\nIn a two language system it is never possible to achieve complete\ncompositionality (the ability to use any expression in a place where a value\nis required). In particular, one can't use XSLT expressions inside XPath. To\ncompensate for this lack of compositionality, it's inevitable that some of\nthe basic scaffolding that any language needs (control structures,\nconditionals, function calling) will be duplicated between the two\nlanguages. Otherwise, the amount of switching beween the two languages would\nbecome unbearable.\n\nIt's my belief that in a two-language system it will never be possible to\ndraw a completely satisfactory boundary between the two, or to avoid some\nduplication, but I haven't seen any proposal that's obviously an improvement\non the split that we have adopted. \n\n> \n>     In particular, XPath 2.0/XSLT 2.0 should be fixing known \n> problems and\n>     omissions in the 1.0 versions, without blowing out excessively.\n>     XPath is there to provide core functionality; other standards can\n>     extend on that, as required.\n> \nIt's probably possible to divide the enhancements in XSLT 2.0/XPath 2.0 into\ntwo categories: the \"functionality\" enhancements, which are all there in\ndirect response to user experience with XSLT 1.0/XPath 1.0, and the \"data\nmodel\" enhancements, which are there to increase the power of the language\nand the range of problems it can be applied to. As XML becomes a key\ncomponent of large-scale distributed information systems, the WGs feel that\nkey components such as XSLT and XPath need to be underpinned by a more\nrigorous and robust type system. It's quite true that few existing users\nhave been asking for this; it's also true that most existing users have been\nusing XSLT and XPath in a very limited domain of application, namely for\nrendition of XML into HTML and other presentation formats. We want the two\nlanguages to be capable of more than that.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "RE: [xml-dev] XPath 2.0  how much of XQuery should it include",
            "content": "> \n> Of course there's not full composability, but then neither \n> design gives you that (or at least not as I understand it). \n> In the current design, there are the duplications:\n> \n>    - xsl:choose   vs. if\n>    - xsl:for-each vs. for\n>    - xsl:variable vs. range variables\n>    - xsl:sort     vs. sort()\n> \n> xsl:item would eliminate the requirement for the last two of \n> these duplications. I'm not sure what duplications it would \n> add in their place?\n\nYou are assuming we would be able to remove range variables from XPath,\nwhich is by no means a necessary consequence of adding xsl:item. We would\nprobably be able to ditch sort(), though I would be reluctant to see it go:\nthe construct\n\n<xsl:variable name=\"sorted-list\">\n  <xsl:for-each select=\"x\">\n    <xsl:sort select=\".\"/>\n    <xsl:item select=\".\"/>\n  </xsl:for-each>\n</xsl:variable>\n\nseems very clumsy compared with\n\n<xsl:variable name=\"sorted-list\" select=\"sort(x)\"/>\n\nWe would end up with a new duplication in the area of sequence construction,\nbecause XPath would certainly not be viable without the (x,y,z) construct.\n\nAnd the more I think about using <xsl:for-each> and <xsl:choose> to do\nsequence construction, the more messy it seems. For example, what does the\nfollowing mean:\n\n<xsl:variable name=\"x\" type=\"sequence\">\n  <xsl:item select=\"1\"/>\n  <xsl:value-of select=\"2\"/>\n  <xsl:value-of select=\"3\"/>\n</xsl:variable>\n\nDo we really want this to create a sequence consisting of one integer and\ntwo text nodes?\n\nAnd consider:\n\n<xsl:template name=\"x\">\n<xsl:value-of select=\"first-name\"/>\n<xsl:text> </xsl:text>\n<xsl:value-of select=\"last-name\"/>\n</xsl:template>\n\n<xsl:variable name=\"y\" type=\"sequence\">\n<xsl:call-template name=\"y\"/>\n</xsl:variable>\n\nHow many items are there in the sequence $y?\n\nThe more I look into this, the more difficult and confusing it seems, and\nthe more I feel that we've got the XSLT/XPath split just about right.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "RE: xslt2 complexit",
            "content": "> -----Original Message-----\n> From: DPawson@rnib.org.uk [mailto:DPawson@rnib.org.uk] \n> Sent: 14 May 2002 09:49\n> To: public-qt-comments@w3.org\n> Subject: xslt2 complexity\n> \n> \n> <quote src='xslt-list-mailer'>\n> Personally, I've been hesitating for close to year about \n> whether moving from DTDs to Schemas really buys me anything. \n...\nI agree with you that not everyone needs schemas. For most of my own ad-hoc\nuses of XML (including preparation of W3C specs) I don't use them myself -\nthough the DTD's we use are becoming so elaborate that perhaps we should.\nBut as XML becomes used more and more for information storage and as the\nmiddleware for building distributed applications, I think it's clear to a\nlot of people that you need to get your information models under control,\nand that's what schemas are for.\n> \n> The second para, asking what has been gained by the wait,\n> is also a good summary. The support for schema in the XSLT\n> list appears minimal on the mulberrytech list, its benefits\n> are minimal in the world of XSLT for a large majority,\n\nAs I explained in response to another comment, I think we're doing two\nthings with XSLT 2.0: we're adding a lot of useful functionality in direct\nresponse to user experience with 1.0, and we're extending the range of\napplication of the language (its scaleability, if you like) by putting in a\nstronger underpinning in the type system. We are conscious that for many of\nthe existing applications of the language, this doesn't necessarily add\nimmediate value. We are also aware that the process of bringing together two\nworking groups has caused far more delay than we would have liked. We're not\ncomplacent, but we're all confident that the alternative, of allowing XSLT\nand XQuery and XML Schema to go their separate ways, would have been doing a\nfar greater disservice to the user community.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "Re: [xml-dev] XPath 2.0  how much of XQuery should it include",
            "content": "Hi Mike,\n\n>> Of course there's not full composability, but then neither\n>> design gives you that (or at least not as I understand it). \n>> In the current design, there are the duplications:\n>> \n>>    - xsl:choose   vs. if\n>>    - xsl:for-each vs. for\n>>    - xsl:variable vs. range variables\n>>    - xsl:sort     vs. sort()\n>> \n>> xsl:item would eliminate the requirement for the last two of \n>> these duplications. I'm not sure what duplications it would \n>> add in their place?\n>\n> You are assuming we would be able to remove range variables from\n> XPath, which is by no means a necessary consequence of adding\n> xsl:item.\n\nYes, you're right. I am assuming that. If you don't remove range\nvariables, I agree that xsl:item isn't worthwhile. The point of\nsuggesting xsl:item was to enable you to remove range variables from\nXPath 2.0 and thus reduce XPath 2.0's one of the parts of the\ncomplexity of XPath 2.0 that people are complaining most about, whilst\nretaining the user's ability to do joins.\n\nOtherwise, xsl:item offers the benefits of allowing people to use\nvariables, xsl:number and to apply templates to nodes to generate\nsequences. But I don't think these benefits are worthwhile in the face\nof the additional duplication. If the choice is range variables with\nxsl:item or range variables without xsl:item, then the latter is the\none to choose. I just don't think those should be the only choices\nyou're considering.\n\n> We would probably be able to ditch sort(), though I would be\n> reluctant to see it go: the construct\n>\n> <xsl:variable name=\"sorted-list\">\n>   <xsl:for-each select=\"x\">\n>     <xsl:sort select=\".\"/>\n>     <xsl:item select=\".\"/>\n>   </xsl:for-each>\n> </xsl:variable>\n>\n> seems very clumsy compared with\n>\n> <xsl:variable name=\"sorted-list\" select=\"sort(x)\"/>\n\nCertainly, but then I believe that it's very rare that you want to\nmake a sorted list *just for the sake of it*. The only time that I can\nthink of people doing that at the moment (naturally through the\nlonghand as above) is so that they can then use\npreceding/following-sibling axes to create groups. But grouping is\nsupported in other ways, the preceding/following-sibling axes won't\nwork within sequences anyway, and the ability to create named sort\nspecifications means that if you *did* want to sort the same sequence\nin the same way twice you could do so easily. So I don't think this is\nsuch a vital operation.\n\nNaturally it's all guesswork and we won't know until we start trying\nto use it, but it's a lot easier to add something to a language later\non than it is to remove it.\n\n> We would end up with a new duplication in the area of sequence\n> construction, because XPath would certainly not be viable without\n> the (x,y,z) construct.\n\nWell, if you view tree construction as a restricted form of sequence\nconstruction, then there's already that duplication.\n\n> And the more I think about using <xsl:for-each> and <xsl:choose> to\n> do sequence construction, the more messy it seems. For example, what\n> does the following mean:\n>\n> <xsl:variable name=\"x\" type=\"sequence\">\n>   <xsl:item select=\"1\"/>\n>   <xsl:value-of select=\"2\"/>\n>   <xsl:value-of select=\"3\"/>\n> </xsl:variable>\n>\n> Do we really want this to create a sequence consisting of one\n> integer and two text nodes?\n\nConsidering that sequences are flat, and that people will use them to\ncreate the equivalent of multi-dimensional arrays by assigning\ndifferent meanings to items in different positions, I'd say yes, you\nprobably do want to allow a mixture of atomic values and result nodes\nwithin a sequence. Also XQuery allows this, I believe, so it would be\ncloser to XQuery semantics to do so.\n\nThen the question is about whether to combine the two text nodes\ngenerated by the xsl:value-ofs. I'd say that you should adapt the XSLT\nrule you already have concerning text nodes. At the moment, it reads:\n\n \"The resulting text node is added to the result of the containing\n  content constructor. When the resulting content is added to a result\n  tree, adjacent text nodes in the result tree are automatically\n  merged.\"\n\nYou could make it:\n\n \"The resulting text node is added to the result of the containing\n  sequence constructor. When the resulting sequence is used, adjacent\n  text nodes in the sequence are automatically merged.\"\n\nin which case you would have a sequence of one integer and one text\nnode.\n\nIf you don't want to allow mixed sequences, then you're going to need\nto put a constraint to say so into XPath anyway. You could always say:\n\n \"If a sequence contains a mixture of atomic values and nodes then\n  the atomic values are automatically converted into text nodes with\n  the same string value. Adjacent text nodes are then merged.\"\n\n> And consider:\n>\n> <xsl:template name=\"x\">\n> <xsl:value-of select=\"first-name\"/>\n> <xsl:text> </xsl:text>\n> <xsl:value-of select=\"last-name\"/>\n> </xsl:template>\n>\n> <xsl:variable name=\"y\" type=\"sequence\">\n> <xsl:call-template name=\"y\"/>\n> </xsl:variable>\n>\n> How many items are there in the sequence $y?\n\nThe variable $y holds the sequence that's constructed by the template\nx. From the above, templates generate sequences of new nodes, and when\nsequences of new nodes are constructed, adjacent text nodes are\ncombined to give the finished article. So $y holds a single text node.\n\nCheers,\n\nJeni\n\n---\nJeni Tennison\nhttp://www.jenitennison.com/\n\n\n\n"
        },
        {
            "subject": "RE: xslt2 complexit",
            "content": "Mike Kay said:\n> I agree with you that not everyone needs schemas. For most of \n> my own ad-hoc\n> uses of XML (including preparation of W3C specs) I don't use \n> them myself -\n<snip/>\n\nI hope this group of end users of XSLT are not forgotten\nin the dash to look to the future. \nWhy this can't be done incrementally, adding features which are\nneeded now, and adding later when the demand is there in numbers\nI simply don't know. \n\nPlease be aware the WG output will be judged against its requirement.\n\nRegards DaveP. \n\n- \n\nNOTICE: The information contained in this email and any attachments is \nconfidential and may be legally privileged. If you are not the \nintended recipient you are hereby notified that you must not use, \ndisclose, distribute, copy, print or rely on this email's content. If \nyou are not the intended recipient, please notify the sender \nimmediately and then delete the email and any attachments from your \nsystem.\n\nRNIB has made strenuous efforts to ensure that emails and any \nattachments generated by its staff are free from viruses. However, it \ncannot accept any responsibility for any viruses which are \ntransmitted. We therefore recommend you scan all attachments.\n\nPlease note that the statements and views expressed in this email \nand any attachments are those of the author and do not necessarily \nrepresent those of RNIB.\n\nRNIB Registered Charity Number: 226227\n\nWebsite: http://www.rnib.org.uk \n\n14th June 2002 is RNIB Look Loud Day - visit http://www.lookloud.org.uk to\nfind out all about it.\n\n\n\n"
        },
        {
            "subject": "Validate Expressions In XPath 2.0 and querying  the PSVI in XQuer",
            "content": "A few questions/statements about validate expressions and other things\n \n1.) The semantics of validate { $x }[0] are very poorly specified especially with regard to how one obtains IN-SCOPE SCHEMA DEFINITIONS when there is no schema import mechanism described in the WD. \n \n2.) Considering that XPath is designed to be embedded in other XML technologies like the DOM or XSLT unlike XQuery, are a validate{ $x} operation as well as run time type identification (instance of) and casting (assert as, cast as, treat as) or complex error handling [2,3,4] really necessary? \n \n3.) Speaking of which exactly WHAT is the rationale behind both XPath 2.0 and XQuery 1.0 being strongly typed languages? Is the W3C assuming that people that don't use types when querying XML documents are second class citizens? \n \n4.) The XQuery and XPath data model do not give the ability to query over the entire PSVI[1], what is the reason the particular  supported subset was chosen? \n \n[0] http://www.w3.org/TR/xpath20/#id-validate\n[1] http://www.w3.org/TR/query-datamodel/#IDASOVR\n[2] http://www.w3.org/TR/xpath20/#xpath-issue-error-object\n[3] http://www.w3.org/TR/xpath20/#xquery-general-errors\n[4] http://www.w3.org/TR/xpath20/#xquery-try-catch-error \n\n\n\n"
        },
        {
            "subject": "Re: Data Model  names used for information  item",
            "content": "Dear Andrew,\n\nYou are correct. We will change the incorrect \"doctype\" reference\nin the next version of the document.\n\nBest regards,\nMarton Nagy\n\n> \n> Date: Mon, 13 May 2002 09:25:09 -0400 (EDT)\n> From: Svgdeveloper@aol.com\n> Message-ID: <f6.1b276280.2a110749@aol.com>\n> To: public-qt-comments@w3.org\n> Subject: Data Model - names used for information items\n> \n> The XML Infoset REC refers to a \"document type declaration\"\n> information item.\n> \n> The Data Model WD (for example in Chapter 2) refers to a \"doctype\" \n> information item.\n> \n> In my view the terms in the Data Model WD (and possibly elsewhere\n> among the XQuery / XPath  2.0 / XSLT 2.0 WDs) should be aligned\n> with the terminology in the Infoset REC.\n> \n> Andrew Watt\n>\n\n\n\n"
        },
        {
            "subject": "Re: Data Model Chapter 2  list of functions and   operator",
            "content": "Dear Andrew,\n\nWe will add some text to explain that the list simply enumerates\nthe functions and operators *used in this document* for which\na detailed description is available in the Functions and Operators WD.\n\nYou are also right regarding the name of the recently changed\nxf:sublist. We will change that to xf:subsequence.\n\nBest regards,\nMarton Nagy\n\n> \n> Date: Mon, 13 May 2002 08:26:05 -0400 (EDT)\n> From: Svgdeveloper@aol.com\n> Message-ID: <d6.16770a1c.2a110ab8@aol.com>\n> To: public-qt-comments@w3.org\n> Subject: Data Model Chapter 2 - list of functions and  operators\n> \n> In Chapter 2 (as the final part of the chapter) of Data Model a list\n> is given of functions and operators.\n> \n> The purpose of the list is not clear and the explanatory text needs\n> to be improved in my view.\n> \n> The list, quite obviously, is a not complete list of functions and\n> operators but it is not clear why that is not the case.\n> \n> In addition, reference is made in the list to an xf:sublist function\n> that I was unable to find in the current WD for Functions and Operators.\n> \n> Andrew Watt\n>\n\n\n\n"
        },
        {
            "subject": "RE: F&amp;O W",
            "content": "> -----Original Message-----\n> From: Jeni Tennison [mailto:jeni@jenitennison.com] \n> \n> I promised some more detailed comments on the F&O WD, so here \n> you are. \n\nSome personal responses from me below...\n> \n>   - node-kind() -- I've hardly ever seen a problem that's required\n>     this functionality. I think it would be more flexible to use the\n>     \"instance of\" operator to work out what kind of node you're\n>     looking at\n\nI agree, \"instance of\" makes this redundant.\n>   \n>   + node-name() -- This used to be the name() function; I wonder\n>     whether it would be possible to merge this with the name()\n>     function.\n\nWe've tried this. If name() is changed to return a QName rather than a\nstring, then it has to return () rather than \"\" for an unnamed node, and\nthat stops things like child::node()[name()!='note'] from working in a\nbackwards-compatible way. So we decided we couldn't change name(); and it\ndoes seem worth introducing a function that returns a QName so that equality\ncomparisons become namespace-sensitive.\n> \n>   * data() -- Certainly required now, but as with a lot of these\n>     functions, I wonder whether it would be helpful to have it follow\n>     the pattern of existing functions, like name() and string(), and\n>     have it return the typed value of the context node if it doesn't\n>     have an argument passed to it.\n\nI'm fairly neutral on this. I wish we had required the explicit argument on\nexisting functions.\n> \n>   - unique-ID() -- I've never known anyone to have to get hold of the\n>     value of the ID attribute on a given element.\n\nI agree.\n> \n>   * compare() -- We do need this facility although not as much as\n>     you might think, in my opinion. \n\nI don't think we actually expect it to be needed that often, which is why a\nslightly awkward return value is acceptable, but it is important for\ninternationalization.\n> \n>   - normalize-unicode() -- As far as I understand the character\n>     model for the WWW, all text on the Internet should be normalized,\n>     and specifications should require unicode normalized (NFC) text.\n\nThe trouble is that word \"should\". And even if the source text is\nnormalized, that doesn't guarantee that the result of operations like\nconcat() and substring() is normalized. I don't have enough experience of\nprocessing non-English text to know how important this function is, I think\nwe have to take advice from the I18N people who tell us that it is.\n> \n>   * upper-case() and lower-case() -- There's definitely a strong\n>     requirement for these, although allowing case-insensitive\n>     comparisons (which I think is supported with collations?) will go\n>     most of the way towards supporting the usual reason for\n>     case-changing.\n\nI think there are enough other applications to justify their retention.\n\n>     As I think I might have mentioned before, I believe\n>     that technically there should be a title-case() function as well,\n\nI Have Always Thought Title Case Was A Style Used Only By American\nNewspapers.\n> \n>   + string-pad() -- Repeating the same string is a fairly common\n>     operation, although it is one that's particularly easy to\n>     accomplish now with a user-defined function and a simple\n>     iteration. I therefore don't think that this function is vital,\n>     and if you want to save space, I think it should be dropped.\n\nI think it's sufficiently handy to be worth keeping.\n> \n>   * match() and replace() -- I think that you know that we need more\n>     regular expression support than this; I believe that you're\n>     working on that and that I've already commented on it.\n\nYes.\n> \n>   + duration/dateTime functions -- I've already commented on these in\n>     a separate thread. I think that this is the poorest section of the\n>     spec. \n\nThere is still ongoing work on these.\n> \n>   * get-local-name() and get-namespace-uri() -- Makes me wish that\n>     the structured data types such as QNames, dates, durations and so\n>     on could be treated as virtual elements, so you could do\n>     $qname/local-name or $date/year. \n\nYes; I'd like to see a consistent approach to component extraction too. I\nhave proposed naming the functions, for example, QName.local-name(),\nDateTime.month(), but I seem to be the only one who likes the idea.\n> \n>   + deep-equal() -- I wouldn't personally say that this was a\n>     high-priority function.\n\nI agree with you, especially as it seems difficult to come up with a single\ndefinition of deep equality that pleases everyone.\n> \n>   - root() -- I think that root($node) does the same thing as\n>     $node/ancestor::node()[last()]. Given that the function is\n>     possible with very little effort, and that you rarely need to get\n>     from a node to the root node of that document, I don't really see\n>     the point of this function.\n\nXQuery still has no ancestor axis. This function is actually there because\nthere is still a debate about the meaning of a leading \"/\": does it mean\nroot(), or does it mean input()? The traditional XSLT meaning is root(), the\ntraditional XQuery meaning is input(). Providing both functions ensures that\nboth capabilities are available unambiguously while we resolve what \"/\"\nshould mean.\n> \n>   - if-absent() and if-empty() are shorthands ...\n\nI'm personally inclined to agree with you; I also worry that people will\nmisunderstand what if-empty() does.\n> \n>   - empty() -- empty($seq) seems to be equivalent to\n>     not(boolean($seq)); as with other shorthands for easy expressions,\n>     I don't think this one's necessary\n> \n>   - exists() -- seems to be equivalent to not(empty($seq))\n\nI quite like the improved readability that you get from empty() and\nexists().\n> \n>   + distinct-nodes() -- This obviously doesn't arise in XSLT 1.0\n>     because it's impossible to create a node set that contains more\n>     than one of a particular node. Given that node sequences are (or\n>     should/can be) created with duplicates automatically removed, I\n>     doubt that this will come into play very often...\n\nI agree that this will probably not be used very often, and that writing\n$N|() or $N/. might be adequate, even though both are non-obvious.\n> \n>   * distinct-values() -- This functionality is required (and\n>     lacking) in XSLT 1.0, but the grouping facilities in XSLT 2.0 mean\n>     that it wouldn't be nearly as important there.\n\nI agree, but I think it's worth keeping, if only for non-XSLT uses of XPath.\n> \n>   - insert() > \n>   - remove() -- Again, I don't see why this is needed\n\nI can't say I've found a use case myself, but the alternative constructs\nseem to be rather hard work and perhaps more difficult to optimize.\n> \n>   * subsequence() -- I imagine would be useful.\n> \n>   + sequence-deep-equal() and sequence-node-equal() -- I'm not sure\n>     about sequence-deep-equal(), for the same reason I'm not sure\n>     about deep-equal().\n\nI'm not happy about these either, but it's hard to come up with the right\nanswer.\n> \n>   - avg() -- I'm not personally convinced (since the equivalent\n>     expression of sum() div count() really isn't difficult).\n\nBut is it equivalent, eg. if the argument is an empty sequence? Also, it's\nboth easier to write and easier to optimize in cases where the argument is a\ncomplex path expression.\n> \n>   * max() and min() -- Definitely. This is a requirements that's\n>     probably even greater than date formatting or regular expressions.\n>     It would be even more helpful if there was a quick way of getting\n>     to the node(s) that has the min/max value, rather than just\n>     getting the value itself. I imagine we're going to see rather a\n>     lot of $nodes[. = max($nodes)] otherwise, although I guess that\n>     could be optimised.\n\nI agree.\n> \n>   - idref() -- As I've said elsewhere, id() turns out to be hardly\n>     used in XSLT because of the issues to do with requiring a DTD be\n>     present for the link to be any use. Where you need a reverse link,\n>     you can generally set up a key instead. I'd rather see keys from\n>     XML Schema supported than a specific idref() function introduced.\n\nI agree.\n> \n>   - filter() -- I think this is potentially very useful, but, like\n>     copy() and shallow(), it has to do with creating nodes, which\n>     means that it shouldn't live at the XPath level.\n\nWe're likely to drop this one.\n> \n>   - collection() -- I don't really understand how this is different\n>     from the document() function.\n\nThink databases. The notion is that a collection is a set of documents that\nyou might want to search, the entire collection being identified by a single\nURI. We don't know exactly how different implementations will model\ncollections of documents, so this gives us a suitable abstraction. We did\nthink of overloading document() so a single URI could return multiple\ndocuments, but it makes an already-complex function even harder to\nunderstand.\n> \n>   * input() -- Sounds reasonable.\n> \n>   - context-item() -- I assume that this is not a real function, but\n>     actually just a backup for the shorthand '.'? It should say so.\n\nActually, there's still a conflict in the published drafts, which at one\npoint say that \".\" means \"self::node()\". We expect to resolve this.\n> \n>   * current-dateTime() -- Definitely required; XForms calls this\n>     function now()\n\nThe bigger the working group, the longer the names it comes up with...\n> \n>   * tokenize(), which people ask for all the time, particularly for\n>     splitting strings into lines or words\n\nI hope that this will be very easy to do with regular expressions.\n> \n>   + possibly sqrt(), sin() and cos(), which are particularly useful\n>     when creating graphic formats such as SVG and aren't that easy to\n>     implement in XSLT\n\nI think we made a conscious decision to exclude trig functions, they can be\neasily provided by a third-party library.\n> \n>   * random() (create random numbers) and more usefully, I think,\n>     randomize() (randomly alter the order of items in a sequence),\n>     both with obvious side-effect issues; again these are impossible\n>     to implement using XSLT\n\nYes, this does come up surprisingly frequently. Needs looking at.\n> \n>   * function-available() to support the idea that XPath function\n>     libraries could be provided by particular implementations.\n\nXQuery isn't prepared to accept dynamic binding of function names, without\nwhich function-available() is meaningless. So this will remain an XSLT-only\nfunction.\n> \n>   * system-property() to support getting information about the XPath\n>     implementation version and so on.\n\nYes, that would be an interesting one to migrate. The current XSLT spec has\nthe disadvantage that it relies on run-time resolution of namespace\nprefixes, which XPath otherwise does not require.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "Re: F&amp;O W",
            "content": "Hi Mike,\n\n>>     As I think I might have mentioned before, I believe\n>>     that technically there should be a title-case() function as well,\n>\n> I Have Always Thought Title Case Was A Style Used Only By American\n> Newspapers.\n\nI was more thinking for capitalising the words at the beginning of\nsentences (or lines in a poem, say) than capitalising the whole\nstring, although I'm sure that in some cases that would be useful too.\n\n>>   * get-local-name() and get-namespace-uri() -- Makes me wish that\n>>     the structured data types such as QNames, dates, durations and so\n>>     on could be treated as virtual elements, so you could do\n>>     $qname/local-name or $date/year. \n>\n> Yes; I'd like to see a consistent approach to component extraction too. I\n> have proposed naming the functions, for example, QName.local-name(),\n> DateTime.month(), but I seem to be the only one who likes the idea.\n\nI certainly prefer that naming scheme to the get-component-from-type()\npattern. It would be even better if you didn't have to define\nfunctions for every single component, but had a separate method for\naccessing components, in my view, especially if external objects are\nallowed (as they are in XPath 1.0).\n\n>>   - root() -- I think that root($node) does the same thing as\n>>     $node/ancestor::node()[last()]. Given that the function is\n>>     possible with very little effort, and that you rarely need to get\n>>     from a node to the root node of that document, I don't really see\n>>     the point of this function.\n>\n> XQuery still has no ancestor axis. This function is actually there\n> because there is still a debate about the meaning of a leading \"/\":\n> does it mean root(), or does it mean input()? The traditional XSLT\n> meaning is root(), the traditional XQuery meaning is input().\n> Providing both functions ensures that both capabilities are\n> available unambiguously while we resolve what \"/\" should mean.\n\nRight. I was commenting from an XPath standpoint. It will be extremely\nbad news if / doesn't mean the same in XPath 2.0 as it did in XPath\n1.0.\n\n>>   - empty() -- empty($seq) seems to be equivalent to\n>>     not(boolean($seq)); as with other shorthands for easy expressions,\n>>     I don't think this one's necessary\n>> \n>>   - exists() -- seems to be equivalent to not(empty($seq))\n>\n> I quite like the improved readability that you get from empty() and\n> exists().\n\nAs I said, I think that improved readability shouldn't be the only\nreason for introducing a function. We can get improved readability,\nfor those that want/need it, through libraries of function\ndefinitions, without having to increase the set of core functions in\nXPath 2.0.\n\n>>   * function-available() to support the idea that XPath function\n>>     libraries could be provided by particular implementations.\n>\n> XQuery isn't prepared to accept dynamic binding of function names,\n> without which function-available() is meaningless. So this will\n> remain an XSLT-only function.\n\nWouldn't it still be useful in cases where different XQuery\nimplementations support different (extension or even core) functions,\nso that people can write queries that can be used across XQuery\nimplementations?\n\n>>   * system-property() to support getting information about the XPath\n>>     implementation version and so on.\n>\n> Yes, that would be an interesting one to migrate. The current XSLT\n> spec has the disadvantage that it relies on run-time resolution of\n> namespace prefixes, which XPath otherwise does not require.\n\nIf you defined system-property() as accepting a QName argument,\npresumably (?) the automatic casting in XPath 2.0 would enable the\nQName strings to be cast to QNames, as in xf:QName-from-string(), so\nthe function could be backwards compatible without requiring any more\nrun-time resolution of namespace prefixes than is there already.\n\nCheers,\n\nJeni\n\n---\nJeni Tennison\nhttp://www.jenitennison.com/\n\n\n\n"
        },
        {
            "subject": "RE: Base URI as used by documen",
            "content": "> > Possibly. But it's the normal convention on the web that \n> when one file \n> > contains a reference to another, the reference is considered to be \n> > relative to the file in which the reference was contained.\n> \n> But it is *not* the source file that contains the reference. \n> The filename is an expression that is calculated at run-time. \n> And the normal convention for when a filename is calculated \n> at run-time, then the reference is relative to the current \n> *run-time* context (directory).\n\nThe spec for the document() function distinguishes the case where the\nargument is a string from the case where it is a node. In the first case,\nthe base URI is taken from the static context, in the second case, it is the\nbase URI of the node containing the relative URI. The first case is designed\nprimarily for the situation where the value is a string literal. In the case\nof a computed string, you can select an alternative base URI by supplying\nthe second parameter to the document() function. This, I think, was designed\nto enable you to supply a run-time base URI. Perhaps the spec should be\nrefined so that the second argument is also allowed to be a string, rather\nthan necessarily a node.\n> \n> Which of course is difficult because there is no convenient \n> way for an application to get an absolute url from the \n> execution environment - i.e. no way reasonable way to get a \n> string parameter from the environment.  I suggested way to do \n> that in the posting \"Variable Declaration in Query Prolog\" \n> from March \n>\n(http://lists.w3.org/Archives/Public/www-xml-query-comments/2002Mar/0007.htm\nl).\n> I was disappointed to not get a response of this, since I think this is an\nessential \n> feature for practical use of XQuery.\n\nI think there is a good argument for allowing a query to take parameters, in\nthe same way as stylesheets can. On the other hand, there is an alternative\nargument that a query with parameters is no different from a function, and\nif you want this capability the right way to provide it is to allow the API\nto invoke an XQuery function directly.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "Comments on Functions and Operators (30th April",
            "content": "[using public-qt-comments  as some WG members have indicated that was\nthe intended comment list for F&O in common with the other documents in\nthis round]\n\n\n\n2.6 xf:unique-ID\n\n   I agree with others that there seems little point in this function.  If\n   for some reason you needed the functionality, it is just something like\n   @*[. instance of xs:ID] isn't it?\n\n\n3.2 Numeric Constructors\n\n   Having xs:byte and friends is almost (but not quite) reasonable in\n   schema where it provides a shorthand to constrain integer values to\n   set ranges (if they are the ranges you happen to want) but I see no\n   reason not to map all these to a single numeric type (or\n   integer/float distinction at most) within Xpath. Standard Xpath\n   constructs can be used to ensure that any calculated value is within\n   range. (However I'll assume in the comments below that all the types\n   are kept)\n\n\n3.2.1 Returns the decimal value that is represented by the characters\n    contained in the value of $srcval. For this constructor, $srcval\n    must be a string literal. \n\n   I commented on this before, as did others I believe. restricting the\n   constructors to literals, especially if they use a function syntax is\n   unreasonable. Arguments involving optimisation don't really hold as\n   any optimising compiler must be able to spot when a function argument\n   is literal and so optimise away the function call.  (This is a\n   generic comment for all constructors, I only comment on this one.)\n\n\n3.3 Operators on Numeric Values\nThe arguments and return types for the arithmetic operators are the\nbasic numeric types: decimal, float, and double and types derived from\nthem. For simplicity, each operator is defined to operate on operands of\nthe same datatype and to return the same datatype \n\n\nThe type promotion scheme includes only two rules: \n\nA derived type may be promoted its base type.\n\ndecimal may be promoted to float, and float may be promoted to double. \n\n\n\n   It is not clear to me from that wording if the arguments are _always_\n   promoted to their base type. The use of \"may\" suggests not but the\n   examples involving integer being promoted to decimal suggest yes.\n   What happens if the two arguments are the same (non-base) type?\n\n   In particular I can not tell if 5 div 3 is first converted\n   to 5.0 div 3.0 (and so compatible with XPath 1) or, as in earlier\n   drafts of this document does integer division returning an integer.\n\n\n   similarly\n\n3.3.5.1 Examples\nop:numeric-mod(10,3) returns 1.\n\n    If 10 and 3 there are integers (which I think they are?) then it\n    should be made clear that 1 is not of integer type (if it isn't).\n\n3.3.7 op:numeric-unary-minus\n    should this specify what happens on NaN (presumably returns NaN?)\n\n\n\n3.4.1 op:numeric-equal\nop:numeric-equal(numeric $operand1, numeric $operand2) => boolean\nReturns true if and only if $operand1 is exactly equal to\n$operand2. This function backs up the \"eq\" and \"ne\" operators on numeric\nvalues. \n\n   As Jeni commented in here comments on this draft, it's not clear that\n   eq is particularly useful at the surface Xpath syntax (as opposed to\n   the semantics), if it were dropped the last phrase would need\n   replacing with one referring to = and !=.\n\n\n\n4.1 String Types\nThe operators described in this section are defined on the following string types.\n\nstring \n normalizedString \n\n   As I commented on the last draft and above for the numeric types the\n   justification for copying over all the schema derived types into\n   XPath is rather weak. \n\n   normalizedString is a particularly bad example it is just a subset of\n   string, in many uses of Xpath (XSLT for example) it's rather hard to\n   generate a string that _isn't_ in this subset.\n\n   The purpose of the datatype in schema is to instruct the parser on\n   the mapping from the input characters to the value space, but this is\n   just a parsing issue it has no use at all in XPath/XQuery.\n\n\n\n4.2.3 xf:token\n   Unless there are some useful functions defined on this datatype that\n   are not available to strings, why would anyone use this? \n\n\n\n4.2.8 xf:ID\nThe semantic correctness of ID values (that they must be unique within a\ngiven document) is not enforced by the xf:ID function.\n   \n\n    Since this property is the only useful property that IDs have, there\n    seems no point in this function, if values of type ID are not\n    guaranteed to be unique to a document  (as they are\n    effectively in XPath 1, even for invalid documents) then you may as\n    well use string.\n\n\n\n[Issue 144: Should the concat function accept sequences as arguments? ] \n\n    Maybe you don't want to overload concat but a mapconcat that\n    takes the string value of every item in a sequence and concatenates\n    the result would be useful (of course if you'd added proper higher\n    order function  support this could have been done with some\n    combination of fold and concat, but....\n\n\n\n4.4.5 xf:contains\n   How do collations work with respect to substring matching as opposed\n   to ordering, if ss and sharp-s collate equal, is \"s\" a substring of\n   sharp-s? (I suspect this is ignorance on my part, but I'm probably\n   not the only one, some examples might help, as is done in some detail\n   for collations and the comparison operators).\n\n\n4.4.10.1 Examples\nxf:normalize-space(\" hello world \") returns \"hello world\". \n\n   As came up recently on xsl-list it would be good to have an example\n   of   \n   xf:normalize-space(\"     \") returns \"\". \n\n  As some readers (surprisingly) managed to construe the XPath 1\n  description as allowing a return value of a space.\n\n\n\n\n> A \"lower-case letter\" is a character whose Unicode General Category\n> class includes \"Ll\". The corresponding upper-case letter is determined\n> using [Unicode Case Mappings].  \n\n   In the unicode tables each character is unambiguously upper or lower\n   case, but the mappings are locale-dependent.\n   so i is lowercase and\n   I and LATIN CAPITAL LETTER I WITH DOT ABOVE are both uppercase\n   but which of these is the the uppercase of i depends on who you ask.\n   (probably it just depends on whether you are in Turkey, but still...)\n   \n\n\n 4.4.15 xf:string-pad\n\n    Would have been more useful in XPath 1 than it is in 2, where it\n    can trivially be defined as a user function.\n\n    It would be better to take out all of these \"shortcut functions\"\n    from the core language and perhaps add them again as a \"standard\n    library\" of functions that are defined within Xquery (or/and\n    XSLT). Many other languages follow this model, have a small core set\n    of functions but a larger collection of useful functions that are\n    provided to the end users but are (specified as being) defined using\n    the language rather than being a core part of the language.  Of\n    course an implementation may or may not use the \"obvious\" definition\n    in the language or a built in optimisation.\n\n\n\n4.4.17 xf:replace\n\n    This doesn't even come close to what is needed, but I think\n    a future draft will have more on this...\n\n\n\n6.1 Duration, Date and Time Types\n\n     This is all so unspeakably horrible. It's not all your fault mind, \n     starting from the mass of date related constructs in W3C schema it\n     may be that nothing better could be done. (Sorry this isn't that\n     constructive a comment, I'm going to skip this section, and didn't\n     want lack of comment to be taken as agreement that it was all\n     fine...)\n\n\n\n\n9.1.2 op:base64-binary-equal\n\n      Wouldn't equality on this type be more useful if it ignored\n      whitespace? That way equality would imply that you get the same\n      binary data if you decode the base64 encoding. If you really want\n      to check the _encoded_ string is equal you can cast to string, but\n      why would you want that?\n\n\n\n\n11.1.6 xf:deep-equal\n\n   Should not be provided as a core fuction, you always need to write a\n   recursive function for the exact notion of equality that you need\n   (do attributes count?, namespaces? white space text nodes?)\n  \n11.1.11 xf:copy\n11.1.12 xf:shallow\n\n   Should (at most) be in XQuery and not in the core XPath.\n\n\n11.2.1 xf:if-absent\n11.2.2 xf:if-empty\n\n   Should not be provided in the core (at most it could be provided in a\n   standard library) but since presumably the second argument is evaluated\n   whether or not the first argument is true, a user would always (?)\n   be better advised to use  the conditional if expression.\n\n\n12.2.5 xf:empty\n12.2.6 xf:exists\n\n   these are simply shorthands for simple expressions, should not be in\n   the core.\n\n12.3.1 xf:sequence-deep-equal\n\n   see previous comments on deep-equal\n\n\n[Issue 67: Should duplicates be eliminated for count() and sum()?] \n\n   No.\n\n12.4.2 xf:avg\nValues that equal the empty sequence are discarded.\n\n  I think that that is just a special case of the (implied) operation\n  that what is constructed is the sequence of values of the data()\n  function.\n  the fact that empty sequences vanish is then just a consequence of the\n  flattening rules for sequences, and this would then also specify what\n  happens if some values are non-empty sequences, which is not fully\n  specified at present.\n\n\n12.4.3 xf:max\n  As Jeni commented it would be useful if max could return the _item_\n  that has a max value rather than just its value.\n\n\n12.4.5 xf:sum\n  As for count I think that the description on empty sequences should be\n  generalised to any sequence. (Also I'm pleased to see that sum() now\n  returns 0 on () unlike the last draft)\n\n\n12.5.1 xf:id\n  Have to have this of course for compatibility although key() turns out\n  to be a lot more useful. (Which is why it is rather odd that XPath2 has => op\n  which is even more restricted than id().)\n\n\n12.5.2 xf:idref\n  Not clear that this is really useful.\n\n\n12.5.3 xf:filter\n[Issue 167: Semantics of xf:filter are underspecified and, perhaps, incorrect.] \n\n   This function probably should be removed.\n\nDavid\n\n_____________________________________________________________________\nThis message has been checked for all known viruses by Star Internet\ndelivered through the MessageLabs Virus Scanning Service. For further\ninformation visit http://www.star.net.uk/stats.asp or alternatively call\nStar Internet for details on the Virus Scanning Service.\n\n\n\n"
        },
        {
            "subject": "RE: Comments on Functions and Operators (30th April",
            "content": "Thanks, David. Just to keep you up to date:\n\n(a) we are close to accepting a proposal that unifies casts and constructor\nfunctions, so hopefully this stuff about constructors requiring a string\nliteral will disappear.\n\n(b) we have started work on a more precise definition of arithmetic,\ncovering the promotion rules, the returned types, scale and precision of\nresults, effect of overflow and underflow etc - but there is a lot of work\nstill to be done.\n\n(c) we have decided to drop some of the more obscure functions such as\nxf:shallow() and xf:filter()\n\nI did look into the question of defining contains() and startsWith() etc\nwith respect to a collation. It works provided the collation has certain\nproperties, in effect it must be a \"character by character\" collation - it\nwon't work on a \"semantic\" collation that sorts January before February or\niso646 before iso2022. We have to decide how much detail we want to specify\non this.\n\nI quite like the idea of distinguishing core functions from utility\nfunctions, my approach to this would be leave the utility functions in the\nsame spec (we have too many documents already) but specify their effect\nusing an actual code implementation.\n\nMichael Kay\n\n> -----Original Message-----\n> From: David Carlisle [mailto:davidc@nag.co.uk] \n> Sent: 21 May 2002 12:11\n> To: public-qt-comments@w3.org\n> Subject: Comments on Functions and Operators (30th April)\n> \n> \n> \n> [using public-qt-comments  as some WG members have indicated \n> that was the intended comment list for F&O in common with the \n> other documents in this round]\n> \n> \n> \n> 2.6 xf:unique-ID\n> \n>    I agree with others that there seems little point in this \n> function.  If\n>    for some reason you needed the functionality, it is just \n> something like\n>    @*[. instance of xs:ID] isn't it?\n> \n> \n> 3.2 Numeric Constructors\n> \n>    Having xs:byte and friends is almost (but not quite) reasonable in\n>    schema where it provides a shorthand to constrain integer values to\n>    set ranges (if they are the ranges you happen to want) but I see no\n>    reason not to map all these to a single numeric type (or\n>    integer/float distinction at most) within Xpath. Standard Xpath\n>    constructs can be used to ensure that any calculated value \n> is within\n>    range. (However I'll assume in the comments below that all \n> the types\n>    are kept)\n> \n> \n> 3.2.1 Returns the decimal value that is represented by the characters\n>     contained in the value of $srcval. For this constructor, $srcval\n>     must be a string literal. \n> \n>    I commented on this before, as did others I believe. \n> restricting the\n>    constructors to literals, especially if they use a \n> function syntax is\n>    unreasonable. Arguments involving optimisation don't really hold as\n>    any optimising compiler must be able to spot when a \n> function argument\n>    is literal and so optimise away the function call.  (This is a\n>    generic comment for all constructors, I only comment on this one.)\n> \n> \n> 3.3 Operators on Numeric Values\n> The arguments and return types for the arithmetic operators \n> are the basic numeric types: decimal, float, and double and \n> types derived from them. For simplicity, each operator is \n> defined to operate on operands of the same datatype and to \n> return the same datatype \n> \n> \n> The type promotion scheme includes only two rules: \n> \n> A derived type may be promoted its base type.\n> \n> decimal may be promoted to float, and float may be promoted \n> to double. \n> \n> \n> \n>    It is not clear to me from that wording if the arguments \n> are _always_\n>    promoted to their base type. The use of \"may\" suggests not but the\n>    examples involving integer being promoted to decimal suggest yes.\n>    What happens if the two arguments are the same (non-base) type?\n> \n>    In particular I can not tell if 5 div 3 is first converted\n>    to 5.0 div 3.0 (and so compatible with XPath 1) or, as in earlier\n>    drafts of this document does integer division returning an integer.\n> \n> \n>    similarly\n> \n> 3.3.5.1 Examples\n> op:numeric-mod(10,3) returns 1.\n> \n>     If 10 and 3 there are integers (which I think they are?) then it\n>     should be made clear that 1 is not of integer type (if it isn't).\n> \n> 3.3.7 op:numeric-unary-minus\n>     should this specify what happens on NaN (presumably returns NaN?)\n> \n> \n> \n> 3.4.1 op:numeric-equal\n> op:numeric-equal(numeric $operand1, numeric $operand2) => \n> boolean Returns true if and only if $operand1 is exactly \n> equal to $operand2. This function backs up the \"eq\" and \"ne\" \n> operators on numeric values. \n> \n>    As Jeni commented in here comments on this draft, it's not \n> clear that\n>    eq is particularly useful at the surface Xpath syntax (as \n> opposed to\n>    the semantics), if it were dropped the last phrase would need\n>    replacing with one referring to = and !=.\n> \n> \n> \n> 4.1 String Types\n> The operators described in this section are defined on the \n> following string types.\n> \n> string \n>  normalizedString \n> \n>    As I commented on the last draft and above for the numeric \n> types the\n>    justification for copying over all the schema derived types into\n>    XPath is rather weak. \n> \n>    normalizedString is a particularly bad example it is just \n> a subset of\n>    string, in many uses of Xpath (XSLT for example) it's \n> rather hard to\n>    generate a string that _isn't_ in this subset.\n> \n>    The purpose of the datatype in schema is to instruct the parser on\n>    the mapping from the input characters to the value space, \n> but this is\n>    just a parsing issue it has no use at all in XPath/XQuery.\n> \n> \n> \n> 4.2.3 xf:token\n>    Unless there are some useful functions defined on this \n> datatype that\n>    are not available to strings, why would anyone use this? \n> \n> \n> \n> 4.2.8 xf:ID\n> The semantic correctness of ID values (that they must be \n> unique within a given document) is not enforced by the xf:ID function.\n>    \n> \n>     Since this property is the only useful property that IDs \n> have, there\n>     seems no point in this function, if values of type ID are not\n>     guaranteed to be unique to a document  (as they are\n>     effectively in XPath 1, even for invalid documents) then \n> you may as\n>     well use string.\n> \n> \n> \n> [Issue 144: Should the concat function accept sequences as \n> arguments? ] \n> \n>     Maybe you don't want to overload concat but a mapconcat that\n>     takes the string value of every item in a sequence and \n> concatenates\n>     the result would be useful (of course if you'd added proper higher\n>     order function  support this could have been done with some\n>     combination of fold and concat, but....\n> \n> \n> \n> 4.4.5 xf:contains\n>    How do collations work with respect to substring matching \n> as opposed\n>    to ordering, if ss and sharp-s collate equal, is \"s\" a substring of\n>    sharp-s? (I suspect this is ignorance on my part, but I'm probably\n>    not the only one, some examples might help, as is done in \n> some detail\n>    for collations and the comparison operators).\n> \n> \n> 4.4.10.1 Examples\n> xf:normalize-space(\" hello world \") returns \"hello world\". \n> \n>    As came up recently on xsl-list it would be good to have an example\n>    of   \n>    xf:normalize-space(\"     \") returns \"\". \n> \n>   As some readers (surprisingly) managed to construe the XPath 1\n>   description as allowing a return value of a space.\n> \n> \n> \n> \n> > A \"lower-case letter\" is a character whose Unicode General Category \n> > class includes \"Ll\". The corresponding upper-case letter is \n> determined \n> > using [Unicode Case Mappings].\n> \n>    In the unicode tables each character is unambiguously \n> upper or lower\n>    case, but the mappings are locale-dependent.\n>    so i is lowercase and\n>    I and LATIN CAPITAL LETTER I WITH DOT ABOVE are both uppercase\n>    but which of these is the the uppercase of i depends on \n> who you ask.\n>    (probably it just depends on whether you are in Turkey, \n> but still...)\n>    \n> \n> \n>  4.4.15 xf:string-pad\n> \n>     Would have been more useful in XPath 1 than it is in 2, where it\n>     can trivially be defined as a user function.\n> \n>     It would be better to take out all of these \"shortcut functions\"\n>     from the core language and perhaps add them again as a \"standard\n>     library\" of functions that are defined within Xquery (or/and\n>     XSLT). Many other languages follow this model, have a \n> small core set\n>     of functions but a larger collection of useful functions that are\n>     provided to the end users but are (specified as being) \n> defined using\n>     the language rather than being a core part of the language.  Of\n>     course an implementation may or may not use the \"obvious\" \n> definition\n>     in the language or a built in optimisation.\n> \n> \n> \n> 4.4.17 xf:replace\n> \n>     This doesn't even come close to what is needed, but I think\n>     a future draft will have more on this...\n> \n> \n> \n> 6.1 Duration, Date and Time Types\n> \n>      This is all so unspeakably horrible. It's not all your \n> fault mind, \n>      starting from the mass of date related constructs in W3C \n> schema it\n>      may be that nothing better could be done. (Sorry this isn't that\n>      constructive a comment, I'm going to skip this section, \n> and didn't\n>      want lack of comment to be taken as agreement that it was all\n>      fine...)\n> \n> \n> \n> \n> 9.1.2 op:base64-binary-equal\n> \n>       Wouldn't equality on this type be more useful if it ignored\n>       whitespace? That way equality would imply that you get the same\n>       binary data if you decode the base64 encoding. If you \n> really want\n>       to check the _encoded_ string is equal you can cast to \n> string, but\n>       why would you want that?\n> \n> \n> \n> \n> 11.1.6 xf:deep-equal\n> \n>    Should not be provided as a core fuction, you always need \n> to write a\n>    recursive function for the exact notion of equality that you need\n>    (do attributes count?, namespaces? white space text nodes?)\n>   \n> 11.1.11 xf:copy\n> 11.1.12 xf:shallow\n> \n>    Should (at most) be in XQuery and not in the core XPath.\n> \n> \n> 11.2.1 xf:if-absent\n> 11.2.2 xf:if-empty\n> \n>    Should not be provided in the core (at most it could be \n> provided in a\n>    standard library) but since presumably the second argument \n> is evaluated\n>    whether or not the first argument is true, a user would always (?)\n>    be better advised to use  the conditional if expression.\n> \n> \n> 12.2.5 xf:empty\n> 12.2.6 xf:exists\n> \n>    these are simply shorthands for simple expressions, should \n> not be in\n>    the core.\n> \n> 12.3.1 xf:sequence-deep-equal\n> \n>    see previous comments on deep-equal\n> \n> \n> [Issue 67: Should duplicates be eliminated for count() and sum()?] \n> \n>    No.\n> \n> 12.4.2 xf:avg\n> Values that equal the empty sequence are discarded.\n> \n>   I think that that is just a special case of the (implied) operation\n>   that what is constructed is the sequence of values of the data()\n>   function.\n>   the fact that empty sequences vanish is then just a \n> consequence of the\n>   flattening rules for sequences, and this would then also \n> specify what\n>   happens if some values are non-empty sequences, which is not fully\n>   specified at present.\n> \n> \n> 12.4.3 xf:max\n>   As Jeni commented it would be useful if max could return the _item_\n>   that has a max value rather than just its value.\n> \n> \n> 12.4.5 xf:sum\n>   As for count I think that the description on empty \n> sequences should be\n>   generalised to any sequence. (Also I'm pleased to see that sum() now\n>   returns 0 on () unlike the last draft)\n> \n> \n> 12.5.1 xf:id\n>   Have to have this of course for compatibility although \n> key() turns out\n>   to be a lot more useful. (Which is why it is rather odd \n> that XPath2 has => op\n>   which is even more restricted than id().)\n> \n> \n> 12.5.2 xf:idref\n>   Not clear that this is really useful.\n> \n> \n> 12.5.3 xf:filter\n> [Issue 167: Semantics of xf:filter are underspecified and, \n> perhaps, incorrect.] \n> \n>    This function probably should be removed.\n> \n> David\n> \n> _____________________________________________________________________\n> This message has been checked for all known viruses by Star \n> Internet delivered through the MessageLabs Virus Scanning \n> Service. For further information visit \n> http://www.star.net.uk/stats.asp or > alternatively call Star \n> Internet for details on the Virus Scanning Service.\n> \n\n\n\n"
        },
        {
            "subject": "Comments on XPath (30th April",
            "content": "2.3.2.2 Dereferences\n\n  Either this should be removed or there needs to be a lot more\n  justification placed in the document as to why it should be included.\n  It appears to just be a cumbersome syntax for a highly restricted from\n  of the function id().\n\n\n2.6.1 Value Comparisons\n\n  these are useful for defining the semantics of = and friends but it\n  isn't clear they are really useful as user level syntax.\n  If eq doesn't generate an error, you could have used = instead (unless I\n  misread, which is possible)\n\n  oh a general typographical comment on the specs that I just noticed at\n  this point:\n  Could glossary entries (like the bold \"Atomization\" here) be made into\n  links to their definition.\n\n2.6.4 Order Comparisons\n\n  It is not at all clear these are desirable in XPath for example\n\n  //purchase[parcel=\"28-451\"] << //sale[parcel=\"33-870\"]\n\n  Could more simply be expressed as (the boolean value of)\n\n  //purchase[parcel=\"28-451\"]/following::sale[parcel=\"33-870\"]\n\n  I realise Xquery as currently spec'd doesn't have a full set of axes,\n  but it certainly ought to and I assume if for some reason they are\n  not in Xquery 1, user pressure will force them to be in Xquery 1.1,\n  The axis notion of navigating round a document tree has been one of\n  the more successful innovations in XPath.\n\n\n2.7 Logical Expressions\n\nThe first step in evaluating a logical expression is to reduce each of\nits operands to an effective boolean value \n\n  This is a horrible incompatibility with XPath1 which explictly states\n  that the second argument is not evaluated if the result can be\n  determined from the first.  This feature is _very_ often used, expressions\n  such as\n  function-available(...) and ...\n  cheap-expression and //*[very-expensive-search]\n  are very common, and with this new definition the first may well cause\n  errors and the second get very slow.\n\n\ntrue or error\n\n  Having the specification being different from XPath 1 is bad enough,\n  having it be unspecified is even worse. \n\n2.8 For Expressions\n\n  The fact that for expressions mean that it possible in XPath to bind\n  variables to items but not to sequences is a very strange state of\n  affairs. Also the fact that there is no version of for that moves the\n  context item (and so .) is going to lead to endless user confusion.\n\n  However to comment on the specifics in the current draft:\n\nA for clause associates one or more variables with expressions, creating\ntuples of variable bindings drawn from the Cartesian product of the\nsequences of values  \n\n   Do you really need to bring in all this stuff on tuples, at the level\n   of user visible behaviour isn't a for with multiple variables just\n   the same as a nested set of for with one variable each?\n\n\n\n\n\n[6]    QuantifiedExpr    ::=    (\"some\" \"$\" |  \"every\" \"$\") QName \"in\" Expr \n                                   (\",\" Variable \"in\" Expr)* \"satisfies\"  Expr \n\n   Why is the first Variable split into $Qname and not the second?\n   isn't this\n\n   [6]    QuantifiedExpr    ::=    (\"some\" | \"every\") Variable \"in\" Expr \n                                      (\",\" Variable \"in\" Expr)* \"satisfies\"  Expr \n\n\n\n\n\n\n[20]    CastExpr    ::=    (\"cast\" \"as\" |  \"treat\" \"as\" |  \"assert\" \"as\")  \n\n\n  I'm glad Mike just indicated  in a reply to my comments on F&O that\n  there will be some rationalisation here, and in the type constructor\n  functions. (Personally I'd prefer to see none of these in XPath, but I\n  assume that's too much to ask.)\n\n\n\n\n2.12 Validate Expressions\n\n  I do not think that this should be in XPath at all. Validation has\n  little to do with querying a document structure, which is the purpose of\n  XPath, and this ties Xpath even more to W3C schema (as opposed to some\n  generic psvi typed input from any source).\n\n  If you must have it (and I really hope it goes) why isn't it a normal\n  function with () syntax rather than a magic form with its own {} curly\n  brace syntax?\n\n\n\n\nDavid\n\n_____________________________________________________________________\nThis message has been checked for all known viruses by Star Internet\ndelivered through the MessageLabs Virus Scanning Service. For further\ninformation visit http://www.star.net.uk/stats.asp or alternatively call\nStar Internet for details on the Virus Scanning Service.\n\n\n\n"
        },
        {
            "subject": "RE: Comments on XPath (30th April",
            "content": "Useful comments, David.\n\n> 2.3.2.2 Dereferences\n> \n>   Either this should be removed or there needs to be a lot more\n>   justification placed in the document as to why it should be \n> included.\n\nThe justification that's used is that the type of the result can be\ndetermined statically, which it can't for id().\n> \n> \n> 2.6.1 Value Comparisons\n> \n>   these are useful for defining the semantics of = and friends but it\n>   isn't clear they are really useful as user level syntax.\n\nI think the justification is that using \"eq\" tells the optimizer it can use\naccess paths (e.g. indexes) that don't support the existential semantics.\nBut I tend to agree with you, people probably aren't going to use these\noperators so there's not much point providing them.\n> \n> 2.6.4 Order Comparisons\n> \n>   It is not at all clear these are desirable in XPath for example\n> \n>   //purchase[parcel=\"28-451\"] << //sale[parcel=\"33-870\"]\n> \n>   Could more simply be expressed as (the boolean value of)\n> \n>   //purchase[parcel=\"28-451\"]/following::sale[parcel=\"33-870\"]\n> \nIt doesn't actually mean quite the same; but I must admit I have difficulty\nfinding convincing use cases for these operators.\n\n> \n> \n> 2.7 Logical Expressions\n> \n> The first step in evaluating a logical expression is to \n> reduce each of its operands to an effective boolean value \n> \n>   This is a horrible incompatibility with XPath1 which \n> explictly states\n>   that the second argument is not evaluated if the result can be\n>   determined from the first. \n\nA difficult one, this. Database systems do need to optimize boolean\npredicates by using indexes, and that makes it very hard to support the\nXPath 1.0 semantics. I don't much like the alternative of introducing a\nsecond pair of operators. I'm more inclined to solve it by having a rule at\nthe XSLT level, whereby XSLT constrains these XPath operators to behave in\nthe XPath 1.0 manner (which conforms to one of the options permitted by\nXPath 2.0). Not nice.\n\n> \n> 2.8 For Expressions\n> \n>   The fact that for expressions mean that it possible in XPath to bind\n>   variables to items but not to sequences is a very strange state of\n>   affairs.\n\nYou think we should allow \"let\" in XPath? The trouble is, we can expand\nXPath or contract it, and whatever we do, we will upset someone.\n\n> Also the fact that there is no version of for that \n> moves the context item (and so .) is going to lead to endless user\nconfusion.\n\nWe've put this on the agenda for discussion once again, because the request\ncomes up repeatedly. The three options are:\n\n* provide a simple (context-based) FOR expression only\n* provide a full FOR expression with range variables\n* provide both\n\n> \n>   However to comment on the specifics in the current draft:\n> \n> A for clause associates one or more variables with \n> expressions, creating tuples of variable bindings drawn from \n> the Cartesian product of the sequences of values  \n\nYou're not the only person who's noticed that a simpler formulation is\npossible. \n> \n> \n> [6]    QuantifiedExpr    ::=    (\"some\" \"$\" |  \"every\" \"$\") \n> QName \"in\" Expr \n>                                    (\",\" Variable \"in\" Expr)* \n> \"satisfies\"  Expr \n> \n>    Why is the first Variable split into $Qname and not the second?\n\nWe're trying to present a syntax that's parseable without lookahead, under\ncertain constraints. \"some $\" and \"every $\" turn out to be \"compound tokens\"\nin this syntax, where \"some\" and \"every\" can only be distinguished from\nQNames by the presence of the following \"$\". It's messy and we're looking at\nways of presenting it better.\n> \n> \n> [20]    CastExpr    ::=    (\"cast\" \"as\" |  \"treat\" \"as\" |  \n> \"assert\" \"as\")  \n> \n> \n>   I'm glad Mike just indicated  in a reply to my comments on F&O that\n>   there will be some rationalisation here, and in the type constructor\n>   functions. (Personally I'd prefer to see none of these in \n> XPath, but I assume that's too much to ask.)\n> \nIt's not necessarily too much to ask. We're certainly looking to make as\nmuch simplification as we can (and no more).\n> \n> \n> 2.12 Validate Expressions\n> \n>   I do not think that this should be in XPath at all.\n\nI agree.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "Re: Comments on XPath (30th April",
            "content": "> The justification that's used is that the type of the result can be\n> determined statically, which it can't for id().\n\nwell yes but personally I don't think that's sufficient justification\nbut also I only know that at all because I have W3C access (or because\nyou just told me), the documents as written just inflict the syntax with\nno suggestion as to why it is there.\n\n> It doesn't actually mean quite the same\nyou can't always replace << by following:: but I think in this case\nit means the same (after coercing to boolean) doesn't it? and in other\ncases (involving attributes or multiple documents you can do _something_)\n\n> You think we should allow \"let\" in XPath?\nI'm not sure, it's just a comment. (An alternative is to take out for\nand move iterating over sequences to xslt, as per Jeni's suggestion)\nThe disability to bind variables does mean that if you are doing\nanything very complicated you are going to have to re-evaluate\nexpressions, or try to move the looping to XSLT anyway. It's easier to\npoint out problems with the current situation than to suggest fixes...\n\n\n\n> I don't much like the alternative of introducing a\n> second pair of operators. I'm more inclined to solve it by having a rule\n> at the XSLT level, \n\nHmm OK if XSLT compatibiliy can be recreated then perhaps this isn't so\nbad.\n\nDavid\n\n_____________________________________________________________________\nThis message has been checked for all known viruses by Star Internet\ndelivered through the MessageLabs Virus Scanning Service. For further\ninformation visit http://www.star.net.uk/stats.asp or alternatively call\nStar Internet for details on the Virus Scanning Service.\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0/XPath 2.0  simplifying predicate  evaluation rule",
            "content": "Rule #4 under \"2.3.2.1 Predicates\" in both the XQuery 1.0 and XPath 2.0\ndocuments seems needlessly awkward to me. The rule states,\n\n4) \"If the value of the predicate expression is a sequence that contains at\nleast one node and does not contain any item that is not a node, ...\"\n\nRule #1) states, \"If the value of the predicate expression is an empty\nsequence, ...\". Thus if we've gotten as far as #4, we already know we have a\nnon-empty sequence. So why not simply say something as straightforward as,\n\n4) \"If the value of the predicate expression is a purely homogeneous\nsequence of nodes only, ...\" or some such? I don't see any loss of technical\naccuracy by doing so.\n\nBest,\nHoward\n\n\n\n"
        },
        {
            "subject": "variable binding in XPath was: Comments on XPath (30th April",
            "content": "me>   The fact that for expressions mean that it possible in XPath to bind\nme>   variables to items but not to sequences is a very strange state of\nme>   affairs.\n\nmike> You think we should allow \"let\" in XPath?\n\nOn reflection, I think yes.\n\n\nmike>* provide a simple (context-based) FOR expression only\nmike>* provide a full FOR expression with range variables\nmike>* provide both\n\nA suggestion.\n\n* Remove the \"full\" for from Xpath.\n* Provide a simpler context based for, either something like\n\n\"foreach\" Expr \"return\" Expr\nor something more symbolic, Xpath-like  syntax, I'd quite like\n\n Expr => Expr  \n\n(with => taking the same precedence as /, and doing a similar job but\nnot restricted to node sequences and not applying doc-order to the\nresult) I know => is currently being used for something else....\n\n* Provide let (with the current XQuery syntax)\n\n\nThe advantages of this over the current situation are \n\na) that simple mappings over sequences (by far the majority case in\nXpath use, I would expect) are simpler, not requiring explicit variables\nat all.\n\nb) There is more functionality for more complicated cases as you can\nbind any value to a variable, not just non-sequence items. For nested\nfor constructs where you need variables to save the context you'd do the\nequivalent of what you do already for xsl:for-each, something like\n\nforeach $lista return\n  let $a . in\n     foreach $listb\n        return my:f(.,$a)\n   \n\nDavid\n\n_____________________________________________________________________\nThis message has been checked for all known viruses by Star Internet\ndelivered through the MessageLabs Virus Scanning Service. For further\ninformation visit http://www.star.net.uk/stats.asp or alternatively call\nStar Internet for details on the Virus Scanning Service.\n\n\n\n"
        },
        {
            "subject": "RE: variable binding in XPath was: Comments on XPath (30th April",
            "content": "> \n> A suggestion.\n> \n> * Remove the \"full\" for from Xpath.\n> * Provide a simpler context based for, either something like\n> \n> \"foreach\" Expr \"return\" Expr\n> or something more symbolic, Xpath-like  syntax, I'd quite like\n> \n>  Expr => Expr  \n> \n> (with => taking the same precedence as /, and doing a similar \n> job but not restricted to node sequences and not applying \n> doc-order to the\n> result) I know => is currently being used for something else....\n> \n> * Provide let (with the current XQuery syntax)\n> \n\nI think that's a nice idea... I'll chew on it.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "Re: Data Model 3.",
            "content": "Dear Andrew,\n\nWe plan to address your suggestions in the next version of\nthe document. In particular we plan to\n- add a link to W3C XML Schema Part I when the PSVI is referenced\n- use the term \"DTD-validated\"\n- specify the version of the Namespace REC \nWe do not plan to provide a self-contained document describing\nPSVI or XML Schemas. \n\nThank you for your comments!\n\nBest regards,\nMarton Nagy\n\n> \n> Date: Sat, 11 May 2002 09:35:02 -0400 (EDT)\n> From: AndrewWatt2001@aol.com\n> Message-ID: <9b.274c8a75.2a0e77d9@aol.com>\n> To: public-qt-comments@w3.org\n> Subject: Data Model 3.3\n> \n> I have a number of specific suggestions to make regarding Chapter 3.3 of the \n> Data Model WD.\n> \n> 1. In the first paragraph the PSVI is referred to without a link. Either a \n> link should be provided to W3C XML Schema Part I or (probably better) a \n> self-contained document should be provided introducing PSVI in a clear, \n> manner and, if possible, avoiding newcomers to XQuery having to grapple with \n> W3C XML Schema Part I.\n> \n> 2. Reference is made to \"schema-validated\" documents and \"DTD-valid\" \n> documents. The terms should structured the same way.\n> \n> 3. When reference is made to documents not conforming to Namespaces in XML a \n> reference should be added to clarify whether version 1.0 or 1.1 is being \n> referred to. By the time XQuery 1.0 gets to REC this may be a practical \n> issue. A link should be added to whichever is relevant.\n> \n> Andrew Watt\n>\n\n\n\n"
        },
        {
            "subject": "Re: variable binding in XPath was: Comments on XPath (30th April",
            "content": "If we remove the \"full\" for from XPath, then I agree that let would be \nneeded. I don't want to give up the ability to access intermediate context \nnodes (as opposed to being restricted to the ends of the spectrum, i.e. . \nand current()).\n\nEvan\n\nOn Wednesday, May 22, 2002, at 03:50  AM, Kay, Michael wrote:\n\n>>\n>> A suggestion.\n>>\n>> * Remove the \"full\" for from Xpath.\n>> * Provide a simpler context based for, either something like\n>>\n>> \"foreach\" Expr \"return\" Expr\n>> or something more symbolic, Xpath-like  syntax, I'd quite like\n>>\n>>  Expr => Expr\n>>\n>> (with => taking the same precedence as /, and doing a similar\n>> job but not restricted to node sequences and not applying\n>> doc-order to the\n>> result) I know => is currently being used for something else....\n>>\n>> * Provide let (with the current XQuery syntax)\n>>\n>\n> I think that's a nice idea... I'll chew on it.\n>\n> Michael Kay\n>\n\n\n\n"
        },
        {
            "subject": "Re: Data Model W",
            "content": "Dear Jeni,\n\nThank you very much for your comments.\nSee my replies below.\n\nBest regards,\nMarton Nagy\n\n\n> Date: Thu, 9 May 2002 06:06:34 -0400 (EDT)\n> From: Jeni Tennison <jeni@jenitennison.com>\n> Message-ID: <251473323306.20020509110629@jenitennison.com>\n> To: public-qt-comments@w3.org\n> Subject: Data Model WD\n> \n> Hi,\n> \n> Congratuations on the new version of the Data Model WD. On the whole,\n> it's very clear and well put-together.\n> \n> I see that you're considering what to do about anonymous types. I\n> don't think that using the empty sequence as their name will help,\n> since that's the only method of access to type information, and would\n> imply that:\n> \n> <xs:element name=\"foo\">\n>   <xs:complexType>...</xs:complexType>\n> </xs:element>\n> \n> and:\n> \n> <xs:element name=\"bar\">\n>   <xs:simpleType>...</xs:simpleType>\n> </xs:element>\n> \n> had the same type. But I think that it's important, particularly for\n> simple types, that they're not just ignored or substituted for\n> xs:anySimpleType, especially if you consider anonymous simple type\n> definitions nested within list and union types. For example:\n> \n> <xs:simpleType name=\"listOfDatesIn2002\">\n>   <xs:list>\n>     <xs:simpleType>\n>       <xs:restriction base=\"xs:date\">\n>         <xs:minInclusive value=\"2002-01-01\" />\n>         <xs:maxExclusive value=\"2003-01-01\" />\n>       </xs:restriction>\n>     </xs:simpleType>\n>   </xs:list>\n> </xs:simpleType>\n> \n> Say I had:\n> \n>   <holidays xsi:type=\"listOfDatesIn2002\">\n>     2002-05-06 2002-06-03\n>   </holidays>\n> \n> I can't find the part of the Data Model WD that explains how the\n> [schema normalized value], which is the string \"2002-05-06 2002-06-03\"\n> gets turned into a sequence of AtomicValues, but I assume that's done\n> by splitting the string at spaces and querying the element's type\n> definition to get hold of the item type definition somehow (a\n> particularly complicated process when the item type is a union type).\n> \n> It would be very unhelpful to have these values interpreted as strings\n> when they're obviously dates. I think that, at least with anonymous\n> simple types, it would be more helpful to use the base type of the\n> anonymous simple type than xs:anySimpleType. Perhaps anonymous complex\n> types could be treated similarly, although that case is more\n> complicated because of the different types of derivation that could\n> occur.\n> \n\nYou are right. At the time of the publication we took a very simple\napproach for handling restrictions of simple types: we just used\nxs:anySimpleType to label those. Since then, we have revisited this\ndecision and will likely do what you suggest: label these restrictions\nwith the name of the base type (if that has a name), or walk up the\ntype hierarchy till we find one that is named and use that.\n\nAlso note that the data model already handles list types.\nIf your example would just be a list of dates (rather than a list\nof restrictions of dates), the atomic values in the sequence would\nbe properly labeled with xs:date. So once we fix the algorithm\nof obtaining the type name of a subtype the whole example will be\nhandled properly.\n\n> \n> One thing that caused me some confusion on my first read was the way\n> that the typed value of elements is created (Section 4.2). It appears\n> that if an element to have a complex type in the schema, then\n> dm:typed-value returns an error, unless it's declared with the complex\n> type xs:anyType, in which case dm:typed-value returns its string\n> value. The more I think about it, the more it makes sense, since\n> xs:anySimpleType is a subtype of xs:anyType, and for consistency with\n> the treatment of well-formed documents, but it might be worth a note\n> or a bit of rephrasing.\n\nI'll try to add some clarification to that section, and possibly\npoint out the reason you mention: for consistency with the treatment\nof well-formed documents.\n\n> \n> By the way, I think that the changes that have been made here have\n> addressed the issue I raised about whitespace normalization of element\n> values (Issue-0073: Whitespace normalization of the string-value of\n> elements with simple content).\n> \n> \n> There's a small typo in Section 5 Atomic Values. It says:\n> \n>  \"XML Schema simple types can be derived by list. Values\n>   corresponding to such types are represented by a sequence of atomic\n>   values whose type is the base type.\"\n> \n> Presumably you mean \"whose type is the item type\". The base type of a\n> list type (or a union type) is xs:anySimpleType.\n> \n\nThanks. I'll fix the typo.\n\n> \n> The schema from Appendix D isn't valid at the moment, because the\n> complex type part-type has an xs:attribute within an xs:sequence. It\n> should be:\n> \n>   <xs:complexType name=\"part-type\">\n>     <xs:sequence>\n>       <xs:element name=\"mfg\" type=\"xs:string\"/>\n>       <xs:element name=\"price\" type=\"xs:decimal\"/>\n>     </xs:sequence>\n>     <xs:attribute name=\"name\" type=\"part-name\"/>\n>   </xs:complexType>\n> \n\nRight. I'll move the attribute declaration outside sequence.\n\n> Even if it were valid, though, the instance document wouldn't be valid\n> against it. The instance document is:\n> \n> <?xml version=\"1.0\"?>\n> <p:part xmlns:p=\"http://www.example.com/PartSchema\"\n>         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n>         xsi:schemaLocation = \"http://www.example.com/PartSchema\n>                               http://www.example.com/PartSchema\"\n>         name=\"NB-401-nutbolt\">\n>   <p:mfg>Acme</p:mfg>\n>   <p:price>10.50</p:price>\n> </p:part>\n> \n> in which the mfg and price elements are in the\n> http://www.example.com/PartSchema namespace. However, these elements\n> are declared locally within the schema (in the complex type definition\n> above), which means, by default, that they should be in no namespace.\n> \n> You should either change the instance document so that the mfg and\n> price elements are in no namespace:\n> \n\nRight again! I'll make the change.\n\n> <?xml version=\"1.0\"?>\n> <p:part xmlns:p=\"http://www.example.com/PartSchema\"\n>         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n>         xsi:schemaLocation = \"http://www.example.com/PartSchema\n>                               http://www.example.com/PartSchema\"\n>         name=\"NB-401-nutbolt\">\n>   <mfg>Acme</mfg>\n>   <price>10.50</price>\n> </p:part>\n> \n> or add an elementFormDefault attribute with the value 'qualified' to\n> the xs:schema element in the schema:\n> \n> <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n>            targetNamespace=\"http://www.example.com/PartSchema\"\n>            xmlns=\"http://www.example.com/PartSchema\"\n>            elementFormDefault=\"qualified\">\n>   ...\n> </xs:schema>\n> \n> \n> I hope these comments are helpful.\n\nYes! Thank you very much!\n\n> \n> Cheers,\n> \n> Jeni\n> ---\n> Jeni Tennison\n> http://www.jenitennison.com/\n>\n\n\n\n"
        },
        {
            "subject": "RE: variable binding in XPath was: Comments on XPath (30th April",
            "content": "> If we remove the \"full\" for from XPath, then I agree that let \n> would be \n> needed. I don't want to give up the ability to access \n> intermediate context \n> nodes (as opposed to being restricted to the ends of the \n> spectrum, i.e. . \n> and current()).\n\nYes. The strongest use case for adding LET is that it would allow you to\nbind to the context node at each level of predicate nesting:\n\n   chapter[let $c := @id return section [starts-with(@id,$c)]]\n\nI don't like the syntax: it would be much nicer to write\n\n   chapter[$c; section [starts-with(@id,$c/@id)]]\n\nbut at least it gives the functionality.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "Re: variable binding in XPath was: Comments on XPath (30th April",
            "content": "> Yes. The strongest use case for adding LET is that it would allow you to\n> bind to the context node at each level of predicate nesting:\n> \n>    chapter[let $c := @id return section [starts-with(@id,$c)]]\n\n'course if you don't provide let then we'll end up telling people to\nabuse for instead...\n\n\nchapter[for $c in @id return section [starts-with(@id,$c)]]\n\nlet reads better but is only extra functionality if you want to bind to\na sequence of more than one item. I suspect that extra functionality\nwill be needed if (as in the current draft) sequence manipulation is \nan XPath rather than XSLT operation.\n\n\nDavid\n\n_____________________________________________________________________\nThis message has been checked for all known viruses by Star Internet\ndelivered through the MessageLabs Virus Scanning Service. For further\ninformation visit http://www.star.net.uk/stats.asp or alternatively call\nStar Internet for details on the Virus Scanning Service.\n\n\n\n"
        },
        {
            "subject": "Re: Data Model W",
            "content": "Hi Marton,\n\nThanks for getting back to me about my comments. Just to pick up on\none of them.\n\n> You are right. At the time of the publication we took a very simple\n> approach for handling restrictions of simple types: we just used\n> xs:anySimpleType to label those. Since then, we have revisited this\n> decision and will likely do what you suggest: label these\n> restrictions with the name of the base type (if that has a name), or\n> walk up the type hierarchy till we find one that is named and use\n> that.\n>\n> Also note that the data model already handles list types. If your\n> example would just be a list of dates (rather than a list of\n> restrictions of dates), the atomic values in the sequence would be\n> properly labeled with xs:date. So once we fix the algorithm of\n> obtaining the type name of a subtype the whole example will be\n> handled properly.\n\nThat sounds great. As you revisit this, here's another example (which\nI had posted to XML-Dev) that demonstrates a problem with lists of\nunion types:\n\nSay you have:\n\n<xs:simpleType name=\"commandType\">\n  <xs:restriction base=\"xs:token\">\n    <xs:enumeration value=\"moveto\" />\n    <xs:enumeration value=\"lineto\" />\n  </xs:restriction>\n</xs:simpleType>\n\n<xs:simpleType name=\"commandOrCoordType\">\n  <xs:union memberTypes=\"commandType xs:integer\" />\n</xs:simpleType>\n\nImagine a commandOrCoord attribute with type commandOrCoordType:\n\n  commandOrCoord=\"moveto\"\n\nIn the PSVI, the commandOrCoord attribute information item has a\nschema normalized value of \"moveto\", a type definition of\ncommandOrCoordType and a member type definition of commandType.\n\nIn the XQuery/XPath 2.0 data model, the attribute node has a type of\ncommandOrCoordType and a typed value with the value 'moveto' and the\ntype commandType. That's all fine, because you can get the type of the\nsingle value from the member type definition of the PSVI.\n\nNow consider:\n\n<xs:simpleType name=\"pathType\">\n  <xs:list itemType=\"commandOrCoordType\" />\n</xs:simpleType>\n\nand a path attribute with the type pathType:\n\n  path=\"moveto 100 300\n        lineto 200 400 300 300\"\n\nThe PSVI contains a path attribute information item with a schema\nnormalized value of \"moveto 100 300 lineto 200 400 300 300\", a type\ndefinition of pathType and no member type definition.\n\nTo satisfy its requirement that atomic values are always of atomic\ntypes, the XQuery/XPath 2.0 data model needs to translate this into an\nattribute node whose typed value is the sequence ('moveto', 100, 300,\n'lineto', 200, 400, 300, 300), with the 1st and 4th items being atomic\nvalues of the type commandType and the rest of the items being atomic\nvalues of the type xs:integer.\n\nI don't think that the current data model WD describes how you get\nfrom the schema normalized value and the type definition of pathType\nto the sequence of commandTypes and integers. I believe that it\nrequires a separate invocation of the schema validator to work out the\nmember type of the items in the sequence, since the information about\nthe types of individual values isn't present in the PSVI.\n\nCheers,\n\nJeni\n\n---\nJeni Tennison\nhttp://www.jenitennison.com/\n\n\n\n"
        },
        {
            "subject": "Re: variable binding in XPath was: Comments on XPath (30th April",
            "content": "Mike wrote:\n> Yes. The strongest use case for adding LET is that it would allow\n> you to bind to the context node at each level of predicate nesting:\n>\n>    chapter[let $c := @id return section [starts-with(@id,$c)]]\n\nYes, that's very very useful. I agree with David -- adding let would\nallow you to get rid of specialised range variables and provide useful\nfunctionality on the XPath side without forcing people to write\nuser-defined functions to achieve their goals. It's essential if you\ndon't allow sequence generation with XSLT, and I think it makes a good\nbalance in either case.\n\n> I don't like the syntax: it would be much nicer to write\n>\n>    chapter[$c; section [starts-with(@id,$c/@id)]]\n>\n> but at least it gives the functionality.\n\nI like the shorter syntax (assuming that it would support assignment\nto any expression, not just the context node (though the shorthand for\nthe context node would be lovely)). Like David, I would favour an\nsymbolic infix operator for the foreach expression too (e.g. '=>' or\n'->') because of the parallel with the '/' operator. But with the\namount of code we're looking at being tucked up in an XPath, keywords\ndefinitely make things a lot clearer.\n\nCheers,\n\nJeni\n\n---\nJeni Tennison\nhttp://www.jenitennison.com/\n\n\n\n"
        },
        {
            "subject": "tokenize neede",
            "content": "This is simply a vote for Issue 143 in Functions and Operators: a \ntokenize function is badly needed in XSLT.\n\nIn particular: As far as I can see, there is no other way to deal with \nspace delimited content (? la XML Schema list types) in the absence of a \nschema.\n\n/dan\n-- \nDan Holmsand\nIB\ndan@eyebee.com\n\n\n\n"
        },
        {
            "subject": "RE: tokenize neede",
            "content": "> This is simply a vote for Issue 143 in Functions and Operators: a \n> tokenize function is badly needed in XSLT.\n> \n> In particular: As far as I can see, there is no other way to \n> deal with \n> space delimited content (? la XML Schema list types) in the \n> absence of a schema.\n> \nI agree we do need the ability to tokenize a string. I'm working on a\nproposal for regular expression handling (it's now on its third iteration)\nwhich will meet this requirement, although it might be a little heavyweight\nfor simple splitting of a space-delimited string. We could look at providing\na convenience function to make easy cases easy.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "Re: tokenize neede",
            "content": "Hi Michael,\n\nKay, Michael wrote:\n> I agree we do need the ability to tokenize a string. I'm working on a\n> proposal for regular expression handling (it's now on its third iteration)\n> which will meet this requirement, although it might be a little heavyweight\n> for simple splitting of a space-delimited string. We could look at providing\n> a convenience function to make easy cases easy.\n\nGreat! Regexp matching/replacing could be useful.\n\nI would love a convenience function, though (preferably working as \njava's StringTokenizer does by default). Regexps inside xpaths inside \nxml might become a bit hairy, syntax wise...\n\n/dan\n\n\n\n"
        },
        {
            "subject": "nodeid in XPath and Xquery document",
            "content": "The  word \"nodeid\" appears in two places (not in bold and not defined)\n\n2.3 Path Expressions\n... after elimination of duplicates based on nodeid.\n\n2.4.2 Combining Sequences\n... without duplicates based based on nodeid.\n\n\nI think this should be spelled as \"node identity\" and  explictly defined\nwith reference to the data model function  dm:node-equal (or\nequivalently the XPath \"is\" operator).\n\nIn fact given that document order + removal of duplicates is such an\nimportant link connecting XPath 2 sequences with XPath 1 node sets, I\nthink probably (at least in the XPath version of the document) it merits\na subsection of its own somewhere in the introductory sections.\n\nDavid\n\n\n_____________________________________________________________________\nThis message has been checked for all known viruses by Star Internet\ndelivered through the MessageLabs Virus Scanning Service. For further\ninformation visit http://www.star.net.uk/stats.asp or alternatively call\nStar Internet for details on the Virus Scanning Service.\n\n\n\n"
        },
        {
            "subject": "Re: Use Cases WD: Status of this documen",
            "content": "At 05:19 AM 10/21/2002 -0400, Svgdeveloper@aol.com wrote:\n\n>In line 1 I suggest you replace \"W3C XML Requirements\" with \"W3C XML Query\n>Language Requirements\" or something similar.\n\nThanks. I fixed that in my working copy.\n\nJonathan\n\n\n\n"
        },
        {
            "subject": "Re: Use Cases: 1.1.9.1 Solution Error",
            "content": "At 05:22 AM 10/21/2002 -0400, Svgdeveloper@aol.com wrote:\n\n>In the XQuery Solution to Q1 it seems to me that the content of the\n>parentheses of the document() function is in error.\n\nWell, it's not really in error - a URL can certainly resolve to an XML \ndocument.\n\n>I suggest you add /bib.xml to the current content.\n\nThis is clearer. I heard from one other person who had the same issue, so \nI'm making the change you suggest. I won't respond separately to the \nmessages where you mention the same issue for other examples.\n\nJonathan\n\n\n\n"
        },
        {
            "subject": "Re: Use Cases: 1.1.9.5 Q5 Solution Errors",
            "content": "At 05:52 AM 10/21/2002 -0400, Svgdeveloper@aol.com wrote:\n>In the content of the two document() functions in the Solution to Q5 the HTTP\n>protocol is not mentioned.\n>\n>Is the \"http://\" not necessary to make this query work correctly?\n\nHi Andrew,\n\nI'm adding \"http://\" to these examples.\n\nThanks!\n\nJonathan\n\n\n\n"
        },
        {
            "subject": "Re: Use Cases: 1.1.9.1",
            "content": "At 06:27 AM 10/21/2002 -0400, Svgdeveloper@aol.com wrote:\n\n>The content of the document() function in the Solution to Q10 points to a\n>document on the bn.com site. Should it not reference the prices.xml document?\n\nThanks, Andrew, I just fixed that.\n\nJonathan\n\n\n\n"
        },
        {
            "subject": "Re: Use Cases: 1.2 Inconsistenc",
            "content": "At 06:43 AM 10/21/2002 -0400, Svgdeveloper@aol.com wrote:\n\n>In 1.2.2 reference is made to a file called \"book.xml\".\n>\n>The Solution to Q1 in 1.2.4 references \"book1.xml\" in the document()\n>function.\n>\n>I suggest these be made consistent.\n\nThanks, I called it \"book.xml\" in both places now.\n\n>For tidiness it might also be useful to name the DTD in 1.2.2 since it is\n>referenced in 1.2.3.\n\nOK, thanks.\n\nJonathan\n\n\n\n"
        },
        {
            "subject": "Re: Use Cases 1.4.4  Inconsistency and Typ",
            "content": "At 07:57 AM 10/21/2002 -0400, Svgdeveloper@aol.com wrote:\n\n>In 1.4.4 it is stated, \"The following results assume that the queries were\n>executed on Feb. 1,1999.\".\n>\n>However, Q8 relates to sales in March 1999 which would be rather difficult to\n>estimate on 1st February 1999.\n>\n>A similar inconsistency arises with respect to Question 9 which relates to\n>several months in 1999 after February.\n\nOK, I'll change the date from Feb 1, 1999 to Jan 1, 2000.\n\n>Is there a typo in the first line of 1.4.4.8 Q8? Should \"actioned\" read\n>\"auctioned\"?\n\nThe term \"actioned\" is defined as \"auction ended\" in this text. It's not a \ntypo.\n\nJonathan\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0 : 3.2.4 Bulleted list typ",
            "content": "Thanks for the suggestion, Andrew. I'll make this change in the next \nedition.\n--Don Chamberlin\n\n---------- original message -------------\nDate: Thu, 24 Oct 2002 16:10:41 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <1c6.9127cb.2ae9ad9e@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 : 3.2.4 Bulleted list typo\n\nIn the bullet point with text, \"//list/member selects all the member \nelements \nin the same document as the context node that have an list parent\", \nreplace \n\"an list\" with \"a list\".\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0  2.5.2.1 / 2.5.2.2 Inconsistency",
            "content": "A Basic XQuery implementation that does not support the Schema Import \nFeature does not accept schema imports. If it encounters one, it raises a \nstatic error. The Schema Import Feature relaxes this limitation. If an \nimplementation that supports the Schema Import Feature encounters a schema \nimport, it processes it instead of raising a static error.\n--Don Chamberlin\n\n-------- original message ---------\nDate: Thu, 24 Oct 2002 10:49:09 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <25.2fbf0ebe.2ae96256@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 - 2.5.2.1 / 2.5.2.2 Inconsistency?\n\nI am having trouble reconciling numbered point 1. in 2.5.2.1 with the \nfirst \nsentence of 2.5.2.2.\n\nIf numbered point 1. is correct I don't see how 2.5.2.2 alleviates the \nproblem.\n\nI am assuming that a SchemaImport (no space) and Schema Import (with an \nintervening space) refer to the same concept/process. It might help if \nthis \nterm / these terms were linked to relevant further explanation.\n\nPerhaps there is some additional explanation that can reconcile the \nseeming \ninconsistency?\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0  2.",
            "content": "Andrew,\nIn my opinion this passage is reasonably clear as written.\n--Don Chamberlin\n \n-----original message-----\n\nDate: Mon, 21 Oct 2002 04:49:07 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <117.1977e036.2ae5195f@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 - 2.3\n\nIn paragraph 5 line 1 of 2.3 we read, \"The value of an element is \nrepresented \nby the children of the element node, which may include text nodes and \nother \nelement nodes.\".\n\nShould \"an element\" be \"an element node\"?\n\nShould \"children\" be \"descendants\"?\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0 : 3.2.1.1 / 3.2.1.2 Inconsistenc",
            "content": "Thanks for the suggestion, Andrew. I'll fix this in the next edition.\n--Don Chamberlin\n\n---------- original message ----------\n\nDate: Thu, 24 Oct 2002 15:50:15 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <48.13d98019.2ae9a8e7@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 : 3.2.1.1 / 3.2.1.2 Inconsistency\n\n3.2.1.1 lists the axes which XQuery 1.0 supports. No mention is made of \nthe \nnamespace axis.\n\n3.2.1.2 indicates, in the bulleted list, the principal node type of the \nnamespace axis.\n\nIt seems to me that some editing is needed.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0 : 3.2.1.2 &quot;expandedname&quot",
            "content": "Thanks for the suggestion, Andrew. I'll make this change in the next \nedition.\n--Don Chamberlin\n\n-------------- original message ----------\nDate: Thu, 24 Oct 2002 15:54:29 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <42.2fb0cb52.2ae9a9c9@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 : 3.2.1.2 \"expanded-name\"\n\nIn 3.2.1.2 the term \"expanded-name\" is used several times. For consistency \n\nwith Data Model should this be \"expanded-QName\"?\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0 : 3.2.3 Bullet points Typ",
            "content": "Thanks for the suggestion, Andrew. I'll make this change in the next \nedition.\n--Don Chamberlin\n\n------------ original message -------------\nDate: Thu, 24 Oct 2002 16:00:55 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <70.252f4442.2ae9ab64@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 : 3.2.3 Bullet points Typo\n\nIn the bullet point with text, \"/descendant::list/child::member selects \nall \nthe member elements that have an list parent and that are in the same \ndocument as the context node\" replace \"an list\" with \"a list\".\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0  3.2.4 Bulleted list erro",
            "content": "Thanks for the suggestion, Andrew. I'll fix this in the next edition.\n--Don Chamberlin\n\n-------- original message ----------\nDate: Thu, 24 Oct 2002 16:12:09 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <9f.2f4ce9c9.2ae9adfe@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 - 3.2.4 Bulleted list error\n\nThe bullet point with text, \". selects the context node\" is in error. The \nabbreviated syntax . now selects the context item not the context node, as \n\nstated.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0  2.4 &quot;node kinds of XML&quot",
            "content": "Thanks, Andrew. I'll fix this in the next edition.\n--Don Chamberlin\n\n---------original message-----------\n\nFrom: Svgdeveloper@aol.com\nMessage-ID: <10c.18b52cfe.2acaeea7@aol.com>\nDate: Tue, 1 Oct 2002 08:27:19 EDT\nTo: public-qt-comments@w3.org\nCC: mf@w3.org, massimo@w3.org\nSubject: XQuery 1.0 - 2.4 \"node kinds of XML\"\n\nIn 2.4 the phrase \"node kinds of XML\" is used.\n\nTo the best of my knowledge \"XML\" has no \"node kinds\". I suggest some \nrephrasing.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0  2.3 &quot;open issue&quot",
            "content": "Andrew,\nI don't believe there's an issue number for this. I'll reword the \nsentence.\n--Don Chamberlin\n\n------ original message --------\nDate: Mon, 21 Oct 2002 04:39:43 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <32.2eec0ec8.2ae5172b@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 - 2.3 \"open issue\"\n\nIn the penultimate paragraph of 2.3 it is stated, \"Transformation of a \nData \nModel instance into an XML document is currently an open issue.\".\n\nIt would be convenient for cross-reference if the Issue number were given.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0  2.",
            "content": "I believe this passage is adequate as written.\n--Don Chamberlin\n\n--------- original message -----------\nDate: Wed, 23 Oct 2002 16:07:08 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <b9.28e39955.2ae85b69@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 - 2.3\n\nIn the second paragraph of text after the numbered list an example is \ngiven \nwhereby a version attribute may have type xsd:decimal.\n\nSince a decimal may be negative perhaps a type more specifically suitable \nto \na version number could be used?\n\nIf that change is made I assume it also needs to be made in XPath 2.0.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0  2.",
            "content": "OK, I'll make this change in the next edition.\n--Don Chamberlin\n\n--------- original message ----------\n\nDate: Mon, 21 Oct 2002 04:50:19 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <1bc.118540da.2ae519a6@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 - 2.2\n\nIn 2.2 paragraph 5, line 1 it is stated that the document() function \nreturns \nthe \"root\". Given the change of terminology in XPath 2.0 would it not be \nclearer to indicate that the \"document node\" was returned?\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0  2.3.2 xsd:anySimpleType /   xsd:Strin",
            "content": "Andrew,\nanySimpleType is not the same as string. For example, arithmetic can be \nperformed on values of anySimpleType, but it cannot be performed on \nstrings.\n--Don Chamberlin\n\n---- original message ------\nDate: Wed, 23 Oct 2002 16:31:37 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <a6.2e84ae71.2ae860ff@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 - 2.3.2 xsd:anySimpleType /  xsd:String\n\nIn numbered point 1. in 2.3.2 I wondered why the type is xsd:anySimpleType \n\nrather than xsd:String.\n\nIf it is a text node, then isn't it xsd:String?\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0  2.3.2 What is &quot;content&quot; of an   element node",
            "content": "This passage talks about nodes whose content is defined by an expression. \nThe meaning here is that the given expression was used in the element \nconstructor that created the node.\n--Don Chamberlin\n\n----- original message ----------\nDate: Wed, 23 Oct 2002 16:46:02 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <80.236c5fe8.2ae86458@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 - 2.3.2 What is \"content\" of an  element node?\n\nIn the first example in numbered point 3. in 2.3.2 reference is made to \nthe \n\"content\" of an element node.\n\nI guess this question relates to my comment on the XSLT 2.0 spec. but I am \n\nunclear what the \"content\" of an element node is. ... I think I am clear \nabout what the content of an element in a serialized XML document is, but \nI \ndon't understand the term content as applied to an element node.\n\nI notice that the term content is not defined in any of the glossaries in \nthe \nvarious specifications.\n\nSo, what is the \"content\" of an element node? How does it differ, if at \nall, \nfrom the nodes which might result from parsing the content of the XML \ndocument which has, perhaps, been parsed to construct the element node? \nHow \nis such \"content\" serialized if it isn't synonymous with the child / \ndescendant nodes of the element node?\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0  2.2 &quot;Collection&quot",
            "content": "Andrew,\nIn my opinion, this passage is reasonably clear as written.\n--Don Chamberlin\n\n---------- original message ---------\nDate: Wed, 23 Oct 2002 15:57:23 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <171.15fc62ad.2ae85900@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 - 2.2 \"Collection\"\n\nThe description in 2.2 of the xf:collection function is confusing, to me \nat \nleast.\n\nA collection is said to be any sequence of nodes but a sequence is defined \n\nelsewhere as a collection of both nodes and atomic values. So, by that \nlatter \ndefinition it isn't that kind of sequence at all.\n\nAlso it doesn't seem helpful to define a collection by using a term which \nis \nitself defined in terms of an (ordered) collection.\n\nA similar lack of clarity/consistency seems to afflict 14.5.4 in Functions \n\nand Operators.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0 : 3.2 Typ",
            "content": "Thanks for the suggestion, Andrew. I'll fix this in the next edition.\n--Don Chamberlin\n\n-------- original message --------\nDate: Thu, 24 Oct 2002 15:35:06 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <130.167d9647.2ae9a540@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 : 3.2 Typo\n\nIn the third last line of 3.2 \"descendant-or-self:node\" should read \n\"descendant-or-self::node\". In other words there is a single colon where \nthere should be a pair.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 2.3.2  Example (E2",
            "content": "Thanks for the suggestion. I'll fix this in the next edition.\n--Don Chamberlin\n\n----  original message -----\n\nDate: Mon, 21 Oct 2002 04:38:19 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <c.78a208.2ae516f0@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 2.3.2 - Example (E2)\n\nIn the Example which refers to \"E2\" it is indicated that a list is a \n\"complex \ntype\".\n\nIsn't a list a simple type?\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XPath 2.0 - 2.1.2  self::node() and ",
            "content": "Andrew,\nThe meaning of \".\" is defined in the section on Abbreviated Syntax. I am \nnot aware of any change in the meaning of self::node().\n--Don Chamberlin\n\n-------- original message --------\n\nDate: Wed, 23 Oct 2002 15:46:17 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <1ac.ac358dd.2ae85686@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XPath 2.0 - 2.1.2 - self::node() and .\n\nIn 2.1.2 of XPath 2.0 the context item is defined. Michael Kay's response \nto \na query I had about XSLT 2.0 indicates a change in meaning of self::node() \n\nand . in XPath 2.0.\n\nIt seems to me that that change is not mentioned in XPath 2.0 but ought to \n\nbe. Chapter 2.1.2 seems an appropriate place to express the change.\n\nAn equivalent change would need to be made in XQuery 1.0 spec too.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "XQuery 1.0  2.3 Transformation / Serialization",
            "content": "Thanks for the suggestion, Andrew.  I'll fix this in the next edition.\n--Don Chamberlin\n\n----------- original message ------------\n\nDate: Wed, 23 Oct 2002 16:11:47 -0400 (EDT)\nFrom: Svgdeveloper@aol.com\nMessage-ID: <122.195ba403.2ae85c5b@aol.com>\nTo: public-qt-comments@w3.org\nSubject: XQuery 1.0 - 2.3 Transformation / Serialization?\n\nIn 2.3 the following sentence is found: \"Transformation of a Data Model \ninstance into an XML document is currently an open issue.\".\n\nWhere the term \"Transformation\" is used is \"Serialization\" intended? Using \n\nthe term transformation seems inappropriate since XPath 2.0 is referenced \nby \nXSLT 2.0.\n\nI assume an equivalent change needs to be made in XPath 2.0.\n\nAndrew Watt\n\n\n\n"
        },
        {
            "subject": "F&amp;O Problems with patterns for duration type",
            "content": "Hi,\n\nIn F&O sections 8.2.1 and 8.2.2, the patterns for yearMonthDuration and\ndayTimeDuration have two problems.  The dashes that appear within square\nbrackets should be escaped, as per XML Schema Errata E2-18.   Also, the\nnumbers should be represented as [0-9] rather than \\p{Nd} as per XML\nSchema Errata E2-23.\n\nThanks,\nPriscilla\n\n-----------------------------------------------------\nPriscilla Walmsley             priscilla@walmsley.com\nhttp://www.priscilla.walmsley.com\n----------------------------------------------------- \n\n\n\n"
        },
        {
            "subject": "XQuery 1.0 Overriding prolog default namespace",
            "content": "Hi,\n\nThe XQuery 1.0 WD (section 4.1) says that namespace declarations that\nappear in element constructors are added to the in-scope namespaces.\nIt's clear what this means for namespace declarations with prefixes.  \n\nIt's not so clear (at least to me!) what this means for default\nnamespace declarations.   The definition of \"in-scope namespaces\"\nappears to specifically be referring to resolving prefixes, and it is\nlisted as a separate component of the expression context from the\n\"Default namespace for element and type names\" and the \"Default\nnamespace for function names\".\n\nSo, my question is, do default namespace declarations in element\nconstructors override these two default namespaces (declared in the\nprolog)?  Both of them, or just the element/type one?  \n\nI think the rec could use some clarification.  \n\nThanks,\nPriscilla\n\n-----------------------------------------------------\nPriscilla Walmsley             priscilla@walmsley.com\nhttp://www.priscilla.walmsley.com\n----------------------------------------------------- \n\n\n\n"
        },
        {
            "subject": "F&amp;O duration types allow positive vs. unsigned  integer",
            "content": "Hi,\n\nIn F&O sections 8.2.1.1 and 8.2.2.1, the lexical representations for\nyearMonthDuration and dayTimeDuration say they allow any \"positive\ninteger\" for the values of the components.  This should be \"unsigned\ninteger\" since zero is allowed (and signs are not.)  This is consistent\nwith XML Schema Errata E2-23.\n\nThanks,\nPriscilla\n\n-----------------------------------------------------\nPriscilla Walmsley             priscilla@walmsley.com\nhttp://www.priscilla.walmsley.com\n----------------------------------------------------- \n\n\n\n"
        },
        {
            "subject": "RE: F&amp;O duration types allow positive vs. unsigned  integer",
            "content": "Fixed!  Thanks!\nAlso fixed the typos you pointed out in your note of 08/20. \n\nAll the best, Ashok\n\n-----Original Message-----\nFrom: Priscilla Walmsley [mailto:priscilla@walmsley.com] \nSent: Tuesday, November 05, 2002 9:01 AM\nTo: public-qt-comments@w3.org\nSubject: F&O duration types allow positive vs. unsigned integers\n\n\n\n\n\nHi,\n\nIn F&O sections 8.2.1.1 and 8.2.2.1, the lexical representations for\nyearMonthDuration and dayTimeDuration say they allow any \"positive\ninteger\" for the values of the components.  This should be \"unsigned\ninteger\" since zero is allowed (and signs are not.)  This is consistent\nwith XML Schema Errata E2-23.\n\nThanks,\nPriscilla\n\n-----------------------------------------------------\nPriscilla Walmsley             priscilla@walmsley.com\nhttp://www.priscilla.walmsley.com\n----------------------------------------------------- \n\n\n\n"
        },
        {
            "subject": "F&amp;O absence of T designator in duration value",
            "content": "Hi,\n\nIn F&O section 8.2.2.1, it says \"The designator 'T' must be absent if\nall of the time items are absent.\"  This should say \"if and only if\",\nwhich is consistent with XML Schema Errata E2-24.\n\nThanks,\nPriscilla\n\n-----------------------------------------------------\nPriscilla Walmsley             priscilla@walmsley.com\nhttp://www.priscilla.walmsley.com\n-----------------------------------------------------  \n\n\n\n"
        },
        {
            "subject": "F&amp;O examples missing seconds portion of tim",
            "content": "Hi,\n\nIn F&O, section 8.6, all of the examples in this section are missing the\nseconds portion of the time values (in both the constructors and the\nreturn values).\n\nThanks,\nPriscilla\n\n-----------------------------------------------------\nPriscilla Walmsley             priscilla@walmsley.com\nhttp://www.priscilla.walmsley.com\n----------------------------------------------------- \n\n\n\n"
        },
        {
            "subject": "changing final output while writing temporary tre",
            "content": "Hi,\n\nI would like to make a case for the removal of the restriction imposed on \nthe result-document instruction when writing to a temporary result tree.\n\nThe proposal states:\n\n[ERR146] It is a dynamic error to evaluate the xsl:result-document \ninstruction when the current destination node is not a node belonging to a \nresult tree (for example, when it is a node belonging to a temporary tree). \nThe processor must signal the error. . This means, for example, that it is \nan error to use xsl:result-document when the tree containing the current \ndestination node is a temporary tree created using xsl:variable, or a tree \ncreated using xsl:message, xsl:attribute, etc\n\nand, as I understand, the issue that brought this restriction was related \nto limiting side-effects and a typical case was stated as:\n\nBut let's take a global variable\n\n<xsl:variable name=\"x\">\n   <xsl:result-document ...>\n     <a/>\n   </\n</\n\nThe variable is never referenced. Should the result document be output, or \nnot?\n\nThere are a few alternatives to answer this question, but restricting \nresult-document is not the right one because it is much to restrictive.\nIn fact it blocks recursion for serialization of documents which I would \nthink is one of the last things to do in a functional environment.\n\nXSLT is functional programming and functional programming is recursion for \nrecursive structures. Blocking recursion is defeating the main purpose.\n\nHere is a brief summary of the issue.\n\nFirst a trivial example where a \"Cannot switch to a final result \ndestination while writing a temporary tree\" error on the line marked with \nan x is generated when the processor (ex: Saxon v7.3.1 reaches the \nrecursive call to 'publish' and executes the 'make-page' template from there.\n\n<xsl:output name=\"outputf-format\" .../>\n\n<xsl:template name=\"make-page\">\n         <xsl:param name=\"src-nodeset\"/>\n         <xsl:param name=\"fname\"/>\nx       <xsl:result-document format=\"output-format\" href=\"{$fname}\">\n                 ...\n                 <xsl:copy-of select=\"$src-nodeset\"/>\n                 ...\n         </xsl:result-document>\n</xsl:template>\n\n<xsl:template name=\"publish\">\n         <xsl:param name=\"src-nodeset\"/>\n         <xsl:for-each select=\"$src-nodeset/section\">\n                 ...\n                 <xsl:call-template name=\"make-page\">\n                         <xsl:with-param name=\"fname\" select=\"@id\"/>\n                         <xsl:with-param name=\"src-nodeset\">\n                                 ...\n                                 <xsl:for-each select=\"sub-section-group\">\n                                         <xsl:call-template name=\"publish\">\n                                                 <xsl:with-param \nname=\"src-nodeset\" select=\".\"/>\n                                         </xsl:call-template>\n                                 </xsl:for-each>\n                         </xsl:with-param>\n                 </xsl:call-template>\n         <xsl:for-each>\n</xsl:template>\n\nWriting a secondary document is not a side effect, it is simply dealing \nwith (serializing to) the real world where information is mapped to finite \nflat files like web pages.\nIt seems to us like a major impediment if a style sheet is limited to \noutputting a single page at a time, without recursion.\n\nWe have here an application with 10 to 20K lines of XSLT, processing \nmillions of lines of streaming and static XML into infinitely complex \ndocuments for printed and interactive access.  There are many issues \ninvolved and performance is one of them.  One of the keys is to stream and \nprocess graphs and structures efficiently.  Recursion and not having to \nreprocess the same (often very large) structures iteratively is crucial.\n\nSo as one traverses such structures, gathering data and building a page, \nand one finds information there that warrants a sub page (and so on \nrecursively), one needs to also produce those pages.  With the current \nrestriction, the only alternative is to iteratively process and reprocess \nthe structure(s), building multiple temporary trees and variables, \nrecalculating values and node sets until the full depth of the \nstructure(s)I has been reached and all sub-pages at all levels of the \nrecurring structure have been generated. This is using iteration to deal \nwith recursion.  It is not only (very) inefficient and awkward (and not \nstreamable), it is plain ugly.\n\nThe example code here was purposely simple to show where the error message \noccurred but we do have real world examples and they are far more \nintricate.  This feature is required by a few major modules in our \napplication (ex: publishing, O-R mapping, invoicing, etc.).  We built this \napplication with Saxon v6.5.2 that complied to the XSLT 1.1  draft which \ndefined a \"document\" instruction that did not have this restriction on \nchanging the final output document while writing to a temporary tree.\n\nOur application works fine with Saxon v6.5.2 (XSLT v1.1) but cannot be \nported to Saxon 7.3.1 (XSLT v2.0) for this single reason.\nThis is a major limitation to us.  But we also feel that it is a major \nlimitation for XSLT.\n\nOf course side-effects should be avoided but preventing recursion (for \nserialisation) is not the right way, because the cost is to high and out \nweights the benefits.\n\nAs for the unused global variable with a result-document in the initial \nexample above, I tend to believe that if the variable is unused, the \ndocument should probably not be output and the processor should probably \nsignal that the variable is not used (and (possibly) that the document will \nnot be output).  Other solutions could also be acceptable to us, including \noutputting the document anyway or even, as was suggested, that the document \nbe output only if the temporary tree gets copied to the final result tree.\n\nWe would be happy to contribute in any way on the resolution of this issue \n(changing final output while writing a temporary tree) so do not hesitate \nto contact us.\n\nThank you.\nRegards,\nAndre Cusson\nac@hyperbase.com\nTel: (1) 514 984 1601\n01 Communications Inc.\n11840 Norwood Avenue\nMontreal, QC, H3L 3H7\n\n\n\n"
        },
        {
            "subject": "Re: XQuery: Ambiguous expression using &quot;context&quot",
            "content": "Hi Twan.  Thank you for the report.\n\npublic-qt-comments-request@w3.org wrote on 01/23/2003 11:19:48 AM:\n>      if (A) then B instance of element C context type else/D\n> According to precedence rules, should be interpreted the same as:\n>      if (A) then (B instance of element C context type else/D)\n> However, this is not a valid expression, since there is no 'else' in if\n> expression.\n\nRight, and neither is the first one.  The lex rules (admitting that there\nwere some massive bugs in the lex tables in the last public draft)\ndetermine that \"else\" occurs in a position where a QName is expected, as\nopposed to the keyword \"else\" expected in the OPERATOR state.\n\nThe following parses fine, and as expected:\n\nif (A) then B instance of element C context type else/D else /D\n\nSo, at least in the current draft (as opposed to the last public draft), I\ndon't see any problem.\n\nAlso double-checked that your:\n\n>      if (A) then (B instance of element C context type) else (/D)\n\nParses OK.  It does.\n\nNote there are some ambiguity bugs with Sequence type for keywords vs.\nQNames, such as \"element\" etc.  We're working on a solution for this.\n\nThank you again for your feedback!\n\n-scott\n\n\n\n"
        },
        {
            "subject": "RE: changing final output while writing temporary tre",
            "content": "I think that the mental model we have used for multiple result trees is that\nthere is conceptually one combined tree, and that the actual result trees\nall have to be subtrees of this combined tree. The stylesheet logic for\nwriting multiple result documents is therefore exactly the same as you would\nwrite if you were generating the combined tree. If you can write the logic\nto produce the combined tree, then it is trivial to modify it to produce\nmultiple trees. What the facility for multiple result trees does not do is\nto free you from the need to produce output in \"result tree order\" - that\nis, the order of instructions in the stylesheet reflects the order of nodes\nwritten to the result.\n\nIts true that the restriction on when xsl:result-document can be used\nappears somewhat draconian, and the problem it is solving seems rather small\nin comparison. Arguably, we are applying the \"no-side-effects\" philosophy of\nthe language rather strictly in this case. I'm sure we could relax the rules\nby leaving some edge cases implementation defined, but on the whole we have\nbeen reluctant to do that.\n\nWe did have a different solution to this problem in earlier drafts, but it\nrequired extra information in the data model and was very hard to\nunderstand. It still imposed substantial restrictions. The model was that a\nresult document was effectively a child node attached to some other tree,\ninvisible to XPath expressions, but still linked in the sense that the tree\nwas written out only if and when the parent node was written to a result\ntree.\n\nWe spent some time debating this and I'm reluctant to re-open it. Rather,\nI'd like to see whether we can use your problem as a test case to see\nwhether the existing language is up to solving the problem. In the example\nyou show, I find it very hard to understand why you are trying to produce a\nresult document as a side-effect of calculating a parameter to a named\ntemplate. It seems a very odd way to do things, though I'm sure it makes\nsense to you.\n\nMichael Kay\n\n\n\n> -----Original Message-----\n> From: Andre Cusson [mailto:ac@hyperbase.com] \n> Sent: 26 January 2003 20:47\n> To: public-qt-comments@w3.org\n> Cc: michael.h.kay@ntlworld.com; saxon-help@lists.sourceforge.net\n> Subject: changing final output while writing temporary tree\n> \n> \n> \n> Hi,\n> \n> I would like to make a case for the removal of the \n> restriction imposed on \n> the result-document instruction when writing to a temporary \n> result tree.\n> \n> The proposal states:\n> \n> [ERR146] It is a dynamic error to evaluate the xsl:result-document \n> instruction when the current destination node is not a node \n> belonging to a \n> result tree (for example, when it is a node belonging to a \n> temporary tree). \n> The processor must signal the error. . This means, for \n> example, that it is \n> an error to use xsl:result-document when the tree containing \n> the current \n> destination node is a temporary tree created using \n> xsl:variable, or a tree \n> created using xsl:message, xsl:attribute, etc\n> \n> and, as I understand, the issue that brought this restriction \n> was related \n> to limiting side-effects and a typical case was stated as:\n> \n> But let's take a global variable\n> \n> <xsl:variable name=\"x\">\n>    <xsl:result-document ...>\n>      <a/>\n>    </\n> </\n> \n> The variable is never referenced. Should the result document \n> be output, or \n> not?\n> \n> There are a few alternatives to answer this question, but restricting \n> result-document is not the right one because it is much to \n> restrictive. In fact it blocks recursion for serialization of \n> documents which I would \n> think is one of the last things to do in a functional environment.\n> \n> XSLT is functional programming and functional programming is \n> recursion for \n> recursive structures. Blocking recursion is defeating the \n> main purpose.\n> \n> Here is a brief summary of the issue.\n> \n> First a trivial example where a \"Cannot switch to a final result \n> destination while writing a temporary tree\" error on the line \n> marked with \n> an x is generated when the processor (ex: Saxon v7.3.1 reaches the \n> recursive call to 'publish' and executes the 'make-page' \n> template from there.\n> \n> <xsl:output name=\"outputf-format\" .../>\n> \n> <xsl:template name=\"make-page\">\n>          <xsl:param name=\"src-nodeset\"/>\n>          <xsl:param name=\"fname\"/>\n> x       <xsl:result-document format=\"output-format\" href=\"{$fname}\">\n>                  ...\n>                  <xsl:copy-of select=\"$src-nodeset\"/>\n>                  ...\n>          </xsl:result-document>\n> </xsl:template>\n> \n> <xsl:template name=\"publish\">\n>          <xsl:param name=\"src-nodeset\"/>\n>          <xsl:for-each select=\"$src-nodeset/section\">\n>                  ...\n>                  <xsl:call-template name=\"make-page\">\n>                          <xsl:with-param name=\"fname\" select=\"@id\"/>\n>                          <xsl:with-param name=\"src-nodeset\">\n>                                  ...\n>                                  <xsl:for-each \n> select=\"sub-section-group\">\n>                                          <xsl:call-template \n> name=\"publish\">\n>                                                  <xsl:with-param \n> name=\"src-nodeset\" select=\".\"/>\n>                                          </xsl:call-template>\n>                                  </xsl:for-each>\n>                          </xsl:with-param>\n>                  </xsl:call-template>\n>          <xsl:for-each>\n> </xsl:template>\n> \n> Writing a secondary document is not a side effect, it is \n> simply dealing \n> with (serializing to) the real world where information is \n> mapped to finite \n> flat files like web pages.\n> It seems to us like a major impediment if a style sheet is limited to \n> outputting a single page at a time, without recursion.\n> \n> We have here an application with 10 to 20K lines of XSLT, processing \n> millions of lines of streaming and static XML into infinitely complex \n> documents for printed and interactive access.  There are many issues \n> involved and performance is one of them.  One of the keys is \n> to stream and \n> process graphs and structures efficiently.  Recursion and not \n> having to \n> reprocess the same (often very large) structures iteratively \n> is crucial.\n> \n> So as one traverses such structures, gathering data and \n> building a page, \n> and one finds information there that warrants a sub page (and so on \n> recursively), one needs to also produce those pages.  With \n> the current \n> restriction, the only alternative is to iteratively process \n> and reprocess \n> the structure(s), building multiple temporary trees and variables, \n> recalculating values and node sets until the full depth of the \n> structure(s)I has been reached and all sub-pages at all levels of the \n> recurring structure have been generated. This is using \n> iteration to deal \n> with recursion.  It is not only (very) inefficient and \n> awkward (and not \n> streamable), it is plain ugly.\n> \n> The example code here was purposely simple to show where the \n> error message \n> occurred but we do have real world examples and they are far more \n> intricate.  This feature is required by a few major modules in our \n> application (ex: publishing, O-R mapping, invoicing, etc.).  \n> We built this \n> application with Saxon v6.5.2 that complied to the XSLT 1.1  \n> draft which \n> defined a \"document\" instruction that did not have this \n> restriction on \n> changing the final output document while writing to a temporary tree.\n> \n> Our application works fine with Saxon v6.5.2 (XSLT v1.1) but \n> cannot be \n> ported to Saxon 7.3.1 (XSLT v2.0) for this single reason.\n> This is a major limitation to us.  But we also feel that it \n> is a major \n> limitation for XSLT.\n> \n> Of course side-effects should be avoided but preventing \n> recursion (for \n> serialisation) is not the right way, because the cost is to \n> high and out \n> weights the benefits.\n> \n> As for the unused global variable with a result-document in \n> the initial \n> example above, I tend to believe that if the variable is unused, the \n> document should probably not be output and the processor \n> should probably \n> signal that the variable is not used (and (possibly) that the \n> document will \n> not be output).  Other solutions could also be acceptable to \n> us, including \n> outputting the document anyway or even, as was suggested, \n> that the document \n> be output only if the temporary tree gets copied to the final \n> result tree.\n> \n> We would be happy to contribute in any way on the resolution \n> of this issue \n> (changing final output while writing a temporary tree) so do \n> not hesitate \n> to contact us.\n> \n> Thank you.\n> Regards,\n> Andre Cusson\n> ac@hyperbase.com\n> Tel: (1) 514 984 1601\n> 01 Communications Inc.\n> 11840 Norwood Avenue\n> Montreal, QC, H3L 3H7\n> \n> \n\n\n\n"
        },
        {
            "subject": "RE: changing final output while writing temporary tre",
            "content": "Hi,\n\nThank you again for your time and interest.\n\nI would like to sit down with you and show you what we are doing but since \nthat is not really possible now and since the code base is relatively large \n(and complex), I will try to describe some typical problems we are trying \nto solve, using result-document.  In essence, it is quite simple:\n\n1. The principle : a possibly large and complex source xml document that \nneeds to be traversed recursively and from which pages (ex: web pages) are \nto be published.\n\n2.. A publishing use case : I have a source XML document of , lets say 50 \nto 100K lines, describing the structured content of a scientific \ninformation web site, organized in volumes, sections, chapters, and pages \n(which are of course also organized into sections, sub-sections, \nparagraphs, etc).  Further, the page contents, gathered from the source \ndocument have to be merged with XML defined layouts that describe the page \nlayout.  Every time a page is to be published, the page-publish template is \ncalled and passed the corresponding contents.  It then merges the contents \ninto specified layout(s) and then serializes the page to html.  Note: this \nis again a simplified model of a section of the application, the publishing \nmodule.\n\nAs the publishing module is traversing the source document, it figures out \nwhat needs to be done and calls the page-publish template as \nrequired.  Many cases happen.  A typical one could be, for example, a test \npage, a page that offers a test to the user:  so we start building the page \ntree and doing all kinds of calculations for the page,  on this page we \nalso find information to build the answer page which uses a lot of the same \ndata so we build the answer page, publish it and go on with the publishing \nof the test page, building hyperlinks and navigation between the pages, and \nso on.  The only issue is that since we are traversing down a tree, the \nleaves get output first and the root, last.\n\n3. O-R mapping use case: Another example could come from our O-R mapping \ntool where we take a tree, any tree and map its contents to a series of \nhyperlinked editing forms, each with a table with the children (or a group \nof them) of a node and where each child that has children will require \nadditional sub-pages, and so on recursively. So, as I am building page 1, I \nfind that I also need to do pages 1a, 1b and 1c (all with bidirectional \nlinks (xpointers) between them).  Since everything is recursive, as I start \nbuilding page 1a, but now I find that I also have to build sub-pages 1a1, \n1a2 and 1a3 and so on.\n\nEvery time that I have a page ready, I publish it but, because of \nrecursion, bottom pages (tree leaves) get publish first and the root node \nis still being build at that time so the result-document instruction bombs out.\n\n\nThe way I see this, we are not using a side-effect, we are doing plain \nrecursive processing, with no tricks or anything twisted.  The fact that \nthere is a tree (final) in a tree (temporary) can hardly (or maybe \nacademically) be called a side-effect.  In my view and for the uses we have \nof this, a tree in a tree is recursion.  Is recursion a side effect ?\n\nNow, I don't doubt that some people may want to abuse recursion or the \nresult-document instruction and I believe that we should do everything \nreasonable to prevent these abuses, short of preventing the development of \nuseful applications.  Personally, the price to pay for side-effects is to \nhigh for me to toy with.  On the other hand, blocking recursion kills my \napplication.\n\nI am surprised that something so natural to (streaming) XSLT like \ntraversing a tree structure and building web pages as you go has not \nbrought up this issue before and I start to wonder, what are others doing \nwith XSLT?\n\nTheoretically, I could process the structure iteratively but I would loose \nperformance, maintainability and I would get sick looking at the code \nbecause of its ugliness and illogical structure.  Comparatively, \n(academical) side-effects are almost nice.\n\nEver since we found out about the new restriction, a few weeks ago, I have \nbeen trying to find a viable alternative but I have not yet.\nIf you can think or suggest me one, I will be happy to try it.\nIf we can't, XSLT 2.0 might run into a problem when people start using it \nto generate web pages as opposed to simply rendering them or building them \nfrom flat structures.\n\nFor now, and until a viable solution is found, the only way we can advance \nand deliver a product to our users is to stick to Saxon v6.5.2 and forget \nabout XSLT 2.0.\nIt is a very high price to pay in the long run but it may be better than \nloosing everything.\n\nI hope that the case is getting clearer and I will be happy to provide you \nwith additional information, try things out, talk on the phone or anything \nthat will help resolve this.\nI also hope that the mix of my passion and my frustration does not blur the \nissues.\n\nI thank you for everything and especially for your interest.\nPlease take care.\n\nRegards,\nAndre Cusson\nac@hyperbase.com\n01 Communications Inc.\n\nPS: Whether I invoke result-document while building a with-param tree or I \ndo it in a variable and then pass the variable as a parameter does not \nimprove the problem because now I have additional variables (which are \ntemporary trees also) and more \"non streamable\" steps, but I still need to \nrecursively generate pages (from temporary trees).\n\nRecursion is designed to handle problems that are cannot (easily) be solved \notherwise and it seems to me that generating html pages from traversing a \nhierarchical structure is one of them.\n\nI am very sorry that the committee might already have spent serious \nresources debating (complex) output tree issues and that I am trying to \nstir things up again but the way I see it, either I am wrong and there is a \nbetter way to do this and I will be happy and I will grow as a programmer \nif I can find/learn it, or I am right and it is in XSLT's best interest to \nrevisit the issue.  Consequently, If I have not been clear enough in my \ndescription of the problem, or anything else, please advise me and I will \nquickly try to fix up or provide more info.\n\n\nPSS: we have a small test portal with some static html pages generated like \ndescribed above, currently on the web.  One of the sites there is a complex \ndocument of close to 1000 web pages, dedicated to a generative approach to \nmusic theory.  This site can be accessed through \nwww.musicnovatory.com.  Please keep in mind that both the sites and the \ntools to generate them are still in construction.  Please also note that \neverything, including all portals, sites, pages, navigation, sitemaps, etc \nare automatically generated from pure content XML source documents (and XML \nlayouts), all with XSLT.\n\n\n\n\nAt 02:42 AM 1/28/2003 +0100, Kay, Michael wrote:\n>I think that the mental model we have used for multiple result trees is that\n>there is conceptually one combined tree, and that the actual result trees\n>all have to be subtrees of this combined tree. The stylesheet logic for\n>writing multiple result documents is therefore exactly the same as you would\n>write if you were generating the combined tree. If you can write the logic\n>to produce the combined tree, then it is trivial to modify it to produce\n>multiple trees. What the facility for multiple result trees does not do is\n>to free you from the need to produce output in \"result tree order\" - that\n>is, the order of instructions in the stylesheet reflects the order of nodes\n>written to the result.\n>\n>Its true that the restriction on when xsl:result-document can be used\n>appears somewhat draconian, and the problem it is solving seems rather small\n>in comparison. Arguably, we are applying the \"no-side-effects\" philosophy of\n>the language rather strictly in this case. I'm sure we could relax the rules\n>by leaving some edge cases implementation defined, but on the whole we have\n>been reluctant to do that.\n>\n>We did have a different solution to this problem in earlier drafts, but it\n>required extra information in the data model and was very hard to\n>understand. It still imposed substantial restrictions. The model was that a\n>result document was effectively a child node attached to some other tree,\n>invisible to XPath expressions, but still linked in the sense that the tree\n>was written out only if and when the parent node was written to a result\n>tree.\n>\n>We spent some time debating this and I'm reluctant to re-open it. Rather,\n>I'd like to see whether we can use your problem as a test case to see\n>whether the existing language is up to solving the problem. In the example\n>you show, I find it very hard to understand why you are trying to produce a\n>result document as a side-effect of calculating a parameter to a named\n>template. It seems a very odd way to do things, though I'm sure it makes\n>sense to you.\n>\n>Michael Kay\n\n\n\n"
        },
        {
            "subject": "RE: changing final output while writing temporary tre",
            "content": "Thanks.\n\nThe reason we produce public working drafts and the reason that I ship an\nearly implementation of the drafts is precisely to get this kind of\nfeedback.\n\nI think we need to take a look at the algorithms you are using, and come to\na position on whether we regard this as being an appropriate use case for\nthe language or not. It looks as if we have some studying to do.\n\nMichael Kay\n\n\n> -----Original Message-----\n> From: Andre Cusson [mailto:ac@hyperbase.com] \n> Sent: 28 January 2003 05:57\n> To: Kay, Michael; public-qt-comments@w3.org\n> Cc: michael.h.kay@ntlworld.com; saxon-help@lists.sourceforge.net\n> Subject: RE: changing final output while writing temporary tree\n> \n> \n> Hi,\n> \n> Thank you again for your time and interest.\n> \n> I would like to sit down with you and show you what we are \n> doing but since \n> that is not really possible now and since the code base is \n> relatively large \n> (and complex), I will try to describe some typical problems \n> we are trying \n> to solve, using result-document.  In essence, it is quite simple:\n> \n> 1. The principle : a possibly large and complex source xml \n> document that \n> needs to be traversed recursively and from which pages (ex: \n> web pages) are \n> to be published.\n> \n> 2.. A publishing use case : I have a source XML document of , \n> lets say 50 \n> to 100K lines, describing the structured content of a scientific \n> information web site, organized in volumes, sections, \n> chapters, and pages \n> (which are of course also organized into sections, sub-sections, \n> paragraphs, etc).  Further, the page contents, gathered from \n> the source \n> document have to be merged with XML defined layouts that \n> describe the page \n> layout.  Every time a page is to be published, the \n> page-publish template is \n> called and passed the corresponding contents.  It then merges \n> the contents \n> into specified layout(s) and then serializes the page to \n> html.  Note: this \n> is again a simplified model of a section of the application, \n> the publishing \n> module.\n> \n> As the publishing module is traversing the source document, \n> it figures out \n> what needs to be done and calls the page-publish template as \n> required.  Many cases happen.  A typical one could be, for \n> example, a test \n> page, a page that offers a test to the user:  so we start \n> building the page \n> tree and doing all kinds of calculations for the page,  on \n> this page we \n> also find information to build the answer page which uses a \n> lot of the same \n> data so we build the answer page, publish it and go on with \n> the publishing \n> of the test page, building hyperlinks and navigation between \n> the pages, and \n> so on.  The only issue is that since we are traversing down a \n> tree, the \n> leaves get output first and the root, last.\n> \n> 3. O-R mapping use case: Another example could come from our \n> O-R mapping \n> tool where we take a tree, any tree and map its contents to a \n> series of \n> hyperlinked editing forms, each with a table with the \n> children (or a group \n> of them) of a node and where each child that has children \n> will require \n> additional sub-pages, and so on recursively. So, as I am \n> building page 1, I \n> find that I also need to do pages 1a, 1b and 1c (all with \n> bidirectional \n> links (xpointers) between them).  Since everything is \n> recursive, as I start \n> building page 1a, but now I find that I also have to build \n> sub-pages 1a1, \n> 1a2 and 1a3 and so on.\n> \n> Every time that I have a page ready, I publish it but, because of \n> recursion, bottom pages (tree leaves) get publish first and \n> the root node \n> is still being build at that time so the result-document \n> instruction bombs out.\n> \n> \n> The way I see this, we are not using a side-effect, we are \n> doing plain \n> recursive processing, with no tricks or anything twisted.  \n> The fact that \n> there is a tree (final) in a tree (temporary) can hardly (or maybe \n> academically) be called a side-effect.  In my view and for \n> the uses we have \n> of this, a tree in a tree is recursion.  Is recursion a side effect ?\n> \n> Now, I don't doubt that some people may want to abuse \n> recursion or the \n> result-document instruction and I believe that we should do \n> everything \n> reasonable to prevent these abuses, short of preventing the \n> development of \n> useful applications.  Personally, the price to pay for \n> side-effects is to \n> high for me to toy with.  On the other hand, blocking \n> recursion kills my \n> application.\n> \n> I am surprised that something so natural to (streaming) XSLT like \n> traversing a tree structure and building web pages as you go has not \n> brought up this issue before and I start to wonder, what are \n> others doing \n> with XSLT?\n> \n> Theoretically, I could process the structure iteratively but \n> I would loose \n> performance, maintainability and I would get sick looking at the code \n> because of its ugliness and illogical structure.  Comparatively, \n> (academical) side-effects are almost nice.\n> \n> Ever since we found out about the new restriction, a few \n> weeks ago, I have \n> been trying to find a viable alternative but I have not yet.\n> If you can think or suggest me one, I will be happy to try \n> it. If we can't, XSLT 2.0 might run into a problem when \n> people start using it \n> to generate web pages as opposed to simply rendering them or \n> building them \n> from flat structures.\n> \n> For now, and until a viable solution is found, the only way \n> we can advance \n> and deliver a product to our users is to stick to Saxon \n> v6.5.2 and forget \n> about XSLT 2.0.\n> It is a very high price to pay in the long run but it may be \n> better than \n> loosing everything.\n> \n> I hope that the case is getting clearer and I will be happy \n> to provide you \n> with additional information, try things out, talk on the \n> phone or anything \n> that will help resolve this.\n> I also hope that the mix of my passion and my frustration \n> does not blur the \n> issues.\n> \n> I thank you for everything and especially for your interest. \n> Please take care.\n> \n> Regards,\n> Andre Cusson\n> ac@hyperbase.com\n> 01 Communications Inc.\n> \n> PS: Whether I invoke result-document while building a \n> with-param tree or I \n> do it in a variable and then pass the variable as a parameter \n> does not \n> improve the problem because now I have additional variables \n> (which are \n> temporary trees also) and more \"non streamable\" steps, but I \n> still need to \n> recursively generate pages (from temporary trees).\n> \n> Recursion is designed to handle problems that are cannot \n> (easily) be solved \n> otherwise and it seems to me that generating html pages from \n> traversing a \n> hierarchical structure is one of them.\n> \n> I am very sorry that the committee might already have spent serious \n> resources debating (complex) output tree issues and that I am \n> trying to \n> stir things up again but the way I see it, either I am wrong \n> and there is a \n> better way to do this and I will be happy and I will grow as \n> a programmer \n> if I can find/learn it, or I am right and it is in XSLT's \n> best interest to \n> revisit the issue.  Consequently, If I have not been clear \n> enough in my \n> description of the problem, or anything else, please advise \n> me and I will \n> quickly try to fix up or provide more info.\n> \n> \n> PSS: we have a small test portal with some static html pages \n> generated like \n> described above, currently on the web.  One of the sites \n> there is a complex \n> document of close to 1000 web pages, dedicated to a \n> generative approach to \n> music theory.  This site can be accessed through \n> www.musicnovatory.com.  Please keep in mind that both the \n> sites and the \n> tools to generate them are still in construction.  Please \n> also note that \n> everything, including all portals, sites, pages, navigation, \n> sitemaps, etc \n> are automatically generated from pure content XML source \n> documents (and XML \n> layouts), all with XSLT.\n> \n> \n> \n> \n> At 02:42 AM 1/28/2003 +0100, Kay, Michael wrote:\n> >I think that the mental model we have used for multiple \n> result trees is \n> >that there is conceptually one combined tree, and that the actual \n> >result trees all have to be subtrees of this combined tree. The \n> >stylesheet logic for writing multiple result documents is therefore \n> >exactly the same as you would write if you were generating \n> the combined \n> >tree. If you can write the logic to produce the combined \n> tree, then it \n> >is trivial to modify it to produce multiple trees. What the facility \n> >for multiple result trees does not do is to free you from \n> the need to \n> >produce output in \"result tree order\" - that is, the order of \n> >instructions in the stylesheet reflects the order of nodes \n> written to \n> >the result.\n> >\n> >Its true that the restriction on when xsl:result-document \n> can be used \n> >appears somewhat draconian, and the problem it is solving \n> seems rather \n> >small in comparison. Arguably, we are applying the \"no-side-effects\" \n> >philosophy of the language rather strictly in this case. I'm sure we \n> >could relax the rules by leaving some edge cases implementation \n> >defined, but on the whole we have been reluctant to do that.\n> >\n> >We did have a different solution to this problem in earlier \n> drafts, but \n> >it required extra information in the data model and was very hard to \n> >understand. It still imposed substantial restrictions. The model was \n> >that a result document was effectively a child node attached to some \n> >other tree, invisible to XPath expressions, but still linked in the \n> >sense that the tree was written out only if and when the parent node \n> >was written to a result tree.\n> >\n> >We spent some time debating this and I'm reluctant to re-open it. \n> >Rather, I'd like to see whether we can use your problem as a \n> test case \n> >to see whether the existing language is up to solving the \n> problem. In \n> >the example you show, I find it very hard to understand why you are \n> >trying to produce a result document as a side-effect of \n> calculating a \n> >parameter to a named template. It seems a very odd way to do things, \n> >though I'm sure it makes sense to you.\n> >\n> >Michael Kay\n> \n\n\n\n"
        },
        {
            "subject": "F&amp;O spelling of binary equality operator",
            "content": "Hi,\n\nIn F&O, section 11.1: For consistency, the spelling/capitalization of\nthe hexBinary and base64Binary equality operators should be the same as\nthe names of the types, i.e. hexBinary-equal and base64Binary-equal\ninstead of hex-binary-equal and base64-binary-equal.\n\nThanks,\nPriscilla\n\n-----------------------------------------------------\nPriscilla Walmsley             priscilla@walmsley.com\nhttp://www.priscilla.walmsley.com\n----------------------------------------------------- \n\n\n\n"
        },
        {
            "subject": "RE: changing final output while writing temporary tre",
            "content": "Hi,\n\nThank you.\n\nI am happy if this is useful.\n\nTell me if/how I can help.\n\nRegards.\nAndre Cusson\nac@hyperbase.com\n01 Communications Inc.\n\n\n\n\nAt 02:30 PM 1/28/2003 +0100, Kay, Michael wrote:\n>Thanks.\n>\n>The reason we produce public working drafts and the reason that I ship an\n>early implementation of the drafts is precisely to get this kind of\n>feedback.\n>\n>I think we need to take a look at the algorithms you are using, and come to\n>a position on whether we regard this as being an appropriate use case for\n>the language or not. It looks as if we have some studying to do.\n>\n>Michael Kay\n>\n>\n> > -----Original Message-----\n> > From: Andre Cusson [mailto:ac@hyperbase.com]\n> > Sent: 28 January 2003 05:57\n> > To: Kay, Michael; public-qt-comments@w3.org\n> > Cc: michael.h.kay@ntlworld.com; saxon-help@lists.sourceforge.net\n> > Subject: RE: changing final output while writing temporary tree\n> >\n> >\n> > Hi,\n> >\n> > Thank you again for your time and interest.\n> >\n> > I would like to sit down with you and show you what we are\n> > doing but since\n> > that is not really possible now and since the code base is\n> > relatively large\n> > (and complex), I will try to describe some typical problems\n> > we are trying\n> > to solve, using result-document.  In essence, it is quite simple:\n> >\n> > 1. The principle : a possibly large and complex source xml\n> > document that\n> > needs to be traversed recursively and from which pages (ex:\n> > web pages) are\n> > to be published.\n> >\n> > 2.. A publishing use case : I have a source XML document of ,\n> > lets say 50\n> > to 100K lines, describing the structured content of a scientific\n> > information web site, organized in volumes, sections,\n> > chapters, and pages\n> > (which are of course also organized into sections, sub-sections,\n> > paragraphs, etc).  Further, the page contents, gathered from\n> > the source\n> > document have to be merged with XML defined layouts that\n> > describe the page\n> > layout.  Every time a page is to be published, the\n> > page-publish template is\n> > called and passed the corresponding contents.  It then merges\n> > the contents\n> > into specified layout(s) and then serializes the page to\n> > html.  Note: this\n> > is again a simplified model of a section of the application,\n> > the publishing\n> > module.\n> >\n> > As the publishing module is traversing the source document,\n> > it figures out\n> > what needs to be done and calls the page-publish template as\n> > required.  Many cases happen.  A typical one could be, for\n> > example, a test\n> > page, a page that offers a test to the user:  so we start\n> > building the page\n> > tree and doing all kinds of calculations for the page,  on\n> > this page we\n> > also find information to build the answer page which uses a\n> > lot of the same\n> > data so we build the answer page, publish it and go on with\n> > the publishing\n> > of the test page, building hyperlinks and navigation between\n> > the pages, and\n> > so on.  The only issue is that since we are traversing down a\n> > tree, the\n> > leaves get output first and the root, last.\n> >\n> > 3. O-R mapping use case: Another example could come from our\n> > O-R mapping\n> > tool where we take a tree, any tree and map its contents to a\n> > series of\n> > hyperlinked editing forms, each with a table with the\n> > children (or a group\n> > of them) of a node and where each child that has children\n> > will require\n> > additional sub-pages, and so on recursively. So, as I am\n> > building page 1, I\n> > find that I also need to do pages 1a, 1b and 1c (all with\n> > bidirectional\n> > links (xpointers) between them).  Since everything is\n> > recursive, as I start\n> > building page 1a, but now I find that I also have to build\n> > sub-pages 1a1,\n> > 1a2 and 1a3 and so on.\n> >\n> > Every time that I have a page ready, I publish it but, because of\n> > recursion, bottom pages (tree leaves) get publish first and\n> > the root node\n> > is still being build at that time so the result-document\n> > instruction bombs out.\n> >\n> >\n> > The way I see this, we are not using a side-effect, we are\n> > doing plain\n> > recursive processing, with no tricks or anything twisted.\n> > The fact that\n> > there is a tree (final) in a tree (temporary) can hardly (or maybe\n> > academically) be called a side-effect.  In my view and for\n> > the uses we have\n> > of this, a tree in a tree is recursion.  Is recursion a side effect ?\n> >\n> > Now, I don't doubt that some people may want to abuse\n> > recursion or the\n> > result-document instruction and I believe that we should do\n> > everything\n> > reasonable to prevent these abuses, short of preventing the\n> > development of\n> > useful applications.  Personally, the price to pay for\n> > side-effects is to\n> > high for me to toy with.  On the other hand, blocking\n> > recursion kills my\n> > application.\n> >\n> > I am surprised that something so natural to (streaming) XSLT like\n> > traversing a tree structure and building web pages as you go has not\n> > brought up this issue before and I start to wonder, what are\n> > others doing\n> > with XSLT?\n> >\n> > Theoretically, I could process the structure iteratively but\n> > I would loose\n> > performance, maintainability and I would get sick looking at the code\n> > because of its ugliness and illogical structure.  Comparatively,\n> > (academical) side-effects are almost nice.\n> >\n> > Ever since we found out about the new restriction, a few\n> > weeks ago, I have\n> > been trying to find a viable alternative but I have not yet.\n> > If you can think or suggest me one, I will be happy to try\n> > it. If we can't, XSLT 2.0 might run into a problem when\n> > people start using it\n> > to generate web pages as opposed to simply rendering them or\n> > building them\n> > from flat structures.\n> >\n> > For now, and until a viable solution is found, the only way\n> > we can advance\n> > and deliver a product to our users is to stick to Saxon\n> > v6.5.2 and forget\n> > about XSLT 2.0.\n> > It is a very high price to pay in the long run but it may be\n> > better than\n> > loosing everything.\n> >\n> > I hope that the case is getting clearer and I will be happy\n> > to provide you\n> > with additional information, try things out, talk on the\n> > phone or anything\n> > that will help resolve this.\n> > I also hope that the mix of my passion and my frustration\n> > does not blur the\n> > issues.\n> >\n> > I thank you for everything and especially for your interest.\n> > Please take care.\n> >\n> > Regards,\n> > Andre Cusson\n> > ac@hyperbase.com\n> > 01 Communications Inc.\n> >\n> > PS: Whether I invoke result-document while building a\n> > with-param tree or I\n> > do it in a variable and then pass the variable as a parameter\n> > does not\n> > improve the problem because now I have additional variables\n> > (which are\n> > temporary trees also) and more \"non streamable\" steps, but I\n> > still need to\n> > recursively generate pages (from temporary trees).\n> >\n> > Recursion is designed to handle problems that are cannot\n> > (easily) be solved\n> > otherwise and it seems to me that generating html pages from\n> > traversing a\n> > hierarchical structure is one of them.\n> >\n> > I am very sorry that the committee might already have spent serious\n> > resources debating (complex) output tree issues and that I am\n> > trying to\n> > stir things up again but the way I see it, either I am wrong\n> > and there is a\n> > better way to do this and I will be happy and I will grow as\n> > a programmer\n> > if I can find/learn it, or I am right and it is in XSLT's\n> > best interest to\n> > revisit the issue.  Consequently, If I have not been clear\n> > enough in my\n> > description of the problem, or anything else, please advise\n> > me and I will\n> > quickly try to fix up or provide more info.\n> >\n> >\n> > PSS: we have a small test portal with some static html pages\n> > generated like\n> > described above, currently on the web.  One of the sites\n> > there is a complex\n> > document of close to 1000 web pages, dedicated to a\n> > generative approach to\n> > music theory.  This site can be accessed through\n> > www.musicnovatory.com.  Please keep in mind that both the\n> > sites and the\n> > tools to generate them are still in construction.  Please\n> > also note that\n> > everything, including all portals, sites, pages, navigation,\n> > sitemaps, etc\n> > are automatically generated from pure content XML source\n> > documents (and XML\n> > layouts), all with XSLT.\n> >\n> >\n> >\n> >\n> > At 02:42 AM 1/28/2003 +0100, Kay, Michael wrote:\n> > >I think that the mental model we have used for multiple\n> > result trees is\n> > >that there is conceptually one combined tree, and that the actual\n> > >result trees all have to be subtrees of this combined tree. The\n> > >stylesheet logic for writing multiple result documents is therefore\n> > >exactly the same as you would write if you were generating\n> > the combined\n> > >tree. If you can write the logic to produce the combined\n> > tree, then it\n> > >is trivial to modify it to produce multiple trees. What the facility\n> > >for multiple result trees does not do is to free you from\n> > the need to\n> > >produce output in \"result tree order\" - that is, the order of\n> > >instructions in the stylesheet reflects the order of nodes\n> > written to\n> > >the result.\n> > >\n> > >Its true that the restriction on when xsl:result-document\n> > can be used\n> > >appears somewhat draconian, and the problem it is solving\n> > seems rather\n> > >small in comparison. Arguably, we are applying the \"no-side-effects\"\n> > >philosophy of the language rather strictly in this case. I'm sure we\n> > >could relax the rules by leaving some edge cases implementation\n> > >defined, but on the whole we have been reluctant to do that.\n> > >\n> > >We did have a different solution to this problem in earlier\n> > drafts, but\n> > >it required extra information in the data model and was very hard to\n> > >understand. It still imposed substantial restrictions. The model was\n> > >that a result document was effectively a child node attached to some\n> > >other tree, invisible to XPath expressions, but still linked in the\n> > >sense that the tree was written out only if and when the parent node\n> > >was written to a result tree.\n> > >\n> > >We spent some time debating this and I'm reluctant to re-open it.\n> > >Rather, I'd like to see whether we can use your problem as a\n> > test case\n> > >to see whether the existing language is up to solving the\n> > problem. In\n> > >the example you show, I find it very hard to understand why you are\n> > >trying to produce a result document as a side-effect of\n> > calculating a\n> > >parameter to a named template. It seems a very odd way to do things,\n> > >though I'm sure it makes sense to you.\n> > >\n> > >Michael Kay\n> >\n\n\n\n"
        },
        {
            "subject": "F&amp;O section 5.",
            "content": "Hi,\n\nIn F&O, section 5.1, it says \"They also apply to user-defined types\nderived by restriction from these types.\"  This should say \"..apply to\nbuilt-in and user-defined derived...\" or simply \"...apply to types\nderived...\", since there are also built-in types derived from integer.\n\nThanks,\nPriscilla\n\n-----------------------------------------------------\nPriscilla Walmsley             priscilla@walmsley.com\nhttp://www.priscilla.walmsley.com\n----------------------------------------------------- \n\n\n\n"
        },
        {
            "subject": "ORA-DM-NAMESPACENODE 4.1.6 typedvalue Accesso",
            "content": "*Data Model, Section 4.1.6 typed-value Accessor*\n\n\nShould the return type for a namespace node be xs:uri rather than \nxdt:untypedAtomic ?\n\n\n\n"
        },
        {
            "subject": "ORA-DM-NAMESPACENODE 4.1.6 typedvalue Accesso",
            "content": "*Data Model, Section 4.1.6 typed-value Accessor*\n\n\nShould the return type for a namespace node be xs:uri rather than \nxdt:untypedAtomic ?\n\n\n\n"
        },
        {
            "subject": "DM and F/O comments from XML Schema WG / request for more tim",
            "content": "The XML Schema Working Group has been preparing comments on\nthe Datamodel and Functions/Operators specifications, but we\nhave not yet completed our review.  This is to let you know\nthat we hope to send you a complete set of last-call comments\non both documents fairly soon; we can send fragmentary sets\nof comments earlier, if that will be helpful.\n\n-C. M. Sperberg-McQueen\n  Co-chair, W3C XML Schema Working Group\n\n\n\n"
        },
        {
            "subject": "DOM WG comments on XQuery 1.0 XPath 2.0 Data Mode",
            "content": "Attached are last-call issues raised by the DOM WG with respect to the \nXQuery 1.0 XPath 2.0 Data Model.\n\nPlease contact the working group for clarifications, etc.\n\nThanks,\n\nRay Whitmer\nRayDWhitmer@aol.com\n\n\n\n\ntext/html attachment: XPDM2-DOM.html\n\n\n\n\n"
        },
        {
            "subject": "RE: ORA-FO-RETURNTYPECHEC",
            "content": "Yes there is such a guarantee. But this information does not belong into\nthe FO spec but the general XQuery and Formal Semantics specification\n(where it should already be mentioned).\n\nBest regards\nMichael\n\n> -----Original Message-----\n> From: public-qt-comments-request@w3.org [mailto:public-qt-comments-\n> request@w3.org] On Behalf Of Stephen Buxton\n> Sent: Monday, June 30, 2003 18:35 PM\n> To: public-qt-comments@w3.org\n> Subject: ORA-FO-RETURN-TYPECHECK\n> \n> \n> Are atomicType results returned by a user-defined function typechecked\n?\n> \n> e.g. myHeight has a max value of 100.\n>  If I define a function that returns myHeight, is there a guarantee\nthat\n> the value returned by the function is not greater than 100 ?\n> \n> \n> \n\n\n\n"
        },
        {
            "subject": "RE: ORA-FO-INPUTTYPE",
            "content": "Most functions that do their own conversion do so, because the standard\nconversions do not apply. E.g. not() is based on the effective boolean\nvalue and not on the normal atomization rules.\n\nBest regards\nMichael\n\n> -----Original Message-----\n> From: public-qt-comments-request@w3.org [mailto:public-qt-comments-\n> request@w3.org] On Behalf Of Stephen Buxton\n> Sent: Monday, June 30, 2003 19:38 PM\n> To: public-qt-comments@w3.org\n> Subject: ORA-FO-INPUT-TYPES\n> \n> \n> Some functions take parameters with generic types, and define the\n> semantics of the atomization/conversion that is done inside the\n> function. Others expect to have more specific types passed in. We\nthink\n> the latter is preferable: functions should not be expected to do\n> type-conversion.\n> \n> eg the boolean-not() function should take a boolean argument rather\nthan\n> item* - the caller should do the implicit or explicit casting to\nboolean\n> before passing the argument to the function.\n> \n> \n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1056: Section 9.3 needs more example",
            "content": "Class: Editorial\n\nAdd more examples for ops on date/time and datetime especially boundary\ncases.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1057: Provide spec for boundary case",
            "content": "Class: Editorial/Technical\n\nProvide spec for boundary cases such as date wraparounds.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1058: Is 28:00:00Z an acceptable value",
            "content": "Class: Editorial\n\nSection 9.3.14.1: Is 28:00:00Z an acceptable value? Emphasize extraction\nis on value space by returning max whole number of units.  Does not\ndepend on how value was passed lexically.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1059: Clarify component extraction functions semantic",
            "content": "Class: Editorial\n\nSection 9.4: Component Extraction Functions on Duration, Date, and Time\nValues Algorithm for extracting value not completely clear. Please\nclarify or remove functions.\n\n\n\n"
        },
        {
            "subject": "F&amp;O Section 16.",
            "content": "Hi,\n\nIn F&O, section 16.4, it says \"If the target data type is a list type,\nthe supplied value is first tokenized using whitespace as the token\nseparator. If any of the resulting tokens is not a valid value in the\nlexical space of the target type, then an error is raised (\"Invalid\nlexical value\").\"  \n\nI think that should say \"lexical space of the target type's item\ntype...\"\n\nThanks,\nPriscilla\n\n-----------------------------------------------------\nPriscilla Walmsley             priscilla@walmsley.com\nhttp://www.priscilla.walmsley.com\n----------------------------------------------------- \n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1060: Divide by zero on duratio",
            "content": "Class: Editorial\n\nSection 9.5.8: What happens with divide by 0?\n\n\n\n"
        },
        {
            "subject": "Comments for WD-xpath-datamodel-20030502 and  WD-xpath-functions2003050",
            "content": "Hello,\n\nThese are quick comments for your \"XQuery 1.0 and XPath 2.0 Data\nModel\" [1] and \"XQuery 1.0 and XPath 2.0 Functions and Operators\" [2]\nLast Call Working Drafts.\n\nOverall they are beautifully done!\n\nBoth specs appear to need a conformance section. Here is a thought in\nthat direction. Functions and operators defines \"must\" and \"may\" in\nTerminology, and this is fine. I am more worried about the data model.\nIt should say:\n     The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\",\n     \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this\n     document are to be interpreted as described in [RFC2119].\n(from http://www.ietf.org/rfc/rfc2119.txt) or, it should say what\ndefinitions are being used (e.g., dictionary definitions). It could\nalso say why the RFC is not used. See the W3C Manual of Style for a\nmarkup suggestion (http://www.w3.org/2001/06/manual/#RFCs).\n\nAt .99MB the functions and operators file is too large. It took more\nthan a minute to load in Mac IE OS 9 and gave a read/write error trying\nto save the file to disk. I suggest breaking the spec into chapters,\nand then providing a single file (for print, for clicking within the\ndocument and for searching).\n\nRunning the data model through Tidy with indent off would save 80-90k,\nor over 25%. For functions and operators, this Tidy setting saves 290k,\nagain over 25%.\n\nFunctions and operators seems to be using an old XMLspec stylesheet.\nThis CSS rule was removed in August 2002 because of rendering problems\n(section F1 and some of the definitions are tough to read in Mac IE;\nscreen shot on request). I suggest upgrading to a later XSLT.\n     dt.label       { display: run-in; }\n\nFor both drafts, the title of a reference should be the link. For\nexample:\n     <dd>World Wide Web Consortium, <em>Namespaces in XML</em> See <a\n     href=\"http://www.w3.org/TR/REC-xml-names/\"\n     >http://www.w3.org/TR/REC-xml-names</a>.</dd>\nbecomes something like this:\n     <dd>World Wide Web Consortium, <cite><a\n     href=\"http://www.w3.org/TR/REC-xml-names/\">Namespaces in\n     XML</a></cite> on-line at http://www.w3.org/TR/REC-xml-names.</dd>\n\nThe Manual of Style shows details for references markup\n(http://www.w3.org/2001/06/manual/#References).\n\nGenerally, white space is two words. This applies to both drafts (see\nhttp://www.w3.org/TR/REC-xml#sec-common-syn).\n\nIn section D of the data model, the green #00CB9C class .element is\ndark with black text. #85e9b1 instead (I am sure you can do better than\nmy color picking) would give some contrast.\n\n[1] http://www.w3.org/TR/2003/WD-xpath-datamodel-20030502/\n[2] http://www.w3.org/TR/2003/WD-xpath-functions-20030502/\n\nBest wishes for your project,\n-- \nSusan Lesch           http://www.w3.org/People/Lesch/\nmailto:lesch@w3.org               tel:+1.858.483.4819\nWorld Wide Web Consortium (W3C)    http://www.w3.org/\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1-064: return type of fn:get-local-name-fromQNam",
            "content": "Class: Technical\n\nSection 10.2.2: Shouldn't the return type of\nfn:get-local-name-from-QName be xs:NCName? xs:NCName is a subtype of\nxs:string so it should not be a problem.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1-061: fn:resolveQNam",
            "content": "Class: Technical\n\nSection 10.1.1: fn:resolve-QName is problematic since it requires all\nnamespace nodes for a (context) node to be accessible. Either resolve\nagainst the static-context namespace nodes or remove the function.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1-062: fn:resolveURI and unnamed namespace node",
            "content": "Class: Editorial\n\nunnamed namespace node is confusing. What is this? Please clarify by\nusing the correct term.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1063: Improve section title of 10.",
            "content": "Class: Editorial\n\nSection 10.2 contains ops and fns. Please reflect this in the title.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1-065: Cut fn:get-namespace-uri-for-prefix/fn:get-in-scopenamespace",
            "content": "Class: Editorial\n\nSections 10.2.4/5: These functions are providing namespace axis\nfunctionality that XQuery decided not to provide. We do not see a reason\nto provide them in function form either. Please cut.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1-066: type of  argument $relative in fn:resolveur",
            "content": "Class: Editorial\n\nSection 11.1: Type of $relative should be xs:string? and not xs:string\nsince it is not a \"steering\" parameter like collations.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1-067: type of argument $base of fn:resolveUR",
            "content": "Section 11.1: $base should be either xs:anyURI or just xs:string (to be\naligned with general URI parameter handling) and not anyURI.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1068: checking base UR",
            "content": "Class: Editorial\n\nSection 11.1: How can you check whether base is a base URI? Add\nreference or explanation.\n\n\n\n"
        },
        {
            "subject": "RE: F&amp;O Problems with patterns for duration type",
            "content": "Done!  Thanks!\n\nAll the best, Ashok\n\n-----Original Message-----\nFrom: Priscilla Walmsley [mailto:priscilla@walmsley.com] \nSent: Tuesday, November 05, 2002 8:59 AM\nTo: public-qt-comments@w3.org\nSubject: F&O Problems with patterns for duration types\n\n\n\n\n\nHi,\n\nIn F&O sections 8.2.1 and 8.2.2, the patterns for yearMonthDuration and\ndayTimeDuration have two problems.  The dashes that appear within square\nbrackets should be escaped, as per XML Schema Errata E2-18.   Also, the\nnumbers should be represented as [0-9] rather than \\p{Nd} as per XML\nSchema Errata E2-23.\n\nThanks,\nPriscilla\n\n-----------------------------------------------------\nPriscilla Walmsley             priscilla@walmsley.com\nhttp://www.priscilla.walmsley.com\n----------------------------------------------------- \n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1069: Examples should use example.com in 11.2.",
            "content": "Class: Editorial\n\nSection 11.2.1 should use example.com in example.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1070: Fix examples in 11.2.",
            "content": "Class: Editorial\n\nSection 11.2.1: The constructors need to be xs:anyURI and not anyURI.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1071: Simplifying section 1",
            "content": "Class: Editorial\n\nSection 13:Why have 13.1? There is no 13.2. Just make 13.1 be 13.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1072: Clarify wording in Section 14 example dat",
            "content": "Class: Editorial\n\nSection 14: In \"Further assume that variables $item1, $item2, etc. are\nbound \nto the nodes for the line-item elements in the document in sequence. \"\nit is \nnot clear whether $item1 is bound to a single instance or a list. Please\n\nclarify.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1073: Section 14.1.1 and namespace node",
            "content": "Class: Editorial\n\nSection 14.1.1: Make reference to namespace node an XPATH only\ncomment.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1074: Context nod",
            "content": "Class: Editorial\n\nIn sections 14.1.1ff: XQuery/XPath has replaced the term context node\nwith the term context item. The term context node is not defined\nanymore. Instead, just use the remark in the parenthesis directly.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1075: Examples in section 14.",
            "content": "Class: Editorial\n\nSection 14.1: Provide examples for all subsections.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1080: element node without QNam",
            "content": "Class: Editorial\n\nSection 14.1.3: What does \"attribute/element node without QName\" mean?\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1076: Section 14.1.2 and namespace node",
            "content": "Class: Editorial\n\nSection 14.1.2: Add XPath only reference to namespace node.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1-077: Add ref to dm:nodename in 14.1.",
            "content": "Class: Editorial\n\nSection 14.1.2: Add reference to dm:node-name for name accessor.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1078: Return types of name function",
            "content": "Class: Technical\n\nSections 14.1.1ff: Why do we return xs:string instead of xs:NCName?\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1079: Typo in 14.1.",
            "content": "Class: Editorial\n\nSection 14.1.3: as a, xs:string. What's the , for? Is something missing\nor the , superfluous?\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1090: fn:boolean() vs EB",
            "content": "Class: Editorial\n\nSections 15, 15.1.4: The document says: fn:boolean casts a sequence to\nan xs:boolean. This is not correctly worded. Instead say: Calculates EBV\nof sequence. Also align this section with EBV section.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1089: fn:root() should only be defined when a document node exist",
            "content": "Class: Technical\n\nSection 14.1.9 fn:root: fn:root() should error if root node is not a\ndocument node. Otherwise the following expression is surprising:\n(<a><b/><c/></a>)[/a/c]/b\n\nThe above expression does not return the b element, since the / would\nreturn the a element node which does not contain an a and thus the\npredicate evaluates to false.\n\nIf we return an error, we avoid this issue. Users can use a let\nexpression to bind the constructed element. And we can decide in a later\nversion to give it a different semantics.\n\nAlso note that in XPath 1.0, fn:root() always gave a document node.\n\nNOTE: This would give at least a return type document (see LC1-088).\n\n\n\n"
        },
        {
            "subject": "RE: F&amp;O section 5.",
            "content": "Done!  Thanks!\n\nAll the best, Ashok\n\n-----Original Message-----\nFrom: Priscilla Walmsley [mailto:priscilla@walmsley.com] \nSent: Tuesday, November 05, 2002 9:12 AM\nTo: public-qt-comments@w3.org\nSubject: F&O section 5.1\n\n\n\n\n\nHi,\n\nIn F&O, section 5.1, it says \"They also apply to user-defined types\nderived by restriction from these types.\"  This should say \"..apply to\nbuilt-in and user-defined derived...\" or simply \"...apply to types\nderived...\", since there are also built-in types derived from integer.\n\nThanks,\nPriscilla\n\n-----------------------------------------------------\nPriscilla Walmsley             priscilla@walmsley.com\nhttp://www.priscilla.walmsley.com\n----------------------------------------------------- \n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1082: fn:number() on atomic context ite",
            "content": "Class: Editorial\n\nSection 14.1.4: fn:number() on atomic context item should work according\nto the four point rule. This is not stated.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1084: fn:lang() function signatur",
            "content": "Class: Editorial/Technical\n\nSection 14.1.5 fn:lang: Why only have one signature form? Also provide\nsignature with explicit node. \n\nNOTE: Same comment was made by Oracle.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1088: fn:root() return typ",
            "content": "Class: Technical\n\nSection 14.1.9: Provide better static return type for fn:root().\nFn:root() is used in normalizing the expressions /, /foo etc. Thus\nunless fn:root() gets a better static type, such expressions cannot be\nstatically typed.\n\nAlso see LC1-089.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1-087: rename op:nodeequa",
            "content": "Class: Editorial\n\nSection 14.1.6: op:node-equal should be called op:node-identical to\navoid value semantics interpretation.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1086: fn:lang() exampl",
            "content": "Class: Editorial\n\nSection 14.1.5: What's the point of the second example? Please clarify\nor remove.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1085: Clarify hyphen",
            "content": "Class: Editorial\n\nSection 14.1.5: \"contains a hyphen\": contains a hyphen or any\nhyphen-like character? Please clarify by providing Unicode codepoint as\nwell.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1083: fn:number() exampl",
            "content": "Class: Editorial\n\nSection 14.1.4: Second example is broken: text is missing.\n\n\n\n"
        },
        {
            "subject": "MS-FO-LC1-081: dm:name should be dm:nodenam",
            "content": "Class: Editorial\n\nSection 14.1.3: replace dm:name with dm:node-name\n\n\n\n"
        },
        {
            "subject": "Re: MS-FO-LC1017: cast untypedAtomic to other type with arithmetic and compare ops",
            "content": "Michael,\n\n> Why don't we cast untypedAtomic to other type instead of directly to\n> xs:double and use xs:double only as fallback for arithmetic and\n> compare?\n>\n> This would mean that an expression such as xs:untypedAtomic(1)+1\n> results in an integer(2) instead of a double(2.0e0) as it does now.\n \nThe problem is that it would also mean that xs:untypedAtomic('2.5')+1\nresulted in a dynamic error, since the untyped atomic value '2.5'\nisn't a legal lexical representation of xs:integer. I think that this\nwould be disconcerting.\n\nCheers,\n\nJeni\n\n---\nJeni Tennison\nhttp://www.jenitennison.com/\n\n\n\n"
        },
        {
            "subject": "Re: MS-FO-LC1033: Allow concat strings to be sequence",
            "content": "Michael Rys wrote:\n> 7.4.1 fn:concat: Why has $op to be xs:string? And not xs:string*.\n> Allow xs:string* and concatenate them as well (see 7.4.2 remark that\n> only holds if fn:concat((\"a\", \"b\")) would be a valid expression).\n>\n> Examples: fn:concat((\"a\",\"b\")) should be \"ab\".\n> fn:concat((\"a\",\"b\"),\"c\") should be \"abc\".\n\nThe string-join() function provides the facility for concatenating\nstrings in a sequence, and is a lot more powerful than concat() for\ndoing so.\n\nIf this change were made, the backwards compatibility conversion rules\nwould also have to change. In XPath 1.0, given:\n\n  concat('foo: ', foo)\n\nyou would get 'foo: ' concatenated with the string value of the\n*first* of the <foo> elements, rather than the string values of the\n<foo> elements all concatenated together. I think that changing the\nbackwards compatibility conversion rules to handle the case where the\ntype of the argument is xs:string* would cause problems elsewhere --\nfor example it would prevent string-join() from working properly in\nbackwards compatibility mode.\n\nCheers,\n\nJeni\n\n---\nJeni Tennison\nhttp://www.jenitennison.com/\n\n\n\n"
        },
        {
            "subject": "Re: MS-FO-LC1-036: stringjoin example is wron",
            "content": "Michael Rys wrote:\n> Last example fn:string-join is wrong: ancestor-or-self::* is a\n> reverse axis so result would be section/chap/doc. Either fix the\n> result or add a /. at the end of the path expression.\n\nThe example is correct in terms of the ordering of the result. The\nresults of a path expression are always returned in document order, so\nthe path \"ancestor-or-self::*\" returns the <doc> element, followed by\nthe <chapter> element, followed by the <section> element.\n\nThe example is wrong, however, because it uses the expression\n\"name(.)\" when it should use \"name($n)\". The current example would\nreturn \"section/section/section\" since \"name(.)\" always returns\n\"section\". The corrected example is:\n\n  fn:string-join(for $n in ancestor-or-self::* return name($n), '/')\n\nCheers,\n\nJeni\n\n---\nJeni Tennison\nhttp://www.jenitennison.com/\n\n\n\n"
        },
        {
            "subject": "Re: ORA-FOCOLLECTION 15.4.5 fn:collectio",
            "content": "Hi Stephen,\n\n> *Functions and Operators, Section 15.4.5 fn:collection*\n>\n> It would be nice if there were some way, using fn:collection, to get\n> metadata (eg document name) alongside nodes, probably in a sequence\n> of tuples or a tuple of sequences.\n\nXPath/XQuery doesn't have the notion of \"tuple\"; the best that\ncollection() could do is return a sequence in which document names and\ndocument nodes alternated, and that would be messy, particularly in\nterms of typing.\n\nInstead, you have to capture the sequence of document nodes in a\nvariable and use other functions to access information about them. I\ndon't think that this is too onerous.\n\nCheers,\n\nJeni\n\n---\nJeni Tennison\nhttp://www.jenitennison.com/\n\n\n\n"
        },
        {
            "subject": "RE: F&amp;O absence of T designator in duration value",
            "content": "Done!  Thanks!\n\nAll the best, Ashok\n\n-----Original Message-----\nFrom: Priscilla Walmsley [mailto:priscilla@walmsley.com] \nSent: Tuesday, November 05, 2002 9:02 AM\nTo: public-qt-comments@w3.org\nSubject: F&O absence of T designator in duration values\n\n\n\n\n\nHi,\n\nIn F&O section 8.2.2.1, it says \"The designator 'T' must be absent if\nall of the time items are absent.\"  This should say \"if and only if\",\nwhich is consistent with XML Schema Errata E2-24.\n\nThanks,\nPriscilla\n\n-----------------------------------------------------\nPriscilla Walmsley             priscilla@walmsley.com\nhttp://www.priscilla.walmsley.com\n-----------------------------------------------------  \n\n\n\n"
        },
        {
            "subject": "Missing duration equalit",
            "content": "May 2, XQuery draft, section B.2 (Operator Mapping)\n\nThe table is missing entries for eq and ne applied to the xs:duration type.\n\n\n\n\n\nMichael Brundage\nxquery@comcast.net\n\nWriting as\nAuthor, \"XQuery: The XML Query Language\" (Addison-Wesley, to appear 2003)\nCo-author, \"Professional XML Databases\" (Wrox Press, 2000)\n\nnot as\nTechnical Lead\nCommon Query Runtime/XML Query Processing\nWebData XML Team\nMicrosoft\n\n\n\n"
        },
        {
            "subject": "RE: Missing duration equalit",
            "content": "That's deliberate!  Equality is not defined on xs:duration because it\nhas a partial order.  Equality is defined only on the two fully ordered\nsubtypes of xs:duration -- xdt:dayTimeDuration and\nxdt:yearMonthduration.\n\nAll the best, Ashok\n> -----Original Message-----\n> From: public-qt-comments-request@w3.org [mailto:public-qt-comments-\n> request@w3.org] On Behalf Of Michael Brundage\n> Sent: Tuesday, July 01, 2003 7:57 AM\n> To: public-qt-comments@w3.org\n> Subject: Missing duration equality\n> \n> \n> May 2, XQuery draft, section B.2 (Operator Mapping)\n> \n> The table is missing entries for eq and ne applied to the xs:duration\n> type.\n> \n> \n> \n> \n> \n> Michael Brundage\n> xquery@comcast.net\n> \n> Writing as\n> Author, \"XQuery: The XML Query Language\" (Addison-Wesley, to appear\n2003)\n> Co-author, \"Professional XML Databases\" (Wrox Press, 2000)\n> \n> not as\n> Technical Lead\n> Common Query Runtime/XML Query Processing\n> WebData XML Team\n> Microsoft\n> \n\n\n\n"
        },
        {
            "subject": "RE: MS-FO-LC1033: Allow concat strings to be sequence",
            "content": "> Class: Technical\n> \n> 7.4.1 fn:concat: Why has $op to be xs:string? And not \n> xs:string*. Allow\n> xs:string* and concatenate them as well (see 7.4.2 remark \n> that only holds if fn:concat((\"a\", \"b\")) would be a valid expression).\n> \n> Examples: fn:concat((\"a\",\"b\")) should be \"ab\". \n> fn:concat((\"a\",\"b\"),\"c\") should be \"abc\".\n> \n\nThis would not be backwards compatible.\n\nYou can use string-join.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "RE: ORA-FO-DEEPEQUAL-NIL 15.2.1 fn:deepequa",
            "content": "Won't two nodes that differ in their \"nil\" property always differ in their\nxsl:nil attribute as well?\n \nMichael Kay\n\n-----Original Message-----\nFrom: Stephen Buxton [mailto:stephen.buxton@oracle.com] \nSent: 01 July 2003 02:00\nTo: public-qt-comments@w3.org\nSubject: ORA-FO-DEEPEQUAL-NIL 15.2.1 fn:deep-equal \n\n\n\nFunctions and Operators, Section 15.2.1 fn:deep-equal <fn:deep-equal>  \n\n\n\nWhat is the effect of the \"nil\" property of the nodes ?\n\n\n\n"
        },
        {
            "subject": "RE: ORA-FO-INPUTTYPE",
            "content": "> \n> Some functions take parameters with generic types, and define the \n> semantics of the atomization/conversion that is done inside the \n> function. Others expect to have more specific types passed \n> in. We think \n> the latter is preferable: functions should not be expected to do \n> type-conversion.\n> \n> eg the boolean-not() function should take a boolean argument \n> rather than \n> item* - the caller should do the implicit or explicit casting \n> to boolean \n> before passing the argument to the function.\n> \n\nThe boolean() function is an explicit invokation of the \"effective boolean\nvalue\" algorithm, and the not() function is its inverse. This algorithm is\ndefined on all kinds of input. If boolean() didn't convert its argument, the\nuser would need to call something that did - what would we name that\nsomething?\n\nMichael Kay \n\n\n\n"
        },
        {
            "subject": "RE: MS-FO-LC1032: Make collation URI a string litera",
            "content": "> \n> Class: Editorial/Technical\n> \n> The collation argument should be a literal. Many current \n> implementation frameworks cannot easily deal with dynamically \n> provided collations. We can always remove this restriction in \n> a later version, but we cannot remove dynamic behaviour \n> without great difficulties once introduced.\n> \n\nIt would be incredibly inconvenient to make users spell out the literal each\ntime it is used, rather than referring to a global variable.\n\nIn addition, XSLT 1.0 has shown that dynamic sorting capability is high on\nusers' requirements lists, and they are prepared to pay a heavy performance\npenalty to achieve it.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "RE: MS-FO-LC1-036: stringjoin example is wron",
            "content": "> \n> Last example fn:string-join is wrong: ancestor-or-self::* is \n> a reverse axis so result would be section/chap/doc. Either \n> fix the result or add a /. at the end of the path expression.\n>\n\nNo, the result of an AxisStep is always in forwards document order.\n\nMichael Kay\n \n> It is also an XPath 2.0-only example and should be marked as such.\n> \n> \n> \n> PS: MS-FO-LC1-035 & -038 was provided to the editors directly.\n> \n\n\n\n"
        },
        {
            "subject": "RE: ORA-FO-NEGATIVEZERO 6.1 Numeric Type",
            "content": "The distinction isn't apparent on serialization - both positive and negative\nzero display as \"0\" (assuming we adopt something close to the XPath 1.0\nrules).\n \nThere are operations that distinguish between them but they are pretty\nobscure. (23 div 0.0e0) > 5 is true, but (23 div -0.0e0) > 5 is false.\n \nMichael Kay\n\n-----Original Message-----\nFrom: Stephen Buxton [mailto:stephen.buxton@oracle.com] \nSent: 01 July 2003 02:34\nTo: public-qt-comments@w3.org\nSubject: ORA-FO-NEGATIVE-ZERO 6.1 Numeric Types \n\n\n\nFunctions and Operators, Section 6.1 Numeric Types \n\n\n\nAre there any operations that distinguish a -0 from a +0 ? \nOr is the distinction only apparent on serialization ?\n\n\n\n"
        },
        {
            "subject": "RE: ORA-FOCOLLECTION 15.4.5 fn:collectio",
            "content": "This aligns with a comment made in Software AG's review of the data model\nthat it would be useful to support an extensible set of user-defined\nproperties for document nodes, along the lines of the WebDAV model.\n \nMichael Kay\n\n-----Original Message-----\nFrom: Stephen Buxton [mailto:stephen.buxton@oracle.com] \nSent: 01 July 2003 03:49\nTo: public-qt-comments@w3.org\nSubject: ORA-FO-COLLECTION 15.4.5 fn:collection \n\n\n\nFunctions and Operators, Section 15.4.5 fn:collection <fn:collection>  \n\n\n\nIt would be nice if there were some way, using fn:collection <fn:collection>\n, to get metadata (eg document name) alongside nodes, probably in a sequence\nof tuples or a tuple of sequences.\n\n\n\n"
        },
        {
            "subject": "RE: MS-FO-LC1055: Section 9.3 comparison on date and tim",
            "content": "> We believe the example is wrong.\n> \n> Functions and Operators, Section 9.3.14.1 Examples\n> The third bullet, the result should be \"false\", not \"true\".\n> \n> 28:00:00Z is not less than 02:00:00Z; even if adjusted by 24 \n> hours, 04:00:00Z is still not less than 02:00:00Z\n> \n> (ORA-FO-DATETIME-EXAMPLES)\n> \n> \nI'm increasingly of the view that we should not support ordering or\ndifferencing of time values. It's meaningless except in the context of a\ndate. The user should be obliged to turn the time into a dateTime before\ndoing such operations.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "RE: ORA-DM-PARENTACCESSOR 4.1 Accessor",
            "content": "Since we're stuck with the assymmetry of the child and parent axes at the\nuser level (for backwards compatibility), what good would it do to make the\nrelationships cleaner at the data model level, which isn't visible to the\nuser?\n \nI've argued in the past that the only problem with the current structure is\nthe nomenclature. If we talked about \"members\" rather than \"children\", there\nwouldn't be an issue.\n \nBut the terminology of the XPath data model has been around for 3.5 years\nnow, and it will be more confusing to change it than to leave it alone.\n \nMichael Kay\n\n-----Original Message-----\nFrom: Stephen Buxton [mailto:stephen.buxton@oracle.com] \nSent: 01 July 2003 04:38\nTo: public-qt-comments@w3.org\nSubject: ORA-DM-PARENT-ACCESSOR 4.1 Accessors \n\n\n\nData Model, Section 4.1 Accessors \n\n\n\nSuggestion: add a dm:owner <dm:owner>  accessor, defined for attributes and\nnamespace nodes. \n\n\nThis allows dm:parent <dm:parent>  and dm:children <dm:children>  to\nsymmetrical. \n\n\nSee also\nhttp://lists.w3.org/Archives/Public/public-qt-comments/2003Jun/0263.html\n<http://lists.w3.org/Archives/Public/public-qt-comments/2003Jun/0263.html> \nSee also\nhttp://lists.w3.org/Archives/Public/public-qt-comments/2003Jun/0384.html\n<http://lists.w3.org/Archives/Public/public-qt-comments/2003Jun/0384.html> \n\n\n\n"
        },
        {
            "subject": "RE: ORA-FO-DEEPEQUAL-VALUES 15.2.1 fn:deepequa",
            "content": "No. \n \n<p>Some <b>bold</b> text</p>\n \nand\n \n<p>Some bold text</p>\n \nhave the same typed value, but they are not deep-equal.\n \nElements with element content do hot have a typed value at all.\n \nMichael Kay\n\n-----Original Message-----\nFrom: Stephen Buxton [mailto:stephen.buxton@oracle.com] \nSent: 01 July 2003 01:55\nTo: public-qt-comments@w3.org\nSubject: ORA-FO-DEEPEQUAL-VALUES 15.2.1 fn:deep-equal \n\n\n\nFunctions and Operators, Section 15.2.1 fn:deep-equal <fn:deep-equal>  \n\n\n\nIf both nodes have been validated, should we just be comparing the typed\nvalues ?\n\n\n\n"
        },
        {
            "subject": "RE: F&amp;O Section 16.",
            "content": "Priscilla:\nWhich version of the F&O are you looking at?  I removed all mention of\ncasting to/from list types since the WGs are still discussing.  I can't\nfind\nthe prose you cite in my version.\n\nAll the best, Ashok\n\n-----Original Message-----\nFrom: Priscilla Walmsley [mailto:priscilla@walmsley.com] \nSent: Tuesday, November 05, 2002 9:15 AM\nTo: public-qt-comments@w3.org\nSubject: F&O Section 16.4\n\n\n\n\n\nHi,\n\nIn F&O, section 16.4, it says \"If the target data type is a list type,\nthe supplied value is first tokenized using whitespace as the token\nseparator. If any of the resulting tokens is not a valid value in the\nlexical space of the target type, then an error is raised (\"Invalid\nlexical value\").\"  \n\nI think that should say \"lexical space of the target type's item\ntype...\"\n\nThanks,\nPriscilla\n\n-----------------------------------------------------\nPriscilla Walmsley             priscilla@walmsley.com\nhttp://www.priscilla.walmsley.com\n----------------------------------------------------- \n\n\n\n"
        },
        {
            "subject": "RE: ORA-FO-DEFAULTNAMESPACE 10.1.1.2 Example",
            "content": "The default namespace always has an empty prefix. If the prefix is \"eg\" then\nit is not the default namespace.\n \nHave I misunderstood the comment?\n \nMichael Kay\n\n-----Original Message-----\nFrom: Stephen Buxton [mailto:stephen.buxton@oracle.com] \nSent: 01 July 2003 03:40\nTo: public-qt-comments@w3.org\nSubject: ORA-FO-DEFAULT-NAMESPACE 10.1.1.2 Examples \n\n\n\nFunctions and Operators, Section 10.1.1.2 Examples says \"Assume that the\nelement bound to $element has a single namespace node bound to the prefix\neg\" \n\n\nCould that namespace be the default namespace ?\n\n\n\n"
        },
        {
            "subject": "RE: MS-FO-LC1089: fn:root() should only be defined when a docume nt node exist",
            "content": "> \n> Section 14.1.9 fn:root: fn:root() should error if root node \n> is not a document node. Otherwise the following expression is \n> surprising: (<a><b/><c/></a>)[/a/c]/b\n> \n> The above expression does not return the b element, since the \n> / would return the a element node which does not contain an a \n> and thus the predicate evaluates to false.\n> \n> If we return an error, we avoid this issue. Users can use a \n> let expression to bind the constructed element. And we can \n> decide in a later version to give it a different semantics.\n\nI agree with this comment, IIRC the XSL WG as a whole wanted this change. Of\ncourse it adds weight to the requirement for the ancestor axis.\n> \n> Also note that in XPath 1.0, fn:root() always gave a document node.\n\nXPath 1.0 did not have an fn:root() function, but it's true that \"/\" always\ngave you a root node, which is what XPath 1.0 called the document node.\n\nMichael Kay\n\n> \n> NOTE: This would give at least a return type document (see LC1-088).\n> \n\n\n\n"
        },
        {
            "subject": "RE: MS-FO-LC1-036: stringjoin example is wron",
            "content": "> \n> The example is wrong, however, because it uses the expression \n> \"name(.)\" when it should use \"name($n)\". The current example \n> would return \"section/section/section\" since \"name(.)\" always \n> returns \"section\". The corrected example is:\n> \n>   fn:string-join(for $n in ancestor-or-self::* return name($n), '/')\n> \n\nIf we can't have a \"for\" expression that binds the context item, I really do\nthink that as a minimum, a \"for\" expression should unbind \".\", so that this\nall-too-common error gets detected.\n\nMichael Kay\n\n\n\n"
        },
        {
            "subject": "RE: MS-FO-LC1037: String functions should treat () as &quot;&quot; (as in  XPath 1.0",
            "content": "> -----Original Message-----\n> From: Michael Rys [mailto:mrys@microsoft.com] \n> Sent: 01 July 2003 02:42\n> To: public-qt-comments@w3.org\n> Subject: MS-FO-LC1-037: String functions should treat () as \n> \"\" (as in XPath 1.0)\n> \n> \n> \n> Class: Technical\n> \n> start-with and most other string functions have an XPath 1.0\n> incompatibilty: () maps to \"\" in XPath 1.0 string functions. \n> No good reason to be incompatible. Treat () as zero-length \n> string and return xs:boolean instead of xs:boolean?.\n> \n> Add this change to all other string functions as well.\n> \n\nWe came to this same conclusion in XSL WG's review of the backwards\ncompatibility appendix. We felt that all the functions that accept strings\nshould treat () as \"\", but that this should be a property of the function\nitself rather than a feature of the function call mechanism - in other\nwords, user functions don't have to follow this example.\n\nAn example that particularly concerned us was [string-length(@a)=0], which\nwhen @a is absent returns true in XPath 1.0, and in 2.0 in backwards\ncompatibility mode, but returns false in 2.0 in non-BC mode.\n\nMichael Kay\n\n\n\n"
        }
    ]
}